0001   0000             	;	DEFINE debug			;debug mode for use with es.pectrum (until Habi changes extension Problem)
0002   0000             	;DEFINE SPACE_IS_ROOT		;Uncomment for SPACE/FIRE2 execute going to ROOT directly. Comment for SPACE/FIRE2 execute going to ".." if current selection is not ".." or Parent Dir is current is ".."
0003   0000             			output "MultMenu.MLD"
0004   0000             			org	#0000
0005   0000             
0006   0000             
0007   0000             			include "resources/labels_multiply.asm"
0001+  0000             ;labels_multiply
0002+  0000             
0003+  0000             ;inherited from ROMSET MENU
0004+  0000             MAXGAMES		EQU 25							; Max number of games 
0005+  0000             
0006+  0000             ;Constants for Files in screen
0007+  0000             MaxChapter	equ		9								;Maximum Chapter (Chapters will be 1..MaxChapter)
0008+  0000             MaxPageChap	equ		11								;Maximum Pages for each Chapter (Pages will be 1..MaxPageChap)
0009+  0000             MaxFilePage	equ		23								;Maximum File number for each Page (will be 1..MaxFilePage)
0010+  0000             
0011+  0000             ;Constants for Position in screen
0012+  0000             MinRowFiles	equ		1								;Row (0..23) for minimum used for Files
0013+  0000             MaxRowFiles	equ		23								;Row (0..23) for maximum used for Files
0014+  0000             FilesPerPag equ		MaxRowFiles-MinRowFiles+1		;Number of Files showing per Page
0015+  0000             MinColFiles	equ		2								;Column (0..63) for minimum used for Files
0016+  0000             MaxColFiles	equ		30								;Max length of file to print in screen
0017+  0000             Sel_Bar_Len	equ		(MaxColFiles+2)/2				;Len of file + icon
0018+  0000             PosRowPath	equ		0								;Row (0..23) for showing the path
0019+  0000             PosColPath	equ		4								;Column (0..63) for showing the path
0020+  0000             MaxColPath	equ		63								;Max Column (0..63) for showing the path
0021+  0000             MaxLenPath	equ		MaxColPath-PosColPath+1			;Maximum length of Path
0022+  0000             
0023+  0000             RowPage		equ		1								;Row (0..23) for showing text "Page xx of xx"
0024+  0000             ColPage		equ		26								;Column (0..63) for showing text "xx/yy"
0025+  0000             
0026+  0000             
0027+  0000             FILEENTRY_NAME	equ		30  						;Max.Length of name
0028+  0000             FILEENTRY_LEN	equ		FILEENTRY_NAME+4			;Length of data for each FileName
0029+  0000             FILEEMPTY		equ		1+FILEENTRY_NAME			;Position of value 0x00 after FileName in the FILEENTRY data
0030+  0000             FILEINDEX		equ		1+FILEENTRY_NAME+1			;Position of Index in the FILEENTRY data
0031+  0000             MAXNFILES		equ		MaxPageChap*MaxFilePage		;Max number of files for listing (MaxPageChap x MaxFilePage = 253), That value contains also entry ".." for 1st chapter
0032+  0000             maxFLen 		equ		256							;Max. length of filename (including last 0x00)
0033+  0000             BorderMenu		equ		7							;Border color for Menu
0034+  0000             MAXSUBDIRS		equ		64							;Max number of subdirectories levels.... 64 are a lot....
0035+  0000             
0036+  0000             ;Constants for Preview screen
0037+  0000             PreviewMax		equ		8							;Counter for updating Preview "miniscreen"
0038+  0000             PreviewLoadWait	equ		3							;Counter for Loading Preview "miniscreen". Don't change!!! to a value below 3 or Routines will Hang it depending the SDCard speed
0039+  0000             PreviewMaxROM	equ		50*5						;Max time for changing preview page for ROMSET (asociated to PrevROMTime) 50*5= 5 seconds (value below 255)
0040+  0000             
0041+  0000             ScreensSCR  equ		#C000							;C000-DAFF used for Loading Screens .SCR
0042+  0000             ScratchRAM	equ		#8000							;Scratch Area
0043+  0000             ;Variables above end of ScreenSCR
0044+  0000             MultiplyVer	equ		ScreensSCR+#1B00				;(8 bytes) Multiply version. It will be "MULTxx.x"
0045+  0000             PathBuffer	equ		MultiplyVer+8					;(61 bytes) Buffer for Current Directory (full path in SDCard) to show in 1st Row of screen
0046+  0000             LenPath		equ		PathBuffer+61					;(1 byte) Len of Current Path (PathBuffer)
0047+  0000             BuffGetDir	equ		LenPath+1						;(256 bytes) Buffer for name as per GetDir (FAT / FAT32 limite it to 255 + 0x00 ending)
0048+  0000             PathIndex	equ		BuffGetDir+256					;(x bytes) 64 x 3 :Max 64 directory entre levels... 1 byte Name len, 2 bytes index of directory.
0049+  0000             PathIndexLast	equ	PathIndex+(MAXSUBDIRS*3)		;(1 byte) Number of last entry level (value 0..64) 0 means root, 1 is "/dir1", 2 is "/dir1/dir2" and so on
0050+  0000             CHK_48K_VAR	equ		PathIndexLast+1					;(1 byte) Will hold Hardware detected: 1=16k, 2=48k, 3=128k
0051+  0000             BufLines	equ		CHK_48K_VAR+1					;(21 bytes) Data for moving Logo (Water effect)
0052+  0000             MovedLines	equ		BufLines+(7*3)					;(1 byte) 0 if not moved lines in this INT (Water effect)
0053+  0000             
0054+  0000             ;Variables for preview screen (see PreviewScreen.asm)
0055+  0000             ;PreviewStat - used in preview screen. 0 if type of file is not SCR...other values as shown below
0056+  0000             PreviewIX	equ		MovedLines+1					;(2 byte) Address of file to load
0057+  0000             PreviewFT	equ		PreviewIX+2						;(1 byte) Type of File for preview between FT_SCR and FT_SNA_SCR so we use the correct command
0058+  0000             PreviewStat	equ		PreviewFT+1						;(1 byte) Small screen preview: 0=NO Preview, 1..nn=Block pending to load, nn+1=Showing
0059+  0000             PreviewCnt	equ		PreviewStat+1					;(1 byte) Down Counter (PreviewMax down to 0) when PreviewStat is nn+1=Showing
0060+  0000             PreviewLoad	equ		PreviewCnt+1					;(1 byte) Down Counter (PreviewLoadWait down to 0) while loading
0061+  0000             RepSRC		equ		PreviewLoad+1					;(2 bytes) Source address for repaint
0062+  0000             RepDest		equ		RepSRC+2						;(2 bytes) Dest address for repaint
0063+  0000             PreviewSP	equ		RepDest+2						;(2 bytes) storing last SP in preview
0064+  0000             LastMove	equ		PreviewSP+2						;(2 bytes) storing current movement
0065+  0000             ;Next variables used for Sorting routine
0066+  0000             TotalB		equ		LastMove+2						;(1 byte)Num of elements sorting (0..253)
0067+  0000             PosFiles	EQU		TotalB+1						;(2 bytes) Will hold the address begining for pointers of files
0068+  0000             HLPosFiles	equ		PosFiles+2						;(2 bytes) Will hold the address begining for files
0069+  0000             SortSP		equ		HLPosFiles+2					;(2 bytes) Will hold SP while sorting
0070+  0000             NumOfFiles	equ		SortSP+2						;(1 byte) Will hold number of files retrieved from Arduino ( < MAXNFILES)
0071+  0000             CurPage		equ		NumOfFiles+1					;(1 byte) Will hold Current Page Number (1..99)
0072+  0000             CurPageOff	equ		CurPage+1						;(1 byte) Will hold Number of Item as per Page Number (1..11) so it's a value: (Pagenumber-1) * 23
0073+  0000             ;Variables for preview ROMSET
0074+  0000             PrevROMPag	equ		CurPageOff+1					;(1 byte) Will hold current page showing romset
0075+  0000             PrevROMxPag	equ		PrevROMPag+1					;(1 byte) Will hold max page for showing romset
0076+  0000             PrevROMTime	equ		PrevROMxPag+1					;(1 byte) Counter of time for changing page in ROMSET preview
0077+  0000             Rom2Write	equ		PrevROMTime+1					;(2 bytes) Address of ROMSET info for writing
0078+  0000             ;Variables for MENU SubMenus
0079+  0000             SubMenuOpt	equ		Rom2Write+2						;(1 byte) 0=Main Menu, 1=ROMSET ENTER submenu, MARIO PENDIENTE SUBMENUS ADICIONALES
0080+  0000             
0081+  0000             
0082+  0000             
0083+  0000             ;Variables below ScreenSCR
0084+  0000             SortBuffer	equ		ScreensSCR-(2*(1+MAXNFILES))			;(508 bytes) Buffer for directory listing sorted (2 bytes per name x 254 -last entry is always in 0x00-)
0085+  0000             Buffer		equ		SortBuffer-(FILEENTRY_LEN*(1+MAXNFILES))	;(8636 bytes) Buffer for directory listing (34 bytes per name x 254 -last entry is always in 0x00-)
0086+  0000             CurRow		equ		Buffer-1						;(1 byte) Current Row for selected files
0087+  0000             AuxCurRow	equ		CurRow-1						;(1 byte) Current Row for printing files
0088+  0000             MaxRow		equ		AuxCurRow-1						;(1 byte) Maximum Row for selected files (based of number of files and current page of listing)
0089+  0000             RowNewPage	equ		MaxRow-1						;(1 byte) Row to go when changing page (depends if using UP-DOWN or LEFT-RIGHT)
0090+  0000             CurKey		equ		RowNewPage-1					;(1 byte) Last key pressed 0 for none, 1..5 as per direction/fire
0091+  0000             LastKey		equ		CurKey-1						;(1 byte) Last key pressed 0 for none, 1..5 as per direction/fire
0092+  0000             LastKeyTime	equ		LastKey-1						;(1 byte) Counting time for repeat key
0093+  0000             KeyToExe	equ		LastKeyTime-1					;(1 byte) Key to process as INT key routine interpreted a key have to be processed
0094+  0000             InfoShown	equ		KeyToExe-1						;(1 byte) Hold value 1 for Pending to show Info BOX, 0 for Info BOX showed
0095+  0000             BufGetInfo	equ		InfoShown-12					;(12 bytes) Used for command CMD_ZX2SD_GETINFO
0096+  0000             InfoVersion	equ		BufGetInfo-9					;(9 bytes) 8 bytes for Version of Menu (slot 1) and 1 byte for num of games
0097+  0000             TXTNumber	equ		InfoVersion-3					;(3 bytes) 2 digits and zero
0098+  0000             ROMVersion  equ 	TXTNumber-9						;(9 bytes) 8 bytes for Version of ROMSET followed by a 0x00 (for printing)
0099+  0000             CurrChapter	equ		ROMVersion-1					;(1 byte) Current Chapter for current folder.
0100+  0000             LastChapter	equ		CurrChapter-1					;(1 byte) Max Chapter for current folder. Value between MinChapter and MaxChapter
0101+  0000             CurrPages	equ		LastChapter-1					;(1 byte) Current Page for current Chapter. Value 1..MaxPageChap (1..11)
0102+  0000             LastPages	equ		CurrPages-1						;(1 byte) Max Page for current Chapter. Value between 1 and MaxPageChap*MaxChapter (1..99)
0103+  0000             CurrFile	equ		LastPages-1						;(1 byte) Current File for current Page Value between 1 and MaxFilePag (1..23)
0104+  0000             LastFile	equ		CurrFile-1						;(1 byte) Max File for Last Page of this Chapter. Value between 1 and MaxFilePage
0105+  0000             ChapTable	equ		LastFile-(MaxChapter*2)			;(18 bytes) Table of chapter indexes
0106+  0000             ;Variables for Degraded
0107+  0000             MsgDegrad	equ		ChapTable-1						;(1 byte) 0=not degraded, 1=degraded, 2=too much degraded
0108+  0000             ;spare		equ		MsgDegrad-x						;(x bytes) spare spare spare spare
0109+  0000             
0110+  0000             Chap1Chapt	equ		0x02							;Offset into ChapTable for Total of chapters
0111+  0000             Chap1Pages	equ		0x03							;Offset into ChapTable for Total of Pages
0112+  0000             Chap1LastF	equ		0x04							;Offset into ChapTable for Num. of files in last Page (usually 253, except for last chapter and last page 1..253)
0113+  0000             Chap1Offset	equ		0x0A							;Offset into ChapTable for 1st chapter index
0114+  0000             ChapDegrad	equ		0x1C							;Offset into ChapTable for Degradation of file system
0115+  0000             
0116+  0000             
0117+  0000             SP_VALUE	equ		#FFF4							;(244 bytes) Used less than 244 bytes, but reserveD #FF00-#FFF4
0118+  0000             IM2ADDR		equ		#FFF4							;(12 bytes) reserved for IM2 routine compatible with inves+
0119+  0000             
0120+  0000             Selec_Color	equ		%01111000						;Selected color is paper white, ink black, bright, no flash
0121+  0000             NoSel_Color	equ		%00111000						;Non selected color is paper white, ink black, no bright, no flash
0122+  0000             Page_Color	equ		%01111000						;Selected color is paper white, ink black, bright, no flash
0123+  0000             
0124+  0000             Time1Val	equ		25								;25/50 sec for first repeat time
0125+  0000             TimesVal	equ		2								;2/50 sec for maintain repeat time
0126+  0000             
0127+  0000             
0128+  0000             ;Variables copied from Dandanator MENU.... so be sure they are "sincronized" with it
0129+  0000             GAMEDATATABADDR	EQU 3584						; Holder for Number of Games and then GameData
0130+  0000             VINFOTXT		EQU 16352						; Version Info Text
0131+  0000             RAMAREAPG2		EQU 32768						; Address of RAM destination for RAM PAGE2 16k block
0132+  0000             TOPRAMMAP		EQU RAMAREAPG2	;RAMTOP			; Set top of variable area (RAM MAP) Adjusted for 16k
0133+  0000             RAM_VARS		EQU	TOPRAMMAP-256				; Zone for Ram Vars (256 bytes)
0134+  0000             SEL_GAME_NUM	EQU RAM_VARS+004				; Selected Game Number (1 byte)	
0135+  0000             AUTOBOOTCHK		EQU	RAM_VARS+142				; Copy of Autoboot game (Slot 2 code will clear it) (1 byte)
0136+  0000             DANSNAP_PAUSE	EQU 16383						; Slot for NMI during play -> 2 for pause, slot (1-32) for Dan-Snap
0137+  0000             PAUSELOOPSN		EQU 64							; Pause function - Number of loops
0138+  0000             
0008   0000             			include "resources/macro_multiply.asm"
0001+  0000             
0002+  0000             		;MACRO SLOT_B
0003+  0000             		;    Send Dandanator command
0004+  0000             		;		IN	- B	: B=Command/Data
0005+  0000             		;		All pulses go to address 0
0006+  0000             		;		Destroys B (return with B=0), Flags are not affected
0007+  0000             		; NOTE: 0 is signaled by 256 pulses.
0008+  0000             		;	Equivalent to SENDNRCMD without pause btw commands
0009+  0000             		MACRO SLOT_B
0010+  0000~            .slot_b		INC HL
0011+  0000~            			DEC HL
0012+  0000~            			LD (0),A
0013+  0000~            			DJNZ .slot_b
0014+  0000             		ENDM
0015+  0000             
0016+  0000             		;MACRO WAIT_B_EXT. Reduced version (3 bytes) waiting the B value (loaded prior to call this)
0017+  0000             		;		Destroys B (return with B=0), Flags are not affected
0018+  0000             		
0019+  0000             		MACRO WAIT_B_EXT
0020+  0000~            .wait_b0	DJNZ .wait_b0
0021+  0000             		ENDM
0022+  0000             
0023+  0000             		;MACRO WAIT_B value
0024+  0000             		;		IN - time value
0025+  0000             		;		Destroys B (return with B=0), Flags are not affected
0026+  0000             		
0027+  0000             		MACRO WAIT_B value
0028+  0000~            			LD B,value
0029+  0000~            			WAIT_B_EXT
0030+  0000             		ENDM
0031+  0000             
0032+  0000             		;MACRO SENDNRCMD_B
0033+  0000             		;    Send Dandanator command
0034+  0000             		;		IN	- B	: B=Command/Data
0035+  0000             		;		All pulses go to address 0
0036+  0000             		;		Destroys B (return with B=0), Flags are not affected
0037+  0000             		; NOTE: 0 is signaled by 256 pulses.
0038+  0000             		;	Equivalent to SENDNRCMD with pause as per value
0039+  0000             		MACRO SENDNRCMD_B value
0040+  0000~            			SLOT_B
0041+  0000~            			WAIT_B value			
0042+  0000             		ENDM
0043+  0000             		
0044+  0000             		;DAN_BIG_COMMAND_NOWAIT
0045+  0000             		; ---- This is equivalente to CALL SENDSPCMD with A=DANCMD_MULTIPLY, D=DANDAT_MULTIPLY, E=register A
0046+  0000             		; 			but it does not send the confirmation pulse
0047+  0000             		;	IN - B = Command to send
0048+  0000             		;	IN - Values passed for Data 1 and Data 2
0049+  0000             		; OUT - Destroys B (return with B=0), Flags are not affected
0050+  0000             		MACRO DAN_BIG_COMMAND_NOWAIT C2, C3
0051+  0000~            			;LD	B,C1			; Command is set externally in B reg
0052+  0000~            			SLOT_B
0053+  0000~            			WAIT_B PAUSELOOPSN			
0054+  0000~            			LD	B,C2			; Data 1
0055+  0000~            			SLOT_B
0056+  0000~            			WAIT_B PAUSELOOPSN
0057+  0000~            			LD  B,C3			; Data 2
0058+  0000~            			SLOT_B
0059+  0000~            			WAIT_B PAUSELOOPSN
0060+  0000             		ENDM
0061+  0000             		
0062+  0000             		;DAN_BIG_COMMAND_NOW
0063+  0000             		; ---- This is equivalente to CALL SENDSPCMD with A=DANCMD_MULTIPLY, D=DANDAT_MULTIPLY, E=register A
0064+  0000             		; 			including confirmation pulse
0065+  0000             		;	IN - As per values passed...
0066+  0000             		; OUT - Destroys B (return with B=0), Flags are not affected
0067+  0000             		MACRO DAN_BIG_COMMAND_NOW C1, C2, C3
0068+  0000~            			LD	B,C1			; Command
0069+  0000~            			DAN_BIG_COMMAND_NOWAIT C2, C3
0070+  0000~            			LD 	(0),A
0071+  0000             		ENDM
0072+  0000             
0073+  0000             		;DAN_BIG_COMMAND_NOWAIT
0074+  0000             		; ---- This is equivalente to CALL SENDSPCMD with A=DANCMD_MULTIPLY, D=DANDAT_MULTIPLY, E=register A
0075+  0000             		; 			but it does not send the confirmation pulse
0076+  0000             		;	IN - As per values passed...
0077+  0000             		; OUT - Destroys B (return with B=0), Flags are not affected
0078+  0000             		MACRO DAN_BIG_COMMAND C1, C2, C3
0079+  0000~            			DAN_BIG_COMMAND_NOW C1, C2, C3
0080+  0000             		ENDM
0081+  0000             
0082+  0000             
0083+  0000             		;MACRO PAUSELONG aprox 65mS
0084+  0000             		; Enter here with B=0, Flags are not affected
0085+  0000             		MACRO PAUSE_LONG
0086+  0000~            .pauselong: 	EX (SP),HL
0087+  0000~            			EX (SP),HL
0088+  0000~            			EX (SP),HL
0089+  0000~            			EX (SP),HL
0090+  0000~            			DJNZ .pauselong
0091+  0000             		ENDM
0092+  0000             		
0093+  0000             	;---------------------------------------------------------------------
0094+  0000             	; Macros for Graphics
0095+  0000             	;---------------------------------------------------------------------
0096+  0000             
0097+  0000             
0098+  0000             ; ----------------------------------------------------------------------------------------
0099+  0000             ; Macro to directly convert Row,Col to Pixels Pos in Screen
0100+  0000             ; ----------------------------------------------------------------------------------------
0101+  0000             			MACRO RowCol2PIX Reg, Row, Col
0102+  0000~            				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0103+  0000             			ENDM
0104+  0000             	
0105+  0000             
0106+  0000             ; ----------------------------------------------------------------------------------------
0107+  0000             ; Macro to directly convert Row,Col to Attribute Pos in Screen
0108+  0000             ; ----------------------------------------------------------------------------------------
0109+  0000             			MACRO RowCol2ATTR Reg, Row, Col
0110+  0000~            				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0111+  0000             			ENDM
0112+  0000             
0113+  0000             ; ----------------------------------------------------------------------------------------
0114+  0000             ; Macro for optimize compare when Value=0
0115+  0000             ; ----------------------------------------------------------------------------------------
0116+  0000             			MACRO	COMPARE Value
0117+  0000~            				IF (Value==0)
0118+  0000~            					AND A
0119+  0000~            				ELSE
0120+  0000~            					CP Value
0121+  0000~            				ENDIF
0122+  0000             			ENDM
0123+  0000             			
0009   0000             			include "resources/multiply_commands_v1.asm"			;Commands for multiply /File types for listing
0001+  0000             //Multiply_commands / Types / Constants
0002+  0000             
0003+  0000             //Commands for Arduino
0004+  0000             CMD_ZX2INO_REQ_ID			EQU		0x01			//Ask for Multiply Identification
0005+  0000             CMD_ZX2INO_REQ_RESET		EQU		0x02			//Reset Arduino
0006+  0000             CMD_ZX2SD_SETZXTYPE     	EQU		0x03		    //Hard type of Spectrum machine: 1=16k, 3=48k, 8=128k
0007+  0000             
0008+  0000             //Commands for SDCARD
0009+  0000             CMD_ZX2SD_OFWRITE			EQU		0x06			//Open File to Write
0010+  0000             CMD_ZX2SD_OFWRITE_IX     	EQU		0x07			//Open File for Write by index
0011+  0000             CMD_ZX2SD_OFREAD			EQU		0x08			//Open File to Read
0012+  0000             CMD_ZX2SD_OFREAD_IX     	EQU		0x09			//Open File for Read by index
0013+  0000             
0014+  0000             // Change Directory
0015+  0000             CMD_ZX2SD_CD_ROOT			EQU		0x0A			//Go to root of SDCARD
0016+  0000             CMD_ZX2SD_CD				EQU		0x0B			//Change to dir
0017+  0000             CMD_ZX2SD_CD_IX				EQU		0x0C			//Change to dir by index
0018+  0000             CMD_ZX2SD_GETDIR        	EQU		0x0D 		    //Get long name of current dir
0019+  0000             
0020+  0000             // Directory Listing
0021+  0000             CMD_ZX2SD_LS_RELATIVE		EQU		0x0E			//Get list of current dir
0022+  0000             CMD_ZX2SD_LS_ABSOLUTE		EQU		0x0F			//Get list of specific dir (full path)
0023+  0000             
0024+  0000             //Commands for screen file type
0025+  0000             CMD_ZX2SD_SCR				EQU		0x10			//Ask for Screen Data
0026+  0000             
0027+  0000             //Commands for SNAPSHOTS - Request File Contents
0028+  0000             CMD_ZX2SD_Z80_16K			EQU		0x11			//Ask for Data of Z80 16k snapshot
0029+  0000             CMD_ZX2SD_Z80_48K			EQU		0x12			//Ask for Data of Z80 48k snapshot
0030+  0000             CMD_ZX2SD_Z80_128K			EQU		0x13			//Ask for Data of Z80 128k snapshot
0031+  0000             CMD_ZX2SD_SCR_FROM_Z80		EQU		0x14			//Ask for Screen of Z80 file
0032+  0000             CMD_ZX2SD_SNA_48K			EQU		0x16			//Ask for Data of Z80 48k snapshot
0033+  0000             CMD_ZX2SD_SNA_128K			EQU		0x17			//Ask for Data of Z80 128k snapshot
0034+  0000             CMD_ZX2SD_SCR_FROM_SNA		EQU		0x18			//Ask for Screen of SNA file
0035+  0000             
0036+  0000             //Additional information from Entries (Directory/File)
0037+  0000             CMD_ZX2SD_GETINFO			EQU		0x1E			//Ask for 4 bytes of additional data
0038+  0000             
0039+  0000             //Commands for tap/tzx files
0040+  0000             CMD_ZX2SD_TAP				EQU		0x20			//Ask for TAP Data
0041+  0000             CMD_ZX2SD_TAP2				EQU  	0x21			//Ask for TAP Data 2
0042+  0000             CMD_ZX2SD_TAP_ULA			EQU  	0x22			//Ask for TAP directly to ULA port
0043+  0000             CMD_ZX2SD_SCRTAP        	EQU		0x23 		    //Ask for Screen into a TAP file
0044+  0000             
0045+  0000             CMD_ZX2SD_TZX				EQU		0x24			//Ask for TZX Data
0046+  0000             CMD_ZX2SD_TZX2				EQU  	0x25			//Ask for TZX Data 2
0047+  0000             CMD_ZX2SD_TZX_ULA			EQU  	0x26			//Ask for TAP directly to ULA port
0048+  0000             
0049+  0000             //Commands for binary files
0050+  0000             CMD_ZX2SD_BINARY_INFO		EQU		0x28			//Ask for Bin file CMD_ZX2SD_BINARY_INFO
0051+  0000             CMD_ZX2SD_BINARY_DATA		EQU 	0x29			//Ask for Bin file DATA
0052+  0000             
0053+  0000             //Commands for ROMSET
0054+  0000             CMD_ZX2SD_ROMSETBLK4B		EQU		0x30			//Ask for ROMSET block with 4bit
0055+  0000             CMD_ZX2SD_ROMSETBLKSER		EQU		0x31			//Ask for ROMSET block with Serial
0056+  0000             
0057+  0000             // Commands from PC
0058+  0000             CMD_PC2AR_ROMSET_TUNNEL		EQU		0xED			//Ask for Romset through Arduino Serial (tunnel)
0059+  0000             CMD_PC2AR_ROMSET_TUN2		EQU		0xF3			//Ask for Romset through Arduino Serial (tunnel)
0060+  0000             CMD_PC2AR_BIN_TUNNEL		EQU		0xEF			//Ask for Binary file through Arduino Serial (tunnel)
0061+  0000             
0062+  0000             //File Types as per directory listing
0063+  0000             //// FILETYPES => FILECONTENTS 4Bit
0064+  0000             FT_END_DIRECTORY			EQU		0x00			//End of directory listing
0065+  0000             
0066+  0000             FT_DIRECTORY				EQU		0x0C			//Directory entry
0067+  0000             
0068+  0000             FT_SCR						EQU		0x10			//Screen (6912 bytes)
0069+  0000             
0070+  0000             FT_Z80_16K					EQU		0x11			//Z80 for 16k snapshot
0071+  0000             FT_Z80_48K					EQU		0x12			//Z80 for 48k snapshot
0072+  0000             FT_Z80_128K					EQU		0x13			//Z80 for 128k snapshot
0073+  0000             FT_Z80_SCR					EQU		0x14			//Screen of Z80
0074+  0000             
0075+  0000             FT_SNA_48K					EQU		0x16			//SNA for 48k snapshot
0076+  0000             FT_SNA_128K					EQU		0x17			//SNA for 128k snapshot
0077+  0000             FT_SNA_SCR					EQU		0x18			//Screen of SNA
0078+  0000             
0079+  0000             FT_TAP						EQU		0x20			//TAP File
0080+  0000             
0081+  0000             FT_BINARY					EQU		0x28			//BIN File
0082+  0000             
0083+  0000             FT_ROMSET					EQU		0x30			//Romset (512k)
0084+  0000             FT_BASIC					EQU		0x31			//Not a real type, used for return to ZX Basic
0085+  0000             
0086+  0000             //Constants for ASM routines
0087+  0000             
0088+  0000             DANCMD_MULTIPLY	EQU		52							//Dandantor command for Multiply operations
0089+  0000             DANDAT_MULTIPLY	EQU		1							//Dandantor data for Multiply command DANCMD_MULTIPLY
0090+  0000             
0091+  0000             SNAP_HEADER		EQU		9							//Used with Commands. 9=Get header of SNA/Z80
0092+  0000             SNAP_CHUNK		EQU		10							//Used with Commands. 10=Get Chunk
0010   0000             			
0011   0000 F3          			DI										;Don't change this DI...it's used also for IM2 interrupts.... #18 #F3 (JR $-#0D) #FFF4
0012   0001 ED 56       			IM		1
0013   0003 31 F4 FF    			LD		SP,SP_VALUE						;it goes down... SP is under IM2 routine for detecting Multiply
0014   0006             
0015   0006 CD 74 18    			CALL	GetDANMENUData					;Get data of 1st slot (if it's a valid Dandanator slot)
0016   0009             			
0017   0009 CD 84 19    			CALL	CheckHardware					;Check hardware and send it to Arduino or return to 1st MLD slot if no Arduino detected
0018   000C             
0019   000C 3E 07       			LD		A,BorderMenu
0020   000E D3 FE       			OUT		(#FE),A
0021   0010             
0022   0010 21 BD 3B    			LD		HL,screenzx7
0023   0013 11 00 40    			LD		DE,#4000
0024   0016 CD 88 09    			CALL	dzx7_turbo
0025   0019             
0026   0019 CD 19 0B    			CALL	PreviewInitial					;Force to painting Cloud Effect in mini screen preview
0027   001C             		;Jump here for going to Root
0028   001C             Goto_ROOT: 
0029   001C 3E 01       			LD		A,MinRowFiles					;First row for filenames is MinRowFiles
0030   001E 32 47 9C    			LD		(CurRow),A						;Initialize Current Row
0031   0021 32 45 9C    			LD		(MaxRow),A						;Initialize Max Row	
0032   0024             
0033   0024             		;Initialize logo water effect
0034   0024 CD 50 0A    			CALL	InitLines
0035   0027             
0036   0027             		;Preload PathBuffer with "/",0x00. Reset PathIndexLast (used for index through subdirectories)
0037   0027 CD 71 19    			CALL	ZX2SD_CD_ROOT					;Multiply: Go to Root directory
0038   002A             Goto_PostROOT: 
0039   002A             			;DI
0040   002A             
0041   002A AF          			XOR		A
0042   002B 32 08 DB    			LD		(PathBuffer),A					;Root is Empty Directory (64 bytes with 0x00)
0043   002E 32 06 DD    			LD		(PathIndexLast),A				;0=No subdir, we're in ROOT "/"
0044   0031 32 3B DD    			LD		(SubMenuOpt),A					;0=Main Menu, 1=Submenu ROMSET Writer, MARIO PENDIENTE SUBMENUS ADICIONALES
0045   0034             
0046   0034 18 41       			JR		Continue
0047   0036             		
0048   0036             ; ----------------------------------------------------------------------------------------
0049   0036 FF          			DEFS	#38-$,#FF
0050   0038             ;RST38 - INT IM1
0051   0038             
0052   0038             			;EI										;Not enable ints after return
0053   0038 ED 4D       			RETI									;Return Interrupt (with ints disabled)
0054   003A             ; ----------------------------------------------------------------------------------------
0055   003A             TXTClearPath: 
0056   003A 20          			defs	MaxColPath-PosColPath+1,32
0057   0076 00          			defb	0
0058   0077             ;Contine (comes from start)
0059   0077             Continue: 
0060   0077 32 45 DB    			LD		(LenPath),A						;Length of current Path to show
0061   007A             GoTo_Dir: 
0062   007A AF          			XOR		A
0063   007B 32 1D 9C    			LD		(CurrChapter),A					;Initialize current chapter to 0 (so will ask not only for chapter 1, but also info for all chapters)
0064   007E 3C          			INC		A
0065   007F 32 34 DD    			LD		(CurPage),A						;Reading 1st chapter so position in Page 1 (curPage value 1..99)
0066   0082 32 1B 9C    			LD		(CurrPages),A					;Reading chapter and position in Page 1 (currPages value 1..11)
0067   0085 32 44 9C    			LD		(RowNewPage),A					;Row to select initially is 1 (1..23)
0068   0088             GoTo_Chapter: 
0069   0088 CD 8A 3B    			CALL	SetCurPageOff					;Adjust CurPageOff (1..11) as per CurrPages (1..99) so browsing correct page
0070   008B             
0071   008B CD 19 0B    			CALL	PreviewInitial					;Force to painting Cloud Effect in mini screen preview
0072   008E             			
0073   008E 3A 44 9C    			LD		A,(RowNewPage)
0074   0091 32 19 9C    			LD		(CurrFile),A					;Initilize CurrFile to RowNewPage (currFile value 1..23)
0075   0094             
0076   0094 CD 9A 3A    			CALL	ClsFiles
0077   0097             		;Clear old path
0078   0097 11 04 00    			LD		DE,0 + (PosRowPath<<8) + PosColPath  	;D=Row (0..23), E=Column (0..63)
0079   009A DD 21 3A 00 			LD		IX,TXTClearPath
0080   009E CD CC 16    			CALL	PrintIXText
0081   00A1             		;Print current path in Row PosRowPath (limited to MaxColFiles columns)
0082   00A1 11 04 00    			LD		DE,0 + (PosRowPath<<8) + PosColPath  	;D=Row (0..23), E=Column (0..63)
0083   00A4 DD 21 08 DB 			LD		IX,PathBuffer					;Show Path...Initially empty, after that will be update through "UpdatePath"
0084   00A8             
0085   00A8 CD CC 16    			CALL	PrintIXText						;Print text in IX at Row D, Column E		
0086   00AB             
0087   00AB             		;Now show Multiply version
0088   00AB DD 21 04 DB 			LD		IX,MultiplyVer+4
0089   00AF DD 7E 04    			LD		A,(IX+4)
0090   00B2 F5          			PUSH	AF
0091   00B3 DD 36 04 00 			LD		(IX+4),0
0092   00B7 11 3C 14    			LD		DE,60+(20 << 8)					;Print Multiply version (3 bytes only)
0093   00BA CD CC 16    			CALL	PrintIXText
0094   00BD F1          			POP		AF
0095   00BE DD 77 FF    			LD		(IX-1),A						;Restore old value there (IX returned with address after 0x00)
0096   00C1             			
0097   00C1 DD 21 29 17 			LD		IX,TXTLoading
0098   00C5 11 22 07    			LD		DE,(2*ColIconSel) + ((5+RowDescSel) << 8)
0099   00C8 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box	
0100   00CB             			
0101   00CB             		;Choose chapter to load as per chapters table
0102   00CB 3A 1D 9C    			LD		A,(CurrChapter)
0103   00CE A7          			AND		A								;Test for CurrChapter = 0
0104   00CF 20 04       			JR		NZ,ChapterIX					;CurrChapter no 0 so jump there
0105   00D1 57          			LD		D,A								;As A=0 we do that for D=0
0106   00D2 5F          			LD		E,A								;DE=0000 for loading chapter 1 and also retrieve info for all chapters
0107   00D3 18 0C       			JR		LoadChapters
0108   00D5             				
0109   00D5             		;Here for loading chapters 1 to MaxChapter
0110   00D5             ChapterIX: 
0111   00D5 21 06 9C    			LD		HL,ChapTable					;Chapter table (1st item is for chapter 1)
0112   00D8 3D          			DEC		A								;A=0 for Chapter 1
0113   00D9 87          			ADD		A,A								;A*2
0114   00DA 16 00       			LD		D,0
0115   00DC 5F          			LD		E,A
0116   00DD 19          			ADD		HL,DE							;Address into Chapter table for chapter required
0117   00DE 56          			LD		D,(HL)							;Low byte of ChapterIX
0118   00DF 23          			INC		HL
0119   00E0 5E          			LD		E,(HL)							;High byte of ChapterIX, so DE=ChapterIX
0120   00E1             
0121   00E1             LoadChapters: 
0122   00E1 3E 0E       			LD		A,CMD_ZX2SD_LS_RELATIVE			;A=Ask for list of current directory, chapter index as per DE (although inverted bytes D=low, E=High)
0123   00E3 37          			SCF 
0124   00E4 CD 76 19         		CALL 	ZX2SD_COMMAND					; Ask for current directory and chapter
0125   00E7             
0126   00E7             			;CALL	SendSerByte						;Request directory listing
0127   00E7             
0128   00E7 3A 44 9C    			LD		A,(RowNewPage)					;First row for filenames
0129   00EA 32 47 9C    			LD		(CurRow),A						;Initialize Current Row
0130   00ED             			
0131   00ED 21 48 9C    			LD		HL,Buffer						;Buffer of file names to recevies Directory/Filenames
0132   00F0             					
0133   00F0             LoopGetList: 
0134   00F0 E5          			PUSH	HL								;Save address of File type of current Filename
0135   00F1 11 22 00    			LD		DE,FILEENTRY_LEN				;DE=Length of package to read
0136   00F4             
0137   00F4 CD BF 32    			CALL	Load4bitBlk						;Get info for dir/file
0138   00F7             
0139   00F7 E3          			EX		(SP),HL							;Save HL in Stack, retrieve HL=Address of 1st char of current name just readed
0140   00F8 7E          			LD		A,(HL)							;1st byte of received data... 0x00 if no more data
0141   00F9 E1          			POP		HL								;HL will be last position of filename readed (HL=Address of filename readed + FILEENTRY_LEN -1)
0142   00FA             			COMPARE	FT_END_DIRECTORY				;Check if A=FT_END_DIRECTORY
0142   00FA A7          >					AND A
0143   00FB 28 03       			JR		Z,EndGetList					;If no more data (A=FT_END_DIRECTORY) then finish getting filenames
0144   00FD 23          			INC		HL								;HL=Next position in buffer of filenames (HL=Address of filename readed + FILEENTRY_LEN)
0145   00FE 18 F0       			JR		LoopGetList						;Get more dir/filenames
0146   0100             			
0147   0100             		;Here for finished getting dir/filenames
0148   0100             EndGetList: 
0149   0100             
0150   0100             		;Now check if we have loaded chapters info
0151   0100 3A 1D 9C    			LD		A,(CurrChapter)
0152   0103 A7          			AND		A								;Test for CurrChapter = 0
0153   0104 28 07       			JR		Z,Chapter0
0154   0106 3D          			DEC		A
0155   0107 CA 37 01    			JP		Z,Chapter1						;CurrChapter = 1 should test if Root or not (for "../Dan" or "../ZX")
0156   010A C3 55 01    			JP		NoRootGetList
0157   010D             			
0158   010D             Chapter0: 
0159   010D             
0160   010D             
0161   010D             		;Here for retrieved info about chapters (received in last entry)
0162   010D 11 E1 FF    			LD		DE,Chap1Chapt-FILEENTRY_LEN+1
0163   0110 19          			ADD		HL,DE							;So HL points to offset for Chap1Chapt
0164   0111 7E          			LD		A,(HL)							;Total of chapters (1..MaxChapter)
0165   0112 32 1C 9C    			LD		(LastChapter),A
0166   0115 23          			INC		HL								;HL points to offset for Chap1Pages
0167   0116 7E          			LD		A,(HL)							;Total of Pages (1..MaxChapter*MaxPageChap)
0168   0117 32 1A 9C    			LD		(LastPages),A
0169   011A 23          			INC		HL								;HL points to offset for Chap1LastF
0170   011B 7E          			LD		A,(HL)							;Num. of files in last Page (usually 253, except for last chapter and last page 1..253)
0171   011C 32 18 9C    			LD		(LastFile),A
0172   011F 11 06 00    			LD		DE,Chap1Offset-Chap1LastF		;Difference btw Offsets  Chap1LastF and Chap1Offset
0173   0122 19          			ADD		HL,DE							;so now HL points to Chap1Offset (Address of Chapter 1 index)
0174   0123 11 06 9C    			LD		DE,ChapTable
0175   0126 01 12 00    			LD		BC,MaxChapter*2
0176   0129 ED B0       			LDIR
0177   012B 3E 01       			LD		A,1								;So chapter 1
0178   012D 32 1D 9C    			LD		(CurrChapter),A					;Chapter 1 so next time in this Folder does not retrieve chapter info again
0179   0130 32 1B 9C    			LD		(CurrPages),A					;Page 1R
0180   0133             
0181   0133 7E          			LD		A,(HL)							;Check HL pointing to ChapDegrad
0182   0134 32 05 9C    			LD		(MsgDegrad),A					;Copy degraded to MsgDegrad
0183   0137             			
0184   0137             Chapter1: 
0185   0137 3A 06 DD    			LD		A,(PathIndexLast)
0186   013A A7          			AND		A								;If PathIndexLast=0 we're in root
0187   013B 20 18       			JR		NZ,NoRootGetList					;So root does not have ".." entry, but have "../Dandanator MENU"
0188   013D             		;Here for ROOT SD. If exists 1st slot as Dandanator then show it, if not then show return to zx basic
0189   013D             			;PUSH	BC			;B not used anymore for Num of files
0190   013D             			;Checking if exists 1st slot MLD correct
0191   013D 21 0F 17    			LD		HL,TXTDanPath					;Type and Text for Dan Path
0192   0140 11 48 9C    			LD		DE,Buffer						;DE=Buffer of file names
0193   0143 01 0D 00    			LD		BC,SizeEndTXTDanPath
0194   0146 3A 2A 9C    			LD		A,(InfoVersion)
0195   0149 FE 76       			CP		"v"								;Dandanator always have "v" for version
0196   014B 28 06       			JR		Z,ShowRootFirst					;Show "../Dan......." or "../ZX...."
0197   014D             		
0198   014D 21 1C 17    			LD		HL,TXTZXPath					;Type and Text for ZX Basic path
0199   0150 01 0D 00    			LD		BC,SizeEndTXTZXPath
0200   0153             ShowRootFirst: 
0201   0153 ED B0       			LDIR
0202   0155             			;POP		BC		;B not used anymore for Num of files
0203   0155             
0204   0155             NoRootGetList: 
0205   0155             		;Update Num of Files for listing
0206   0155 21 1C 9C    			LD		HL,LastChapter
0207   0158 3A 1D 9C    			LD		A,(CurrChapter)
0208   015B BE          			CP		(HL)
0209   015C 20 0E       			JR		NZ,NoLast						;If Current chapter is not the last, then jump
0210   015E 21 1A 9C    			LD		HL,LastPages
0211   0161 3A 1B 9C    			LD		A,(CurrPages)
0212   0164 BE          			CP		(HL)
0213   0165 20 05       			JR		NZ,NoLast						;If current page is not the last, then jump
0214   0167             		;Here only for Last chapter, Last page, so using "LastFile" number of files
0215   0167 3A 18 9C    			LD		A,(LastFile)
0216   016A 18 02       			JR		SetNumFiles
0217   016C             NoLast: 
0218   016C 3E FD       			LD		A,MAXNFILES						;By default chapter should have MAXNFILES except for last chapter
0219   016E             SetNumFiles: 
0220   016E 32 33 DD    			LD		(NumOfFiles),A					;Update total of files (1..253)
0221   0171             		
0222   0171             		;And sort texts
0223   0171             			;Print text "Sorting" for the chance it takes a bit long....
0224   0171 DD 21 42 17 			LD		IX,TXTSorting
0225   0175 11 22 07    			LD		DE,ColOPTSel + ((5+RowDescSel) << 8)
0226   0178 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box
0227   017B             
0228   017B CD C6 18    			CALL	Sort							;Sort of Directory
0229   017E             
0230   017E             
0231   017E             ;Here for printing filenames. Printed only MaxColFiles columns
0232   017E             ;	Printed only MaxRowFiles-MinRowFiles filenames
0233   017E             
0234   017E             Printing_PAGE: 
0235   017E CD 9A 3A    			CALL	ClsFiles
0236   0181             
0237   0181 3E 01       			LD		A,1
0238   0183 32 46 9C    			LD		(AuxCurRow),A					;Aux row for printing filenames
0239   0186 3A 34 DD    			LD		A,(CurPage)						;Current Page to show (1..99)
0240   0189 DD 21 27 9C 			LD		IX,TXTNumber
0241   018D CD 9E 16    			CALL	NumberAtoIX						;Convert reg A to number and store into (IX)(IX+1)
0242   0190             
0243   0190 FD 21 04 BE 			LD		IY,SortBuffer					;Buffer of sorted Files (2 bytes each)
0244   0194             			
0245   0194 3A 35 DD    			LD		A,(CurPageOff)					;Current page number offset
0246   0197 5F          			LD		E,A
0247   0198 16 00       			LD		D,0
0248   019A FD 19       			ADD		IY,DE
0249   019C FD 19       			ADD		IY,DE							;IY + (2 * offset page number)
0250   019E             	;Here for printing from Entry pointed by IX
0251   019E             Printing: 
0252   019E FD 7E 01    			LD		A,(IY+1)						;High byte of File addr (0x00 for no more entries)
0253   01A1 A7          			AND		A
0254   01A2 28 38       			JR		Z,EndPrinting
0255   01A4             
0256   01A4 FD 7E 00    			LD		A,(IY)							;Low addr
0257   01A7 DD 6F       			LD		IXL,A							;Low addr
0258   01A9 FD 7E 01    			LD		A,(IY+1)						;High addr
0259   01AC DD 67       			LD		IXH,A							;High addr
0260   01AE             			;LD		IX,Buffer						;Buffer of file names
0261   01AE             			
0262   01AE DD 46 00    			LD		B,(IX)							;B=FileType
0263   01B1 DD E5       			PUSH	IX								;Save Position of this file
0264   01B3 3A 46 9C    			LD		A,(AuxCurRow)
0265   01B6 57          			LD		D,A
0266   01B7 1E 00       			LD		E,0								;E=Column (0..32) / D=Row (0..23)				
0267   01B9 CD 76 12    			CALL	PrintIcon8x8					;Print Icon8x8 as per B reg into Row D and Column E
0268   01BC             
0269   01BC DD 23       			INC		IX								;Skip Type... IX points to name
0270   01BE 3A 46 9C    			LD		A,(AuxCurRow)
0271   01C1 57          			LD		D,A
0272   01C2 1E 02       			LD		E,MinColFiles					;Position											
0273   01C4 CD CC 16    			CALL	PrintIXText						;Print string pointing by IX
0274   01C7 DD E1       			POP		IX								;Position of this file
0275   01C9             						
0276   01C9 FD 23       > INC IY							
0276   01CB FD 23       > INC IY							
0277   01CD 3A 46 9C    			LD		A,(AuxCurRow)
0278   01D0 3C          			INC		A
0279   01D1 32 46 9C    			LD		(AuxCurRow),A
0280   01D4 3D          			DEC		A
0281   01D5 32 45 9C    			LD		(MaxRow),A						;Update maximum row for selecting	- MARIO PENDIENTE HACER MEJOR CUANDO HAYAN VARIAS PAGINAS DE FICHEROS
0282   01D8 FE 17       			CP		MaxRowFiles						;Avoid going beyond MaxRowFiles (max.row to be used by filenames)
0283   01DA 20 C2       			JR		NZ,Printing
0284   01DC             					
0285   01DC             EndPrinting: 
0286   01DC             		;Still have to print Number of pages (only if more than 1 page)
0287   01DC 3A 1A 9C    			LD		A,(LastPages)					;Num of Pages in directory
0288   01DF             			RowCol2ATTR HL, RowPage, ColPage/2		;Attr pos for xx/yy for page numbers
0288   01DF 21 2D 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0289   01E2 FE 01       			CP		1								;Max Page is 1 ?
0290   01E4 F5          			PUSH	AF								;Save value of Max Page, also Z=1 if only 1 pag
0291   01E5 0E 38       			LD		C,NoSel_Color					;C=NoSel_Color if total pages = 1
0292   01E7 DD 21 5A 17 			LD		IX,TXTMaxPageEmpty				;Blank for Only 1 pg 
0293   01EB             			
0294   01EB 28 06       			JR		Z,ToShowPage
0295   01ED             		;change attributes to bright
0296   01ED 0E 78       			LD		C,Page_Color					;C=Selec_Color if total pages > 1
0297   01EF DD 21 53 17 			LD		IX,TXTPageof					;More than 1pg
0298   01F3             ToShowPage: 
0299   01F3             		;No change attr of "xx/yy" to sel_colour if Max Page >1, if Max Page = 1 then nosel_colour
0300   01F3             
0301   01F3 06 03       			LD		B,(TXTMaxPageEmpty-TXTPageof-1)/2
0302   01F5             .loop: 
0303   01F5 71          			LD		(HL),C
0304   01F6 23          			INC		HL								;Changing attrs to bright
0305   01F7 10 FC       			DJNZ	.loop
0306   01F9             		;And print the texts	
0307   01F9 11 1A 01    			LD		DE,ColPage+(RowPage << 8)		;Text "  /  "
0308   01FC CD CC 16    			CALL	PrintIXText						;Print Text
0309   01FF             
0310   01FF F1          			POP		AF
0311   0200 28 1A       			JR		Z,NoShowPage					;If only 1 page, jump there
0312   0202 C5          			PUSH	BC								;Save C=colour for attrs
0313   0203 F5          			PUSH	AF								;Save value of Max Page
0314   0204             			
0315   0204 DD 21 27 9C 			LD		IX,TXTNumber					;Current page
0316   0208 11 1B 01    			LD		DE,1+ColPage+(RowPage << 8)		;Text xx into "xx/yy"
0317   020B CD CC 16    			CALL	PrintIXText
0318   020E             			
0319   020E F1          			POP		AF
0320   020F DD 21 27 9C 			LD		IX,TXTNumber
0321   0213 CD 9E 16    			CALL	NumberAtoIX						;Convert reg A to number and store into (IX)(IX+1)
0322   0216 11 1E 01    			LD		DE,ColPage+4+(RowPage << 8)		;Text yy into "xx/yy"
0323   0219 CD CC 16    			CALL	PrintIXText						;Print Text
0324   021C             			
0325   021C             NoShowPage: 
0326   021C             	
0327   021C 3A 44 9C    			LD		A,(RowNewPage)					;Row to change for default selected (1st file or "..", or last row if caming from next page)
0328   021F             
0329   021F             MenuUpdateSelected: 			
0330   021F 32 47 9C    			LD		(CurRow),A						;Selected row
0331   0222 0E 78       			LD		C,Selec_Color					;Attr for selected
0332   0224 CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0333   0227 3E 01       			LD		A,1
0334   0229 32 3F 9C    			LD		(InfoShown),A					;1 for Pending to show Info BOX
0335   022C CD 0E 0B    			CALL	PreviewInit						;Reset information of Pre-view
0336   022F             
0337   022F             MenuWaitChange: 
0338   022F ED 56       			IM		1								;Using IM1 for "normal" interrupt
0339   0231 FB          			EI
0340   0232 76          			HALT
0341   0233             ;Moved from IM1 here (only here we use EI-HALT-DI
0342   0233 CD 5C 0A    			CALL	INTLines						;return with (Z) Z activated if no line was moved, (NZ) Z deactivated if lines was moved
0343   0236             
0344   0236 3A 43 9C    			LD		A,(CurKey)
0345   0239 A7          			AND		A								;Z if no key was pressed (so it's time for loading preview)
0346   023A CC 3A 0B    			CALL	Z,INTpreview					;return with (Z) Z activated if preview did not execute long calls, (NZ) Z deactivated if did something
0347   023D             
0348   023D CD 00 30    			CALL	ProcessKey						;Last thing is to Process keys
0349   0240             ;Moved from IM1 here (only here we use EI-HALT-DI
0350   0240 3A 3B DD    			LD		A,(SubMenuOpt)					;SubMenu selected. 1=ROMSET_SubMenu.... no more yet
0351   0243 3D          			DEC		A
0352   0244 CA 8E 04    			JP		Z,ROMSET_SubMenu				;Jump for submenu 1
0353   0247             		; MARIO PENDIENTE SUBMENUS ADICIONALES
0354   0247             		
0355   0247             		;Here for no submenu option
0356   0247 3A 40 9C    			LD		A,(KeyToExe)					;Key pressed for execute something
0357   024A 0F          			RRCA
0358   024B DA 7D 03    			JP		C,KeyRIGHT						;Bit 0 for Right
0359   024E 0F          			RRCA
0360   024F DA 15 03    			JP		C,KeyLEFT						;Bit 1 for Left
0361   0252 0F          			RRCA
0362   0253 DA EA 02    			JP		C,KeyDOWN						;Bit 2 for Down
0363   0256 0F          			RRCA
0364   0257 38 60       			JR		C,KeyUP							;Bit 3 for UP
0365   0259 0F          			RRCA
0366   025A 38 38       			JR		C,KeyFIRE						;Bit 4 for FIRE
0367   025C 0F          			RRCA
0368   025D DA DF 03    			JP		C,KeyROOT 						;Bit 5 for ROOT
0369   0260             	
0370   0260             AfterCheckKeys: 
0371   0260             		;Only when all keys have been released (or in between repeats) then Info BOX will appear
0372   0260 3A 3F 9C    			LD		A,(InfoShown)					;1 for Pending to show Info BOX, 0 for Info BOX showed
0373   0263 3D          			DEC		A
0374   0264 20 C9       			JR		NZ,MenuWaitChange				;If info was showed then skip show it again
0375   0266             		;Now show the additional info in right box
0376   0266             			;XOR		A
0377   0266 32 3F 9C    			LD		(InfoShown),A					;0 for Info BOX showed so next time does not update
0378   0269             			
0379   0269 FD 21 04 BE 			LD		IY,SortBuffer					;Buffer of sorted Files (2 bytes each)
0380   026D             			
0381   026D 3A 35 DD    			LD		A,(CurPageOff)					;Current page number offset
0382   0270 5F          			LD		E,A
0383   0271 16 00       			LD		D,0
0384   0273 FD 19       			ADD		IY,DE
0385   0275 FD 19       			ADD		IY,DE							;IY + (2 * offset page number)
0386   0277             			
0387   0277 3A 47 9C    			LD		A,(CurRow)						;Selected row
0388   027A D6 01       			SUB		MinRowFiles						;So 1st row will be 0
0389   027C             PrintIconSel_Loop: 
0390   027C 28 07       			JR		Z,PrintIconSel					;A=0 jump there
0391   027E FD 23       > INC IY							
0391   0280 FD 23       > INC IY							
0392   0282 3D          			DEC		A
0393   0283 18 F7       			JR		PrintIconSel_Loop				;Until arrive to current row
0394   0285             PrintIconSel: 
0395   0285 FD 7E 00    			LD		A,(IY)							;Low addr
0396   0288 DD 6F       			LD		IXL,A							;Low addr
0397   028A FD 7E 01    			LD		A,(IY+1)						;High addr
0398   028D DD 67       			LD		IXH,A							;High addr
0399   028F CD 44 13    			CALL	PrintIXInfo						;Print Info Box: Icon and additional info (see print.asm)
0400   0292             			
0401   0292 18 9B       			JR MenuWaitChange
0402   0294             
0403   0294             	;Here for Fire pressed
0404   0294             KeyFIRE: 
0405   0294 FD 21 04 BE 			LD		IY,SortBuffer					;Pointers to sorted filenames
0406   0298             
0407   0298 3A 35 DD    			LD		A,(CurPageOff)					;Current page number offset
0408   029B 5F          			LD		E,A
0409   029C 16 00       			LD		D,0
0410   029E FD 19       			ADD		IY,DE
0411   02A0 FD 19       			ADD		IY,DE							;IY + (2 * offset page number)
0412   02A2             			
0413   02A2 3A 47 9C    			LD		A,(CurRow)						;Row=MinRowFiles..MaxRowFiles
0414   02A5 D6 01       			SUB     MinRowFiles						;Converts Row value MinRowFiles..N into value 0..N-MinRowFiles
0415   02A7             
0416   02A7 47          			LD		B,A								;B=num of file to load (0..x)
0417   02A8 28 06       			JR		Z,CalcFile_End
0418   02AA             CalcFile: 
0419   02AA FD 23       > INC IY
0419   02AC FD 23       > INC IY
0420   02AE 10 FA       			DJNZ	CalcFile
0421   02B0             CalcFile_End: 
0422   02B0 FD 6E 00    			LD		L,(IY)							;Low addr
0423   02B3 FD 66 01    			LD		H,(IY+1)						;High addr		
0424   02B6             
0425   02B6 C3 0B 04    			JP	ProcessFIRE							;Go there to procees pressing fire
0426   02B9             
0427   02B9             	;Here for UP pressed
0428   02B9             KeyUP: 
0429   02B9 3A 47 9C    			LD		A,(CurRow)
0430   02BC FE 01       			CP		MinRowFiles						;Minimum row is MinRowFiles constant
0431   02BE 20 1E       			JR		NZ,KeyUP_Cont					;Trying going before 1st
0432   02C0 3A 1A 9C    			LD		A,(LastPages)
0433   02C3 3D          			DEC		A
0434   02C4 20 11       			JR		NZ,KeyUP_SomePages
0435   02C6 3A 47 9C    			LD		A,(CurRow)
0436   02C9 0E 38       			LD		C,NoSel_Color					;Attr for non selected
0437   02CB CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0438   02CE 3A 18 9C    			LD		A,(LastFile)					;As we have only 1 page, then it will be value 1..23
0439   02D1 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0440   02D4 C3 1C 02    			JP		NoShowPage
0441   02D7             			
0442   02D7             KeyUP_SomePages: 
0443   02D7 3E 17       			LD		A,MaxRowFiles
0444   02D9 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0445   02DC 18 43       			JR		KeyLEFT_after
0446   02DE             KeyUP_Cont: 
0447   02DE 0E 38       			LD		C,NoSel_Color					;Attr for non selected
0448   02E0 CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0449   02E3 3A 47 9C    			LD		A,(CurRow)
0450   02E6 3D          			DEC		A
0451   02E7 C3 1F 02    			JP		MenuUpdateSelected
0452   02EA             			
0453   02EA             	;Here for DOWN pressed
0454   02EA             KeyDOWN: 
0455   02EA 21 45 9C    			LD		HL,MaxRow
0456   02ED 3A 47 9C    			LD		A,(CurRow)
0457   02F0 BE          			CP		(HL)							;Maximum row
0458   02F1 28 0C       			JR		Z,KeyDOWN_MovePages				;Last Row, try go go Next page(there will be solved)
0459   02F3             
0460   02F3 0E 38       			LD		C,NoSel_Color					;Attr for non selected
0461   02F5 CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0462   02F8 3A 47 9C    			LD		A,(CurRow)
0463   02FB 3C          			INC		A
0464   02FC C3 1F 02    			JP		MenuUpdateSelected
0465   02FF             
0466   02FF             KeyDOWN_MovePages: 
0467   02FF 3A 1A 9C    			LD		A,(LastPages)
0468   0302 3D          			DEC		A
0469   0303 20 78       			JR		NZ,KeyRIGHT						;Last Row and more than 1 page so go there to deal with it
0470   0305 3A 47 9C    			LD		A,(CurRow)
0471   0308 0E 38       			LD		C,NoSel_Color					;Attr for non selected
0472   030A CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0473   030D 3E 01       			LD		A,1
0474   030F 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0475   0312 C3 1C 02    			JP		NoShowPage
0476   0315             
0477   0315             	;Here for LEFT pressed
0478   0315             KeyLEFT: 
0479   0315 3A 1A 9C    			LD		A,(LastPages)
0480   0318 3D          			DEC		A
0481   0319 CA 2F 02    			JP		Z,MenuWaitChange				;If only 1 page then Left don't do anything
0482   031C             			
0483   031C 3E 01       			LD		A,MinRowFiles
0484   031E 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0485   0321             KeyLEFT_after: 
0486   0321 21 34 DD    			LD		HL,CurPage						;Current page (1..99)
0487   0324 3E 01       			LD		A,1
0488   0326 BE          			CP		(HL)
0489   0327 CA 40 03    			JP		Z,KeyGoLastPage					;If 1st page, go to last page  ;;JP Z, MenuWaitChange				;If 1st page, nothing to do->jump
0490   032A 35          			DEC		(HL)							;Decrease current page number
0491   032B 3A 1B 9C    			LD		A,(CurrPages)					;Page 1..11 into chapter
0492   032E 3D          			DEC		A
0493   032F 20 42       			JR		NZ,KeyLEFT_Page					;If Page was > 1 then process next page
0494   0331             
0495   0331             		;Here arriving if we were in 1st page of this chapter
0496   0331 3E 0B       			LD		A,MaxPageChap
0497   0333 32 1B 9C    			LD		(CurrPages),A					;Update current page 11 (1..11)
0498   0336 3A 1D 9C    			LD		A,(CurrChapter)
0499   0339 3D          			DEC		A
0500   033A 32 1D 9C    			LD		(CurrChapter),A					;Go to previous chapter
0501   033D C3 88 00    			JP		GoTo_Chapter
0502   0340             
0503   0340             KeyGoLastPage: 
0504   0340 3A 1A 9C    			LD		A,(LastPages)
0505   0343 32 34 DD    			LD		(CurPage),A						;Goto page 1..99
0506   0346             KeyGoLastPage_Subpage: 
0507   0346 FE 0C       			CP		MaxPageChap+1
0508   0348 38 04       			JR		C,KeyGoLastPage_EndSubpage		;if less or queal to MaxPageChap (11)
0509   034A D6 0B       			SUB		MaxPageChap
0510   034C 18 F8       			JR		KeyGoLastPage_Subpage
0511   034E             			
0512   034E             KeyGoLastPage_EndSubpage: 			
0513   034E 32 1B 9C    			LD		(CurrPages),A					;page 1..11 as per page in chapter
0514   0351 3A 18 9C    			LD		A,(LastFile)
0515   0354             KeyGoLastPage_SubFile: 
0516   0354 FE 18       			CP		MaxFilePage+1
0517   0356 38 04       			JR		C,KeyGoLastPage_EndSubFile		;if less or queal to MaxFilePage (23)
0518   0358 D6 17       			SUB		MaxFilePage
0519   035A 18 F8       			JR		KeyGoLastPage_SubFile
0520   035C             KeyGoLastPage_EndSubFile: 
0521   035C 32 19 9C    			LD		(CurrFile),A
0522   035F 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0523   0362             
0524   0362 CD 8A 3B    			CALL	SetCurPageOff					;Adjust CurPageOff (1..11) as per CurrPages (1..99) so browsing correct page
0525   0365             
0526   0365 3A 1C 9C    			LD		A,(LastChapter)
0527   0368 32 1D 9C    			LD		(CurrChapter),A
0528   036B FE 01       			CP		1
0529   036D CA 7E 01    			JP		Z,Printing_PAGE					;Jump if having only 1 chapter (no require to reload chapters)
0530   0370             		;Here if more than 1 chapter (so going to last chapter, last page, last file)
0531   0370 C3 88 00    			JP		GoTo_Chapter
0532   0373             
0533   0373             KeyLEFT_Page: 
0534   0373 32 1B 9C    			LD		(CurrPages),A					;Update current page
0535   0376             
0536   0376 3A 35 DD    			LD		A,(CurPageOff)
0537   0379 D6 17       			SUB		FilesPerPag
0538   037B 18 54       			JR		LEFT_RIGHT_UPDPage
0539   037D             
0540   037D             	;Here for RIGHT pressed
0541   037D             KeyRIGHT: 
0542   037D 3A 1A 9C    			LD		A,(LastPages)
0543   0380 3D          			DEC		A
0544   0381 CA 2F 02    			JP		Z,MenuWaitChange				;If only 1 page then Right don't do anything
0545   0384             
0546   0384 3E 01       			LD		A,MinRowFiles
0547   0386 32 44 9C    			LD		(RowNewPage),A					;After change page go to last Row
0548   0389 21 34 DD    			LD		HL,CurPage						;Current page (1..99)
0549   038C 3A 1A 9C    			LD		A,(LastPages)					;Max number of page to go to the next (1..99)
0550   038F BE          			CP		(HL)
0551   0390 28 18       			JR		Z,KeyGo1stPage					;If Last page, go to last page  ;;JP		Z,MenuWaitChange				;If last page, nothing to do->jump
0552   0392 34          			INC		(HL)							;Increase current page number
0553   0393 3A 1B 9C    			LD		A,(CurrPages)					;Page 1..11 into chapter
0554   0396 3C          			INC		A
0555   0397 FE 0C       			CP		MaxPageChap+1
0556   0399 20 2E       			JR		NZ,KeyRIGHT_Page				;If Page was <11 then process next page
0557   039B             			
0558   039B             		;Here arriving arriving if we were in last page of this chapter
0559   039B 3E 01       			LD		A,1
0560   039D 32 1B 9C    			LD		(CurrPages),A					;Update current page 1 (1..11)
0561   03A0 3A 1D 9C    			LD		A,(CurrChapter)
0562   03A3 3C          			INC		A
0563   03A4 32 1D 9C    			LD		(CurrChapter),A					;Go to next chapter
0564   03A7 C3 88 00    			JP		GoTo_Chapter
0565   03AA             			
0566   03AA             KeyGo1stPage: 
0567   03AA 3E 01       			LD		A,1
0568   03AC 32 1D 9C    			LD		(CurrChapter),A					;1st chapter
0569   03AF 32 34 DD    			LD		(CurPage),A						;Goto page 1 (1..99)
0570   03B2 32 1B 9C    			LD		(CurrPages),A					;Subpage 1 (1..11 as per Page into Chapter)
0571   03B5 32 19 9C    			LD		(CurrFile),A					;1st file selected
0572   03B8 32 44 9C    			LD		(RowNewPage),A					;After change page go to 1st Row
0573   03BB             
0574   03BB CD 8A 3B    			CALL	SetCurPageOff					;Adjust CurPageOff (1..11) as per CurrPages (1..99) so browsing correct page
0575   03BE             
0576   03BE 3A 1C 9C    			LD		A,(LastChapter)
0577   03C1 FE 01       			CP		1
0578   03C3 CA 7E 01    			JP		Z,Printing_PAGE					;Jump if having only 1 chapter (no require to reload chapters)
0579   03C6             		;Here if more than 1 chapter (so going to 1st chapter, 1st page, 1st file)
0580   03C6 C3 88 00    			JP		GoTo_Chapter
0581   03C9             
0582   03C9             		
0583   03C9             KeyRIGHT_Page: 
0584   03C9 32 1B 9C    			LD		(CurrPages),A					;Update current page
0585   03CC             			
0586   03CC 3A 35 DD    			LD		A,(CurPageOff)
0587   03CF C6 17       			ADD		FilesPerPag
0588   03D1             		;Common zone for LEFT-RIGHT
0589   03D1             LEFT_RIGHT_UPDPage: 
0590   03D1 32 35 DD    			LD		(CurPageOff),A					;Update offset for Page
0591   03D4             
0592   03D4 CD 9A 3A    			CALL	ClsFiles
0593   03D7             			
0594   03D7 3E 01       			LD		A,MinRowFiles					;So repaint will begin in MinRowFiles
0595   03D9 32 47 9C    			LD		(CurRow),A						;Update CurRow for repaint
0596   03DC             
0597   03DC C3 7E 01    			JP		Printing_PAGE		
0598   03DF             
0599   03DF             	;Here for go to ROOT or PARENT as per SPACE_IS_ROOT is defined of no
0600   03DF             KeyROOT: 
0601   03DF             	IFDEF SPACE_IS_ROOT
0602   03DF~            		;Here for Going to ROOT (SPACE_IS_ROOT was defined)
0603   03DF~            			LD		A,(PathIndexLast)
0604   03DF~            			AND		A
0605   03DF~            			JP		NZ,Goto_ROOT					;If we're in a subdir... go to ROOT
0606   03DF~            		;Here only if current dir is ROOT dir
0607   03DF~            			LD		HL,CurPage
0608   03DF~            			LD		A,1
0609   03DF~            			CP		(HL)
0610   03DF~            			JP		Z,AfterCheckKeys				;If we were in page 1 then avoid going to ROOT (not needed)
0611   03DF~            			LD		(HL),A							;Update page as 1
0612   03DF~            			XOR		A								;A=0 to update curpageoff (offset)
0613   03DF~            			JP		LEFT_RIGHT_UPDPage				;We're in root but as page > 1 then go to 1st page
0614   03DF~            ; ----------------------------------------------------------------------------------------
0615   03DF             	ELSE
0616   03DF             		;Here for Going to PARENT (SPACE_IS_ROOT was NOT defined)
0617   03DF             			
0618   03DF 3A 1D 9C    			LD		A,(CurrChapter)
0619   03E2 3D          			DEC		A
0620   03E3 20 C5       			JR		NZ,KeyGo1stPage					;Chapter differs
0621   03E5 3A 1B 9C    			LD		A,(CurrPages)
0622   03E8 3D          			DEC		A
0623   03E9 20 BF       			JR		NZ,KeyGo1stPage					;Page differs but same chapter
0624   03EB 3A 47 9C    			LD		A,(CurRow)
0625   03EE 3D          			DEC		A
0626   03EF 20 0A       			JR		NZ,KeyROOT_no1st_NoRepaint		;Selected is not the 1st so it's goint to parent
0627   03F1             			
0628   03F1             			;Current is 1st chapter, 1st page, 1st element => Go to Parent ".." (if root nothing happens)
0629   03F1 3A 06 DD    			LD		A,(PathIndexLast)				;A will be >0 (never 0 if entered here, as 0 is for root and don't have ".." )
0630   03F4 A7          			AND		A
0631   03F5 CA 60 02    			JP		Z,AfterCheckKeys				;Nothing to do as we're in ROOT
0632   03F8             			
0633   03F8 C3 B0 3A    			JP		Load_FT_DIRECTORY_GotoParent	;Proceed going to Parent dir
0634   03FB             			
0635   03FB             KeyROOT_no1st_NoRepaint: 
0636   03FB 3A 47 9C    			LD		A,(CurRow)
0637   03FE 0E 38       			LD		C,NoSel_Color					;Attr for non selected
0638   0400 CD 79 16    			CALL	RowAttr							;A=Row, C=attribute colour
0639   0403 3E 01       			LD		A,1
0640   0405 32 44 9C    			LD		(RowNewPage),A
0641   0408 C3 1C 02    			JP		NoShowPage						;Update selection 1st row without repaint
0642   040B             
0643   040B             	
0644   040B             	ENDIF
0645   040B             			
0646   040B             ;Process option selected: Change dir, Show SCR, Launch file in SNA directory, etc...
0647   040B             ; HL points to data (without directory)
0648   040B             ProcessFIRE: 
0649   040B             		;Next commands using Filename,0x00
0650   040B             
0651   040B 7E          			LD		A,(HL)							;A=FileType
0652   040C FE 31       			CP		FT_BASIC						;Check for type: "Go to ZX Basic" entry
0653   040E CA 98 3B    			JP		Z,ReturnTOBASIC 				;If FT_BASIC, then jump there
0654   0411             
0655   0411 FE 30       			CP		FT_ROMSET						;Check for type: ROMSET entry
0656   0413 C2 F4 04    			JP		NZ,NextProcessFIRE				;If no ROMSET, then jump there
0657   0416             
0658   0416             		;Here for ROMSET
0659   0416 3A 47 9C    			LD A,(CurRow)				;Current row.... if value is MinRowFiles then is to jump to Internal ROMSET
0660   0419 FE 01       			CP MinRowFiles
0661   041B C2 43 04    			JP NZ,ROMSET_pre			;No 1st row is because we selected a file of type ROMSET
0662   041E             			
0663   041E             		;check for 1st page to be sure is going to Dandanator 1st slot or it's a ROMSET in another page (not 1st)
0664   041E 3A 34 DD    			LD A,(CurPage)
0665   0421 3D          			DEC A
0666   0422 20 1F       			JR NZ,ROMSET_pre			;No 1st row is because we selected a file of type ROMSET in 2nd or later-on page
0667   0424             
0668   0424             		;Here for internal ROMSET . MARIO PENDIENTE CUANDO SE ELIGI ROMSET EN UNA PAGINA QUE NO ES LA 1...(eso indica que no es el internal romset)
0669   0424             Goto_Dan1stSlot: 			
0670   0424 21 31 04    			LD HL,RAMTOINTERNAL
0671   0427 11 00 80    			LD DE,ScratchRAM
0672   042A D5          			PUSH DE
0673   042B 01 12 00    			LD BC,ENDRAMTOINTERNAL-RAMTOINTERNAL
0674   042E ED B0       			LDIR
0675   0430 C9          			RET
0676   0431             
0677   0431             RAMTOINTERNAL: 
0678   0431 06 01       			LD B,1						;Slot to jump to
0679   0433             			SLOT_B
0679   0433 23          >.slot_b		INC HL
0679   0434 2B          >			DEC HL
0679   0435 32 00 00    >			LD (0),A
0679   0438 10 F9       >			DJNZ .slot_b
0680   043A             			WAIT_B PAUSELOOPSN
0680   043A 06 40       >			LD B,value
0680   043C 10 FE       >.wait_b0	DJNZ .wait_b0
0681   043E AF          			XOR A
0682   043F             			
0683   043F 32 8E 7F    			LD (AUTOBOOTCHK),A			; Save it to RAM so autolaunch is disabled
0684   0442 CF          			RST	#08						;Jump there to continue with normal launch (without autolaunch)
0685   0443             ENDRAMTOINTERNAL: 
0686   0443             		;End of launch internal Dandanator MENU
0687   0443             ROMSET_pre: 
0688   0443 22 39 DD    			LD		(Rom2Write),HL					;Save addres of romset info 
0689   0446             		;Check if romset is lower than v10 to show messages as per TXTROM10
0690   0446 DD 21 1E 9C 			LD		IX,ROMVersion					;As per GetInfo we have there the string of Version of Romset vx.x or vxx.x
0691   044A DD 7E 00    			LD		A,(IX)
0692   044D FE 76       			CP		'v'								;Check v string for version
0693   044F 20 07       			JR		NZ,noROMSETver					;Jump if v char is not found
0694   0451 DD 7E 03    			LD		A,(IX+3)
0695   0454 FE 2E       			CP		'.'
0696   0456 28 13       			JR		Z,ROMSET_pre2					;Jump if vxx.x (that means is a >=10.0)
0697   0458             		;Here if version not compatible with Multiply
0698   0458             noROMSETver: 
0699   0458 11 13 05    			LD		DE,(ColDescSel/2) + ((3+RowDescSel) << 8)
0700   045B 01 0C 7A    			LD		BC,12+(%01111010<<8)			;C=12 bytes to change attr, B=Bright, Paper white, ink red
0701   045E CD 6B 16    			CALL	RowAttrMod						; change attribute colours at Row D(0..23), Column E(0..31) with attribute B for a number of byte as per C
0702   0461             
0703   0461 DD 21 9A 17 			LD		IX,TXTROM10
0704   0465 11 26 05    			LD		DE,ColDescSel + ((3+RowDescSel) << 8)
0705   0468 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box
0706   046B             ROMSET_pre2: 
0707   046B             			
0708   046B             		;Here to confirm writing romset to Dandanator EEPROM
0709   046B             		
0710   046B 11 11 07    			LD		DE,(ColOPTSel/2) + ((5+RowDescSel) << 8)
0711   046E 01 0D 79    			LD		BC,13+(%01111001<<8)			;C=12 bytes to change attr, B=Bright, Paper white, ink blue
0712   0471 CD 6B 16    			CALL	RowAttrMod						; change attribute colours at Row D(0..23), Column E(0..31) with attribute B for a number of byte as per C
0713   0474             
0714   0474 DD 21 7F 17 			LD		IX,TXTROMWRITE
0715   0478 11 22 07    			LD		DE,ColOPTSel + ((5+RowDescSel) << 8)
0716   047B CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box
0717   047E             
0718   047E             		;Now flash option " NO " (2 bytes)
0719   047E             			RowCol2ATTR HL, 5+RowDescSel, (ColOPTSel/2)+TXTROMWRoffNO	;Attr position for NO
0719   047E 21 F9 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0720   0481 CB FE       			SET		7,(HL)							;Activate flash of 1st attribute
0721   0483 23          			INC		HL
0722   0484 CB FE       			SET		7,(HL)							;Activate flash of 2nd attribute
0723   0486             
0724   0486 3E 01       			LD		A,1
0725   0488             ROMSET_SM: 
0726   0488 32 3B DD    			LD		(SubMenuOpt),A					;Tell Menu routine we're waiting in submenu number 1 (so no process normal Menu keys)
0727   048B C3 2F 02    			JP		MenuWaitChange					;Nothing more to do here so return to wait for submenu options	
0728   048E             			
0729   048E             ;	DEFINE	LESSKEYS								;Uncomment using only RIGHT-LEFT-FIRE. Comment for using also UP,DOWN,SPACE to exit
0730   048E             			
0731   048E             		;Here when pressed a key in submenu ROMSET (SubMenuOpt)=1
0732   048E             ROMSET_SubMenu: 
0733   048E 3A 40 9C    			LD		A,(KeyToExe)					;Get valid key
0734   0491 0F          			RRCA
0735   0492 38 12       			JR		C,ROMSET_SubMenuChange			;Bit 0 for Right
0736   0494 0F          			RRCA
0737   0495 38 0F       			JR		C,ROMSET_SubMenuChange			;Bit 1 for Left
0738   0497             		IFDEF LESSKEYS
0739   0497~            			.3		RRCA
0740   0497~            			JR		C,ROMSET_SubMenuENTER			;Bit 4 for FIRE
0741   0497             		ELSE
0742   0497 0F          			RRCA
0743   0498 38 27       			JR		C,ROMSET_SubMenuEND				;Bit 2 for Down
0744   049A 0F          			RRCA
0745   049B 38 24       			JR		C,ROMSET_SubMenuEND				;Bit 3 for UP
0746   049D 0F          			RRCA
0747   049E 38 19       			JR		C,ROMSET_SubMenuENTER			;Bit 4 for FIRE
0748   04A0 0F          			RRCA
0749   04A1 38 1E       			JR		C,ROMSET_SubMenuEND				;Bit 5 for ROOT	
0750   04A3             		ENDIF
0751   04A3             ROMSET_SubMenu_Ret: 
0752   04A3 C3 2F 02    			JP		MenuWaitChange					;Nothing selected, return to wait for new keys
0753   04A6             
0754   04A6             ;ROMSET_SubMenuChange - Swap  NO-YES for selection
0755   04A6             ROMSET_SubMenuChange: 
0756   04A6             			RowCol2ATTR HL, 5+RowDescSel, (ColOPTSel/2)+TXTROMWRoffNO	;Attr position for NO
0756   04A6 21 F9 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0757   04A9 06 80       			LD		B,#80							;Value to swap flashing on<->off
0758   04AB 7E          			LD		A,(HL)							;1st byte of " NO "
0759   04AC A8          			XOR		B
0760   04AD 77          			LD		(HL),A		
0761   04AE 23          			INC		HL
0762   04AF 77          			LD		(HL),A							;2nd byte of " NO "
0763   04B0             
0764   04B0 23          > INC		HL						
0764   04B1 23          > INC		HL						
0765   04B2 7E          			LD		A,(HL)							;1st byte of " YES"
0766   04B3 A8          			XOR		B
0767   04B4 77          			LD		(HL),A		
0768   04B5 23          			INC		HL
0769   04B6 77          			LD		(HL),A							;2nd byte of " YES"
0770   04B7 18 EA       			JR		ROMSET_SubMenu_Ret
0771   04B9             
0772   04B9             ROMSET_SubMenuENTER: 
0773   04B9             			RowCol2ATTR HL, 5+RowDescSel, (ColOPTSel/2)+TXTROMWRoffNO	;Attr position for NO
0773   04B9 21 F9 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0774   04BC CB 7E       			BIT		7,(HL)							;Bit 7=1 if " NO " is activated, 0 for " YES" activated
0775   04BE CA 2E 33    			JP		Z,Load_FT_ROMSET				;for " YES" jump to eewriter
0776   04C1             		;If " NO " then exit submenu
0777   04C1             			
0778   04C1             		IFNDEF LESSKEYS
0779   04C1             ROMSET_SubMenuEND: 
0780   04C1             			RowCol2ATTR HL, 5+RowDescSel, (ColOPTSel/2)+TXTROMWRoffNO	;Attr position for NO
0780   04C1 21 F9 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0781   04C4             		ENDIF
0782   04C4 06 05       			LD  B,5									;5 bytes to clear flash attr
0783   04C6             .clear: 
0784   04C6 CB BE       			RES	    7,(HL)							;Clear flash attr
0785   04C8 23          			INC		HL
0786   04C9 10 FB       			DJNZ	.clear							;do it for all the bytes
0787   04CB             
0788   04CB DD 21 27 1B 			LD		IX,FT_ROMSET_ENTER				;Usual text
0789   04CF 11 22 07    			LD		DE,ColOPTSel + ((5+RowDescSel) << 8)
0790   04D2 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box
0791   04D5             
0792   04D5 DD 21 B7 1A 			LD		IX,FT_EMPTY
0793   04D9 11 26 05    			LD		DE,ColDescSel + ((3+RowDescSel) << 8)
0794   04DC CD CC 16    			CALL	PrintIXText						;Clear text in that line (use for romset not compatible)
0795   04DF             			
0796   04DF 11 13 05    			LD		DE,(ColDescSel/2) + ((3+RowDescSel) << 8)
0797   04E2 01 0C 78    			LD		BC,12+(%01111000<<8)			;C=12 bytes to change attr, B=Bright, Paper white, ink black
0798   04E5 CD 6B 16    			CALL	RowAttrMod						; change attribute colours at Row D(0..23), Column E(0..31) with attribute B for a number of byte as per C
0799   04E8             
0800   04E8 11 11 07    			LD		DE,(ColOPTSel/2) + ((5+RowDescSel) << 8)
0801   04EB 01 0D 78    			LD		BC,13+(%01111000<<8)			;C=12 bytes to change attr, B=Bright, Paper white, ink black
0802   04EE CD 6B 16    			CALL	RowAttrMod						; change attribute colours at Row D(0..23), Column E(0..31) with attribute B for a number of byte as per C
0803   04F1             
0804   04F1             
0805   04F1 AF          			XOR		A
0806   04F2 18 94       			JR		ROMSET_SM						;Jump there to deactivate submenu and return to menu
0807   04F4             
0808   04F4             
0809   04F4             ;Here for NO ROMSET was selected
0810   04F4             NextProcessFIRE: 
0811   04F4             			;LD		A,(HL)							;A=FileType	;<-Not required
0812   04F4 FE 0C       			CP		FT_DIRECTORY					;Check for type: Directory entry (so enter there -or go parent if ".." - )
0813   04F6 CA A8 3A    			JP		Z,Load_FT_DIRECTORY
0814   04F9             			
0815   04F9             
0816   04F9             			;LD		A,(HL)							;A=FileType ;<-Not required
0817   04F9 FE 10       			CP		FT_SCR							;Check for type: Screen (6912 bytes)
0818   04FB CA F0 08    			JP		Z,Load_FT_SCR
0819   04FE             
0820   04FE             			;LD		A,(HL)							;A=FileType ;<-Not required
0821   04FE FE 20       			CP		FT_TAP							;Check for type: TAP
0822   0500 CA B7 19    			JP		Z,Load_FT_TAP
0823   0503             		
0824   0503             		;MARIO PENDIENTE OTROS TIPOS QUE VAYAMOS INTRODUCIENDO A FUTURO....TZX...BIN...
0825   0503             		
0826   0503             		
0827   0503             		
0828   0503             		;Here for load Snapshot (SNA or Z80)
0829   0503             			;JP LaunchSnap		;Not required as it's just here..... REMOVE ; IF CHANGED "LaunchSnap" TO ANOTHER PLACE
0830   0503             LaunchSnap: 
0831   0503             		include "launchSnap/Launch_Snap.asm"	;Take care IF CHANGED "LaunchSnap" TO ANOTHER PLACE, see previous lines....
0001+  0503             ;Launch_Snap -
0002+  0503             ;	IN HL = Address where filename to launch is stored
0003+  0503             
0004+  0503             
0005+  0503             SNALEN			EQU 64								; length of SNA header
0006+  0503             SNA7FFD			EQU 29								; Position in SNA header of #1FFD register
0007+  0503             SNA1FFD			EQU 30								; Position in SNA header of #1FFD register
0008+  0503             SNATYPE			EQU 31								; Position in SNA header of SNA type: 16k, 48k, 128k
0009+  0503             SNAAY			EQU 32								; Position in SNA header of AY registers
0010+  0503             LENCHUNK		EQU	512								; Size of Chunk (last 512 bytes of RAM5), also maximum size or Snapshot loading/launching routine
0011+  0503             ADDRSP			EQU #8000							; Addr for stack
0012+  0503             ADDRRAM			EQU ADDRSP-LENCHUNK					; Place to put the loading routine (load4bit will be in ROM)
0013+  0503 F3          			DI
0014+  0504             			;IM		1
0015+  0504 3E 01       			LD		A,1
0016+  0506 D3 FE       			OUT		(#FE),A							;Blue border for waiting
0017+  0508 31 00 80    			LD		SP,ADDRSP
0018+  050B E5          			PUSH	HL								;Save HL address for filename to launch (1 byte File type, then chars finished in 0x00,0xFF)
0019+  050C             			
0020+  050C 21 3A 05    			LD		HL,BeginRAM
0021+  050F 11 00 7E    			LD		DE,ADDRRAM
0022+  0512 01 94 01    			LD		BC,EndRAM-BeginRAM
0023+  0515 ED B0       			LDIR									;Copy routine to RAM
0024+  0517             		DISPLAY "DanSnap_Val: ",/A,DanSnap_Val
0025+  0517             		DISPLAY "End of chunk routine : ",/A,ADDRRAM+(EndRAM-BeginRAM)
0026+  0517             		ASSERT (ADDRRAM+(EndRAM-BeginRAM))<ADDRSP-#0010		;Avoid collision of routine with stack (free 16 bytes even less will be used)
0027+  0517             
0028+  0517             			;Clear attr area of screen
0029+  0517 21 00 58    			LD		HL,#5800
0030+  051A CD 64 7F    			CALL	CLS_ATTR
0031+  051D             
0032+  051D             			;for the chance this was 128k, also clear shadow screen
0033+  051D 11 07 04    			LD DE,#0407
0034+  0520 CD 6E 7F    			CALL RAMSPAGEDE						;Page #1FFD with D, #7FFD with E
0035+  0523             			
0036+  0523 21 00 D8    			LD HL,#D800
0037+  0526 CD 64 7F    			CALL CLS_ATTR
0038+  0529             			
0039+  0529 1E 00       			LD		E,#00							;E=#00 to be sure RAM 0 is paged
0040+  052B CD 74 7F    			CALL	RAMSPAGEE						;Page only #7FFD with E
0041+  052E             
0042+  052E             		;Send (command CMD_RESET) to arduino so it resets-itself
0043+  052E             		;	LD		A, CMD_RESET					; Request Arduino to auto-reset (Command DANCMD_MULTIPLY,DANDAT_MULTIPLY,CMD_RESET)
0044+  052E             
0045+  052E             		;    CALL	SendSerByteLC
0046+  052E             
0047+  052E             		;	
0048+  052E             		;	LD		B,75					;Wait 75 times, that is 75/50 = 1.5 seconds... so Arduino can finish auto-reset
0049+  052E             		;	CALL	WAITING
0050+  052E             			
0051+  052E C3 1E 7E    			JP		StartRoutine
0052+  0531             
0053+  0531             WAIT_B: 
0054+  0531 01 00 10    			LD		BC,#1000
0055+  0534             WAITING: 
0056+  0534 0B          			DEC		BC
0057+  0535 78          			LD		A,B
0058+  0536 B1          			OR		C
0059+  0537 20 FB       			JR		NZ,WAITING
0060+  0539 C9          			RET
0061+  053A             
0062+  053A             
0063+  053A             BeginRAM: 
0064+  053A             		DISP ADDRRAM
0065+  7E00             
0066+  7E00             ;Required SPARE SPACE so here to ADDRSNA there is 0x25 bytes... DON'T CHANGE THIS
0067+  7E00 FF          			defs	30,#FF
0068+  7E1E             StartRoutine: 
0069+  7E1E             
0070+  7E1E DD E1       			POP		IX
0071+  7E20 DD 7E 00    			LD		A,(IX)
0072+  7E23 32 7C 7F    			LD		(File_FTYPE),A					;Copy to RAM so we know File Type for loading blocks...
0073+  7E26             			
0074+  7E26 3E 09       			LD		A,CMD_ZX2SD_OFREAD_IX				;Command = Open File (Relative Path)
0075+  7E28 DD 56 20    			LD		D,(IX+FILEINDEX)					;Low byte of Index
0076+  7E2B DD 5E 21    			LD		E,(IX+FILEINDEX+1)					;High Byte of index
0077+  7E2E 37          			SCF											;Long confirmation for last byte sent
0078+  7E2F CD 76 19    			CALL 	ZX2SD_COMMAND
0079+  7E32             
0080+  7E32             		;Send command  to arduino asking for SNA data
0081+  7E32 21 FD 7D    			LD		HL,ENDSNA-SNALEN				; Destination of data
0082+  7E35 11 40 00    			LD		DE,SNALEN						; Length of data (SNA header as send by Arduino)
0083+  7E38 0E 09       			LD		C,SNAP_HEADER					;c=SNAP_HEADER so command is get SNA or Z80 header
0084+  7E3A             
0085+  7E3A CD CE 06    			CALL	LoadBlock						;Load Snap_Header
0086+  7E3D             		
0087+  7E3D             ENDSNA: 	;Used so we calculate where to store SNA header so it finished just here
0088+  7E3D             ADDRSNA		EQU ENDSNA-SNALEN
0089+  7E3D             		DISPLAY "ENDSNA-SNALEN should be more than 0x25:",/A,$-ADDRRAM
0090+  7E3D             	ASSERT ($-ADDRRAM) > 0X25
0091+  7E3D             		
0092+  7E3D             		;Restore some registers not used in next routines. Other registers will be moved to stack (SP=ADDRSP at this moment)
0093+  7E3D 3A FD 7D    			LD		A,(ADDRSNA)
0094+  7E40 ED 47       			LD		I,A								;Restored I
0095+  7E42 31 FE 7D    			LD		SP,ADDRSNA+1
0096+  7E45 E1          			POP		HL
0097+  7E46 D1          			POP		DE
0098+  7E47 C1          			POP		BC
0099+  7E48 D9          			EXX										;Restored HL', DE', BC'
0100+  7E49             			
0101+  7E49 F1          			POP		AF
0102+  7E4A 08          			EX		AF,AF							;Restored AF'
0103+  7E4B E1          			POP		HL
0104+  7E4C 22 8A 7F    			LD		(LastHL+1),HL					;Save into RAM for the final routine that will be saved to sector
0105+  7E4F E1          			POP		HL
0106+  7E50 22 8E 7F    			LD		(LastDE+1),HL					;Save into RAM for the final routine that will be saved to sector
0107+  7E53 E1          			POP		HL
0108+  7E54 22 91 7F    			LD		(LastBC+1),HL					;Save into RAM for the final routine that will be saved to sector
0109+  7E57 FD E1       			POP		IY								;Restored IY
0110+  7E59             
0111+  7E59 DD E1       			POP		IX								;Restores IX
0112+  7E5B             
0113+  7E5B C1          			POP		BC								;C=EI/DI (bit 2), B=R
0114+  7E5C 79          			LD		A,C
0115+  7E5D E6 04       			AND		%00000100						;Isolate bit 2
0116+  7E5F 32 7D 7F    			LD		(LastINT),A						;Store EI/DI directly in LastINT (so bit 2 is DI/EI)
0117+  7E62             
0118+  7E62 78          			LD		A,B								;Copy value of R to A
0119+  7E63 E6 7F       			AND		#7F								;Remove bit 7 => 0
0120+  7E65 C6 6F       			ADD		#6F								;Adjust R for returning routine
0121+  7E67 E6 7F       			AND		#7F								;Remove bit 7 => 0
0122+  7E69 CB 78       			BIT 	7,B								;if bit 7 = 1 then Z=deactivated
0123+  7E6B 28 02       			JR		Z,noBit7
0124+  7E6D F6 80       			OR		#80								;Restore bit 7 = 1
0125+  7E6F             noBit7: 
0126+  7E6F 32 7E 7F    			LD		(LastR),A					    ;For saving into RAM for the final routine that will be saved to sector
0127+  7E72             			
0128+  7E72 E1          			POP		HL								;AF reg in SNA
0129+  7E73 22 7F 7F    			LD		(LastAF),HL					    ;For saving into RAM for the final routine that will be saved to sector
0130+  7E76 E1          			POP		HL								;SP reg in SNA
0131+  7E77 22 82 7F    			LD		(LastSP+1),HL					;For saving into RAM for the final routine that will be saved to sector
0132+  7E7A             
0133+  7E7A             		;restore more registers
0134+  7E7A E1          			POP		HL								;H=border / L=IIMx 0,1,2
0135+  7E7B 7C          			LD		A,H
0136+  7E7C 32 00 7F    			LD		(LastBorder+1),A				;Store border colour for change at the end (prior to load chunk and jump to game)
0137+  7E7F FE 01       			CP		1
0138+  7E81 3E 01       			LD		A,1								;Usual loading border is blue
0139+  7E83 20 02       			JR		NZ,OkBorderLoad
0140+  7E85 3E 05       			LD		A,5								;Alternative loading border cyan (when real border is blue)
0141+  7E87             OkBorderLoad: 
0142+  7E87 D3 FE       			OUT		(#FE),A							;Restore border colour from SNA
0143+  7E89             			
0144+  7E89 7D          			LD		A,L
0145+  7E8A E6 03       			AND		3								;Isolate bits for IMx
0146+  7E8C 21 7D 7F    			LD		HL,LastINT					    ;For saving into RAM for the final routine that will be saved to sector
0147+  7E8F B6          			OR		(HL)
0148+  7E90 77          			LD		(HL),A							;Update final value
0149+  7E91             IM_EndSet: 
0150+  7E91             
0151+  7E91             		;adjust PC for final jump
0152+  7E91 E1          			POP		HL								;PC for jump, or 0 if PC was already into stack
0153+  7E92 22 85 7F    			LD		(LastPreHL+1),HL			    ;For saving into RAM for the final routine that will be saved to sector
0154+  7E95 7C          			LD		A,H
0155+  7E96 B5          			OR		L
0156+  7E97 20 03       			JR		NZ,HavePUSHDE					;If PC was <>0 it had value 
0157+  7E99 32 87 7F    			LD		(LastRET),A						;Change PUSH DE to NOP (SNA48 have PC in stack so no need to do anything else) -in RAM to be saved in sector-
0158+  7E9C             HavePUSHDE: 			
0159+  7E9C 31 00 80    			LD		SP,ADDRSP						;Provisional stack address during loading blocks (end of chunk)
0160+  7E9F             			
0161+  7E9F             		;Now load the blocks (except chunk with length=LENCHUNK )
0162+  7E9F 21 10 7F    			LD		HL,Table16K
0163+  7EA2 3A 1C 7E    			LD		A,(ADDRSNA+SNATYPE)				;SNA type: 1=16k, 3=48k, 8=128k
0164+  7EA5 FE 01       			CP		1
0165+  7EA7 28 14       			JR		Z,LoadBlocks					;1=16k, jump
0166+  7EA9 21 15 7F    			LD		HL,Table48K
0167+  7EAC FE 03       			CP		3
0168+  7EAE 28 0D       			JR		Z,LoadBlocks					;3=48k, jump
0169+  7EB0 21 22 7F    			LD		HL,Table128K
0170+  7EB3 3A 1A 7E    			LD		A,(ADDRSNA+SNA7FFD)				;Value in port #7FFD
0171+  7EB6 E6 08       			AND		#08								;Isolate Shadow/Normal screen bit
0172+  7EB8 28 03       			JR		Z,LoadBlocks
0173+  7EBA 21 43 7F    			LD		HL,Table128KShadow
0174+  7EBD             LoadBlocks: 
0175+  7EBD             
0176+  7EBD             		;(HL)= <ram to page>,<HIGH start>,<HIGH Len>,<value to ask arduino>
0177+  7EBD 7E          			LD		A,(HL)							;<ram to page>
0178+  7EBE FE FF       			CP		#FF
0179+  7EC0 28 15       			JR		Z,NowLoadChunk					;End loading so jump there
0180+  7EC2             			
0181+  7EC2 CD 75 7F    			CALL	RAMSPAGEA						;Map Upper RAM as per A reg
0182+  7EC5 23          			INC		HL
0183+  7EC6 5E          			LD		E,(HL)							;E=<HIGH start>
0184+  7EC7 23          			INC		HL
0185+  7EC8 56          			LD		D,(HL)							;E=<HIGH len>
0186+  7EC9 23          			INC		HL
0187+  7ECA 4E          			LD		C,(HL)							;E=<value to ask arduino>
0188+  7ECB 23          			INC		HL								;Prepare HL for next time
0189+  7ECC E5          			PUSH	HL								;Save HL for next time
0190+  7ECD AF          			XOR		A
0191+  7ECE 6F          			LD		L,A								;L=0 => HL will be xx00
0192+  7ECF 63          			LD		H,E								;HL=start
0193+  7ED0 5F          			LD		E,A								;DE=lenght => DE will be xx00
0194+  7ED1             		;LoadBlock require HL=Destination of data (start), DE=Length of data, C=block to load 1..8
0195+  7ED1             
0196+  7ED1 CD CE 06    			CALL	LoadBlock						;Will load correspondent Block 1..8 starting HL and length DE
0197+  7ED4             
0198+  7ED4 E1          			POP		HL								;Restore HL for next block to load
0199+  7ED5 18 E6       			JR		LoadBlocks
0200+  7ED7             
0201+  7ED7             NowLoadChunk: 
0202+  7ED7             		;banks for 128k models
0203+  7ED7 3A 1B 7E    			LD		A,(ADDRSNA+SNA1FFD)				; A=value for Port #1FFD
0204+  7EDA 57          			LD		D,A
0205+  7EDB 3A 1A 7E    			LD		A,(ADDRSNA+SNA7FFD)				; A=value for Port #7FFD
0206+  7EDE 5F          			LD		E,A
0207+  7EDF CD 6E 7F    			CALL	RAMSPAGEDE
0208+  7EE2             
0209+  7EE2             		;Restore AY registers
0210+  7EE2             
0211+  7EE2 21 1E 7E    			LD		HL,ADDRSNA+SNAAY+1				;HL=First AY reg (0..15)
0212+  7EE5 0E FD       			LD      C,#FD
0213+  7EE7 AF          			XOR		A								; Recuperate 16 regs (0..15)
0214+  7EE8             RESTAY128_Loop:  
0215+  7EE8 5E          			LD		E,(HL)							;L=Value for AY reg
0216+  7EE9 06 FF       			LD		B,#FF
0217+  7EEB ED 79       			OUT		(C),A							; AY reg
0218+  7EED 06 BF       			LD		B,#BF
0219+  7EEF ED 59       			OUT		(C),E							; Change value
0220+  7EF1 23          			INC		HL								;IX points to AYreg value
0221+  7EF2 3C          			INC		A
0222+  7EF3 FE 10       			CP		16								;if 0..15 saved z will be activated
0223+  7EF5 20 F1       			JR		NZ,RESTAY128_Loop				;Continue for 0..15 regs		
0224+  7EF7             
0225+  7EF7 3A 1D 7E    			LD		A,(ADDRSNA+SNAAY)				;Last out to #FFFD
0226+  7EFA 01 FD FF    			LD		BC,#FFFD
0227+  7EFD ED 79       			OUT		(C),A
0228+  7EFF             ;EndAY:
0229+  7EFF             		
0230+  7EFF 3E 00       LastBorder: 	LD		A,0								;Don't change that to XOR A.... it will hold the real value of border (maybe 0 or 1..7)
0231+  7F01 D3 FE       			OUT		(#FE),A							;Restore real border colour
0232+  7F03             
0233+  7F03             Begin_LaunchSAV: 
0234+  7F03 CD DC 07    			CALL	LaunchSAVESECT					;Save sector with last routine, Address of sector is in (PAYLOAD_addr)
0235+  7F06             End_LaunchSAV: 
0236+  7F06             		DISPLAY "End_LaunchSAV - ENDRAMSECTOR > 0:",/A,End_LaunchSAV - ENDRAMSECTOR
0237+  7F06             			ASSERT (End_LaunchSAV - ENDRAMSECTOR) > 0x00		;If (ENDRAMSECTOR < End_LaunchSAV)=False then send ERROR, if =True then continue compiling
0238+  7F06             
0239+  7F06 CD 5C 1A    			CALL ReenableButtons					;Reenable Left button as per Pause / DanSnap (if they exists in internal Dan EEPROM)
0240+  7F09             
0241+  7F09 ED 7B 9E 7E 			LD		SP,(PAYLOAD_addr)				;Will point to LastINT
0242+  7F0D             		;Copy all neccesary data to Final routine (still in RAM) so we can save it in the sector
0243+  7F0D             		;	SP=LastINT
0244+  7F0D             
0245+  7F0D C3 DE 06    			JP SLOT0_TOGAME							;From RAM goto Slot to 
0246+  7F10             
0247+  7F10             ;TableRamPages, contains <ram to page>,<HIGH start>,<HIGH Len>,<value to ask arduino>
0248+  7F10             CHK		EQU	HIGH (ADDRRAM-#4000)
0249+  7F10             Table16K: 
0250+  7F10 00403E01FF  			DEFB	#00,#40,CHK,1, #FF
0251+  7F15             Table48K: 
0252+  7F15             			DEFB	#00,#40,CHK,1, #00,#80,#40,2, #00,#C0,#40,3,#FF
0252+  7F15 00403E010080400200C04003FF
0253+  7F22             Table128K: 
0254+  7F22             			DEFB	#00,#40,CHK,1, #00,#80,#40,2, #00,#C0,#40,3, #01,#C0,#40,4, #03,#C0,#40,5, #04,#C0,#40,6, #06,#C0,#40,7, #07,#C0,#40,8, #FF
0254+  7F22 00403E010080400200C0400301C0400403C0400504C0400606C0400707C04008
0254+  7F42 FF
0255+  7F43             Table128KShadow: 
0256+  7F43             			DEFB	#0F,#C0,#40,8, #08,#40,CHK,1, #08,#80,#40,2, #08,#C0,#40,3, #09,#C0,#40,4, #0B,#C0,#40,5, #0C,#C0,#40,6, #0E,#C0,#40,7, #FF
0256+  7F43 0FC0400808403E010880400208C0400309C040040BC040050CC040060EC04007
0256+  7F63 FF
0257+  7F64             			
0258+  7F64             
0259+  7F64             ;CLS_ATTR - Clear only Attributes of screen, Normal or Shadow
0260+  7F64             ;	IN HL - #5800 for Normal Screen, #D800 for Shadow Screen
0261+  7F64             CLS_ATTR: 
0262+  7F64 54          			LD		D,H
0263+  7F65 5D          			LD		E,L
0264+  7F66 1C          			INC		E								;So DE=HL+1
0265+  7F67 01 FF 02    			LD		BC,#300-1						;BC=Size of attributes - 1
0266+  7F6A 75          			LD		(HL),L							;L has to be 0, so use it to fill
0267+  7F6B ED B0       			LDIR
0268+  7F6D C9          			RET
0269+  7F6E             ;RAMSPAGEDE - Page #1FFD with value in D, #7FFD with value in E
0270+  7F6E             RAMSPAGEDE: 
0271+  7F6E 7A          			LD		A,D
0272+  7F6F 01 FD 1F    			LD		BC,#1FFD
0273+  7F72 ED 79       			OUT		(C),A
0274+  7F74             ;RAMSPAGEE - Page #7FFD with value in E
0275+  7F74             RAMSPAGEE: 		; Page only #7FFD with value in E
0276+  7F74 7B          			LD		A,E
0277+  7F75             ;RAMSPAGEA - Page #7FFD with value in A
0278+  7F75             RAMSPAGEA: 		; Page only #7FFD with value in A
0279+  7F75 01 FD 7F    			LD		BC,#7FFD
0280+  7F78 ED 79       			OUT		(C),A
0281+  7F7A C9          			RET
0282+  7F7B             
0283+  7F7B 00          DanSnap		defb	0								;Will Hold slot in Dandantor for Pause or DanSnap (valid value 2-32)
0284+  7F7C 00          File_FTYPE	defb	0								;Will Hold File Type for using with LoadBlock
0285+  7F7D             ; ----------------------------------------------------------------------------------------
0286+  7F7D 00          LastINT: 	defb	0								;(1 byte) 1st byte Bit0= 0 IM 1, 1 IM2, Bit1=0 DI, 1 EI.
0287+  7F7E 00          LastR: 		defb	0								;(1 byte) R final (adjusted)
0288+  7F7F 00 00       LastAF: 		defw	0								;(2 bytes) AF final
0289+  7F81             LastRoutine: 	
0290+  7F81 31 FF FF    LastSP:  	LD	SP,#FFFF							;(3 bytes) SP final
0291+  7F84 21 FF FF    LastPreHL: 	LD  HL,#FFFF							;(3 bytes) Address of PC to put into stack (except SNA48)
0292+  7F87 E5          LastRET: 	PUSH	HL 								;(1 byte) For SNA48 it's a NOP, for others PUSH DE so DE will have PC address
0293+  7F88 D5          			PUSH	DE								;(1 byte) Position in RAM to Jump where is a RET 
0294+  7F89 21 FF FF    LastHL: 		LD	HL,#FFFF							;(3 bytes) HL final
0295+  7F8C 02          LasftFast: 	LD	(BC),A								;(1 byte) B = 0 so launch FastChange...we'll have 30-34Ts until changing to internal ROM and danzx locked...required more time
0296+  7F8D 11 FF FF    LastDE:  	LD	DE,#FFFF							;(3 bytes) 10Ts	
0297+  7F90 01 FF FF    LastBC:  	LD	BC,#FFFF							;(3 bytes) 10Ts	
0298+  7F93 C9          			RET										;(1 byte) 10Ts <-Return to address with the RET, from there return to game (PC)
0299+  7F94             
0300+  7F94             	;total 23 bytes+6 = 29
0301+  7F94             EndLastRoutine: 
0302+  7F94             DanSnap_Val: 										;(1 byte) Copy of DANSNAP_PAUSE value from internal Dandanator slot 1
0303+  7F94             													; does not use defb so LDIR to RAM will not overwrite value
0304+  7F94             		ENT
0305+  06CE             EndRAM: 
0306+  06CE             
0307+  06CE             ;Next will be executed from ROM...
0308+  06CE             
0309+  06CE             ;-----------------------------------------------------
0310+  06CE             ; IN HL - Destination of data
0311+  06CE             ; IN DE - Length of Data
0312+  06CE             ; IN (File_FTYPE)  - Command for ask block
0313+  06CE             ; IN C  - Value to send for command
0314+  06CE             ;-----------------------------------------------------
0315+  06CE             LoadBlock: 
0316+  06CE             		;Send (command as per File_FTYPE) to arduino asking for block (data= 6 for RAM5)
0317+  06CE 3A 7C 7F    			LD		A,(File_FTYPE)					;File Type for loading blocks
0318+  06D1             		
0319+  06D1             LoadBlockDirect1Par: 		;Insertion point to pass 1 byte parameter (i.e load screen)
0320+  06D1 CD D4 32    		    CALL	SendSerByteLC
0321+  06D4             LoadBlockDirect: 			
0322+  06D4 79          			LD		A,C
0323+  06D5 CD 04 33    			CALL	SendSerByte						; Request data of SNA block from SD (Command DANCMD_MULTIPLY,DANDAT_MULTIPLY,A)
0324+  06D8             
0325+  06D8 CD BF 32    			CALL	Load4bitBlk 					; Load block using 4bit Kempston (HL=Destination data, DE=Length)
0326+  06DB             
0327+  06DB C3 31 05    			JP		WAIT_B							;Wait a bit to sincronize Dandanator <-> Arduino and then return	
0328+  06DE             
0329+  06DE             ;-------------------new version less RAM usage
0330+  06DE             SLOT0_TOGAME: 
0331+  06DE             ;-------------------new version less RAM usage
0332+  06DE             			include "launchSnap/Launch_Snap_LASTROUTINE.asm"
0001++ 06DE             ;Launch_Snap_LASTROUTINE.asm
0002++ 06DE             ; Improved routine for using minimal RAM... using only B, AF and HL, no other register... exists with B=0, HL=#8000, AF=something....
0003++ 06DE             		;	SP=LastINT, DE=dir PC
0004++ 06DE             
0005++ 06DE 3A 7C 7F    			LD		A,(File_FTYPE)					;File Type for loading blocks
0006++ 06E1             
0007++ 06E1             		DAN_BIG_COMMAND_NOW DANCMD_MULTIPLY, DANDAT_MULTIPLY, A
0007++ 06E1 06 34       >			LD	B,C1			; Command
0007++ 06E3 23          >.slot_b		INC HL
0007++ 06E4 2B          >			DEC HL
0007++ 06E5 32 00 00    >			LD (0),A
0007++ 06E8 10 F9       >			DJNZ .slot_b
0007++ 06EA 06 40       >			LD B,value
0007++ 06EC 10 FE       >.wait_b0	DJNZ .wait_b0
0007++ 06EE 06 01       >			LD	B,C2			; Data 1
0007++ 06F0 23          >.slot_b		INC HL
0007++ 06F1 2B          >			DEC HL
0007++ 06F2 32 00 00    >			LD (0),A
0007++ 06F5 10 F9       >			DJNZ .slot_b
0007++ 06F7 06 40       >			LD B,value
0007++ 06F9 10 FE       >.wait_b0	DJNZ .wait_b0
0007++ 06FB 47          >			LD  B,C3			; Data 2
0007++ 06FC 23          >.slot_b		INC HL
0007++ 06FD 2B          >			DEC HL
0007++ 06FE 32 00 00    >			LD (0),A
0007++ 0701 10 F9       >			DJNZ .slot_b
0007++ 0703 06 40       >			LD B,value
0007++ 0705 10 FE       >.wait_b0	DJNZ .wait_b0
0007++ 0707 32 00 00    >			LD 	(0),A
0008++ 070A             		;Customized PAUSE_LONG without using SP
0009++ 070A DD A6 00    > AND (IX)
0009++ 070D DD A6 00    > AND (IX)
0009++ 0710 DD A6 00    > AND (IX)
0009++ 0713 DD A6 00    > AND (IX)
0010++ 0716 10 F2       			DJNZ .mypauselong
0011++ 0718             		
0012++ 0718             		;PAUSE_LONG
0013++ 0718             
0014++ 0718             		DAN_BIG_COMMAND_NOW DANCMD_MULTIPLY, DANDAT_MULTIPLY, SNAP_CHUNK
0014++ 0718 06 34       >			LD	B,C1			; Command
0014++ 071A 23          >.slot_b		INC HL
0014++ 071B 2B          >			DEC HL
0014++ 071C 32 00 00    >			LD (0),A
0014++ 071F 10 F9       >			DJNZ .slot_b
0014++ 0721 06 40       >			LD B,value
0014++ 0723 10 FE       >.wait_b0	DJNZ .wait_b0
0014++ 0725 06 01       >			LD	B,C2			; Data 1
0014++ 0727 23          >.slot_b		INC HL
0014++ 0728 2B          >			DEC HL
0014++ 0729 32 00 00    >			LD (0),A
0014++ 072C 10 F9       >			DJNZ .slot_b
0014++ 072E 06 40       >			LD B,value
0014++ 0730 10 FE       >.wait_b0	DJNZ .wait_b0
0014++ 0732 06 0A       >			LD  B,C3			; Data 2
0014++ 0734 23          >.slot_b		INC HL
0014++ 0735 2B          >			DEC HL
0014++ 0736 32 00 00    >			LD (0),A
0014++ 0739 10 F9       >			DJNZ .slot_b
0014++ 073B 06 40       >			LD B,value
0014++ 073D 10 FE       >.wait_b0	DJNZ .wait_b0
0014++ 073F 32 00 00    >			LD 	(0),A
0015++ 0742             
0016++ 0742 21 00 7E    			LD		HL,ADDRRAM						; Destination of data 
0017++ 0745 01 00 02    			LD		BC,LENCHUNK						; Length of chunk to load
0018++ 0748             ;------------------------------------
0019++ 0748             ;Last  Load4bitBlk customized only for  last chunk... 512 bytes to load between #7E00-#7FFF
0020++ 0748             ; Using only HL and AF
0021++ 0748             ;	IN HL=#7E00
0022++ 0748             FINALLoad4bitBlk: 
0023++ 0748             
0024++ 0748 2B          			DEC HL						;6Ts
0025++ 0749             FINALLoopByte: 
0026++ 0749             
0027++ 0749             FINALLoopFor1: 
0028++ 0749 DB 1F       			IN		A,(#1F)				;11 Ts
0029++ 074B 1F          			RRA							;4 Ts - bit 0 to carry, load value shifted to bits 3,2,1,0
0030++ 074C 30 FB       			JR		NC,FINALLoopFor1		;12/7 Ts - 1st nibble have always bit0=1
0031++ 074E             
0032++ 074E             ;EndLoopFor1:
0033++ 074E 23          			INC		HL					;6 Ts
0034++ 074F 0B          			DEC		BC					;6 Ts
0035++ 0750 77          			LD (HL),A					;7 Ts - RLD							;18 Ts - Move LOW nibble of A (really is the HIGH nibble we need)  to (HL) into LOW nibble
0036++ 0751             
0037++ 0751             
0038++ 0751             FINALLoopFor0: 
0039++ 0751 DB 1F       			IN		A,(#1F)				;11 Ts
0040++ 0753 1F          			RRA							;4 Ts - bit 0 to carry, load value shifted to bits 3,2,1,0
0041++ 0754 38 FB       			JR		C,FINALLoopFor0			;12/7 Ts - 2nd nibble have always bit0=0
0042++ 0756             
0043++ 0756             ;EndLoopFor0:
0044++ 0756 ED 6F       			RLD							;18 Ts - Move LOW nibble to (HL) into LOW nibble, previous LOW nibble in (HL) goes to HIGH nibble in (HL)
0045++ 0758 78          			LD		A,B
0046++ 0759 B1          			OR		C
0047++ 075A 20 ED       			JR		NZ,FINALLoopByte			;12 Ts - Bit 7 of H is zero.... continue.... 1 for we finish loading last 512 bytes
0048++ 075C             
0049++ 075C             ;------------------------------
0050++ 075C             
0051++ 075C             		;	SP=LastINT
0052++ 075C             
0053++ 075C 21 00 00    			LD	HL,0
0054++ 075F 39          			ADD	HL,SP			;So HL=LastINT
0055++ 0760 EB          			EX	DE,HL			;so DE=LastINT
0056++ 0761 31 00 80    			LD	SP,#8000		;SP point to RAM so EI-HALT can work correctly (if points to #0000-#3FFF dandanator receive pulse as command)
0057++ 0764 ED 4B FE 7F 			LD		BC,(#7FFE)
0058++ 0768 FB          			EI
0059++ 0769 76          			HALT
0060++ 076A ED 43 FE 7F 			LD		(#7FFE),BC
0061++ 076E             ;-----------------------------------------------------------
0062++ 076E             
0063++ 076E             ; Locate a RET (#C9) op-code in #4000-#FFFF.... ajuste en LastPreRET+1 (tiene un LD HL,xxxx + PUSH HL)
0064++ 076E 62          			LD  H,D
0065++ 076F 6B          			LD  L,E				;HL=LastINT
0066++ 0770 23          > INC HL			
0066++ 0771 23          > INC HL			
0066++ 0772 23          > INC HL			
0066++ 0773 23          > INC HL			
0066++ 0774 23          > INC HL			
0067++ 0775 7E          			LD A,(HL)			;Low byte of LastSP
0068++ 0776 23          			INC HL
0069++ 0777 66          			LD H,(HL)			;High byte of LastSP
0070++ 0778 6F          			LD L,A				;HL=LastSP
0071++ 0779 F9          			LD  SP,HL			;SP=LastSP
0072++ 077A             			
0073++ 077A             	;So now we can locate in RAM a RET
0074++ 077A 21 00 40    			LD	HL,#4000
0075++ 077D 01 00 C0    			LD	BC,#C000
0076++ 0780 3E C9       			LD	A,#C9
0077++ 0782             LocaRET_Loop: 
0078++ 0782 ED B1       			CPIR
0079++ 0784             	;CPIR stop when found #C9.... it should be very very strange no one #C9... it always should appear
0080++ 0784             	;so HL=address after #C9... also check it's not in range SP-2 <-> SP-1 and if so discard it and check for a new address
0081++ 0784 2B          			DEC		HL				;Adjust as CPIR finish in the next address after #C9
0082++ 0785 A7          			AND    A			;Remove carry
0083++ 0786 ED 72       			SBC    HL,SP			;HL=HL-SP	
0084++ 0788 30 0E       			JR     NC,RetValid		;Carry if HL>=SP (no conflict)
0085++ 078A 39          			ADD	HL,SP			;Recuperate value (DON'T USE CARRY)
0086++ 078B 23          > INC HL			
0086++ 078C 23          > INC HL			
0087++ 078D A7          			AND    A			;Remove carry
0088++ 078E ED 72       			SBC    HL,SP			;HL=HL-SP	
0089++ 0790 38 04       			JR     C,RetValid2		;Carry if HL<SP (conflict) -really check is address with #C9 - 2 < SP
0090++ 0792 39          			ADD	HL,SP			;Recuperate value (DON'T USE CARRY)
0091++ 0793 2B          			DEC HL			;skip SP-2 and SP-1 that are not valid
0092++ 0794 18 EC       			JR	LocaRET_Loop		;Repeat to locate another position
0093++ 0796             RetValid2: 
0094++ 0796 2B          > DEC HL
0094++ 0797 2B          > DEC HL
0095++ 0798             RetValid: 
0096++ 0798 39          			ADD	HL,SP			;Recuperate value (DON'T USE CARRY)
0097++ 0799             
0098++ 0799             	;Finally we have HL=Position in RAM with a RET
0099++ 0799             ;-----------------------------------------------------------	
0100++ 0799 EB          			EX DE,HL			;So DE=AddrwithRET, HL=LastINT
0101++ 079A             			
0102++ 079A             		;Now we send Special command 40,33,8: 
0103++ 079A 06 28       			LD		B,40							;Command 40=Fast command
0104++ 079C             			DAN_BIG_COMMAND_NOWAIT	33,8			;	 Data1=33 for Internal ROM, 8=Disable dandanator
0104++ 079C 23          >.slot_b		INC HL
0104++ 079D 2B          >			DEC HL
0104++ 079E 32 00 00    >			LD (0),A
0104++ 07A1 10 F9       >			DJNZ .slot_b
0104++ 07A3 06 40       >			LD B,value
0104++ 07A5 10 FE       >.wait_b0	DJNZ .wait_b0
0104++ 07A7 06 21       >			LD	B,C2			; Data 1
0104++ 07A9 23          >.slot_b		INC HL
0104++ 07AA 2B          >			DEC HL
0104++ 07AB 32 00 00    >			LD (0),A
0104++ 07AE 10 F9       >			DJNZ .slot_b
0104++ 07B0 06 40       >			LD B,value
0104++ 07B2 10 FE       >.wait_b0	DJNZ .wait_b0
0104++ 07B4 06 08       >			LD  B,C3			; Data 2
0104++ 07B6 23          >.slot_b		INC HL
0104++ 07B7 2B          >			DEC HL
0104++ 07B8 32 00 00    >			LD (0),A
0104++ 07BB 10 F9       >			DJNZ .slot_b
0104++ 07BD 06 40       >			LD B,value
0104++ 07BF 10 FE       >.wait_b0	DJNZ .wait_b0
0105++ 07C1             
0106++ 07C1 F9          			LD	SP,HL								;SP = LastINT
0107++ 07C2 C1          			POP	BC									;Take IMx-DI/EI-SNA48 bits (C) and R byte (B) 
0108++ 07C3 79          			LD  A,C									;C=0 for IM0, 1 for IM1, 2 for IM2
0109++ 07C4 E6 03       			AND 3									;Isolate bits for IMx
0110++ 07C6 3D          			DEC A
0111++ 07C7 3D          			DEC A
0112++ 07C8 20 02       			JR	NZ,setIM1							;If A=0 it was IM2
0113++ 07CA ED 5E       			IM	2									;if not set IM2 then we're in IM1
0114++ 07CC             setIM1: 
0115++ 07CC CB 51       			BIT	2,C									;Check if DI (0) or EI (1)
0116++ 07CE 28 01       			JR	Z,setDI
0117++ 07D0 FB          			EI										;if not EI we're in DI Still we have enought time before arriving Screen Interrupt
0118++ 07D1             setDI: 
0119++ 07D1 78          			LD	A,B									;B=R
0120++ 07D2 ED 4F       			LD	R,A									;R adjusted ....pending value
0121++ 07D4             
0122++ 07D4 F1          			POP	AF									;Restore AF (take from LastAF)
0123++ 07D5 23          > INC HL								
0123++ 07D6 23          > INC HL								
0123++ 07D7 23          > INC HL								
0123++ 07D8 23          > INC HL								
0124++ 07D9             
0125++ 07D9 06 00       			LD	B,0									;So BC=address points into EEP zone for activate previous Fast Command
0126++ 07DB E9          			JP	(HL)								;Jump to HL=LastRoutine
0127++ 07DC             
0333+  07DC             		
0334+  07DC             			include "launchSnap/Launch_Snap_SAVESECT.asm"
0001++ 07DC             ;SAVESECT - Save sector info... writing 1 byte is
0002++ 07DC             ;	Comando 48, 1, sector number (0..127)		
0003++ 07DC             ;	OUT (PAYLOAD_addr)=Zone in #2000-#2FFF where sector was saved				
0004++ 07DC             
0005++ 07DC             RAMSECTOR	equ		ADDRRAM							;#7E00
0006++ 07DC             
0007++ 07DC             
0008++ 07DC             ;Prepare routines in RAM to execute Erasing/Programming (always have to run from RAM... it trying from Slot it will hang speccy)
0009++ 07DC             LaunchSAVESECT: 
0010++ 07DC 21 50 08    			LD		HL,SECROUTINES
0011++ 07DF 11 00 7E    			LD		DE,RAMSECTOR
0012++ 07E2 01 A0 00    			LD		BC,ENDSECROUTINES-SECROUTINES
0013++ 07E5 ED B0       			LDIR
0014++ 07E7 3A EA 3F    			LD		A,(MLDoffset)					;Get from MLD the current slot number (0..31)
0015++ 07EA 3C          			INC		A								;Convert to 1..32
0016++ 07EB 32 9D 7E    			LD		(LAUNCH_MyCurMLD),A				;Saving in RAM so we can return to the correct slot when return from RAM
0017++ 07EE 3D          			DEC		A								;Againt 0..31
0018++ 07EF             ;Calculate sector   SlotMLD * 4 + 2
0019++ 07EF 87          			ADD A,A						
0020++ 07F0 87          			ADD A,A						
0021++ 07F1 C6 02       			ADD A,2									; A =sector number (0..127)... always is the 2nd sector (0,1,2,3) of the MLD slot
0022++ 07F3 5F          			LD  E,A									;Save in E the value of Sector (0..127)		
0023++ 07F4             							
0024++ 07F4             ;Routine to obtain address as per used bits (bits in "0"). MLD have bits in "1" intially in area #2000-#2FFF (bits in "1" for writing "0")							
0025++ 07F4 0E 00       			LD C,#00								;Will have the count of bits in 0 (used).		
0026++ 07F6 21 00 20    			LD HL,#2000								;#2000-#200F are 16 bytes x 8 bits, indicating each bit the usage of a block of 32 bytes. #2010-#201F are not used (always #FF)
0027++ 07F9 7E          			LD A,(HL)						
0028++ 07FA 3C          			INC A									;If A=#FF then now A=0. This means the MLD have not been used so #2000 is #FF (empty)		
0029++ 07FB 28 14       			JR Z,AfterErase							;As sector is erased (clean), jump there to begin to use it		
0030++ 07FD             Loop32: 							
0031++ 07FD 06 08       			LD B,8									;To process upto 8 bits		
0032++ 07FF 7E          			LD A,(HL)								;Value from address #2000-#200F	for getting the used sectors	
0033++ 0800             Loop8: 							
0034++ 0800 0F          			RRCA									;Take lower bit "1" Carry for not used, "0" Not carry if it's used
0035++ 0801 38 06       			JR C,LastBitActive						;if we find a bit in "1" is because is not used so exit (bit with 0 are always consecutive)
0036++ 0803 0C          			INC C									;Count 1 group of 16 bytes used
0037++ 0804             BitIs1: 							
0038++ 0804 10 FA       			DJNZ Loop8								;Repeat upto 8 bits
0039++ 0806 2C          			INC L									;Next address, only low byte is required as range is #2000-#201F		
0040++ 0807             			;LD A,L
0041++ 0807             			;CP #10									;Finish when arriving address #2010 (last valid address is #200F)		<-Not required as #2010 always have #FF
0042++ 0807 20 F4       			JR NZ,Loop32							;Repeat while in zone #2000-#201F and still getting bit with "0" value
0043++ 0809             LastBitActive: 
0044++ 0809 79          			LD A,C
0045++ 080A FE 7F       			CP #7F									;Finish when we saved #7f (127) times
0046++ 080C 20 11       			JR NZ,SaveZone							;No arriving to address #2010 is sign of we did not use all the saves (we have 127)
0047++ 080E             							
0048++ 080E             ;Here for erase sector (we used all saves - 127)
0049++ 080E             EraseSecExe: 
0050++ 080E CD 00 7E    			CALL EraseSectorRegE					;Erase sector as per E value 0..127	
0051++ 0811             							
0052++ 0811             ;Here for initial saving							
0053++ 0811             AfterErase: 							
0054++ 0811 0E FE       			LD C,%11111110							;So will write 1 bit with "0", indicating fist block of 32 bytes were used		
0055++ 0813 21 00 20    			LD HL,#2000						
0056++ 0816 CD 5E 7E    			CALL WriteValueRegE						;Write value in #2000 for sector as per E value 0..127
0057++ 0819 0E 01       			LD C,1									;C=1 indicating to begin after 1 initial block of 32 bytes
0058++ 081B 43          			LD		B,E								;E=B=Sector (0..127)
0059++ 081C C5          			PUSH	BC								;Saving C for using later-on
0060++ 081D 18 0C       			JR		AfterWriteLocByte				;Skip writing Loc byte
0061++ 081F             ;C says how much blocks of 32 bytes have been used (so next will be used this time). Value 1..127
0062++ 081F             ;	HL Points to last address in which "spare" bit was found (first bit with "1")				
0063++ 081F             ;So go to write LocByte
0064++ 081F             SaveZone: 
0065++ 081F 43          			LD		B,E								;E=B=Sector (0..127)
0066++ 0820 C5          			PUSH	BC								;Saving C for using later-on
0067++ 0821 A7          			AND		A								;Clear carry
0068++ 0822 7E          			LD		A,(HL)							;Get current value
0069++ 0823 17          			RLA										;Insert a "0" from right
0070++ 0824 4F          			LD		C,A
0071++ 0825 CD 5E 7E    			CALL WriteValueRegE						;Write value in #20xx for sector as per E value 0..127		
0072++ 0828 C1          			POP		BC								;Restore B sector, C value (LocByte)
0073++ 0829 C5          			PUSH	BC								;Save B sector, C value (LocByte)
0074++ 082A 0C          			INC		C								;C=C+1 so this block is the next saved
0075++ 082B             ;Now write the own data in the correct address as per last LocByte
0076++ 082B             AfterWriteLocByte: 
0077++ 082B             
0078++ 082B 69          			LD		L,C								;C=Number of block saved up to now
0079++ 082C 26 00       			LD		H,0
0080++ 082E 29          			ADD		HL,HL							;*2
0081++ 082F 29          			ADD		HL,HL							;*4
0082++ 0830 29          			ADD		HL,HL							;*8
0083++ 0831 29          			ADD		HL,HL							;*16
0084++ 0832 29          			ADD		HL,HL							;*32
0085++ 0833 01 00 20    			LD		BC,#2000
0086++ 0836 09          			ADD		HL,BC							;Calculated address where to save data
0087++ 0837             
0088++ 0837 22 9E 7E    			LD		(PAYLOAD_addr),HL				;Store used address in sector
0089++ 083A             
0090++ 083A C1          			POP		BC								;Restore B sector, C value (LocByte)
0091++ 083B             
0092++ 083B 0E 17       			LD		C,EndLastRoutine-LastINT; #20							;upto 32 bytes to save... using only the bytes required
0093++ 083D             
0094++ 083D 11 7D 7F    			LD		DE,LastINT						;Position for writing data
0095++ 0840             
0096++ 0840             LoopWriteBytes: 
0097++ 0840 C5          			PUSH	BC
0098++ 0841 1A          			LD		A,(DE)
0099++ 0842 4F          			LD		C,A
0100++ 0843 13          			INC		DE
0101++ 0844 D5          			PUSH	DE								;Save DE=Adress
0102++ 0845             
0103++ 0845 58          			LD		E,B
0104++ 0846 CD 5E 7E    			CALL	WriteValueRegE					;HL=Addr in sector, E=sector (0..127), C=value to write
0105++ 0849             
0106++ 0849 23          			INC		HL
0107++ 084A D1          			POP		DE								;Restore DE=Adress
0108++ 084B C1          			POP		BC
0109++ 084C 0D          			DEC		C
0110++ 084D 20 F1       			JR		NZ,LoopWriteBytes
0111++ 084F             
0112++ 084F C9          			RET
0113++ 0850             
0114++ 0850             ;------------------------------------------------------------------------------------
0115++ 0850             ; NEXT ROUTINES WILL EXECUTE FROM RAM---- NEVER USE FROM SLOT AS IT WILL HANG SPECCY
0116++ 0850             ;------------------------------------------------------------------------------------
0117++ 0850             SECROUTINES: 
0118++ 0850             			DISP	RAMSECTOR
0119++ 7E00             ;------------------------------------------------------------------------------------
0120++ 7E00             ; Customized routines for ERASE SECTOR and PROGRAM BYTE
0121++ 7E00             
0122++ 7E00             ;EraseSectorRegE - Erase sector in EEPROM
0123++ 7E00             ;	IN E=Sector (0..127) to erase
0124++ 7E00             ;
0125++ 7E00             ;	OUT E=Sector (0..127) erased
0126++ 7E00             ;	HL, A and B are used internally
0127++ 7E00             EraseSectorRegE: 
0128++ 7E00             
0129++ 7E00 06 30       			LD B,48									; Special Command 48, External eeprom operations			
0130++ 7E02             			DAN_BIG_COMMAND_NOWAIT #10, E			;Data1= #10=16 Sector Erase, Data2= E =Sector to erase (0..127)
0130++ 7E02 23          >.slot_b		INC HL
0130++ 7E03 2B          >			DEC HL
0130++ 7E04 32 00 00    >			LD (0),A
0130++ 7E07 10 F9       >			DJNZ .slot_b
0130++ 7E09 06 40       >			LD B,value
0130++ 7E0B 10 FE       >.wait_b0	DJNZ .wait_b0
0130++ 7E0D 06 10       >			LD	B,C2			; Data 1
0130++ 7E0F 23          >.slot_b		INC HL
0130++ 7E10 2B          >			DEC HL
0130++ 7E11 32 00 00    >			LD (0),A
0130++ 7E14 10 F9       >			DJNZ .slot_b
0130++ 7E16 06 40       >			LD B,value
0130++ 7E18 10 FE       >.wait_b0	DJNZ .wait_b0
0130++ 7E1A 43          >			LD  B,C3			; Data 2
0130++ 7E1B 23          >.slot_b		INC HL
0130++ 7E1C 2B          >			DEC HL
0130++ 7E1D 32 00 00    >			LD (0),A
0130++ 7E20 10 F9       >			DJNZ .slot_b
0130++ 7E22 06 40       >			LD B,value
0130++ 7E24 10 FE       >.wait_b0	DJNZ .wait_b0
0131++ 7E26             
0132++ 7E26 21 00 20    			LD		HL,ScratchSECT					;Always is the same address, we use only the correspondent sector to it
0133++ 7E29             			;CALL	LaunchSECTOR_ERASE
0134++ 7E29             
0135++ 7E29             ; LaunchSECTOR_ERASE. Send commands to EEPROM with the little help of PIC for the address #5555
0136++ 7E29             ;		- HL= Address of zone in sector to erase (#0000-#3FFF)
0137++ 7E29             LaunchSECTOR_ERASE: 			
0138++ 7E29 32 00 00    			LD	(0),A
0139++ 7E2C             			WAIT_B PAUSELOOPSN
0139++ 7E2C 06 40       >			LD B,value
0139++ 7E2E 10 FE       >.wait_b0	DJNZ .wait_b0
0140++ 7E30             			
0141++ 7E30             ;SE_Step1:
0142++ 7E30 3E AA       			LD A, $AA
0143++ 7E32 32 55 15    			LD (J5555),A			
0144++ 7E35             ;SE_Step2:
0145++ 7E35 0F          			RRCA						;LD A, $55	; replaced as $AA >> is $55
0146++ 7E36 32 AA 2A    			LD (J2AAA),A	
0147++ 7E39             ;SE_Step3:
0148++ 7E39 3E 80       			LD A, $80
0149++ 7E3B 32 55 15    			LD (J5555),A
0150++ 7E3E             ;SE_Step4:
0151++ 7E3E 3E AA       			LD A, $AA
0152++ 7E40 32 55 15    			LD (J5555),A
0153++ 7E43             ;SE_Step5:
0154++ 7E43 0F          			RRCA						;LD A, $55	; replaced as $AA >> is $55
0155++ 7E44 32 AA 2A    			LD (J2AAA),A
0156++ 7E47             ;SE_Step6:
0157++ 7E47 3E 30       			LD A, $30					; Actual sector erase		
0158++ 7E49 77          			LD (HL),A					; First Address of zone in sector to erase
0159++ 7E4A             
0160++ 7E4A             		;After sending JEDEC command Erase sector we use Toggle bit to finish (see SST39SF040 datasheet, time is around 18ms)
0161++ 7E4A             		;					Toggle bit is reading value in sector... when 2 reads return the same value then Erase have finished
0162++ 7E4A             LaunchSECTOR_ERASE_loop: 
0163++ 7E4A 7E          			LD		A,(HL)				; 7 Ts
0164++ 7E4B BE          			CP		(HL)				; 7 Ts
0165++ 7E4C 20 FC       			JR		NZ, LaunchSECTOR_ERASE_loop ; 12 Ts for repeat.... total is 26Ts (around 7.43us -miminal is 70ns so we're safe-... it will loop over for around 2423 times !!!)
0166++ 7E4E             
0167++ 7E4E             			; Finally return to correct slot.
0168++ 7E4E             LaunchRet_Slot: 
0169++ 7E4E 3A 9D 7E    			LD		A,(LAUNCH_MyCurMLD)		;That 1 change dinamically as per real Slot to return to
0170++ 7E51 47          			LD		B,A
0171++ 7E52             			SLOT_B
0171++ 7E52 23          >.slot_b		INC HL
0171++ 7E53 2B          >			DEC HL
0171++ 7E54 32 00 00    >			LD (0),A
0171++ 7E57 10 F9       >			DJNZ .slot_b
0172++ 7E59             			WAIT_B	PAUSELOOPSN
0172++ 7E59 06 40       >			LD B,value
0172++ 7E5B 10 FE       >.wait_b0	DJNZ .wait_b0
0173++ 7E5D C9          			RET
0174++ 7E5E             
0175++ 7E5E             
0176++ 7E5E             ;WriteValueRegE - Write some bytes in sector in EEPROM
0177++ 7E5E             ;	IN E  =Sector (0..127) to write to
0178++ 7E5E             ;	IN HL = Address in sector to write to
0179++ 7E5E             ;	IN C  =Vaue to write in the byte
0180++ 7E5E             WriteValueRegE: 
0181++ 7E5E 06 30       			LD B,48									; Special Command 48, External eeprom operations			
0182++ 7E60             			DAN_BIG_COMMAND_NOWAIT #01, E			;Data1= #01=01 Sector Program a byte, Data2= E =Sector to erase (0..127)
0182++ 7E60 23          >.slot_b		INC HL
0182++ 7E61 2B          >			DEC HL
0182++ 7E62 32 00 00    >			LD (0),A
0182++ 7E65 10 F9       >			DJNZ .slot_b
0182++ 7E67 06 40       >			LD B,value
0182++ 7E69 10 FE       >.wait_b0	DJNZ .wait_b0
0182++ 7E6B 06 01       >			LD	B,C2			; Data 1
0182++ 7E6D 23          >.slot_b		INC HL
0182++ 7E6E 2B          >			DEC HL
0182++ 7E6F 32 00 00    >			LD (0),A
0182++ 7E72 10 F9       >			DJNZ .slot_b
0182++ 7E74 06 40       >			LD B,value
0182++ 7E76 10 FE       >.wait_b0	DJNZ .wait_b0
0182++ 7E78 43          >			LD  B,C3			; Data 2
0182++ 7E79 23          >.slot_b		INC HL
0182++ 7E7A 2B          >			DEC HL
0182++ 7E7B 32 00 00    >			LD (0),A
0182++ 7E7E 10 F9       >			DJNZ .slot_b
0182++ 7E80 06 40       >			LD B,value
0182++ 7E82 10 FE       >.wait_b0	DJNZ .wait_b0
0183++ 7E84             
0184++ 7E84             			;CALL	SECTOR_WRITE1BYTE
0185++ 7E84             
0186++ 7E84             ; SECTOR_WRITE1BYTE. Send commands to EEPROM with the little help of PIC for the address #5555
0187++ 7E84             ;	IN HL = Address in sector to write to
0188++ 7E84             ;	IN C  = Byte to write
0189++ 7E84             SECTOR_WRITE1BYTE: 
0190++ 7E84 32 00 00    			LD	(0),A
0191++ 7E87             			WAIT_B PAUSELOOPSN
0191++ 7E87 06 40       >			LD B,value
0191++ 7E89 10 FE       >.wait_b0	DJNZ .wait_b0
0192++ 7E8B             
0193++ 7E8B             ;Write the data in sector
0194++ 7E8B             ;SECTLP:												; Sector Loop C times
0195++ 7E8B 3E AA       			LD		A,$AA							;Value to store			(7Ts) - time btw writes is 73Ts (>20.85us) so it's into SST39SF040 specs
0196++ 7E8D 32 55 15    			LD		(J5555),A
0197++ 7E90             ;PB_Step2:
0198++ 7E90 0F          			RRCA									;LD A, $55	; replaced as $AA >> is $55
0199++ 7E91 32 AA 2A    			LD		(J2AAA),A
0200++ 7E94             ;PB_Step3:
0201++ 7E94 3E A0       			LD		A,$A0
0202++ 7E96 32 55 15    			LD		(J5555),A	
0203++ 7E99             ;PB_Step4:
0204++ 7E99 79          			LD		A,C								; Value to Write
0205++ 7E9A 77          			LD		(HL),A							; Write it in the address
0206++ 7E9B             												; Datasheet tell us 20us max write time
0207++ 7E9B 18 B1       			JR		LaunchRet_Slot						;Return to caller MLD slot... it takes longer than 20us so no worry about EEP writing byte max time
0208++ 7E9D             						
0209++ 7E9D             ;------------------------------------------------------------------------------------
0210++ 7E9D             ; LOCAL VARIABLES IN RAM USED ONLY FOR SECTOR ROUTINES
0211++ 7E9D 00          LAUNCH_MyCurMLD	defb	0								;Will hold num or slot into EEP (value 0..31)
0212++ 7E9E 00 00       PAYLOAD_addr	defw	0								;Address for last routine (#2020-#2FF0)
0213++ 7EA0             
0214++ 7EA0             ;------------------------------------------------------------------------------------
0215++ 7EA0             ; END OF ROUTINES FROM RAM---- NEVER USE FROM SLOT AS IT WILL HANG SPECCY
0216++ 7EA0             ;------------------------------------------------------------------------------------
0217++ 7EA0             ENDRAMSECTOR: 
0218++ 7EA0             			ENT
0219++ 08F0             ENDSECROUTINES: 
0220++ 08F0             ;------------------------------------------------------------------------------------
0221++ 08F0             
0222++ 08F0             
0223++ 08F0             
0335+  08F0             ;-------------------------------------------------
0336+  08F0             
0832   08F0             
0833   08F0             LB: 
0834   08F0             		;loading routines per file type
0835   08F0             		include "resources/loadroutines.asm"
0001+  08F0             ;Load routines per file type
0002+  08F0             
0003+  08F0             
0004+  08F0             ;Load_FT_SCR - Load a screen (show it and return to directory after pressed a key)
0005+  08F0             Load_FT_SCR: 
0006+  08F0             			;DI
0007+  08F0             			
0008+  08F0 AF          			XOR		A
0009+  08F1 D3 FE       			OUT		(#FE),A
0010+  08F3             			
0011+  08F3 3A 21 DD    			LD		A,(PreviewStat)
0012+  08F6 FE 11       			CP		PreviewSHOWING
0013+  08F8 20 05       			JR		NZ,FullLoad
0014+  08FA             
0015+  08FA CD 74 09    			CALL	Swap_Screen						;We have it loaded so no need to load again
0016+  08FD 18 3C       			JR		WaitNKey1st
0017+  08FF             			
0018+  08FF             FullLoad: 
0019+  08FF 3E 11       			LD		A,PreviewSHOWING
0020+  0901 32 21 DD    			LD		(PreviewStat),A					;As will be loaded, it can be used
0021+  0904 E5          			PUSH	HL
0022+  0905 21 00 40    			LD		HL,#4000
0023+  0908 11 00 C0    			LD		DE,ScreensSCR					;Address for saving the current screen (Multiply menu with directory..etc...
0024+  090B 01 00 1B    			LD		BC,#1B00
0025+  090E ED B0       			LDIR									;Save screen for later on
0026+  0910 2B          			DEC		HL
0027+  0911 54          			LD		D,H
0028+  0912 5D          			LD		E,L
0029+  0913 1B          			DEC		DE
0030+  0914 36 00       			LD		(HL),0
0031+  0916 01 FF 02    			LD		BC,#300-1
0032+  0919 ED B8       			LDDR									;Clear attributes
0033+  091B             
0034+  091B DD E1       			POP		IX					;IX=file struct
0035+  091D             			;LD HL, FileSNA				; Request Arduino to open the file
0036+  091D             
0037+  091D             			;CALL ReqFileA							;Request to open the file..using command as per register A
0038+  091D 3E 09       			LD		A,CMD_ZX2SD_OFREAD_IX				;Command = Open File (Relative Path)
0039+  091F CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0040+  0922 DD 7E 20    			LD		A,(IX+FILEINDEX)				;Low byte of index
0041+  0925 CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0042+  0928 DD 7E 21    			LD		A,(IX+FILEINDEX+1)				;High byte of index
0043+  092B CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0044+  092E             			;PAUSE_LONG
0045+  092E             		;Send command  to arduino asking for SNA data
0046+  092E 21 00 40    			LD		HL,#4000						; Destination of data
0047+  0931 11 00 1B    			LD		DE,6912							; Length of data (screen)
0048+  0934 3E 10       			LD		A,CMD_ZX2SD_SCR					;c=CMD_ZX2SD_SCR so command is get screen
0049+  0936 0E 00       			LD		C,0								;Additional parameter is to load "full screen" Par:0x00
0050+  0938             
0051+  0938 CD D1 06    			CALL	LoadBlockDirect1Par				;Load Screen
0052+  093B             
0053+  093B             ;Now wait for joy released or key released
0054+  093B             WaitNKey1st: 
0055+  093B DB 1F       			IN		A,(#1F)
0056+  093D E6 1F       			AND		%00011111
0057+  093F A7          			AND		A
0058+  0940 20 F9       			JR		NZ,WaitNKey1st					;A=0 for no joy moved
0059+  0942             
0060+  0942             WaitN2Key1st: 
0061+  0942 AF          			XOR		A
0062+  0943 DB FE       			IN		A,(#FE)
0063+  0945 F6 E0       			OR		%11100000						;Isolate keys
0064+  0947 3C          			INC		A								;A=0 for no key pressed
0065+  0948 20 F8       			JR		NZ,WaitN2Key1st
0066+  094A             			
0067+  094A             ;Now wait for joy moved or key pressed
0068+  094A             WaitKey: 
0069+  094A DB 1F       			IN		A,(#1F)
0070+  094C E6 1F       			AND		%00011111
0071+  094E A7          			AND		A								;A=0 for no joy moved
0072+  094F 20 0A       			JR		NZ,WaitNKey						;If joy moved then jump to check joy not moved
0073+  0951 AF          			XOR		A
0074+  0952 DB FE       			IN		A,(#FE)
0075+  0954 F6 E0       			OR		%11100000						;Isolate keys
0076+  0956 3C          			INC		A								;A=0 for no key pressed
0077+  0957 20 02       			JR		NZ,WaitNKey						;If key pressed then jump to check key released
0078+  0959 18 EF       			JR		WaitKey
0079+  095B             			
0080+  095B             ;Now wait for joy released or key released
0081+  095B             WaitNKey: 
0082+  095B DB 1F       			IN		A,(#1F)
0083+  095D E6 1F       			AND		%00011111
0084+  095F A7          			AND		A
0085+  0960 20 F9       			JR		NZ,WaitNKey						;A=0 for no joy moved
0086+  0962             			;JR		Load_FT_SCR_END
0087+  0962             WaitN2Key: 
0088+  0962 AF          			XOR		A
0089+  0963 DB FE       			IN		A,(#FE)
0090+  0965 F6 E0       			OR		%11100000						;Isolate keys
0091+  0967 3C          			INC		A								;A=0 for no key pressed
0092+  0968 20 F8       			JR		NZ,WaitN2Key
0093+  096A             			
0094+  096A             Load_FT_SCR_END: 
0095+  096A 3E 07       			LD		A,BorderMenu
0096+  096C D3 FE       			OUT		(#FE),A
0097+  096E             
0098+  096E CD 74 09    			CALL	Swap_Screen
0099+  0971             		;	LDIR									;Restore screen
0100+  0971             		;	EI
0101+  0971             
0102+  0971             		;FIN LUEGO QUITAR MARIO
0103+  0971 C3 2F 02    			JP		MenuWaitChange					;Contine where we were
0104+  0974             			
0105+  0974             Swap_Screen: 
0106+  0974 21 00 C0    			LD		HL,ScreensSCR
0107+  0977 11 00 40    			LD		DE,#4000
0108+  097A 01 00 1B    			LD		BC,#1B00
0109+  097D             Swapping: 
0110+  097D 1A          			LD		A,(DE)
0111+  097E ED A0       			LDI
0112+  0980 2B          			DEC		HL
0113+  0981 77          			LD		(HL),A
0114+  0982 23          			INC		HL
0115+  0983 78          			LD		A,B
0116+  0984 B1          			OR		C
0117+  0985 20 F6       			JR		NZ,Swapping
0118+  0987 C9          			RET	
0119+  0988             			
0836   0988             LE: 
0837   0988             showinfdzxB: 
0838   0988             		include "resources/dzx7_turbo.asm"
0001+  0988             ; -----------------------------------------------------------------------------
0002+  0988             ; ZX7 decoder by Einar Saukas & Urusergi
0003+  0988             ; "Turbo" version (88 bytes, 25% faster)
0004+  0988             ; -----------------------------------------------------------------------------
0005+  0988             ; Parameters:
0006+  0988             ;   HL: source address (compressed data)
0007+  0988             ;   DE: destination address (decompressing)
0008+  0988             ; -----------------------------------------------------------------------------
0009+  0988             
0010+  0988             dzx7_turbo: 
0011+  0988 3E 80               ld      a, $80
0012+  098A             dzx7t_copy_byte_loop: 
0013+  098A ED A0               ldi                             ; copy literal byte
0014+  098C             dzx7t_main_loop: 
0015+  098C 87                  add     a, a                    ; check next bit
0016+  098D CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0017+  0990 30 F8               jr      nc, dzx7t_copy_byte_loop ; next bit indicates either literal or sequence
0018+  0992             
0019+  0992             ; determine number of bits used for length (Elias gamma coding)
0020+  0992 D5                  push    de
0021+  0993 01 01 00            ld      bc, 1
0022+  0996 50                  ld      d, b
0023+  0997             dzx7t_len_size_loop: 
0024+  0997 14                  inc     d
0025+  0998 87                  add     a, a                    ; check next bit
0026+  0999 CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0027+  099C 30 F9               jr      nc, dzx7t_len_size_loop
0028+  099E C3 AB 09            jp      dzx7t_len_value_start
0029+  09A1             
0030+  09A1             ; determine length
0031+  09A1             dzx7t_len_value_loop: 
0032+  09A1 87                  add     a, a                    ; check next bit
0033+  09A2 CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0034+  09A5 CB 11               rl      c
0035+  09A7 CB 10               rl      b
0036+  09A9 38 2D               jr      c, dzx7t_exit           ; check end marker
0037+  09AB             dzx7t_len_value_start: 
0038+  09AB 15                  dec     d
0039+  09AC 20 F3               jr      nz, dzx7t_len_value_loop
0040+  09AE 03                  inc     bc                      ; adjust length
0041+  09AF             
0042+  09AF             ; determine offset
0043+  09AF 5E                  ld      e, (hl)                 ; load offset flag (1 bit) + offset value (7 bits)
0044+  09B0 23                  inc     hl
0045+  09B1 CB 33               defb    $cb, $33                ; opcode for undocumented instruction "SLL E" aka "SLS E"
0046+  09B3 30 1A               jr      nc, dzx7t_offset_end    ; if offset flag is set, load 4 extra bits
0047+  09B5 87                  add     a, a                    ; check next bit
0048+  09B6 CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0049+  09B9 CB 12               rl      d                       ; insert first bit into D
0050+  09BB 87                  add     a, a                    ; check next bit
0051+  09BC CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0052+  09BF CB 12               rl      d                       ; insert second bit into D
0053+  09C1 87                  add     a, a                    ; check next bit
0054+  09C2 CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0055+  09C5 CB 12               rl      d                       ; insert third bit into D
0056+  09C7 87                  add     a, a                    ; check next bit
0057+  09C8 CC DC 09            call    z, dzx7t_load_bits      ; no more bits left?
0058+  09CB 3F                  ccf
0059+  09CC 38 01               jr      c, dzx7t_offset_end
0060+  09CE 14                  inc     d                       ; equivalent to adding 128 to DE
0061+  09CF             dzx7t_offset_end: 
0062+  09CF CB 1B               rr      e                       ; insert inverted fourth bit into E
0063+  09D1             
0064+  09D1             ; copy previous sequence
0065+  09D1 E3                  ex      (sp), hl                ; store source, restore destination
0066+  09D2 E5                  push    hl                      ; store destination
0067+  09D3 ED 52               sbc     hl, de                  ; HL = destination - offset - 1
0068+  09D5 D1                  pop     de                      ; DE = destination
0069+  09D6 ED B0               ldir
0070+  09D8             dzx7t_exit: 
0071+  09D8 E1                  pop     hl                      ; restore source address (compressed data)
0072+  09D9 D2 8C 09            jp      nc, dzx7t_main_loop
0073+  09DC             
0074+  09DC             dzx7t_load_bits: 
0075+  09DC 7E                  ld      a, (hl)                 ; load another group of 8 bits
0076+  09DD 23                  inc     hl
0077+  09DE 17                  rla
0078+  09DF C9                  ret
0079+  09E0             
0080+  09E0             ; -----------------------------------------------------------------------------
0081+  09E0             
0839   09E0             showinfdzxE: 
0840   09E0             
0841   09E0             PB: 	
0842   09E0             		;Path Routines
0843   09E0             		include	"resources/PathRoutines.asm"
0001+  09E0             ;Path and change directory routines
0002+  09E0             ;	Using PathBuffer (61 bytes of path) , LenPath (1 byte) length of current path (always <= 60)
0003+  09E0             ;			BuffGetDir (256 bytes of filename) 
0004+  09E0             ;			MaxLenPath (constant) Max length of Path
0005+  09E0             ;	Call this routine after a CALL ZX2SD_COMMAND with command CMD_ZX2SD_GETDIR (It will fill BuffGetDir)
0006+  09E0             ;	OUT C: Len of Directory name
0007+  09E0             
0008+  09E0             
0009+  09E0             ;UpdatePath - Update path to show in PathBar
0010+  09E0             UpdatePath: 
0011+  09E0 0E 00       			LD		C,0								;C?len of Directory name.... 0 for root
0012+  09E2 21 46 DB    			LD		HL,BuffGetDir					;1st Char of new Dir to add to path
0013+  09E5 7E          			LD		A,(HL)
0014+  09E6 FE 2F       			CP		"/"
0015+  09E8 C8          			RET		Z								;If Root then return without any update
0016+  09E9             Fill_NoRoot: 
0017+  09E9 AF          			XOR		A
0018+  09EA 4F          			LD		C,A								;Initiallize counter of Len of Name=> C=A=0
0019+  09EB             UpdatePath_Locate0: 
0020+  09EB BE          			CP		(HL)
0021+  09EC 28 04       			JR		Z,UpdatePath_Pos0
0022+  09EE 23          			INC		HL
0023+  09EF 0C          			INC		C								;One more char for Len of Name
0024+  09F0 18 F9       			JR		UpdatePath_Locate0
0025+  09F2             UpdatePath_Pos0: 
0026+  09F2 C5          			PUSH	BC								;Save C=Len of Directory name in BuffGetDir
0027+  09F3             		;Here located last char, address is HL
0028+  09F3 79          			LD		A,C
0029+  09F4 FE 3B       			CP		MaxLenPath-1					;Check if new length is >MaxLenPath-1 (aka >=59 char)... remember we have to add "/" so 1 less)
0030+  09F6 38 1F       			JR		C,UpdatePath_NewLess60
0031+  09F8             
0032+  09F8 3A 45 DB    			LD		A,(LenPath)
0033+  09FB A7          			AND		A
0034+  09FC 20 05       			JR		NZ,UpdatePath_NewGE60
0035+  09FE             		;If CurrentPath is Root (no path) then check against MaxLenPath
0036+  09FE 79          			LD		A,C
0037+  09FF FE 3C       			CP		MaxLenPath						;MARIO TENIA CP MaxLenPath+1
0038+  0A01 38 14       			JR		C,UpdatePath_NewLess60
0039+  0A03             		;Here if NewPath is greater or equal to MaxLenPath
0040+  0A03             
0041+  0A03             		
0042+  0A03             UpdatePath_NewGE60: 
0043+  0A03             
0044+  0A03             		
0045+  0A03 3E 7E       			LD		A,"~"
0046+  0A05 32 08 DB    			LD		(PathBuffer),A
0047+  0A08 3E 3C       			LD		A,MaxLenPath					;A=Len of Name
0048+  0A0A 32 45 DB    			LD		(LenPath),A						;Update new Len
0049+  0A0D 01 3C 00    			LD		BC,MaxLenPath					;Coping 1 less of len (so don't overwrite "~") MARIO TENIA LD BC,MaxLenPath
0050+  0A10             UpdatePath_NoMaxLen: 
0051+  0A10 11 44 DB    			LD		DE,PathBuffer+MaxLenPath		;DE=Last position of PathBuffer (just in 0x00 after path)
0052+  0A13 ED B8       			LDDR									;Copy the path to show
0053+  0A15 18 37       			JR		EndUpdatePath					;MARIO quizas luego esto sea un simple RET....REVISAR
0054+  0A17             
0055+  0A17             		;Here for NewDir is less than 59
0056+  0A17             UpdatePath_NewLess60: 
0057+  0A17 C5          			PUSH	BC								;Save C=Len of Name
0058+  0A18 2B          			DEC		HL								;So get position prior to 0x00 (last char of Dir Name)
0059+  0A19 11 44 DC    			LD		DE,BuffGetDir+254				;Last position in buffer prior to the ending 0x00
0060+  0A1C 06 00       			LD		B,0								;So BC=Len of Name
0061+  0A1E ED B8       			LDDR									;Copy Name to end of buffer
0062+  0A20             		;At this moment DE=position in buffer prior to 1st Char
0063+  0A20 3E 2F       			LD		A,"/"
0064+  0A22 12          			LD		(DE),A							;Add "/" to the new directory so it's like /Dir
0065+  0A23             
0066+  0A23             		;Now will add the current Path prior to the name of new dir
0067+  0A23 21 07 DB    			LD		HL,PathBuffer-1					;So ADD HL,BC below will get last char prior to 0x00
0068+  0A26 3A 45 DB    			LD		A,(LenPath)						;Len of current Path
0069+  0A29 4F          			LD		C,A								;For BC=Len of current Path
0070+  0A2A A7          			AND		A								;Check the case LenPath=0 (Root)
0071+  0A2B 20 03       			JR		NZ,PathCopy
0072+  0A2D C1          			POP		BC								;C=Len of Name
0073+  0A2E 18 06       			JR		AfterCopy
0074+  0A30             PathCopy: 
0075+  0A30             			;LD		B,0								;Not required as per last LDDR B=0
0076+  0A30 09          			ADD		HL,BC							;Last char (prior to 0x00)
0077+  0A31 1B          			DEC		DE								;So we're prior to "/" char
0078+  0A32 ED B8       			LDDR									;Copy PathBuffer prior to "/" and new dir
0079+  0A34             
0080+  0A34             		;At this moment DE=position in buffer prior to 1st Char
0081+  0A34 C1          			POP		BC								;C=Len of Name
0082+  0A35 0C          			INC		C								;C=Len of Name (now is 1 char more as per "/")
0083+  0A36             AfterCopy: 
0084+  0A36             			;LD		A,(LenPath)						;No needed as per previous LD A,(LenPath) and A was not changed
0085+  0A36             
0086+  0A36 81          			ADD		A,C								;Calculate new length
0087+  0A37 4F          			LD		C,A
0088+  0A38 FE 3B       			CP		MaxLenPath-1					;Check if new length is > MaxLenPath (aka >= 60 char)	MARIO ERA Maxlenpath+1
0089+  0A3A             
0090+  0A3A 21 45 DC    			LD		HL,BuffGetDir+255				;For the chance A>=60 jump to copy last chars and adding "~" or "~/" as pen C
0091+  0A3D 30 C4       			JR		NC,UpdatePath_NewGE60			;NC if A>=60    C if A<60
0092+  0A3F             		;Here for new len <60, so we can copy directly
0093+  0A3F EB          			EX		DE,HL							;HL=Position in buffer of 1st Char
0094+  0A40 11 08 DB    			LD		DE,PathBuffer
0095+  0A43 79          			LD		A,C								;A=New len of path
0096+  0A44 06 00       			LD		B,0								;BC=New len of path
0097+  0A46 23          			INC		HL								;Move to 1st char
0098+  0A47 32 45 DB    			LD		(LenPath),A
0099+  0A4A ED B0       			LDIR
0100+  0A4C AF          			XOR		A
0101+  0A4D 12          			LD		(DE),A
0102+  0A4E             
0103+  0A4E             EndUpdatePath: 
0104+  0A4E             		;Restore C=Len of GetDirBuff Directory name
0105+  0A4E C1          			POP		BC								;C=Len of Directory Name
0106+  0A4F C9          			RET
0107+  0A50             			
0844   0A50             PE: 	
0845   0A50             		
0846   0A50             WB: 
0847   0A50             		;Water Logo movemente
0848   0A50             		include "resources/Water_Effect.asm"
0001+  0A50             ;water_effect
0002+  0A50             ;Initialize lines data into RAM
0003+  0A50             InitLines: 
0004+  0A50 21 F9 0A    			LD		HL,PosLines
0005+  0A53 11 08 DD    			LD		DE,BufLines
0006+  0A56 01 15 00    			LD		BC,EndPosLines-PosLines
0007+  0A59 ED B0       			LDIR
0008+  0A5B             			
0009+  0A5B C9          			RET
0010+  0A5C             
0011+  0A5C             INTLines: 
0012+  0A5C AF          			XOR		A
0013+  0A5D 32 1D DD    			LD		(MovedLines),A
0014+  0A60             
0015+  0A60 DD 21 08 DD 			LD		IX,BufLines
0016+  0A64 CD 7A 0A    			CALL	MovingLines
0017+  0A67             
0018+  0A67 DD 21 0F DD 			LD		IX,BufLines+LineLENDATA
0019+  0A6B CD 7A 0A    			CALL	MovingLines
0020+  0A6E             
0021+  0A6E DD 21 16 DD 			LD		IX,BufLines+LineLENDATA+LineLENDATA
0022+  0A72 CD 7A 0A    			CALL	MovingLines
0023+  0A75             
0024+  0A75 3A 1D DD    			LD		A,(MovedLines)
0025+  0A78 A7          			AND		A								;So return with (Z) Z activated if no line was moved, (NZ) Z deactivated if lines was moved
0026+  0A79             
0027+  0A79 C9          			RET
0028+  0A7A             	
0029+  0A7A             ;-------------------------------------------------------------------------------
0030+  0A7A             MovingLines: 
0031+  0A7A DD 7E 05    			LD		A,(IX+LineCnt)					;Counter for executing movement
0032+  0A7D 3C          			INC		A
0033+  0A7E DD 77 05    			LD		(IX+LineCnt),A
0034+  0A81 DD BE 06    			CP		(IX+LineMXC)					;Check if arrived to Max value
0035+  0A84 C0          			RET		NZ								;Return if not arrived
0036+  0A85 3C          			INC		A								;As per RET NZ A is 0 so change the value to 1
0037+  0A86 32 1D DD    			LD		(MovedLines),A					;Mark MovedLines as "did a move line"
0038+  0A89             
0039+  0A89 AF          			XOR		A
0040+  0A8A DD 77 05    			LD		(IX+LineCnt),A					;Reset counter for next time
0041+  0A8D             
0042+  0A8D DD 7E 02    			LD		A,(IX+LineDir)					;Pos 3 is Direction: 0=Left, other=Right
0043+  0A90 A7          			AND		A								;So we can check Zero and Sign (CPL does not change these Flag)
0044+  0A91 28 33       			JR		Z,LinesToLeft
0045+  0A93             
0046+  0A93             		;Here LineToRight		
0047+  0A93 DD 66 00    			LD		H,(IX+LineAdd)					;1st scanline to move
0048+  0A96 2E F0       			LD		L,#F0							;Last Row in Third (Row 7), Column 16
0049+  0A98 44          			LD		B,H
0050+  0A99 0E FF       			LD		C,#FF							;Last Row in Third (Row 7), Column 31
0051+  0A9B 0A          			LD		A,(BC)							;Column 31
0052+  0A9C             			
0053+  0A9C             			;LD		HL,#51F0						;Row 23, Column 16, Scanline 1
0054+  0A9C             			;LD		A,(#51F0+15)
0055+  0A9C 0F          			RRCA									;Copy right bit to Carry
0056+  0A9D             			
0057+  0A9D 06 10       			LD		B,16
0058+  0A9F             LoopLines: 
0059+  0A9F CB 1E       			RR		(HL)							;Rotate right, carry comes into bit 7
0060+  0AA1 23          			INC		HL
0061+  0AA2 10 FB       			DJNZ	LoopLines
0062+  0AA4             
0063+  0AA4 DD 66 00    			LD		H,(IX+LineAdd)					;1st scanline to move
0064+  0AA7 24          			INC		H								;Convert into 2nd scanline
0065+  0AA8 2E F0       			LD		L,#F0							;Last Row in Third (Row 7), Column 16
0066+  0AAA             			;LD		HL,#52F0						;Row 23, Column 16, Scanline 2
0067+  0AAA 44          			LD		B,H								;2nd scanline
0068+  0AAB 0A          			LD		A,(BC)
0069+  0AAC             			;LD		A,(#52F0+15)
0070+  0AAC 0F          			RRCA									;Copy right bit to Carry
0071+  0AAD             			
0072+  0AAD 06 10       			LD		B,16
0073+  0AAF             LoopLines_a: 
0074+  0AAF CB 1E       			RR		(HL)							;Rotate right, carry comes into bit 7
0075+  0AB1 23          			INC		HL
0076+  0AB2 10 FB       			DJNZ	LoopLines_a
0077+  0AB4             
0078+  0AB4 DD 7E 01    			LD		A,(IX+LineVal)					;Position of line 1
0079+  0AB7 3C          			INC		A
0080+  0AB8 DD 77 01    			LD		(IX+LineVal),A					;Update
0081+  0ABB DD BE 04    			CP		(IX+LineMax)					;Check if arrived to maximum
0082+  0ABE 20 38       			JR		NZ,End_Lines
0083+  0AC0 AF          			XOR		A
0084+  0AC1 DD 77 02    			LD		(IX+LineDir),A					;Change direction
0085+  0AC4             
0086+  0AC4 18 32       			JR		End_Lines
0087+  0AC6             			
0088+  0AC6             LinesToLeft: 
0089+  0AC6 DD 66 00    			LD		H,(IX+LineAdd)					;1st scanline to move
0090+  0AC9 2E FF       			LD		L,#FF							;Last column
0091+  0ACB             			;LD		HL,#51F0+15						;Row 23, Column 31, Scanline 1
0092+  0ACB 44          			LD		B,H
0093+  0ACC 0E F0       			LD		C,#F0
0094+  0ACE 0A          			LD		A,(BC)
0095+  0ACF             			;LD		A,(#51F0)
0096+  0ACF 07          			RLCA									;Copy left bit to Carry
0097+  0AD0             			
0098+  0AD0 06 10       			LD		B,16
0099+  0AD2             LoopLines_b: 
0100+  0AD2 CB 16       			RL		(HL)							;Rotate left, carry comes into bit 0
0101+  0AD4 2B          			DEC		HL
0102+  0AD5 10 FB       			DJNZ	LoopLines_b
0103+  0AD7             
0104+  0AD7 DD 66 00    			LD		H,(IX+LineAdd)					;1st scanline to move
0105+  0ADA 24          			INC		H								;2nd scanline to move
0106+  0ADB 2E FF       			LD		L,#FF							;Last column
0107+  0ADD             			;LD		HL,#52F0+15						;Row 23, Column 31, Scanline 2
0108+  0ADD 44          			LD		B,H
0109+  0ADE 0A          			LD		A,(BC)
0110+  0ADF             			;LD		A,(#52F0)
0111+  0ADF 07          			RLCA									;Copy left bit to Carry
0112+  0AE0             			
0113+  0AE0 06 10       			LD		B,16
0114+  0AE2             LoopLines_c: 
0115+  0AE2 CB 16       			RL		(HL)							;Rotate left, carry comes into bit 7
0116+  0AE4 2B          			DEC		HL
0117+  0AE5 10 FB       			DJNZ	LoopLines_c
0118+  0AE7             
0119+  0AE7 DD 7E 01    			LD		A,(IX+LineVal)					;Position of line 1
0120+  0AEA 3D          			DEC		A
0121+  0AEB DD 77 01    			LD		(IX+LineVal),A
0122+  0AEE DD BE 03    			CP		(IX+LineMin)					;Check if arrived to minimum
0123+  0AF1 20 05       			JR		NZ,End_Lines
0124+  0AF3 3E FF       			LD		A,#FF
0125+  0AF5 DD 77 02    			LD		(IX+LineDir),A					;Update direction
0126+  0AF8             End_Lines: 
0127+  0AF8 C9          			RET
0128+  0AF9             
0129+  0AF9             LineAdd		equ		0
0130+  0AF9             LineVal		equ		1
0131+  0AF9             LineDir		equ		2
0132+  0AF9             LineMin		equ		3
0133+  0AF9             LineMax		equ		4
0134+  0AF9             LineCnt		equ		5
0135+  0AF9             LineMXC		equ		6
0136+  0AF9             
0137+  0AF9             ;Position of scanlines 1-2, 3-4, 5-6 (0 and 7 are not moved)
0138+  0AF9             ;High byte of address(0),LValue(1),LDirection(2),LMin(3),LMax(4),Counter(5),MaxCounter(6)
0139+  0AF9             PosLines	defb	#51,0,0,-2,2,0,25
0139+  0AF9 510000FE020019
0140+  0B00             PosLine2	defb	#53,0,#FF,-5,5,0,13
0140+  0B00 5300FFFB05000D
0141+  0B07             PosLine3	defb	#55,0,0,-7,7,0,11
0141+  0B07 550000F907000B
0142+  0B0E             EndPosLines: 
0143+  0B0E             LineLENDATA	equ		PosLine2-PosLines
0144+  0B0E             
0849   0B0E             WE: 	
0850   0B0E             PBP: 
0851   0B0E             		;Preview screen routines
0852   0B0E             		include "resources/PreviewScreen.asm"
0001+  0B0E             ;PreviewScreen
0002+  0B0E             PreviewRow		equ		8
0003+  0B0E             PreviewCol		equ		16
0004+  0B0E             UsedRows		equ		12
0005+  0B0E             
0006+  0B0E             LastRow			equ		PreviewRow+UsedRows				;When arriving to this Row in Screen process will finish
0007+  0B0E             HLRow			equ		PreviewCol +16 + ((LastRow & 7)<<5) + (($58 | (3 & (LastRow>>3))) <<8 )	;Equivalent to Attribute Addr for that LastRow
0008+  0B0E             
0009+  0B0E             SCRAttr			equ		ScreensSCR+#1800	
0010+  0B0E             
0011+  0B0E             SRC1TH			equ		HIGH SCRAttr					;1st Third of screen
0012+  0B0E             SRC2TH			equ		HIGH SCRAttr + 1				;2nd Third of screen
0013+  0B0E             SRC3TH			equ		HIGH SCRAttr + 2				;3rd Third of screen
0014+  0B0E             
0015+  0B0E             SRC1PX			equ		HIGH ScreensSCR					;1st Third of screen
0016+  0B0E             SRC2PX			equ		HIGH ScreensSCR + 8				;2nd Third of screen
0017+  0B0E             SRC3PX			equ		HIGH ScreensSCR + 16			;3rd Third of screen
0018+  0B0E             
0019+  0B0E             SCR_BLKSIZE	equ		432
0020+  0B0E             
0021+  0B0E             PreviewSHOWING	equ		1+(6912/SCR_BLKSIZE)			;Value in which the preview is launched
0022+  0B0E             PreviewROMSET	equ		PreviewSHOWING+1				;Value in which ROMSET preview could be done
0023+  0B0E             PreviewROMDone	equ		PreviewROMSET+1					;Value in which ROMSET preview was done
0024+  0B0E             
0025+  0B0E             PreviewInit: 
0026+  0B0E 3A 21 DD    			LD		A,(PreviewStat)
0027+  0B11 FE 11       			CP		PreviewSHOWING					;Greater or equal to PreviewSHOWING have to repaint a new cloud
0028+  0B13 38 07       			JR		C,PreviewInit_NoHadPreview		;If no showing then we had a cloud, so no paint a new one
0029+  0B15 FE 12       			CP		PreviewROMSET
0030+  0B17 28 03       			JR		Z,PreviewInit_NoHadPreview		;If PreviewROMSET was not executed, skip create new cloud
0031+  0B19             PreviewInitial: 
0032+  0B19 CD E8 12    			CALL	MiniScreenCloud					;Repaint Screen cloud
0033+  0B1C             PreviewInit_NoHadPreview: 
0034+  0B1C             
0035+  0B1C AF          			XOR		A
0036+  0B1D 32 21 DD    			LD		(PreviewStat),A					;Initialize preview to 0 (nothing)
0037+  0B20 32 20 DD    			LD		(PreviewFT),A					;0=Nothing to preview
0038+  0B23 3E 01       			LD		A,1								;Value = 1 so 1st time appears just after loaded
0039+  0B25 32 22 DD    			LD		(PreviewCnt),A					;So when activated it appears quickly
0040+  0B28 3E 04       			LD		A,PreviewLoadWait+1				;So 1st OFREAD will begin not  this int, in the next time
0041+  0B2A 32 23 DD    			LD		(PreviewLoad),A					;Max Counter for preview while loading
0042+  0B2D 21 20 59    			LD		HL,#5800+(PreviewRow*32)+PreviewCol+16	;Destination Attr address in screen, always is the same
0043+  0B30 22 26 DD    			LD		(RepDest),HL
0044+  0B33 21 94 0C    			LD		HL,TableMove					;Table of movements
0045+  0B36 22 2A DD    			LD		(LastMove),HL
0046+  0B39 C9          			RET
0047+  0B3A             
0048+  0B3A             ;INTpreview - Interruption for preview (load/show)		
0049+  0B3A             INTpreview: 
0050+  0B3A 3A 21 DD    			LD		A,(PreviewStat)					;0 no preview, 1..nn Loading blocks, nn+1 Show preview.
0051+  0B3D A7          			AND		A
0052+  0B3E C8          			RET     Z ;JR		Z,PreviewInit
0053+  0B3F             			
0054+  0B3F FE 12       			CP		PreviewROMSET
0055+  0B41 D2 28 15    			JP		NC,PrintMyROMSET				;For PreviewROMSET or PreviewROMDone jump there
0056+  0B44             
0057+  0B44 FE 11       			CP		PreviewSHOWING					;Check if PreviewStat was nn+1 (it was increases INC A)
0058+  0B46 28 3F       			JR		Z,Preview_Show					;Full Image was loaded so can be previewed
0059+  0B48             
0060+  0B48             		;Check if we did open file (PreviewStat=1 for not open)
0061+  0B48             			;LD		A,(PreviewStat)
0062+  0B48 FE 01       			CP		1								;Check if this is the 1st block
0063+  0B4A 20 24       			JR		NZ,INTpreview_NoFirst
0064+  0B4C             		;Here only for 1st block load
0065+  0B4C 3A 23 DD    			LD		A,(PreviewLoad)
0066+  0B4F FE 03       			CP		PreviewLoadWait					;Check if was initialized with PreviewLoadWait (new file preview initialized)
0067+  0B51 20 1D       			JR		NZ,INTpreview_NoFirst
0068+  0B53             
0069+  0B53 3D          			DEC		A
0070+  0B54 32 23 DD    			LD		(PreviewLoad),A					;Update ints wait for loading
0071+  0B57             			
0072+  0B57 DD 2A 1E DD 			LD		IX,(PreviewIX)					;Restore File selected
0073+  0B5B DD 7E 00    			LD		A,(IX)
0074+  0B5E FE 20       			CP		FT_TAP							;Check if TAP screen (don't use OFREAD)
0075+  0B60 28 23       			JR		Z,Preview_Busy					;      (file is opened and located in screen)
0076+  0B62 DD 56 20    			LD		D,(IX+FILEINDEX)				;Low Byte of Index
0077+  0B65 DD 5E 21    			LD		E,(IX+FILEINDEX+1)				;High Byte of index
0078+  0B68 3E 09       			LD		A,CMD_ZX2SD_OFREAD_IX			;Command = Open File (Relative Path)
0079+  0B6A             INTpreview_Open: 
0080+  0B6A A7          			AND		A	;SCF for long					;Short confirmation for last byte sent (loading will begin a lot of time after this)
0081+  0B6B CD 76 19    			CALL 	ZX2SD_COMMAND				
0082+  0B6E 18 15       			JR		Preview_Busy
0083+  0B70             			
0084+  0B70             INTpreview_NoFirst: 
0085+  0B70             		;Check if is time for loading a "piece"	
0086+  0B70 3A 23 DD    			LD		A,(PreviewLoad)					;Count for loading blocks so no all ints load data
0087+  0B73 3D          			DEC		A
0088+  0B74 32 23 DD    			LD		(PreviewLoad),A					;Reinit ints wait for loading
0089+  0B77 20 1F       			JR		NZ,Preview_ExitZ				;No loading, jump there to return as (nothing special done)
0090+  0B79             
0091+  0B79             
0092+  0B79 CD 9A 0B    			CALL	Preview_Subload					;Load a "piece"
0093+  0B7C 21 21 DD    			LD		HL,PreviewStat
0094+  0B7F 34          			INC		(HL)							;Update for next loading block (or 17 when finish all loads)
0095+  0B80 3E 03       			LD		A,PreviewLoadWait				;Reinit Max ints wait for loading
0096+  0B82 32 23 DD    			LD		(PreviewLoad),A					;Reinit ints wait for loading
0097+  0B85             
0098+  0B85             Preview_Busy: 
0099+  0B85 AF          			XOR		A								;So z is activated to indicate largetime-consuming done
0100+  0B86 C9          			RET
0101+  0B87             
0102+  0B87             		;Preview SHOW (not using PIC commands to Arduino)
0103+  0B87             Preview_Show: 
0104+  0B87 3A 22 DD    			LD		A,(PreviewCnt)
0105+  0B8A 3D          			DEC		A
0106+  0B8B 32 22 DD    			LD		(PreviewCnt),A					;Timing for "moving" the preview
0107+  0B8E 20 08       			JR		NZ,Preview_ExitZ
0108+  0B90 CD B7 0B    			CALL	LoopRoutine						;value=0 for animating
0109+  0B93 3E 08       			LD		A,PreviewMax					;Reinit counter
0110+  0B95 32 22 DD    			LD		(PreviewCnt),A					;Timing for "moving" the preview			
0111+  0B98             Preview_ExitZ: 
0112+  0B98             			;LD		A,1
0113+  0B98 A7          			AND		A								;So Z will be here deactivated (Z=we did something)
0114+  0B99 C9          			RET
0115+  0B9A             			
0116+  0B9A             ;Preview_Subload - Subroutine for load pieces of screen for preview
0117+  0B9A             Preview_Subload: 
0118+  0B9A 21 50 BE    			LD		HL,ScreensSCR-SCR_BLKSIZE		; Destination of data
0119+  0B9D 3A 21 DD    			LD		A,(PreviewStat)					; Num of block to load 1..16
0120+  0BA0 4F          			LD		C,A								;Additional parameter is to load a piece Par: 1 to 16
0121+  0BA1 11 B0 01    			LD		DE,SCR_BLKSIZE					;DE=Size to load
0122+  0BA4             Preview_Subload_Loop: 
0123+  0BA4 19          			ADD		HL,DE							;HL=HL+SCR_BLKSIZE
0124+  0BA5 3D          			DEC		A
0125+  0BA6 20 FC       			JR		NZ,Preview_Subload_Loop
0126+  0BA8             		
0127+  0BA8 3A 20 DD    			LD		A,(PreviewFT)					;Type of preview so we send the correct command
0128+  0BAB             			;LD		A,CMD_ZX2SD_SCR					;c=CMD_ZX2SD_SCR so command is get screen
0129+  0BAB 11 B0 01    			LD		DE,SCR_BLKSIZE					;DE=Size to load
0130+  0BAE C3 D1 06    			JP		LoadBlockDirect1Par				;Load Screen piece (HL=Destination of data, DE=Len of data to load)
0131+  0BB1             
0132+  0BB1             ;LoopRoutine - Move preview screen around "window" as per TableMove			
0133+  0BB1             BeginRoutine: 			
0134+  0BB1 21 94 0C    			LD		HL,TableMove					;Table of movements
0135+  0BB4 22 2A DD    			LD		(LastMove),HL
0136+  0BB7             LoopRoutine: 
0137+  0BB7 2A 2A DD    			LD		HL,(LastMove)
0138+  0BBA 7E          			LD		A,(HL)
0139+  0BBB FE FF       			CP		#FF
0140+  0BBD 28 F2       			JR		Z,BeginRoutine					;Reinit table
0141+  0BBF 56          			LD		D,(HL)							;Row
0142+  0BC0 23          			INC		HL
0143+  0BC1 5E          			LD		E,(HL)							;Column
0144+  0BC2 23          			INC		HL
0145+  0BC3 22 2A DD    			LD		(LastMove),HL
0146+  0BC6             
0147+  0BC6 CD 5B 16    			CALL	XYtoAttr						;HL=Position in screen as per D=Row, E=Column
0148+  0BC9 11 00 80    			LD		DE,ScreensSCR-#4000
0149+  0BCC 19          			ADD		HL,DE							;HL=Position as per ScreensSCR
0150+  0BCD             	
0151+  0BCD 22 24 DD    			LD		(RepSRC),HL						;Attr Source in screen
0152+  0BD0             			
0153+  0BD0             
0154+  0BD0             ;PreviewScreen - All checks are doing with destination (screen)
0155+  0BD0             ;		That way is possible to have the source screen in any place (not required aligment)
0156+  0BD0             PreviewScreen: 
0157+  0BD0             
0158+  0BD0 FD E5       			PUSH	IY				;RST#38 SAVED HL,DE,BC,AF,IX
0159+  0BD2 D9          			EXX
0160+  0BD3 08          			EX		AF,AF
0161+  0BD4 E5 D5 C5    			PUSH	HL,DE,BC
0162+  0BD7 F5          			PUSH	AF
0163+  0BD8             
0164+  0BD8             	;Here to wait for tracing below required Row of chars
0165+  0BD8 11 90 04    			LD		DE,#260+(PreviewRow*#46)			;Add xxx for each row lower
0166+  0BDB             Loop1: 
0167+  0BDB 1B          			DEC		DE
0168+  0BDC 7A          			LD		A,D
0169+  0BDD B3          			OR		E
0170+  0BDE 20 FB       			JR		NZ,Loop1
0171+  0BE0             	;Let's go		
0172+  0BE0             			;1st Third
0173+  0BE0 DD 2A 24 DD 			LD		IX,(RepSRC)		;Source Attr (from SCRBuff area)
0174+  0BE4 FD 2A 26 DD 			LD		IY,(RepDest)	;Destination Attr in screen +16 columns
0175+  0BE8             
0176+  0BE8 ED 73 28 DD 			LD		(PreviewSP),SP		;20 Ts
0177+  0BEC             BucleAttr: 
0178+  0BEC             ;	Fill attributes (16 bytes)
0179+  0BEC DD F9       			LD		SP,IX			;10 Ts
0180+  0BEE E1 D1 C1 F1 			POP		HL,DE,BC,AF		;4x10 Ts
0181+  0BF2 D9          			EXX						;4 Ts
0182+  0BF3 08          			EX		AF,AF			;4 Ts
0183+  0BF4 E1 D1 C1 F1 			POP		HL,DE,BC,AF		;4x10 Ts
0184+  0BF8             			
0185+  0BF8 FD F9       			LD		SP,IY			;10 Ts
0186+  0BFA F5 C5 D5 E5 			PUSH	AF,BC,DE,HL		;4x11 Ts
0187+  0BFE 08          			EX		AF,AF			;4 Ts
0188+  0BFF D9          			EXX						;4 Ts
0189+  0C00 F5 C5 D5 E5 			PUSH	AF,BC,DE,HL		;4x11 Ts
0190+  0C04             
0191+  0C04             		;Convert Attr of Source in Pixel of Source
0192+  0C04 11 00 E8    			LD		DE,#E800
0193+  0C07 DD 7C       			LD		A,IXH
0194+  0C09 FE D8       			CP		SRC1TH
0195+  0C0B 28 08       			JR		Z,SrcThird
0196+  0C0D 16 EF       			LD		D,#EF
0197+  0C0F FE D9       			CP		SRC2TH
0198+  0C11 28 02       			JR		Z,SrcThird
0199+  0C13 16 F6       			LD		D,#F6
0200+  0C15             SrcThird: 
0201+  0C15 DD 19       			ADD		IX,DE
0202+  0C17             			
0203+  0C17             		;Convert Attr of Destination in Pixel of Destination
0204+  0C17             			
0205+  0C17 16 E8       			LD		D,#E8
0206+  0C19 FD 2B       			DEC		IY				;Avoid problems with last column in screen
0207+  0C1B FD 7C       			LD		A,IYH			;High of attr address in screen
0208+  0C1D FE 58       			CP		#58									;removed as always will be in 2nd and 3rd Third
0209+  0C1F 28 08       			JR		Z,BucleAttr_EndThird
0210+  0C21 16 EF       			LD		D,#EF
0211+  0C23 FE 59       			CP		#59
0212+  0C25 28 02       			JR		Z,BucleAttr_EndThird
0213+  0C27 16 F6       			LD		D,#F6
0214+  0C29             BucleAttr_EndThird: 
0215+  0C29 FD 23       			INC		IY
0216+  0C2B FD 19       			ADD		IY,DE			;Attributes
0217+  0C2D             			
0218+  0C2D             BuclePOPU: 
0219+  0C2D DD F9       			LD		SP,IX			;10 Ts	- Source
0220+  0C2F E1 D1 C1 F1 			POP		HL,DE,BC,AF		;4x10 Ts
0221+  0C33 D9          			EXX						;4 Ts
0222+  0C34 08          			EX		AF,AF			;4 Ts
0223+  0C35 E1 D1 C1 F1 			POP		HL,DE,BC,AF		;4x10 Ts
0224+  0C39             			
0225+  0C39 FD F9       			LD		SP,IY			;10 Ts	- Destination (screen)
0226+  0C3B F5 C5 D5 E5 			PUSH	AF,BC,DE,HL		;4x11 Ts
0227+  0C3F D9          			EXX						;4 Ts
0228+  0C40 08          			EX		AF,AF			;4 Ts
0229+  0C41 F5 C5 D5 E5 			PUSH	AF,BC,DE,HL		;4x11 Ts
0230+  0C45             
0231+  0C45 DD 24       			INC		IXH
0232+  0C47 FD 24       			INC		IYH
0233+  0C49 DD 7C       			LD		A,IXH
0234+  0C4B E6 07       			AND		7				;Finish when scan is 0
0235+  0C4D C2 2D 0C    			JP		NZ,BuclePOPU
0236+  0C50             NextRow: 			
0237+  0C50             
0238+  0C50             ; Check if we finish with last Row to process
0239+  0C50             
0240+  0C50             
0241+  0C50             ;	Change Pixels of Source to Attr
0242+  0C50 11 20 10    			LD		DE,#1020
0243+  0C53 DD 7C       			LD		A,IXH			;High of pix address source
0244+  0C55 FE C8       			CP		SRC2PX
0245+  0C57 28 08       			JR		Z,BuclePix_EndThird
0246+  0C59 16 09       			LD		D,#09
0247+  0C5B FE D0       			CP		SRC3PX
0248+  0C5D 28 02       			JR		Z,BuclePix_EndThird
0249+  0C5F 16 02       			LD		D,#02
0250+  0C61             BuclePix_EndThird: 
0251+  0C61 DD 19       			ADD		IX,DE			;For next row IX
0252+  0C63             
0253+  0C63 16 10       			LD		D,#10
0254+  0C65 FD 2B       			DEC		IY				;Avoid problems with last column
0255+  0C67 FD 7C       			LD		A,IYH			;High of pix address in screen	;removed as always will be in 2nd and 3rd Third
0256+  0C69 FE 48       			CP		#48
0257+  0C6B 28 08       			JR		Z,BuclePix_EndYThird
0258+  0C6D 16 09       			LD		D,#09
0259+  0C6F FE 50       			CP		#50
0260+  0C71 28 02       			JR		Z,BuclePix_EndYThird
0261+  0C73 16 02       			LD		D,#02
0262+  0C75             BuclePix_EndYThird: 
0263+  0C75 FD 23       			INC		IY
0264+  0C77 FD 19       			ADD		IY,DE				;For next row IY
0265+  0C79 FD 7D       			LD		A,IYL
0266+  0C7B FE A0       			CP		LOW HLRow			;A=#00..#1F when try to go beyond Third		(era CP#20)
0267+  0C7D C2 EC 0B    			JP		NZ,BucleAttr		;Repeat for next row
0268+  0C80 FD 7C       			LD		A,IYH
0269+  0C82 FE 5A       			CP		HIGH HLRow			;A=#00..#1F when try to go beyond Third		(era CP#20)
0270+  0C84 C2 EC 0B    			JP		NZ,BucleAttr		;Repeat for next row
0271+  0C87             EndPaint: 
0272+  0C87             			;XOR		A
0273+  0C87             			;LD		(Repaint),A		;Clear flag for repaint
0274+  0C87             
0275+  0C87 ED 7B 28 DD 			LD		SP,(PreviewSP)		;20 Ts
0276+  0C8B F1          			POP		AF
0277+  0C8C C1 D1 E1    			POP		BC,DE,HL
0278+  0C8F D9          			EXX
0279+  0C90 08          			EX		AF,AF
0280+  0C91 FD E1       			POP		IY
0281+  0C93 C9          			RET
0282+  0C94             			
0283+  0C94             ;TableMove - Information for moving the "Half-screen"
0284+  0C94             ;	Each data is 2 bytes:
0285+  0C94             ;		Row		: Row of screen 0..12...
0286+  0C94             ;		Column	: Column of screen 0..16
0287+  0C94             TableMove: 
0288+  0C94             		defb	#00, #00, #00, #01, #00, #02, #00, #03, #00, #04, #00, #05, #00, #06, #00, #07, #00, #08, #00, #09, #00, #0A, #00, #0B, #00, #0C, #00, #0D, #00, #0E, #00, #0F, #00, #10
0288+  0C94 0000000100020003000400050006000700080009000A000B000C000D000E000F
0288+  0CB4 0010
0289+  0CB6             		defb	#01, #0F, #02, #0E, #03, #0D, #04, #0B, #05, #0A, #06, #08, #07, #07, #08, #05, #09, #04, #0A, #02, #0B, #01
0289+  0CB6 010F020E030D040B050A06080707080509040A020B01
0290+  0CCC             		defb	#0C, #00, #0C, #01, #0C, #02, #0C, #03, #0C, #04, #0C, #05, #0C, #06, #0C, #07, #0C, #08, #0C, #09, #0C, #0A, #0C, #0B, #0C, #0C, #0C, #0D, #0C, #0E, #0C, #0F, #0C, #10
0290+  0CCC 0C000C010C020C030C040C050C060C070C080C090C0A0C0B0C0C0C0D0C0E0C0F
0290+  0CEC 0C10
0291+  0CEE             		defb	#0B, #0F, #0A, #0E, #09, #0D, #08, #0B, #07, #0A, #06, #08, #05, #07, #04, #05, #03, #04, #02, #02, #01, #01
0291+  0CEE 0B0F0A0E090D080B070A060805070405030402020101
0292+  0D04             		
0293+  0D04 FF          		defb #FF
0294+  0D05             		
0853   0D05             PEP: 
0854   0D05             Charset8x4: 
0855   0D05             		include "resources/charset8x4.asm"
0001+  0D05             ;Charset8x4 - Special charset for 8x4
0002+  0D05             ;			Each byte have the same 4 bits in High and Low nibble
0003+  0D05             		defb 0, 0, 0, 0, 0, 0, 0, 0 ;<SPACE>
0003+  0D05 0000000000000000
0004+  0D0D             		defb 34, 34, 34, 34, 34, 0, 34, 0 ;!
0004+  0D0D 2222222222002200
0005+  0D15             		defb 85, 85, 0, 0, 0, 0, 0, 0 ; "
0005+  0D15 5555000000000000
0006+  0D1D             		defb 0, 85, 255, 85, 85, 255, 85, 0 ; #
0006+  0D1D 0055FF5555FF5500
0007+  0D25             		defb 34, 51, 102, 51, 51, 102, 34, 0 ; $
0007+  0D25 2233663333662200
0008+  0D2D             		defb 85, 17, 34, 34, 34, 68, 85, 0 ; %
0008+  0D2D 5511222222445500
0009+  0D35             		defb 0, 34, 85, 34, 85, 102, 51, 0 ; &
0009+  0D35 0022552255663300
0010+  0D3D             		defb 17, 34, 0, 0, 0, 0, 0, 0 ; '
0010+  0D3D 1122000000000000
0011+  0D45             		defb 34, 68, 68, 68, 68, 68, 34, 0 ; (
0011+  0D45 2244444444442200
0012+  0D4D             		defb 68, 34, 34, 34, 34, 34, 68, 0 ; )
0012+  0D4D 4422222222224400
0013+  0D55             		defb 0, 0, 85, 34, 119, 34, 85, 0 ; *
0013+  0D55 0000552277225500
0014+  0D5D             		defb 0, 0, 34, 34, 119, 34, 34, 0 ; +
0014+  0D5D 0000222277222200
0015+  0D65             		defb 0, 0, 0, 0, 34, 34, 68, 0 ; ,
0015+  0D65 0000000022224400
0016+  0D6D             		defb 0, 0, 0, 0, 119, 0, 0, 0 ; -
0016+  0D6D 0000000077000000
0017+  0D75             		defb 0, 0, 0, 0, 0, 0, 34, 0 ; .
0017+  0D75 0000000000002200
0018+  0D7D             		defb 17, 17, 34, 34, 34, 68, 68, 0 ; /
0018+  0D7D 1111222222444400
0019+  0D85             		defb 34, 85, 85, 85, 85, 85, 34, 0 ; 0
0019+  0D85 2255555555552200
0020+  0D8D             		defb 34, 102, 34, 34, 34, 34, 119, 0 ; 1
0020+  0D8D 2266222222227700
0021+  0D95             		defb 34, 85, 17, 34, 68, 68, 119, 0 ; 2
0021+  0D95 2255112244447700
0022+  0D9D             		defb 119, 17, 17, 34, 17, 17, 102, 0 ; 3
0022+  0D9D 7711112211116600
0023+  0DA5             		defb 17, 51, 85, 85, 119, 17, 17, 0 ; 4
0023+  0DA5 1133555577111100
0024+  0DAD             		defb 119, 68, 68, 102, 17, 17, 102, 0 ; 5
0024+  0DAD 7744446611116600
0025+  0DB5             		defb 34, 68, 68, 102, 85, 85, 34, 0 ; 6
0025+  0DB5 2244446655552200
0026+  0DBD             		defb 119, 17, 17, 34, 34, 34, 34, 0 ; 7
0026+  0DBD 7711112222222200
0027+  0DC5             		defb 34, 85, 85, 34, 85, 85, 34, 0 ; 8
0027+  0DC5 2255552255552200
0028+  0DCD             		defb 34, 85, 85, 51, 17, 17, 34, 0 ; 9
0028+  0DCD 2255553311112200
0029+  0DD5             		defb 0, 0, 34, 0, 0, 34, 0, 0 ; :
0029+  0DD5 0000220000220000
0030+  0DDD             		defb 0, 0, 0, 34, 0, 34, 68, 0 ; ;
0030+  0DDD 0000002200224400
0031+  0DE5             		defb 0, 0, 17, 34, 68, 34, 17, 0 ; <
0031+  0DE5 0000112244221100
0032+  0DED             		defb 0, 0, 0, 119, 0, 119, 0, 0 ; =
0032+  0DED 0000007700770000
0033+  0DF5             		defb 0, 0, 68, 34, 17, 34, 68, 0 ; >
0033+  0DF5 0000442211224400
0034+  0DFD             		defb 34, 85, 17, 34, 34, 0, 34, 0 ; ?
0034+  0DFD 2255112222002200
0035+  0E05             		defb 34, 85, 85, 102, 68, 85, 34, 0 ; @
0035+  0E05 2255556644552200
0036+  0E0D             		defb 34, 85, 85, 119, 85, 85, 85, 0 ; A
0036+  0E0D 2255557755555500
0037+  0E15             		defb 34, 85, 85, 102, 85, 85, 102, 0 ; B
0037+  0E15 2255556655556600
0038+  0E1D             		defb 51, 68, 68, 68, 68, 68, 51, 0 ; C
0038+  0E1D 3344444444443300
0039+  0E25             		defb 102, 85, 85, 85, 85, 85, 102, 0 ; D
0039+  0E25 6655555555556600
0040+  0E2D             		defb 119, 68, 68, 102, 68, 68, 119, 0 ; E
0040+  0E2D 7744446644447700
0041+  0E35             		defb 119, 68, 68, 102, 68, 68, 68, 0 ; F
0041+  0E35 7744446644444400
0042+  0E3D             		defb 51, 68, 68, 85, 85, 85, 34, 0 ; G
0042+  0E3D 3344445555552200
0043+  0E45             		defb 85, 85, 85, 119, 85, 85, 85, 0 ; H
0043+  0E45 5555557755555500
0044+  0E4D             		defb 119, 34, 34, 34, 34, 34, 119, 0 ; I
0044+  0E4D 7722222222227700
0045+  0E55             		defb 119, 17, 17, 17, 17, 85, 34, 0 ; J
0045+  0E55 7711111111552200
0046+  0E5D             		defb 85, 85, 85, 102, 85, 85, 85, 0 ; K
0046+  0E5D 5555556655555500
0047+  0E65             		defb 68, 68, 68, 68, 68, 68, 119, 0 ; L
0047+  0E65 4444444444447700
0048+  0E6D             		defb 85, 119, 119, 85, 85, 85, 85, 0 ; M
0048+  0E6D 5577775555555500
0049+  0E75             		defb 85, 85, 119, 119, 85, 85, 85, 0 ; N
0049+  0E75 5555777755555500
0050+  0E7D             		defb 119, 85, 85, 85, 85, 85, 119, 0 ; O
0050+  0E7D 7755555555557700
0051+  0E85             		defb 119, 85, 85, 119, 68, 68, 68, 0 ; P
0051+  0E85 7755557744444400
0052+  0E8D             		defb 119, 85, 85, 85, 85, 119, 119, 0 ; Q
0052+  0E8D 7755555555777700
0053+  0E95             		defb 119, 85, 85, 102, 85, 85, 85, 0 ; R
0053+  0E95 7755556655555500
0054+  0E9D             		defb 34, 85, 68, 34, 17, 85, 34, 0 ; S
0054+  0E9D 2255442211552200
0055+  0EA5             		defb 119, 34, 34, 34, 34, 34, 34, 0 ; T
0055+  0EA5 7722222222222200
0056+  0EAD             		defb 85, 85, 85, 85, 85, 85, 119, 0 ; U
0056+  0EAD 5555555555557700
0057+  0EB5             		defb 85, 85, 85, 85, 85, 34, 34, 0 ; V
0057+  0EB5 5555555555222200
0058+  0EBD             		defb 85, 85, 85, 85, 119, 119, 85, 0 ; W
0058+  0EBD 5555555577775500
0059+  0EC5             		defb 85, 85, 85, 34, 85, 85, 85, 0 ; X
0059+  0EC5 5555552255555500
0060+  0ECD             		defb 85, 85, 85, 34, 34, 34, 34, 0 ; Y
0060+  0ECD 5555552222222200
0061+  0ED5             		defb 119, 17, 17, 34, 68, 68, 119, 0 ; Z
0061+  0ED5 7711112244447700
0062+  0EDD             		defb 102, 68, 68, 68, 68, 68, 102, 0 ; [
0062+  0EDD 6644444444446600
0063+  0EE5             		defb 68, 68, 34, 34, 34, 17, 17, 0 ; \
0063+  0EE5 4444222222111100
0064+  0EED             		defb 102, 34, 34, 34, 34, 34, 102, 0 ; ]
0064+  0EED 6622222222226600
0065+  0EF5             		defb 34, 119, 34, 34, 34, 34, 34, 0 ; Arrow
0065+  0EF5 2277222222222200
0066+  0EFD             		defb 0, 0, 0, 0, 0, 0, 119, 0 ; _
0066+  0EFD 0000000000007700
0067+  0F05             		defb 119, 68, 34, 17, 34, 68, 119, 0 ; Sum
0067+  0F05 7744221122447700
0068+  0F0D             		defb 0, 0, 34, 17, 51, 85, 51, 0 ; a
0068+  0F0D 0000221133553300
0069+  0F15             		defb 0, 68, 68, 102, 85, 85, 34, 0 ; b
0069+  0F15 0044446655552200
0070+  0F1D             		defb 0, 0, 51, 68, 68, 68, 51, 0 ; c
0070+  0F1D 0000334444443300
0071+  0F25             		defb 0, 17, 17, 51, 85, 85, 51, 0 ; d
0071+  0F25 0011113355553300
0072+  0F2D             		defb 0, 0, 34, 85, 119, 68, 51, 0 ; e
0072+  0F2D 0000225577443300
0073+  0F35             		defb 0, 17, 34, 119, 34, 34, 34, 0 ; f
0073+  0F35 0011227722222200
0074+  0F3D             		defb 0, 0, 34, 85, 85, 51, 17, 102 ; g
0074+  0F3D 0000225555331166
0075+  0F45             		defb 0, 68, 68, 102, 85, 85, 85, 0 ; h
0075+  0F45 0044446655555500
0076+  0F4D             		defb 0, 34, 0, 102, 34, 34, 119, 0 ; i
0076+  0F4D 0022006622227700
0077+  0F55             		defb 0, 34, 0, 102, 34, 34, 34, 68 ; j
0077+  0F55 0022006622222244
0078+  0F5D             		defb 0, 68, 68, 85, 102, 85, 85, 0 ; k
0078+  0F5D 0044445566555500
0079+  0F65             		defb 0, 34, 34, 34, 34, 34, 17, 0 ; l
0079+  0F65 0022222222221100
0080+  0F6D             		defb 0, 0, 102, 119, 119, 119, 119, 0 ; m
0080+  0F6D 0000667777777700
0081+  0F75             		defb 0, 0, 102, 85, 85, 85, 85, 0 ; n
0081+  0F75 0000665555555500
0082+  0F7D             		defb 0, 0, 102, 85, 85, 85, 51, 0 ; o
0082+  0F7D 0000665555553300
0083+  0F85             		defb 0, 0, 102, 85, 85, 102, 68, 68 ; p
0083+  0F85 0000665555664444
0084+  0F8D             		defb 0, 0, 51, 85, 85, 51, 17, 17 ; q
0084+  0F8D 0000335555331111
0085+  0F95             		defb 0, 0, 119, 68, 68, 68, 68, 0 ; r
0085+  0F95 0000774444444400
0086+  0F9D             		defb 0, 0, 51, 68, 34, 17, 102, 0 ; s
0086+  0F9D 0000334422116600
0087+  0FA5             		defb 0, 34, 34, 119, 34, 34, 17, 0 ; t
0087+  0FA5 0022227722221100
0088+  0FAD             		defb 0, 0, 85, 85, 85, 85, 51, 0 ; u
0088+  0FAD 0000555555553300
0089+  0FB5             		defb 0, 0, 85, 85, 85, 85, 34, 0 ; v
0089+  0FB5 0000555555552200
0090+  0FBD             		defb 0, 0, 85, 85, 119, 119, 85, 0 ; w
0090+  0FBD 0000555577775500
0091+  0FC5             		defb 0, 0, 85, 85, 34, 119, 85, 0 ; x
0091+  0FC5 0000555522775500
0092+  0FCD             		defb 0, 0, 85, 85, 85, 51, 17, 102 ; y
0092+  0FCD 0000555555331166
0093+  0FD5             		defb 0, 0, 119, 17, 34, 68, 119, 0 ; z
0093+  0FD5 0000771122447700
0094+  0FDD             		defb 51, 34, 68, 34, 34, 34, 51, 0 ; {
0094+  0FDD 3322442222223300
0095+  0FE5             		defb 34, 34, 34, 34, 34, 34, 34, 0 ; |
0095+  0FE5 2222222222222200
0096+  0FED             		defb 102, 34, 17, 34, 34, 34, 102, 0 ; }
0096+  0FED 6622112222226600
0097+  0FF5             		defb 0, 0, 0, 85, 170, 0, 0, 0 ; ~
0097+  0FF5 00000055AA000000
0098+  0FFD             		defb 17, 51, 119, 51, 85, 34, 17, 0;0, 0, 17, 51, 119, 51, 17, 0; (C)
0098+  0FFD 1133773355221100
0099+  1005             	;Icons for dandanator
0100+  1005             		defb 0, 0, 85, 204, 85, 85, 85, 0			;128k (char 128)
0100+  1005 000055CC55555500
0101+  100D             		defb 0, 0, 170, 221, 170, 85, 170, 0		;128k (char 129)
0101+  100D 0000AADDAA55AA00
0102+  1015             		defb 0, 0, 17, 51, 85, 119, 17, 0			;48k  (char 130)
0102+  1015 0000113355771100
0103+  101D             		defb 0, 0, 34, 85, 34, 85, 34, 0			;48k  (char 131)
0103+  101D 0000225522552200
0104+  1025             		defb 0, 0, 17, 51, 17, 17, 17, 0			;16k  (char 132)
0104+  1025 0000113311111100
0105+  102D             		defb 0, 0, 34, 68, 102, 85, 34, 0			;16k  (char 133)
0105+  102D 0000224466552200
0106+  1035             		defb 0, 0, 102, 68, 85, 85, 85, 0			;ROM  (char 134)
0106+  1035 0000664455555500
0107+  103D             		defb 0, 0, 34, 51, 187, 187, 187, 0			;ROM  (char 135)
0107+  103D 00002233BBBBBB00
0108+  1045             		defb 0, 0, 17, 68, 238, 85, 17, 0			;+2A  (char 136)
0108+  1045 00001144EE551100
0109+  104D             		defb 0, 0, 170, 153, 187, 51, 187, 0		;+2A  (char 137)
0109+  104D 0000AA99BB33BB00
0110+  1055             		defb 0, 0, 68, 102, 68, 85, 119, 0			;TAP  (char 138)
0110+  1055 0000446644557700
0111+  105D             		defb 0, 0, 0, 0, 187, 187, 187, 34			;TAP  (char 139)
0111+  105D 00000000BBBBBB22
0112+  1065             
0113+  1065             
0114+  1065             		
0115+  1065             
0116+  1065             
0117+  1065             
0118+  1065             
0856   1065             Charset8x4END: 
0857   1065             
0858   1065             ;;;;;;;;; MARIO PENDIENTE AL FINAL AJUSTAR ESTA RUTINA PARA QUE EL "HUECO" ENTRE LA ANTERIOR Y LA DE IM2 SEA LO MENOR POSIBLE
0859   1065             IMB: 
0860   1065             		include "resources/IM2_routines.asm"		;IM2 routines used with "checkhardware.asm"
0001+  1065             ;IM2 routines - Compatible with Inves +
0002+  1065             ;Routine to support aborting checking if Multiply is connected to dandanator
0003+  1065             ;Used only in CheckHardware as IM1 is not enought (we need an INT for discarding return after int)
0004+  1065             Init_IM2: 
0005+  1065             			;DI										;We're in DI so not required
0006+  1065 3E 11       			LD		A,HIGH FalseIM2Table			;Change I interrupt for IM2 so it always take address from #FFFF.
0007+  1067 ED 47       			LD		I,A
0008+  1069 21 01 12    			LD		HL,ROMFalseIM2
0009+  106C 11 F4 FF    			LD		DE,IM2ADDR
0010+  106F 01 0C 00    			LD		BC,#000C						;IM2 uses only these 12 bytes
0011+  1072 ED B0       			LDIR
0012+  1074 C9          			RET
0013+  1075             Spare_IM2: 
0014+  1075 00          		align	256,0
0015+  1100             			DISPLAY "Current Spare zone for IM2 : ",/A,$-Spare_IM2
0016+  1100             @FalseIM2Table: 
0017+  1100 FF          			DEFS	#101,#FF
0018+  1201             			DISPLAY "IM2ADDR:",/A,IM2ADDR
0019+  1201             			DISPLAY "False IM2 table:",/A,FalseIM2Table
0020+  1201             			DISPLAY "False IM2 table end:",/A,$
0021+  1201             ;END FALSE IM2 TABLE CONSTRUCTOR
0022+  1201             ROMFalseIM2: 
0023+  1201             		DISP	IM2ADDR
0024+  FFF4 D1          			POP		DE								;Discard return address so last CALL is aborted
0025+  FFF5 ED 4D       			RETI
0026+  FFF7             			
0027+  FFF7 FF          			DEFS	$FFFF-$,#FF
0028+  FFFF 18          			DEFB	#18								;This #18 with #F3 (from DI address #0000) makes a JR #FFF4 (JR IM2ADDR)
0029+  0000             		ENT
0030+  120D             ;GetMultiplyVer
0031+  120D             GetMultiplyVer: 
0032+  120D CD 65 10    			CALL	Init_IM2						;Initialize IM2 routine (but does not activate yet)
0033+  1210             						
0034+  1210             ;GetMultiplyVer_WaitInit:
0035+  1210 ED 56       			IM		1
0036+  1212 FB          			EI
0037+  1213 76          			HALT									;Sinchronize to int (can't use IM2 because it discards return address)
0038+  1214             
0039+  1214 0E 0A       			LD		C,10							;C=10 tries of getting info from Arduino
0040+  1216             GetMultiplyVer_Loop: 
0041+  1216             		;1st Check Arduino is not sending data (maybe it was finishing sending data)
0042+  1216 06 00       			LD		B,0								;Be sure 256 times reading Kempston it's in value 0
0043+  1218 68          			LD		L,B								;Initialize with 0, and will OR port #1F 256 times:required a 0 for ok
0044+  1219             .loopB: 
0045+  1219 DB 1F       			IN		A,(#1F)							;Test kemspton port
0046+  121B             			;AND		#1F							;Isolate valid 5 low bits <-Parece que sin el AND va todo mejor, p.ej. en +2/+3
0047+  121B B5          			OR		L
0048+  121C 6F          			LD		L,A
0049+  121D 10 FA       			DJNZ	.loopB
0050+  121F 20 18       			JR		NZ,GetMultiplyCheck_Retry		;If value<>0 then count for new try
0051+  1221             
0052+  1221 3E 01       			LD		A,CMD_ZX2INO_REQ_ID				;Require version from Arduino
0053+  1223 CD 04 33    			CALL	SendSerByte;LC					;Send Command
0054+  1226 ED 5E       			IM		2								;Change to IM2 for aborting
0055+  1228 FB          			EI
0056+  1229 21 00 DB    			LD		HL,MultiplyVer
0057+  122C 11 08 00    			LD		DE,8
0058+  122F CD BF 32    			CALL	Load4bitBlk						;Try to get 8 bytes for Multiply version
0059+  1232 F3          			DI
0060+  1233 ED 56       			IM		1
0061+  1235 7A          			LD		A,D								;Although Load4bitBlk finish with Z=activate, if it did not finish Z can be anything
0062+  1236 B3          			OR		E								;so better check DE=0
0063+  1237 28 26       			JR		Z,GetMultiplyCheck				;Load4bitBlk finished so we have the info
0064+  1239             GetMultiplyCheck_Retry: 
0065+  1239 0D          			DEC		C
0066+  123A 20 DA       			JR		NZ,GetMultiplyVer_Loop
0067+  123C             			
0068+  123C             		;Here if Multiply did not response
0069+  123C 3A 8E 7F    			LD		A,(AUTOBOOTCHK)
0070+  123F A7          			AND		A
0071+  1240 C2 24 04    			JP		NZ,Goto_Dan1stSlot				;If Multiply was autoboot then return to 1st slot without notification
0072+  1243             		;Here if not multiply and it was launched manually from Dandantor menu.... show notification and return to Dan Menu
0073+  1243 DD 21 61 17 			LD		IX,TXTNOMultiply
0074+  1247 3A 04 7F    			LD		A,(SEL_GAME_NUM)				;Selected game number (value 1..10)
0075+  124A             GetMultiplyVer_Game: 
0076+  124A D6 0A       			SUB		10
0077+  124C 30 FC       			JR		NC,GetMultiplyVer_Game
0078+  124E C6 13       			ADD		19
0079+  1250             			;
0080+  1250             			;ADD		9
0081+  1250 57          			LD		D,A
0082+  1251 1E 06       			LD		E,6								;Row 10+selected, Column 6
0083+  1253 CD CC 16    			CALL	PrintIXText
0084+  1256             			
0085+  1256 06 32       			LD		B,50
0086+  1258             GetMultiplyVer_Loop_Wait: 
0087+  1258 FB          			EI
0088+  1259 76          			HALT
0089+  125A 10 FC       			DJNZ	GetMultiplyVer_Loop_Wait
0090+  125C C3 24 04    			JP		Goto_Dan1stSlot					;Jump there to return to 1st MLD slot
0091+  125F             
0092+  125F             GetMultiplyCheck: 
0093+  125F 21 72 12    			LD		HL,MultString
0094+  1262 11 00 DB    			LD		DE,MultiplyVer
0095+  1265 06 04       			LD		B,4
0096+  1267             GetMultiplyCheck_Loop: 
0097+  1267 1A          			LD		A,(DE)
0098+  1268 BE          			CP		(HL)
0099+  1269 23          			INC		HL
0100+  126A 13          			INC		DE
0101+  126B 20 A9       			JR		NZ,GetMultiplyVer_Loop			;Not equal, not valid....repeat
0102+  126D 10 F8       			DJNZ	GetMultiplyCheck_Loop
0103+  126F             			
0104+  126F C3 35 1A    			JP 		DisableButtons					;Go there to disable left button (dansnap / pause)
0105+  1272             						
0106+  1272 4D 55 4C 54 MultString: 		defb	"MULT"
0861   1276             IME: 
0862   1276             
0863   1276             PBPR: 
0864   1276             		include "resources/print.asm"			;Routine for printing icons and asociated info to selected file and navigation info
0001+  1276             ;Print Info routines.....Icon routines and info box
0002+  1276             
0003+  1276             RowIconSel		equ		2							;Row (0..23) for showing Icon16x16 info of selected
0004+  1276             ColIconSel		equ		17							;Column (0..31) for showing Icon16x16 info of selected
0005+  1276             RowDescSel		equ		2							;Row (0..23) for showing Desc of selected
0006+  1276             ColDescSel		equ		19*2						;Column (0..63) for showing Desc info of selected
0007+  1276             ColOPTSel		equ		17*2						;Column (0..63) for showing Options info of selected
0008+  1276             WidthDesc		equ		24							;Num of columns into box for Descs
0009+  1276             
0010+  1276             Colour_Cloud	equ	%01101111						;No Flash, Bright, Paper Cyan, Ink White
0011+  1276             Colour_ROMSET	equ %01001111						;No Flash, Bright, Paper Blue, Ink White
0012+  1276             
0013+  1276             ;Print Icon8x8 for current item Locate, by filetype, the 1st Icon equal or greater (they are sorted low to high)
0014+  1276             ;PrintIcon8x8 - Print Icon8x8 as per B reg into Row D and Column E
0015+  1276             PrintIcon8x8: 
0016+  1276 D5          			PUSH 	DE								;Row,column for priting
0017+  1277 21 7D 31    			LD		HL,Icons						;Icons for filetype
0018+  127A 11 2E 00    			LD		DE,IconNext						;Offset from Icon to Next Icon
0019+  127D             Icon_Loop8x8: 
0020+  127D 7E          			LD		A,(HL)							;A=current type
0021+  127E B8          			CP		B								;A-B = current type-file type searching
0022+  127F 30 03       			JR		NC,Icon_Located8x8				;A-B >= 0 finish loop
0023+  1281 19          			ADD		HL,DE
0024+  1282 18 F9       			JR		Icon_Loop8x8
0025+  1284             Icon_Located8x8: 
0026+  1284 11 25 00    			LD		DE,Icon8x8						;Offset from Icon type to Icon 8x8 data
0027+  1287 19          			ADD		HL,DE							;Position of Icon8x8 info (8 bytes pixel and 1 byte attribute)
0028+  1288             		;HL is the position of the Icon8x8
0029+  1288 D1          			POP		DE								;Row,column for priting
0030+  1289 D5          			PUSH	DE								;Row,column for priting
0031+  128A E5          			PUSH	HL								;Address of Icon8x8
0032+  128B CD 4C 16    			CALL	XYtoAddr						;with D=Row, E=Col, returns HL=position in screen
0033+  128E D1          			POP		DE								;Address of Icon8x8
0034+  128F             			
0035+  128F 06 08       			LD	B,8									;Printing 8 scanlines
0036+  1291             PrintIcon8x8_Loop: 
0037+  1291 1A          			LD	A,(DE)
0038+  1292 77          			LD	(HL),A
0039+  1293 13          			INC	DE									;Next byte of Icon8x8
0040+  1294 24          			INC H									;Next scanline in screen
0041+  1295 10 FA       			DJNZ PrintIcon8x8_Loop
0042+  1297             			
0043+  1297 1A          			LD	A,(DE)								;A=attribute colour
0044+  1298 4F          			LD	C,A									;C=Attribute colour
0045+  1299             			
0046+  1299 D1          			POP DE									;DE=row,column to print
0047+  129A CD 5B 16    			CALL XYtoAttr							;Calculate attr screen pos, HL=position in screen
0048+  129D 71          			LD	(HL),C								;Change attribute colour
0049+  129E C9          			RET
0050+  129F             
0051+  129F             ;Print Icon16x16 for current item Locate, by filetype, the 1st Icon equal or greater (they are sorted low to high)
0052+  129F             ;PrintIcon16x16 - Print Icon16x16 as per B reg into Row RowIconSel and Column ColIconSel
0053+  129F             PrintIcon16x16: 
0054+  129F 21 7D 31    			LD		HL,Icons						;Icons for filetype
0055+  12A2 11 2E 00    			LD		DE,IconNext						;Offset from Icon to Next Icon
0056+  12A5             Icon_Loop16x16: 
0057+  12A5 7E          			LD		A,(HL)							;A=current type
0058+  12A6 B8          			CP		B								;A-B = current type-file type searching
0059+  12A7 30 03       			JR		NC,Icon_Located16x16			;A-B >= 0 finish loop
0060+  12A9 19          			ADD		HL,DE
0061+  12AA 18 F9       			JR		Icon_Loop16x16
0062+  12AC             Icon_Located16x16: 
0063+  12AC 23          			INC		HL
0064+  12AD             		;HL is the position of the pixels info for Icon16x16
0065+  12AD             
0066+  12AD             			RowCol2PIX DE, RowIconSel, ColIconSel
0066+  12AD 11 51 40    >				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0067+  12B0             
0068+  12B0 CD C8 12    			CALL	Print8x16
0069+  12B3             			
0070+  12B3             			RowCol2PIX DE, RowIconSel+1, ColIconSel
0070+  12B3 11 71 40    >				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0071+  12B6             
0072+  12B6 CD C8 12    			CALL	Print8x16
0073+  12B9             			
0074+  12B9             			RowCol2ATTR DE,RowIconSel, ColIconSel
0074+  12B9 11 51 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0075+  12BC ED A0       			LDI
0076+  12BE ED A0       			LDI										;Copied 2 attributes
0077+  12C0             
0078+  12C0             			RowCol2ATTR DE,RowIconSel+1, ColIconSel
0078+  12C0 11 71 58    >				LD Reg, Col + ((Row & 7)<<5) + (($58 | (3 & (Row>>3))) <<8 )
0079+  12C3 ED A0       			LDI
0080+  12C5 ED A0       			LDI
0081+  12C7 C9          			RET
0082+  12C8             
0083+  12C8             Print8x16: 
0084+  12C8 06 08       			LD	B,8									;Printing 8 scanlines
0085+  12CA             PrintIcon16x16_Loop: 
0086+  12CA 7E          			LD	A,(HL)
0087+  12CB 12          			LD	(DE),A
0088+  12CC 23          			INC	HL									;Next byte of Icon16x16
0089+  12CD 13          			INC DE									;Next byte (2nd column in screen)
0090+  12CE 7E          			LD	A,(HL)
0091+  12CF 12          			LD	(DE),A
0092+  12D0 1B          			DEC DE									;Prev byte (1st column in screen)
0093+  12D1 23          			INC	HL									;Next byte of Icon16x16
0094+  12D2 14          			INC D									;Next scanline in screen
0095+  12D3 10 F5       			DJNZ PrintIcon16x16_Loop
0096+  12D5 C9          			RET
0097+  12D6             	
0098+  12D6             ;MiniScreenAttrs - Change attributes to miniscreen Preview
0099+  12D6             MiniScreenAttrs: 
0100+  12D6             		;Here to clear attributes as per C reg in preview
0101+  12D6 06 0C       			LD		B,12
0102+  12D8 21 10 59    			LD		HL,#5800+(PreviewRow*32)+PreviewCol	;Attr address of preview screen
0103+  12DB 11 10 00    			LD		DE,16
0104+  12DE             PrintClrPreview_Loop: 
0105+  12DE 7B          			LD		A,E
0106+  12DF             PrintClrPreview2_Loop: 		
0107+  12DF 71          			LD		(HL),C							;Colour of Attr
0108+  12E0 23          			INC		HL
0109+  12E1 3D          			DEC		A
0110+  12E2 20 FB       			JR		NZ,PrintClrPreview2_Loop
0111+  12E4 19          			ADD		HL,DE							;Skip Columns not used by preview
0112+  12E5 10 F7       			DJNZ	PrintClrPreview_Loop
0113+  12E7 C9          			RET
0114+  12E8             
0115+  12E8             ;MiniScreenCloud - Paint Miniscreen with Cloud Effect rom pseudo-random numbers
0116+  12E8             MiniScreenCloud: 
0117+  12E8 0E 6F       			LD		C,Colour_Cloud					;Attribute colour cloud
0118+  12EA CD D6 12    			CALL	MiniScreenAttrs
0119+  12ED             		;Now fill Pixels with "random" values... using a mix of "R" reg and value from own romset 0-#5FF is used (8 x 16 x 12)
0120+  12ED             
0121+  12ED             			
0122+  12ED             			RowCol2PIX HL, PreviewRow, PreviewCol	;DE = Addr for pix in Row,Col of MiniScreen
0122+  12ED 21 10 48    >				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0123+  12F0             
0124+  12F0 11 10 00    			LD		DE,16							;offset btw scanlines
0125+  12F3 0E 0C       			LD		C,12							;C=num of Rows to process
0126+  12F5             MSC_Next: 
0127+  12F5 E5          			PUSH	HL
0128+  12F6             MSC_Scan: 	
0129+  12F6 06 10       			LD		B,16							;B=Rows to process
0130+  12F8 E5          			PUSH	HL
0131+  12F9             MSC_Row: 
0132+  12F9 ED 5F       			LD		A,R
0133+  12FB CB B4       			RES		6,H								;Convert HL address into a ROM address
0134+  12FD AE          			XOR		(HL)							;Should be enoght for a pseudo-random
0135+  12FE CB F4       			SET		6,H								;Convert HL address into a Screen address
0136+  1300 77          			LD		(HL),A							;Update pixels
0137+  1301 23          			INC		HL
0138+  1302 10 F5       			DJNZ	MSC_Row
0139+  1304 E1          			POP		HL
0140+  1305 24          			INC		H								;Next scanline for this row
0141+  1306 7C          			LD		A,H
0142+  1307 E6 07       			AND		7
0143+  1309 20 EB       			JR		NZ,MSC_Scan						;Repeat until done 8 scanlines
0144+  130B E1          			POP		HL
0145+  130C 19          			ADD		HL,DE
0146+  130D             			;AQUI CHEQUEAR....si L es 0 (cambio de Third) #4900 tiene que pasar a #4800
0147+  130D 7D          			LD		A,L
0148+  130E A7          			AND		A
0149+  130F 20 04       			JR		NZ,MSC_NoThirdChg
0150+  1311             		;Here change of third
0151+  1311 3E 07       			LD		A,7
0152+  1313 84          			ADD		A,H
0153+  1314 67          			LD		H,A								;So #4100->#4800 or #4900->#5000
0154+  1315             MSC_NoThirdChg: 
0155+  1315 19          			ADD		HL,DE
0156+  1316 0D          			DEC		C
0157+  1317 20 DC       			JR		NZ,MSC_Next
0158+  1319             			
0159+  1319 C9          			RET
0160+  131A             			
0161+  131A             ;MiniScreenEmpty - Paint Miniscreen with C attributes and empty pixels
0162+  131A             MiniScreenEmpty: 
0163+  131A             			;LD		C,Colour_
0164+  131A CD D6 12    			CALL	MiniScreenAttrs
0165+  131D             		;Now fill Pixels with "random" values... using a mix of "R" reg and value from own romset 0-#5FF is used (8 x 16 x 12)
0166+  131D             
0167+  131D             			
0168+  131D             			RowCol2PIX HL, PreviewRow, PreviewCol	;DE = Addr for pix in Row,Col of MiniScreen
0168+  131D 21 10 48    >				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0169+  1320             
0170+  1320 11 10 00    			LD		DE,16							;offset btw scanlines
0171+  1323 0E 0C       			LD		C,12							;C=num of Rows to process
0172+  1325             MSE_Next: 
0173+  1325 E5          			PUSH	HL
0174+  1326             MSE_Scan: 	
0175+  1326 06 10       			LD		B,16							;B=Rows to process
0176+  1328 E5          			PUSH	HL
0177+  1329             MSE_Row: 
0178+  1329 36 00       			LD		(HL),0							;Empty pixels
0179+  132B 23          			INC		HL
0180+  132C 10 FB       			DJNZ	MSE_Row
0181+  132E E1          			POP		HL
0182+  132F 24          			INC		H								;Next scanline for this row
0183+  1330 7C          			LD		A,H
0184+  1331 E6 07       			AND		7
0185+  1333 20 F1       			JR		NZ,MSE_Scan						;Repeat until done 8 scanlines
0186+  1335 E1          			POP		HL
0187+  1336 19          			ADD		HL,DE
0188+  1337             			;AQUI CHEQUEAR....si L es 0 (cambio de Third) #4900 tiene que pasar a #4800
0189+  1337 7D          			LD		A,L
0190+  1338 A7          			AND		A
0191+  1339 20 04       			JR		NZ,MSE_NoThirdChg
0192+  133B             		;Here change of third
0193+  133B 3E 07       			LD		A,7
0194+  133D 84          			ADD		A,H
0195+  133E 67          			LD		H,A								;So #4100->#4800 or #4900->#5000
0196+  133F             MSE_NoThirdChg: 
0197+  133F 19          			ADD		HL,DE
0198+  1340 0D          			DEC		C
0199+  1341 20 E2       			JR		NZ,MSE_Next
0200+  1343             			
0201+  1343 C9          			RET
0202+  1344             
0203+  1344             ;PrintIXInfo - Print Info in right box
0204+  1344             PrintIXInfo: 
0205+  1344 DD 46 00    			LD		B,(IX)							;B=File 
0206+  1347 CD 9F 12    			CALL	PrintIcon16x16					;Print Icon16x16 into Row RowIconSel and Column ColIconSel
0207+  134A             			;JP		PrintFileType					;Print FileType additional information
0208+  134A             			
0209+  134A             ;PrintFileType - Additional info of file in the right BOX
0210+  134A             PrintFileType: 
0211+  134A             		;Now check filetype in order to update BOX with the correspondent information
0212+  134A DD 7E 00    			LD		A,(IX)							;A=Filetype
0213+  134D FE 10       			CP		FT_SCR
0214+  134F 28 15       			JR		Z,PrintFileType_SCR
0215+  1351 38 1D       			JR		C,PrintFileType_NoPreview		;Less than FT_SCR does not show preview
0216+  1353 FE 14       			CP		FT_Z80_SCR
0217+  1355 38 08       			JR		C,PrintFileType_Z80
0218+  1357 FE 19       			CP		FT_SNA_SCR+1
0219+  1359 30 15       			JR		NC,PrintFileType_NoPreview		;Greater than FT_SNA_SCR does not show preview
0220+  135B 3E 18       			LD		A,FT_SNA_SCR
0221+  135D 18 07       			JR		PrintFileType_SCR
0222+  135F             PrintFileType_Z80: 
0223+  135F 3E 14       			LD		A,FT_Z80_SCR
0224+  1361 32 20 DD    			LD		(PreviewFT),A					;Update type so we call correct command to load scr preview
0225+  1364 18 0A       			JR		PrintFileType_NoPreview			;Don't call OFREAD_IX at this moment... will do it after GetInfo
0226+  1366             PrintFileType_SCR: 
0227+  1366 32 20 DD    			LD		(PreviewFT),A					;Update type so we call correct command to load scr preview
0228+  1369             PrintFileType_Preview: 
0229+  1369             	
0230+  1369             		;Here for scr/sna so activate preview
0231+  1369 DD 22 1E DD 			LD		(PreviewIX),IX					;Save address of file to show preview
0232+  136D CD 10 16    			CALL	Print_RQ_Preview				;Activate preview
0233+  1370             
0234+  1370             			
0235+  1370             PrintFileType_NoPreview: 
0236+  1370 DD E5       			PUSH	IX								;Pointer to FileData
0237+  1372             
0238+  1372 3A 05 9C    			LD		A,(MsgDegrad)					;Degraded message was show if A<>0
0239+  1375 A7          			AND		A								;check for 0x00
0240+  1376 28 36       			JR		Z,ChaptMsg_End					;0x00 for no Message
0241+  1378             
0242+  1378 CB 7F       			BIT		7,A								;Bit 7 = 0 if message not show yet / Bit 7 = 1 if was shown
0243+  137A 20 2B       			JR		NZ,ChaptMsgShown
0244+  137C             
0245+  137C F5          			PUSH	AF
0246+  137D 0E 68       			LD		C,%01101000
0247+  137F CD 1A 13    			CALL	MiniScreenEmpty
0248+  1382             			
0249+  1382 DD 21 C0 17 			LD		IX,TXTDEGRA
0250+  1386 F1          			POP		AF
0251+  1387 3D          			DEC		A
0252+  1388 28 04       			JR		Z,ChaptMsg
0253+  138A             			
0254+  138A DD 21 18 18 			LD		IX,TXTTOODEGRA
0255+  138E             ChaptMsg: 
0256+  138E             
0257+  138E 11 20 0B    			LD		DE,32+(11<<8)					;D=Row 11, E=Column 32
0258+  1391 CD CC 16    			CALL	PrintIXText						;Print text in IX at Row D, Column E
0259+  1394 11 20 0D    			LD		DE,32+(13<<8)					;D=Row 13, E=Column 32
0260+  1397 CD CC 16    			CALL	PrintIXText						;Print text in IX at Row D, Column E
0261+  139A 11 20 0F    			LD		DE,32+(15<<8)					;D=Row 15, E=Column 32
0262+  139D CD CC 16    			CALL	PrintIXText						;Print text in IX at Row D, Column E
0263+  13A0             
0264+  13A0 21 05 9C    			LD		HL,MsgDegrad
0265+  13A3 CB FE       			SET		7,(HL)							;Active bit degradation
0266+  13A5 18 07       			JR		ChaptMsg_End
0267+  13A7             			
0268+  13A7             ChaptMsgShown: 
0269+  13A7 CD E8 12    			CALL	MiniScreenCloud
0270+  13AA AF          			XOR		A
0271+  13AB 32 05 9C    			LD		(MsgDegrad),A					;Clear variable, not needed anymore for this folder
0272+  13AE             
0273+  13AE             ChaptMsg_End: 
0274+  13AE DD E1       			POP		IX								;Pointer to FileData
0275+  13B0 DD E5       			PUSH	IX								;Pointer to FileData
0276+  13B2             
0277+  13B2 DD 46 00    			LD		B,(IX)							;B=File type searching
0278+  13B5 21 90 1A    			LD		HL,FileTypeTexts				;Table for filetype texts
0279+  13B8 11 03 00    			LD		DE,FileTypeTexts_Size			;Offset btw record of table
0280+  13BB             PrintFileType_Search: 
0281+  13BB 7E          			LD		A,(HL)							;A=current type
0282+  13BC B8          			CP		B								;A-B = current type-file type searching
0283+  13BD 30 03       			JR		NC,PrintFileType_Found			;A-B >= 0 finish loop
0284+  13BF 19          			ADD		HL,DE
0285+  13C0 18 F9       			JR		PrintFileType_Search
0286+  13C2             PrintFileType_Found: 
0287+  13C2 23          			INC		HL
0288+  13C3             		;HL is the position of the Record for text as per Type
0289+  13C3 7E          			LD		A,(HL)
0290+  13C4 DD 6F       			LD		IXL,A
0291+  13C6 23          			INC		HL
0292+  13C7 7E          			LD		A,(HL)
0293+  13C8 DD 67       			LD		IXH,A							;IX points to text to print
0294+  13CA             			
0295+  13CA 11 26 02    			LD		DE,ColDescSel + (RowDescSel << 8)
0296+  13CD CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for 1st row of box
0297+  13D0             
0298+  13D0 11 26 03    			LD		DE,ColDescSel + ((1+RowDescSel) << 8)
0299+  13D3 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for 2nd row of box
0300+  13D6             
0301+  13D6 11 26 04    			LD		DE,ColDescSel + ((2+RowDescSel) << 8)
0302+  13D9 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for 3rd row of box
0303+  13DC             
0304+  13DC 11 26 05    			LD		DE,ColDescSel + ((3+RowDescSel) << 8)
0305+  13DF CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for 4rd row of box
0306+  13E2             
0307+  13E2 11 22 07    			LD		DE,ColOPTSel + ((5+RowDescSel) << 8)
0308+  13E5 CD 33 16    			CALL	PrintIXText_Spaces				;Print text in IX for text outside the box
0309+  13E8 DD E1       			POP		IX								;Pointer to FileData
0310+  13EA DD 7E 00    			LD		A,(IX)							;A=Filetype
0311+  13ED FE 20       			CP		FT_TAP
0312+  13EF C2 2D 14    			JP		NZ,PrintF_NoTAP
0313+  13F2             			
0314+  13F2             		;Here for TAP type
0315+  13F2 DD 7E 00    			LD		A,(IX)							;A=Filetype
0316+  13F5 DD 22 1E DD 			LD		(PreviewIX),IX					;Provisionally Save address of file to show preview
0317+  13F9             
0318+  13F9 11 0B 00    			LD		DE,11							;Length to retrieve for TAP type
0319+  13FC CD 1C 16    			CALL	DO_GetInfo						;Ask Arduino for 11 bytes of info about TAP file
0320+  13FF             			
0321+  13FF DD 21 33 9C 			LD		IX,BufGetInfo					;Buffer readed
0322+  1403 DD 36 0B 00 			LD		(IX+11),0						;Be sure program name ends with 0x00
0323+  1407 DD 7E 00    			LD		A,(IX)							;Gets info about TAP having Screen: 0x00 = No, 0x01=Yes
0324+  140A 32 21 DD    			LD		(PreviewStat),A					;Update preview stat: 0x00 for no preview, 1 for begin to load for preview
0325+  140D A7          			AND		A
0326+  140E 28 05       			JR		Z,Tap_nopreview
0327+  1410 3E 23       			LD		A,CMD_ZX2SD_SCRTAP
0328+  1412 32 20 DD    			LD		(PreviewFT),A					;Update preview type
0329+  1415             Tap_nopreview: 
0330+  1415 DD 23       			INC		IX								;IX Points to PROGRAM name
0331+  1417 11 30 05    			LD		DE,ColDescSel + ((3+RowDescSel) << 8)+(FT_TAP_Program2-FT_TAP_Program)
0332+  141A CD CC 16    			CALL	PrintIXText						;Print PROGRAM name and return from there to menu
0333+  141D 3A 33 9C    			LD		A,(BufGetInfo)
0334+  1420 A7          			AND		A
0335+  1421 C0          			RET		NZ
0336+  1422 DD 21 AF 17 			LD		IX,TXTTAPnoScreen				;Print text about TAP no having screen
0337+  1426 11 28 04    			LD		DE,ColDescSel + 2 + ((2+RowDescSel) << 8)
0338+  1429 CD CC 16    			CALL	PrintIXText
0339+  142C C9          			RET
0340+  142D             		;END OF TAP GET INFO PROCESSING
0341+  142D             		
0342+  142D             PrintF_NoTAP: 
0343+  142D FE 30       			CP		FT_ROMSET
0344+  142F C2 B6 15    			JP		NZ,PrintF_NoROMSET
0345+  1432             
0346+  1432             		;Here for ROMSET TYPE
0347+  1432 3A 47 9C    			LD		A,(CurRow)
0348+  1435 FE 01       			CP		MinRowFiles
0349+  1437 20 13       			JR      NZ,Do_ROMSETINFO				;No 1st row then it's a SD ROMSET selected..... If romset and 1st row is because it's "../Dandanator MENU" 
0350+  1439             		;check for 1st page to be sure is going to Dandanator 1st slot or it's a ROMSET in another page (not 1st)
0351+  1439 3A 34 DD    			LD 		A,(CurPage)
0352+  143C 3D          			DEC 	A
0353+  143D 20 0D       			JR 		NZ,Do_ROMSETINFO				;No 1st row is because we selected a file of type ROMSET in 2nd or later-on page
0354+  143F             		;Here for ../Dan
0355+  143F 21 2A 9C    			LD		HL,InfoVersion
0356+  1442 11 33 9C    			LD		DE,BufGetInfo
0357+  1445 01 09 00    			LD		BC,9
0358+  1448 ED B0       			LDIR
0359+  144A 18 16       			JR		Do_ROMSETPrint					;Skip get info from Multiply and directly print the info into the BOX
0360+  144C             		
0361+  144C             Do_ROMSETINFO: 
0362+  144C DD 7E 00    			LD		A,(IX)							;A=Filetype
0363+  144F             			
0364+  144F 11 09 00    			LD		DE,9							;Length of additional info
0365+  1452 CD 1C 16    			CALL	DO_GetInfo						;Ask Arduino for 9 bytes of info about ROMSET
0366+  1455             
0367+  1455 21 33 9C    			LD		HL,BufGetInfo
0368+  1458 11 1E 9C    			LD		DE,ROMVersion
0369+  145B 01 08 00    			LD		BC,8
0370+  145E ED B0       			LDIR
0371+  1460 AF          			XOR		A
0372+  1461 12          			LD		(DE),A							;Copied there for later-on usage
0373+  1462             			
0374+  1462             Do_ROMSETPrint: 
0375+  1462             			;1st Print version
0376+  1462             			
0377+  1462 DD 21 33 9C 			LD		IX,BufGetInfo					;Buffer readed
0378+  1466 DD 7E 08    			LD		A,(IX+8)						;Num of Games (0..25)
0379+  1469 DD 77 09    			LD		(IX+9),A						;Save for later-on
0380+  146C DD 7E 00    			LD		A,(IX)							;Major version
0381+  146F FE FF       			CP		#FF								;Check for no valid
0382+  1471 20 12       			JR		NZ,Valid_ROMSE
0383+  1473             		;Here for no valid romset
0384+  1473 DD 36 00 2D 			LD		(IX),"-"
0385+  1477 DD 36 01 2D 			LD		(IX+1),"-"
0386+  147B DD 36 02 2D 			LD		(IX+2),"-"
0387+  147F DD 36 03 00 			LD		(IX+3),0x00
0388+  1483 18 04       			JR		Text_ROMSE
0389+  1485             Valid_ROMSE: 			
0390+  1485 DD 36 08 00 			LD		(IX+8),0						;Ending (if version use the 8 bytes)
0391+  1489             Text_ROMSE: 
0392+  1489 11 2F 03    			LD		DE,((RowDescSel+1)<<8)+ColDescSel+(FT_R_V2-FT_R_V)
0393+  148C CD CC 16    			CALL	PrintIXText						;Print Version as per IX in Row D, Column E
0394+  148F             			;2nd Print Num of Games
0395+  148F DD 21 33 9C 			LD		IX,BufGetInfo
0396+  1493 DD 7E 09    			LD		A,(IX+9)						;Num of Games (0..25)
0397+  1496 FE 1A       			CP		MAXGAMES+1						;Check for no valid (great than max number of games in romsets)
0398+  1498 38 0E       			JR		C,Valid_Games
0399+  149A DD 36 00 2D 			LD		(IX),"-"
0400+  149E DD 36 01 2D 			LD		(IX+1),"-"
0401+  14A2 DD 36 02 00 			LD		(IX+2),0x00
0402+  14A6 18 26       			JR		PrintGames
0403+  14A8             Valid_Games: 
0404+  14A8 DD 36 00 30 			LD		(IX),"0"						;Prepare Tens of Num of Games for the case Games:0 .. 9
0405+  14AC DD 7E 09    			LD		A,(IX+9)						;Num of Games (0..25)
0406+  14AF             TestTens: 
0407+  14AF FE 0A       			CP		10
0408+  14B1 38 07       			JR		C,No_Tens
0409+  14B3 DD 34 00    			INC		(IX)							;Change "0" to "1".... "1" to "2"
0410+  14B6 D6 0A       			SUB		10
0411+  14B8 18 F5       			JR		TestTens
0412+  14BA             			
0413+  14BA             No_Tens: 
0414+  14BA C6 30       			ADD		A,"0"							;Convert number in Char of digit 0..9
0415+  14BC DD 77 01    			LD		(IX+1),A						;Store Units
0416+  14BF DD 36 02 00 			LD		(IX+2),0						;End of text to print
0417+  14C3 DD 7E 00    			LD		A,(IX)
0418+  14C6 FE 30       			CP		"0"
0419+  14C8 20 04       			JR		NZ,PrintGames
0420+  14CA DD 36 00 20 			LD		(IX)," "						;If no tens then update with space
0421+  14CE             PrintGames: 
0422+  14CE 11 28 04    			LD		DE,((RowDescSel+2)<<8)+ColDescSel+2
0423+  14D1 CD CC 16    			CALL	PrintIXText						;Print text in IX in Row D, Column E and return from there
0424+  14D4             
0425+  14D4             		;Now Get Games and save into table
0426+  14D4 3A 34 DD    			LD		A,(CurPage)
0427+  14D7 3D          			DEC		A
0428+  14D8 20 06       			JR		NZ,NoInternalROMSET				;Only Internal Romset in 1st page
0429+  14DA             			
0430+  14DA 3A 47 9C    			LD		A,(CurRow)
0431+  14DD FE 01       			CP		MinRowFiles
0432+  14DF C8          			RET		Z								;Return if selected is "Internal Romset"-> MARIO PENDIENTE AUN SIN PREVIEW
0433+  14E0             
0434+  14E0             NoInternalROMSET: 
0435+  14E0 3A 3C 9C    			LD		A,(BufGetInfo+9)				;Num of games (0..25)
0436+  14E3 A7          			AND		A
0437+  14E4 C8          			RET		Z								;No games, no preview
0438+  14E5             			
0439+  14E5             		;Here for external romset...Get data for preview -> MARIO PENDIENTE PONER DATOS EN "MINISCREEN" Y CAMBIAR ATTRIBUTES PARA QUE SE VEA (no usa PREVIEW)
0440+  14E5 FE 1A       			CP		MAXGAMES+1						;Check for no valid (great than max number of games in romsets)
0441+  14E7 D0          			RET		NC								;Return if num of games >25
0442+  14E8             		;Now calculate how much bytes to get (all the games at once time)
0443+  14E8 26 00       			LD		H,0
0444+  14EA 87          			ADD		A,A								;A=N.Games * 2 (1..25 => 2..50)
0445+  14EB 87          			ADD		A,A								;A=N.Games * 4 (2..50 => 4..100)
0446+  14EC 5F          			LD		E,A								;E=N.Games * 4
0447+  14ED 54          			LD		D,H								;DE=N.Games * 4
0448+  14EE 87          			ADD		A,A								;A=N.Games * 8 (4..100 => 8..200)
0449+  14EF 6F          			LD		L,A								;HL=N.Games * 8
0450+  14F0 29          			ADD		HL,HL							;HL=N.Games * 16
0451+  14F1 29          			ADD		HL,HL							;HL=N.Games * 32
0452+  14F2 19          			ADD		HL,DE							;HL=N.Games * 32 + N.Games * 4 = N.Games * 36
0453+  14F3             
0454+  14F3 EB          			EX		DE,HL							;DE=Total of bytes to get
0455+  14F4             			
0456+  14F4             		;DE=Num of games * 36
0457+  14F4 21 00 C0    			LD		HL,ScreensSCR					;Games will be hold there
0458+  14F7 CD BF 32    			CALL	Load4bitBlk						;Get Game data
0459+  14FA             			
0460+  14FA 23          			INC		HL								;Skip last address with data received
0461+  14FB 36 00       			LD		(HL),0							;Will update after last game with 0x00 (no more games)
0462+  14FD 3E 12       			LD		A,PreviewROMSET
0463+  14FF 32 21 DD    			LD		(PreviewStat),A					;Set preview for ROMSET (will be shown further if no keys pressed)
0464+  1502             
0465+  1502 3E 01       			LD		A,1
0466+  1504 32 36 DD    			LD		(PrevROMPag),A					;Cur number of page 1
0467+  1507             			
0468+  1507 3A 3C 9C    			LD		A,(BufGetInfo+9)				;Num of games (1..25)
0469+  150A 06 01       			LD		B,1
0470+  150C FE 0B       			CP		11
0471+  150E 38 06       			JR		C,.nomore
0472+  1510 04          			INC		B
0473+  1511 FE 15       			CP		21
0474+  1513 38 01       			JR		C,.nomore
0475+  1515 04          			INC		B
0476+  1516             .nomore: 
0477+  1516 78          			LD		A,B								;Num of max pages
0478+  1517 32 37 DD    			LD		(PrevROMxPag),A					;Max number of pages (1.2.3)
0479+  151A             			
0480+  151A C9          			RET
0481+  151B             			
0482+  151B             		
0483+  151B             PrintMyROMSET_NextPage: 
0484+  151B 3A 37 DD    			LD		A,(PrevROMxPag)
0485+  151E FE 01       			CP		1
0486+  1520 C8          			RET		Z								;Only 1 page nothing to do here
0487+  1521             			
0488+  1521 21 38 DD    			LD		HL,PrevROMTime
0489+  1524 35          			DEC		(HL)							;Countdown timer
0490+  1525 C0          			RET		NZ								;Return if timing did not expire
0491+  1526             			
0492+  1526 18 0D       			JR		PMR_Page
0493+  1528             		
0494+  1528             ;PrintMyROMSET - Here for Print Games of a ROMSET
0495+  1528             PrintMyROMSET: 
0496+  1528 3A 21 DD    			LD		A,(PreviewStat)					;Check if we're in preview for ROMSET
0497+  152B FE 13       			CP		PreviewROMDone					;IF was printed previously jump there
0498+  152D 28 EC       			JR		Z,PrintMyROMSET_NextPage
0499+  152F FE 12       			CP		PreviewROMSET
0500+  1531 3C          			INC		A								;Convert into PreviewROMDone
0501+  1532 32 21 DD    			LD		(PreviewStat),A					;Mark as Preview Done (so no repeat -only repeat for new pages when more than 1 page-)
0502+  1535             
0503+  1535             PMR_Page: 			
0504+  1535 0E 4F       			LD		C,Colour_ROMSET					;Attribute colour ROMSET
0505+  1537 CD 1A 13    			CALL	MiniScreenEmpty					;Set attributes as per C and Empty miniscreen
0506+  153A             			
0507+  153A             		;print version string
0508+  153A DD 21 1E 9C 			LD		IX,ROMVersion
0509+  153E 11 20 08    			LD		DE,(PreviewCol*2)+((PreviewRow)<<8)	;1st Row of MiniScreen Preview, column 0 inside preview (same as dan menu)
0510+  1541 CD CC 16    			CALL	PrintIXText			
0511+  1544             			
0512+  1544             		;If more than 10 games print Pages number
0513+  1544 3A 37 DD    			LD		A,(PrevROMxPag)					;Total of pages
0514+  1547 FE 01       			CP		1								;If 1 page then does not show info about that
0515+  1549 28 2F       			JR		Z,.nopages
0516+  154B             		;Here for showing page number
0517+  154B 3E FA       			LD		A,PreviewMaxROM
0518+  154D 32 38 DD    			LD		(PrevROMTime),A					;Initialize preview of pages
0519+  1550 DD 21 7D 17 			LD		IX,TXTROMPage					;Text of rompage for ROMSET
0520+  1554 11 3E 08    			LD		DE,(PreviewCol*2)+30+((PreviewRow)<<8)	;1st Row of MiniScreen Preview, column 23 inside preview (same as dan menu)
0521+  1557 CD CC 16    			CALL	PrintIXText
0522+  155A             			
0523+  155A 3A 36 DD    			LD		A,(PrevROMPag)					;Current page
0524+  155D DD 21 27 9C 			LD		IX,TXTNumber
0525+  1561 CD C0 16    			CALL	UnitAtoIX						;Convert reg A to number and store into (IX)
0526+  1564             
0527+  1564 11 3D 08    			LD		DE,(PreviewCol*2)+29+((PreviewRow)<<8)	;1st Row of MiniScreen Preview, column 26 inside preview (same as dan menu)
0528+  1567 CD CC 16    			CALL	PrintIXText
0529+  156A             
0530+  156A 3A 37 DD    			LD		A,(PrevROMxPag)					;Max page
0531+  156D DD 21 27 9C 			LD		IX,TXTNumber
0532+  1571 CD C0 16    			CALL	UnitAtoIX						;Convert reg A to number and store into (IX)
0533+  1574             
0534+  1574 11 3F 08    			LD		DE,(PreviewCol*2)+31+((PreviewRow)<<8)	;1st Row of MiniScreen Preview, column 27 inside preview (same as dan menu)
0535+  1577 CD CC 16    			CALL	PrintIXText
0536+  157A             		;Now printing games
0537+  157A             .nopages: 
0538+  157A DD 21 00 C0 			LD		IX,ScreensSCR					;Point to Screen so we can Show then
0539+  157E 21 36 DD    			LD		HL,PrevROMPag					;Address of Current page to print
0540+  1581 7E          			LD		A,(HL)							;Current page to print
0541+  1582 3D          			DEC		A
0542+  1583 28 0A       			JR		Z,.pages							;jump for Page 1
0543+  1585 11 68 01    			LD		DE,36*10						;To skip as per each page
0544+  1588 DD 19       			ADD		IX,DE							;Next page
0545+  158A 3D          			DEC		A
0546+  158B 28 02       			JR		Z,.pages						;jump for Page 2, continue for page 3
0547+  158D DD 19       			ADD		IX,DE							;Next page
0548+  158F             .pages: 
0549+  158F 3A 37 DD    			LD		A,(PrevROMxPag)					;Max numbers of pages
0550+  1592 3C          			INC		A								;1 more of last page to check page going beyond
0551+  1593 34          			INC		(HL)							;Next page
0552+  1594 BE          			CP		(HL)							;Max pages - page
0553+  1595 20 02       			JR		NZ,.games
0554+  1597 36 01       			LD		(HL),1							;Reinitialize for page 1
0555+  1599             .games: 
0556+  1599 11 20 0A    			LD		DE,(PreviewCol*2)+((2+PreviewRow)<<8)	;1st Row of MiniScreen Preview
0557+  159C             PrintGames_ROM_Loop: 
0558+  159C DD 7E 00    			LD		A,(IX)
0559+  159F A7          			AND		A
0560+  15A0 C8          			RET		Z								;No more games, return
0561+  15A1 D5 DD E5    			PUSH	DE,IX
0562+  15A4 CD CC 16    			CALL	PrintIXText
0563+  15A7 DD E1       			POP		IX
0564+  15A9 11 24 00    			LD		DE,36							;MARIO cambiar a su etiqueta correcta
0565+  15AC DD 19       			ADD		IX,DE
0566+  15AE D1          			POP		DE
0567+  15AF 14          			INC		D								;Next Row
0568+  15B0 7A          			LD		A,D
0569+  15B1 FE 14       			CP		10+(2+PreviewRow)				;Maximun 10 Files per page
0570+  15B3 C8          			RET		Z								;MARIO pendiente que hacer si hay ms de 12 juegos
0571+  15B4             			
0572+  15B4 18 E6       			JR		PrintGames_ROM_Loop
0573+  15B6             
0574+  15B6             ; END OF FT_ROMSET
0575+  15B6             
0576+  15B6             
0577+  15B6             ;PrintF_NoROMSET - NO ROMSET file type.... If no Z80 then return to caller... Pending in future TAP / TZX / BIN / what else????
0578+  15B6             PrintF_NoROMSET: 
0579+  15B6 FE 14       			CP		FT_Z80_128K+1
0580+  15B8 D0          			RET		NC								;Return if greater than FT_Z80_128K
0581+  15B9 FE 11       			CP		FT_Z80_16K
0582+  15BB D8          			RET		C								;Return if lower than FT_Z80_16K
0583+  15BC             		;Here only for Z80 Snapshot
0584+  15BC DD 22 1E DD 			LD		(PreviewIX),IX					;Save address of file to show preview
0585+  15C0 11 03 00    			LD		DE,3							;Length of additional info
0586+  15C3 CD 1C 16    			CALL	DO_GetInfo						;Ask Arduino for 3 bytes of info about Z80 Romset
0587+  15C6 DD 21 33 9C 			LD		IX,BufGetInfo					;Buffer readed
0588+  15CA DD 7E 01    			LD		A,(IX+1)						;Value for Hardware Mode
0589+  15CD FE FF       			CP		#FF								;#FF for unknown (usually for v1)
0590+  15CF 28 45       			JR		Z,Z80_Unk
0591+  15D1 FE 80       			CP		#80								;#80 Special case for TS2068
0592+  15D3 21 3E 31    			LD		HL,HW_TS2068
0593+  15D6 28 32       			JR		Z,PrintF_Z80
0594+  15D8 FE 10       			CP		#10								;Valid values are lower than 0x10
0595+  15DA 30 3A       			JR		NC,Z80_Unk						;greater than 0x0F is unknown
0596+  15DC             		;Here for a "valid" number (0x00.0x0F)
0597+  15DC 21 88 30    			LD		HL,HW_Table
0598+  15DF DD 7E 00    			LD		A,(IX)
0599+  15E2 FE 17       			CP		#17								;Check for V2
0600+  15E4 DD 7E 01    			LD		A,(IX+1)						;Get Hard Mode
0601+  15E7 20 09       			JR		NZ,NoV2							;If was not v2 then jump
0602+  15E9 FE 03       			CP		3
0603+  15EB 28 04       			JR		Z,IsV2
0604+  15ED FE 04       			CP		4
0605+  15EF 20 01       			JR		NZ,NoV2
0606+  15F1             IsV2: 
0607+  15F1 3C          			INC		A								;v2 change value 3..4 to 4..5 to correspond with v3
0608+  15F2             NoV2: 
0609+  15F2 FE 09       			CP		9								;Only check bit 7 for Machine btw 0..8
0610+  15F4 30 08       			JR		NC,HW_Machine
0611+  15F6             			
0612+  15F6 DD CB 02 7E 			BIT		7,(IX+2)						;Check bit 7 of 0x25 (1 for change of Machine)
0613+  15FA 28 02       			JR		Z,HW_Machine
0614+  15FC C6 10       			ADD		#10								;Change value to extended Hardware
0615+  15FE             
0616+  15FE             HW_Machine: 
0617+  15FE 87          			ADD		A,A								;A*2
0618+  15FF 5F          			LD		E,A
0619+  1600 16 00       			LD		D,0
0620+  1602 19          			ADD		HL,DE							;HL=Position of pointer to text
0621+  1603 5E          			LD		E,(HL)
0622+  1604 23          			INC		HL
0623+  1605 56          			LD		D,(HL)							;DE=Address for text
0624+  1606 DD 6B       			LD		IXL,E
0625+  1608 DD 62       			LD		IXH,D							;So IX points to Text of Machine
0626+  160A             PrintF_Z80: 
0627+  160A 11 33 05    			LD		DE,((RowDescSel+3)<<8)+ColDescSel+(FT_Z80_V2-FT_Z80_V-1)
0628+  160D CD CC 16    			CALL	PrintIXText						;Print text in IX in Row D, Column E
0629+  1610             
0630+  1610             		;After all getinfo done, now we can request image preview
0631+  1610             Print_RQ_Preview: 
0632+  1610 3E 01       			LD		A,1
0633+  1612 32 21 DD    			LD		(PreviewStat),A					;Mark for loading
0634+  1615 C9          			RET
0635+  1616             			
0636+  1616             			
0637+  1616             ;Here for print Unknown version (usually for v1... v2 and v3 should meet a Hardware)
0638+  1616             Z80_Unk: 
0639+  1616 DD 21 BA 30 			LD		IX,HW_Unknown
0640+  161A 18 EE       			JR		PrintF_Z80
0641+  161C             
0642+  161C             ;DO_GetInfo - Send command to Arduino to get additional data of a File
0643+  161C             ;	IN - IX points to File struct
0644+  161C             ;	IN - DE Number of bytes to ask for (or 0 if no response required)
0645+  161C             DO_GetInfo: 
0646+  161C 3E 1E       			LD		A,CMD_ZX2SD_GETINFO
0647+  161E             			;DI
0648+  161E CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0649+  1621 DD 7E 20    			LD		A,(IX+FILEINDEX)				;Low byte of index
0650+  1624 CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0651+  1627 DD 7E 21    			LD		A,(IX+FILEINDEX+1)				;High byte of index
0652+  162A CD 04 33    			CALL	SendSerByte						;Command to ask for more info about file
0653+  162D             						
0654+  162D 21 33 9C    			LD		HL,BufGetInfo
0655+  1630 C3 BF 32    			JP		Load4bitBlk
0656+  1633             			
0657+  1633             			
0658+  1633             ;PrintIXText_Spaces - Print string (adding spaces at the end to fill upto last column of BOX)
0659+  1633             ;	IN - IX = Address for text to print (ending with 0x00)
0660+  1633             ;	IN - DE = D=Row, E=Column
0661+  1633             ;  OUT - IX = Address after the pos of the 0x00 of after the "spaces"
0662+  1633             PrintIXText_Spaces: 
0663+  1633 CD CC 16    			CALL	PrintIXText						;Print text in IX at Row D, Column E
0664+  1636 DD E5       			PUSH	IX
0665+  1638             
0666+  1638 3E 26       			LD		A,ColDescSel					;Initial column
0667+  163A DD 21 B7 1A 			LD		IX,FT_EMPTY						;Points  spacetext
0668+  163E             PrintFileType_Spaces: 
0669+  163E BB          			CP		E								;Check if arrived to column for printing
0670+  163F 28 05       			JR		Z,PrintFileType_printit			;print spaces (or nothing if last column)
0671+  1641 DD 23       			INC		IX
0672+  1643 3C          			INC		A
0673+  1644 18 F8       			JR		PrintFileType_Spaces
0674+  1646             PrintFileType_printit: 
0675+  1646 CD CC 16    			CALL	PrintIXText						;Replace other possible chars in the row with "spaces"		
0676+  1649             PrintFileType_End: 
0677+  1649 DD E1       			POP		IX
0678+  164B C9          			RET
0679+  164C             			
0680+  164C             ;-----------------------------------------------------------------------------------------
0681+  164C             ; XYtoAddr - Converts a screen char coord  into a Pixel Address  d,e = y,x positions
0682+  164C             ;	IN  - D=Row(0..23), E=Column(0..31)
0683+  164C             ;	OUT - HL=Address of acanline 0 in Screen
0684+  164C             ;	Conversion:
0685+  164C             ;			Row FFfff   Column CCCCC
0686+  164C             ;			HL=%010FF000 fffCCCCC
0687+  164C             ;-----------------------------------------------------------------------------------------
0688+  164C             XYtoAddr: 
0689+  164C             		;Calculate addr of scanline 0 of the char in screen.
0690+  164C             ;   Input	: DE => Row D=0..23, Column E=0..31
0691+  164C             ;	Output  : HL = Address of scanline0 in Screen
0692+  164C             ;   		How to calc the pixels of screen:
0693+  164C             ;			Row (bit) 43210	  Column(bit) 43210
0694+  164C             ; 					  RRrrr				  ccccc
0695+  164C             ;			Address (High)	76543210	(Low) 76543210
0696+  164C             ;							010RRsss		  rrrccccc
0697+  164C             ;   				RR -> 00 = Block.0, 01=B.1 10=B.2
0698+  164C             ;					rrr = row (0..7) / combining RR & rrr it's the 24 rows (0..23)
0699+  164C             ;					ccccc -> column (0..31) / sss -> n.scanline (0..7)
0700+  164C 7A          				LD		A,D				;	000RRrrr  <=Row 0..23
0701+  164D 0F          > RRCA					
0701+  164E 0F          > RRCA					
0701+  164F 0F          > RRCA					
0702+  1650 E6 E0       				AND		%11100000		;	rrr00000
0703+  1652             										;E=	000ccccc  <=Column 0..31
0704+  1652 B3          				OR		E				;	rrrccccc
0705+  1653 6F          				LD		L,A				;L= rrrccccc
0706+  1654             
0707+  1654 7A          				LD		A,D				;	000RRrrr  <=(Row 0..23)
0708+  1655 E6 18       				AND		%00011000		;	000RR000
0709+  1657 F6 40       				OR		%01000000		;	010RR000
0710+  1659 67          				LD		H,A				;H=	010RR000 <-scan line 0
0711+  165A C9          				RET						;HL=010RR000 rrrccccc
0712+  165B             
0713+  165B             ;-----------------------------------------------------------------------------------------
0714+  165B             ; XYtoAttr - Converts a screen char coord  into a ATTR Address  d,e = y,x positions
0715+  165B             ;	IN  - D=Row(0..23), E=Column(0..31)
0716+  165B             ;	OUT - HL=Address of Attribute in Screen
0717+  165B             ;	Conversion:
0718+  165B             ;			Row FFfff   Column CCCCC
0719+  165B             ;			HL=%010110FF fffCCCCC
0720+  165B             ;-----------------------------------------------------------------------------------------
0721+  165B             XYtoAttr: 
0722+  165B             ;Calculate addr of Attribute screen.
0723+  165B             ;   Input	: DE => Row D=0..23, Column E=0..31
0724+  165B             ;	Output  : HL = Address of Attribute in Screen
0725+  165B             ;   		How to calc the Attribute of screen:
0726+  165B             ;   		Attribut Row	76543210	Col	76543210
0727+  165B             ;							000RRrrr		000ccccc
0728+  165B             ;			Address (High)	76543210  (Low) 76543210
0729+  165B             ;							010110RR		rrrccccc
0730+  165B             ;							RR -> 00 = Block.0, 01=B.1 10=B.2
0731+  165B             ;							rrr = row (0..7) / combining RR & rrr it's the 24 rows (0..23)
0732+  165B             ;							ccccc -> column (0..31)
0733+  165B 7A          				LD		A,D				;	000RRrrr	(Fila 0..23)
0734+  165C 0F          > RRCA					
0734+  165D 0F          > RRCA					
0734+  165E 0F          > RRCA					
0735+  165F 67          				LD		H,A				;H=	rrr000RR	for calculate High Addr later-on
0736+  1660 E6 E0       				AND		%11100000		;A=	rrr00000
0737+  1662 B3          				OR		E				;A=	rrrccccc
0738+  1663 6F          				LD		L,A				;L=	rrrccccc
0739+  1664             				
0740+  1664 7C          				LD		A,H				;	rrr000RR
0741+  1665 E6 03       				AND		%00000011		;	000000RR
0742+  1667 F6 58       				OR		%01011000		;	010110RR
0743+  1669 67          				LD		H,A				;H=	010110RR
0744+  166A             
0745+  166A C9          				RET						;HL = 010110RR rrrccccc
0746+  166B             
0747+  166B             ;RowAttrMod - change attribute colours at Row D(0..23), Column E(0..31) with attribute B for a number of byte as per C
0748+  166B             RowAttrMod: 
0749+  166B CD 5B 16    			CALL	XYtoAttr			;HL=Attr pos
0750+  166E 54          			LD		D,H
0751+  166F 5D          			LD		E,L
0752+  1670 13          			INC		DE					;DE=Next attr pos
0753+  1671 70          			LD		(HL),B				;Change colour to 1st position
0754+  1672 0D          			DEC		C
0755+  1673 C8          			RET		Z					;Is C was 1 then don't have to do the LDIR
0756+  1674 06 00       			LD		B,0					;So BC is quantity
0757+  1676 ED B0       			LDIR						;Copy colour to all positions
0758+  1678 C9          			RET
0759+  1679             			
0760+  1679             ;RowAttr - change attribute bright for the file selected, 1st char (icon) does not change ink, only bright
0761+  1679             ;		also if row is MinRowFiles (where page number is) and LastPages>1, then it does not change
0762+  1679             ;	IN A - Row
0763+  1679             ;	IN C - Attribute colour
0764+  1679             RowAttr: 
0765+  1679 F5          			PUSH	AF								;Saving Row
0766+  167A 57          			LD		D,A								;D=Row
0767+  167B 1E 00       			LD		E,0								;A=Column 0
0768+  167D CD 5B 16    			CALL	XYtoAttr						;HL=Attr in screen
0769+  1680 7E          			LD		A,(HL)
0770+  1681             			;AND		7
0771+  1681             			;OR		E
0772+  1681 EE 40       			XOR		NoSel_Color^Selec_Color			;Swap Selec_Color <->NoSel_Color
0773+  1683 77          			LD		(HL),A							;Attribute for the selected/nonselected
0774+  1684 23          			INC		HL
0775+  1685 71          			LD		(HL),C							;Attribute colour
0776+  1686 54          			LD		D,H
0777+  1687 5D          			LD		E,L
0778+  1688 13          			INC		DE
0779+  1689 01 0E 00    			LD		BC,Sel_Bar_Len-1-1				;Filling attributes Bar - Icon - 1st byte filled with LD (HL),C
0780+  168C F1          			POP		AF
0781+  168D FE 01       			CP		MinRowFiles						;Check if is the 1st
0782+  168F 20 0A       			JR		NZ,RowAttrNo1st
0783+  1691 3A 1A 9C    			LD		A,(LastPages)
0784+  1694 FE 01       			CP		1								;Check if only 1 page
0785+  1696 28 03       			JR		Z,RowAttrNo1st
0786+  1698 01 0B 00    			LD		BC,Sel_Bar_Len-1-1-((TXTMaxPageEmpty-TXTPageof-1)/2) ;does not change attr for Page Number
0787+  169B             RowAttrNo1st: 
0788+  169B ED B0       			LDIR
0789+  169D C9          			RET
0790+  169E             
0791+  169E             ;NumberAtoIX - Convert a number (2 digits) into text (routine add 0x00 at the end)
0792+  169E             ;	IN  A = Number to print
0793+  169E             ;	IN  IX = Address where to put the chars (changes IX and IX+1, also IX+2 store 0)
0794+  169E             ;	A is saved so can be used after routine
0795+  169E             NumberAtoIX: 
0796+  169E F5          			PUSH	AF
0797+  169F 0E 00       			LD		C,0								;C will hold Tens
0798+  16A1             NumberAtoIX_Loop: 
0799+  16A1 D6 0A       			SUB		10
0800+  16A3 38 03       			JR		C,NumberAtoIX_NoTens
0801+  16A5             		;Here if have tens
0802+  16A5 0C          			INC		C								;Increment Tens
0803+  16A6 18 F9       			JR		NumberAtoIX_Loop
0804+  16A8             			
0805+  16A8             NumberAtoIX_NoTens: 
0806+  16A8 C6 3A       			ADD		10+"0"							;Recuperate Units and also convert to Char
0807+  16AA DD 77 01    			LD		(IX+1),A						;Store Units as char
0808+  16AD 79          			LD		A,C
0809+  16AE A7          			AND		A
0810+  16AF 28 04       			JR		Z,NumberAtoIX_TenIsZero
0811+  16B1 C6 30       			ADD		"0"								;Convert Tens to Char
0812+  16B3 18 02       			JR		NumberAtoIX_TenNoZero
0813+  16B5             NumberAtoIX_TenIsZero: 
0814+  16B5 3E 20       			LD		A," "
0815+  16B7             NumberAtoIX_TenNoZero: 
0816+  16B7 DD 77 00    			LD		(IX),A							;Store Tens as char
0817+  16BA DD 36 02 00 			LD		(IX+2),0						;Add a zero at the end for use with PrintIXText
0818+  16BE F1          			POP		AF
0819+  16BF C9          			RET
0820+  16C0             	
0821+  16C0             ;UnitAtoIX - Convert a number (1 digit) into text (routine add 0x00 at the end)
0822+  16C0             ;	IN  A = Number to print
0823+  16C0             ;	IN  IX = Address where to put the chars (changes IX, also IX+1 store 0)
0824+  16C0             ;	A is saved so can be used after routine
0825+  16C0             UnitAtoIX: 
0826+  16C0 F5          			PUSH	AF
0827+  16C1 C6 30       			ADD		"0"								;Unit to char
0828+  16C3 DD 77 00    			LD		(IX),A							;Store Units as char
0829+  16C6 DD 36 01 00 			LD		(IX+1),0						;Add a zero at the end for use with PrintIXText
0830+  16CA F1          			POP		AF
0831+  16CB C9          			RET	
0832+  16CC             			
0833+  16CC             ;PrintIXText - Print Text in screen. D=Row, E=Column
0834+  16CC             PrintIXText: 
0835+  16CC D5          			PUSH 	DE								;Save copy D=Row, E=Column
0836+  16CD A7          			AND		A								;Clear carry
0837+  16CE CB 1B       			RR		E								;Half value and bit to carry
0838+  16D0 01 0F F0    			LD		BC,#F00F						;C=#0F for left char in screen to clear (Carry=0, even column) B=#F0 for left char to add from charset
0839+  16D3 30 03       			JR		NC,CharEven						;Carry bit for odd value
0840+  16D5 01 F0 0F    			LD		BC,#0FF0						;C=#F0 for right char in screen to clear (Carry=1, odd column) B=#0F for right char to add from charset
0841+  16D8             CharEven: 
0842+  16D8 CD 4C 16    			CALL	XYtoAddr						;Calculate pix address from D=Row, E=Column => HL=Pix address
0843+  16DB D1          			POP		DE								;D=Row, E=Column as per input
0844+  16DC             			
0845+  16DC             		;so HL=Address in screen for pixels
0846+  16DC             PrintIXText_Loop: 
0847+  16DC DD 7E 00    			LD		A,(IX)							;A=Char to print
0848+  16DF DD 23       			INC		IX								;IX point to next char for next time
0849+  16E1 A7          			AND		A								;Check if A=0 (end of text)
0850+  16E2 C8          			RET		Z								;If end of text then return
0851+  16E3 CD E9 16    			CALL	PrintChar
0852+  16E6 1C          			INC		E								;Only column is updated
0853+  16E7 18 F3       			JR		PrintIXText_Loop
0854+  16E9             			
0855+  16E9             		;This is the PrintChar routine
0856+  16E9             PrintChar: 
0857+  16E9 D5          			PUSH	DE								;D=Row, E=Column 
0858+  16EA E5          			PUSH	HL								;Save HL=Address in screen to print
0859+  16EB             	;Here for printing a char 32..139
0860+  16EB 6F          			LD		L,A								;4Ts
0861+  16EC 26 00       			LD		H,0								;7Ts
0862+  16EE 29          			ADD		HL,HL							;11 *2
0863+  16EF 29          			ADD		HL,HL							;11 *4
0864+  16F0 29          			ADD		HL,HL							;11 *8
0865+  16F1 11 05 0C    			LD		DE,Charset8x4-(32*8)			;10
0866+  16F4 19          			ADD		HL,DE							;11
0867+  16F5             	;HL=Address in charset
0868+  16F5 EB          			EX		DE,HL							;DE=Address in charset
0869+  16F6 E1          			POP		HL								;HL=Address in screen to print
0870+  16F7 E5          			PUSH	HL								;HL=Address in screen to print
0871+  16F8             
0872+  16F8             	;CharLoop for the 8 scanlines
0873+  16F8             CharLoop: 
0874+  16F8 7E          			LD		A,(HL)							;A=Value on screen so we change only the correct nibble
0875+  16F9 A1          			AND		C								;Clear nibble we're going to use, mantain the other nibble of screen
0876+  16FA 77          			LD		(HL),A							;Update in screen clearing the nibble we're going to change
0877+  16FB 1A          			LD		A,(DE)							;Value of char (remember it have repeated the scanline in both nibbles)
0878+  16FC A0          			AND		B								;Isolate Left/Right as per column even/odd
0879+  16FD B6          			OR		(HL)							;"Mix" nibble in screen with nibble in A
0880+  16FE 77          			LD		(HL),A							;Store update nibble
0881+  16FF 13          			INC		DE								;Next scanline of char in charset
0882+  1700 24          			INC		H								;Next scanline in screen
0883+  1701 7C          			LD		A,H
0884+  1702 E6 07       			AND		7
0885+  1704 20 F2       			JR		NZ,CharLoop						;So repeat until again we have an scanline 0
0886+  1706 E1          			POP		HL								;HL=Address in screen to print
0887+  1707 D1          			POP		DE								;D=Row, E=Column 
0888+  1708 78          			LD		A,B
0889+  1709 41          			LD		B,C
0890+  170A 4F          			LD		C,A								;Swapped B<->C values #0F <-> #F0
0891+  170B A7          			AND		A								;and activate Sign as per #0F (positive) , #F0 (Negative)
0892+  170C F8          			RET		M								; Increment HL only when A=#0F (positive). Return if A=#F0 (Negative)
0893+  170D 23          			INC		HL
0894+  170E C9          			RET
0895+  170F             
0865   170F             PEPR: 
0866   170F             OB: 
0867   170F             		include "resources/OtherTexts.asm"			;Other texts for different uses (more info inside the own file)
0001+  170F             ;OtherTexts.asm
0002+  170F             ;	General texts for some uses
0003+  170F             
0004+  170F             TXTDanPath: 		defb	FT_ROMSET,"../Dan MENU",0		;Dandanator "Go to menu" text
0004+  170F 302E2E2F44616E204D454E5500
0005+  171C             SizeEndTXTDanPath equ	$-TXTDanPath
0006+  171C             
0007+  171C             TXTZXPath: 		defb	FT_BASIC,"../ZX Basic",0		;Dandanator "Go to BASIC" text
0007+  171C 312E2E2F5A5820426173696300
0008+  1729             SizeEndTXTZXPath equ	$-TXTZXPath
0009+  1729             
0010+  1729             TXTLoading: 		defb	"Retrieving File Names...",0
0010+  1729 52657472696576696E672046696C65204E616D65732E2E2E00
0011+  1742             TXTSorting: 		defb	"Sorting Files...",0
0011+  1742 536F7274696E672046696C65732E2E2E00
0012+  1753             
0013+  1753             TXTPageof: 		defb	127,"  /  ",0					;"  /  ",127,0
0013+  1753 7F20202F202000
0014+  175A             
0015+  175A             TXTMaxPageEmpty: 
0016+  175A 20          				defs	TXTMaxPageEmpty-TXTPageof-1," "
0017+  1760 00          				defb	0
0018+  1761             				
0019+  1761             TXTNOMultiply: 	defb	" < Multiply NOT DETECTED > ",0
0019+  1761 203C204D756C7469706C79204E4F54204445544543544544203E2000
0020+  177D             
0021+  177D             ;Texts for ROMSET preview
0022+  177D 2F 00       TXTROMPage: 		defb	"/",0
0023+  177F             ;Texts for ROMSET options
0024+  177F             TXTROMWRITE: 	defb	"Sure to write?  "
0024+  177F 5375726520746F2077726974653F2020
0025+  178F 20 4E 4F 20 TXTROMWRITENO: 	defb	" NO "
0026+  1793 20 20       				defb	"  "			;2 Bytes separator so we have text aligned with Screen Attr
0027+  1795 2059455300  				defb	" YES",0
0028+  179A             TXTROMWRoffNO	equ		(TXTROMWRITENO-TXTROMWRITE)/2
0029+  179A             
0030+  179A             TXTROM10: 		defb	"No Multiply support!",0
0030+  179A 4E6F204D756C7469706C7920737570706F72742100
0031+  17AF             
0032+  17AF             TXTTAPnoScreen: 	defb	"Screen not found",0
0032+  17AF 53637265656E206E6F7420666F756E6400
0033+  17C0             
0034+  17C0             ;Texts for File System Degraded
0035+  17C0             TXTDEGRA: 		defb	"    Folder with many hidden,",0
0035+  17C0 20202020466F6C6465722077697468206D616E792068696464656E2C00
0036+  17DD             				defb	" deleted or incompatible files.",0
0036+  17DD 2064656C65746564206F7220696E636F6D70617469626C652066696C65732E00
0037+  17FD             				defb	"     Degraded performance.",0
0037+  17FD 2020202020446567726164656420706572666F726D616E63652E00
0038+  1818             				
0039+  1818             TXTTOODEGRA: 	defb	"Folder with way too many hidden,",0
0039+  1818 466F6C64657220776974682077617920746F6F206D616E792068696464656E2C
0039+  1838 00
0040+  1839             				defb	" deleted or incompatible files.",0
0040+  1839 2064656C65746564206F7220696E636F6D70617469626C652066696C65732E00
0041+  1859             				defb	"     Very bad performance.",0
0041+  1859 2020202020566572792062616420706572666F726D616E63652E00
0868   1874             OE: 
0869   1874             GetDANMENUData: 
0870   1874             		include "resources/GetDANMENUData.asm"		;Get info about the 1st slot in the EEPROM
0001+  1874             ;GetDANMENUData - Get info about the 1st slot in EEPROM
0002+  1874             		
0003+  1874 21 81 18    			LD HL,GetRDMData
0004+  1877 11 00 80    			LD DE,RAMRDMData
0005+  187A D5          			PUSH DE
0006+  187B 01 45 00    			LD BC,ENDGetRDMData-GetRDMData
0007+  187E ED B0       			LDIR
0008+  1880 C9          			RET
0009+  1881             
0010+  1881             GetRDMData: 
0011+  1881             		DISP	ScratchRAM
0012+  8000             RAMRDMData: 
0013+  8000 3A EA 3F    			LD	A,(MLDoffset)
0014+  8003 3C          			INC A
0015+  8004 32 44 80    			LD (GetRDMData_MLD),A
0016+  8007 06 01       			LD B,1						;1st Slot to jump there
0017+  8009             			SLOT_B
0017+  8009 23          >.slot_b		INC HL
0017+  800A 2B          >			DEC HL
0017+  800B 32 00 00    >			LD (0),A
0017+  800E 10 F9       >			DJNZ .slot_b
0018+  8010             			WAIT_B PAUSELOOPSN
0018+  8010 06 40       >			LD B,value
0018+  8012 10 FE       >.wait_b0	DJNZ .wait_b0
0019+  8014             
0020+  8014 3A FF 3F    			LD  A,(DANSNAP_PAUSE)		;Slot for Pause/DanSnap (valid value only 2-32)
0021+  8017 32 94 7F    			LD	(DanSnap_Val),A			;Copy value to there so Multiply have it for use when launching games
0022+  801A             
0023+  801A 21 E0 3F    			LD	HL,VINFOTXT
0024+  801D 7E          			LD  A,(HL)
0025+  801E FE 76       			CP  "v"						;Dandanator menu have version there "vxxxxxxx" (8 bytes)
0026+  8020 28 06       			JR  Z,ValidDanMENU
0027+  8022             		;Here if no valid Dan MENU
0028+  8022 AF          			XOR A
0029+  8023 32 2A 9C    			LD  (InfoVersion),A
0030+  8026 18 0C       			JR   GetRDMData_Rt
0031+  8028             ValidDanMENU: 
0032+  8028 11 2A 9C    			LD DE,InfoVersion
0033+  802B 01 08 00    			LD BC,8
0034+  802E ED B0       			LDIR
0035+  8030 3A 00 0E    			LD A,(GAMEDATATABADDR)		;Number of games in Dandanator Menu
0036+  8033 12          			LD	(DE),A
0037+  8034             
0038+  8034             GetRDMData_Rt: 
0039+  8034 3A 44 80    			LD A,(GetRDMData_MLD)
0040+  8037 47          			LD B,A						;Multiply Slot to return
0041+  8038             			SLOT_B
0041+  8038 23          >.slot_b		INC HL
0041+  8039 2B          >			DEC HL
0041+  803A 32 00 00    >			LD (0),A
0041+  803D 10 F9       >			DJNZ .slot_b
0042+  803F             			WAIT_B PAUSELOOPSN
0042+  803F 06 40       >			LD B,value
0042+  8041 10 FE       >.wait_b0	DJNZ .wait_b0
0043+  8043             			
0044+  8043 C9          			RET
0045+  8044             
0046+  8044 00          GetRDMData_MLD: 	defb 0				;Will hold MLD number of Multiply so we can return there
0047+  8045             		ENT
0048+  18C6             ENDGetRDMData: 
0871   18C6             	
0872   18C6             SBS: 	
0873   18C6             		include "resources/Sorting.asm"				;Sort routines
0001+  18C6             ;Sort - Sort of Directories
0002+  18C6             ; Filenames have up to 30 chars... not used are filled up with 0x00
0003+  18C6             ;	Each entry is:  
0004+  18C6             ;		#00 - Filetype (1 byte)
0005+  18C6             ;		#01 - Filename (30 bytes)
0006+  18C6             ;		#1F - Always 0x00 (1 byte)
0007+  18C6             ;		#20-#21 - Index (low byte, high byte) (2 bytes)
0008+  18C6             ;		#22 - Next entry....
0009+  18C6             ;
0010+  18C6             ; Steps for sort:
0011+  18C6             ;		**Process for Directories
0012+  18C6             ;				a)".." is retain as "1st entry" but not sorted
0013+  18C6             ;				b)copy addresses of each Dir to SortBuffer.... only for FT_DIRECTORY.. 
0014+  18C6             ;				c)IY points to 1st entry, B=counted entries to sort (discarding ".." that is not sorted)
0015+  18C6             ;				d)Sorting:
0016+  18C6             ;					d1)B=B-1 (save for later-on usage)
0017+  18C6             ;					d2)if this item is greater than next item then swap them, also mark C=1 if any swapped in "this round"
0018+  18C6             ;					d3)repeat d1-d2 up to current value of B=0
0019+  18C6             ;					d4)if C=0 we finished (nothing was swapped in "this round")
0020+  18C6             ;					d5)if C=1 then repeat, so restore B and repeat from d1
0021+  18C6             ;
0022+  18C6             ;		**Process for Files
0023+  18C6             ;				Repeat the procedure done with directories
0024+  18C6             
0025+  18C6             ;	After that we'll have a addresses list with the sorted items for both: Directories and Files
0026+  18C6             
0027+  18C6             Sort: 
0028+  18C6             ;				a)".." is leaved with 0x00 and retain as "1st entry"
0029+  18C6 ED 73 31 DD 			LD		(SortSP),SP						;saving SP for later-on
0030+  18CA             
0031+  18CA 21 48 9C    			LD		HL,Buffer						;Buffer of 34 x 254 (last entry is always 0x00) so only 253 can be used
0032+  18CD FD 21 04 BE 			LD		IY,SortBuffer					;Buffer of 2 x 254 (last entry is always 0x00) so only 253 can be used (arranged for 23 * 11 screens)
0033+  18D1             
0034+  18D1 FD F9       			LD		SP,IY							;We'll use SP for moving data
0035+  18D3             
0036+  18D3 11 22 00    			LD		DE,FILEENTRY_LEN
0037+  18D6             			
0038+  18D6             		;Check if we're in Root dir or subdir.... subdir have 1st entry as ".." so skip it in the sort
0039+  18D6 3A 49 9C    			LD		A,(Buffer+1)					;1st char of first item
0040+  18D9 FE 2E       			CP		"."
0041+  18DB 20 08       			JR		NZ,FillupSort					;Root dir does not have a ".." entry, in that case jump to begin sorting
0042+  18DD             		;Here if 1st entry is ".." (subdirectory) so that entry is out of sort
0043+  18DD C1          			POP		BC;.2		INC SP				;Move SP+2 (BC is discarded)
0044+  18DE E5          			PUSH	HL
0045+  18DF E1          			POP		HL
0046+  18E0 FD 21 06 BE 			LD		IY,SortBuffer+2
0047+  18E4 19          			ADD		HL,DE							;So points to next entry
0048+  18E5             FillupSort: 
0049+  18E5             ;				Unpdate SortBuffer with all current entries, type FT_DIRECTORY
0050+  18E5 01 00 00    			LD		BC,0							;0 entries, also C=0 for later on
0051+  18E8             
0052+  18E8             Sort_Fillup: 
0053+  18E8 7E          			LD		A,(HL)
0054+  18E9 FE 0C       			CP		FT_DIRECTORY
0055+  18EB 20 08       			JR		NZ,Sort_EndFillup				;There is no Directories
0056+  18ED 04          			INC		B
0057+  18EE 33          > INC SP
0057+  18EF 33          > INC SP
0058+  18F0 E5          			PUSH	HL
0059+  18F1 E1          			POP		HL
0060+  18F2 19          			ADD		HL,DE							;So points to next entry
0061+  18F3 18 F3       			JR		Sort_Fillup	
0062+  18F5             			
0063+  18F5             Sort_EndFillup: 
0064+  18F5 D1          			POP		DE;.2		INC SP				;Move SP+2 (DE is discarded)
0065+  18F6 11 00 00    			LD		DE,0
0066+  18F9 D5          			PUSH	DE								;Assure ends in 0x00
0067+  18FA             
0068+  18FA ED 73 2D DD 			LD		(PosFiles),SP					;Position for later with pointer to files
0069+  18FE 22 2F DD    			LD		(HLPosFiles),HL					;Position for later with files
0070+  1901             			
0071+  1901 78          			LD		A,B								;B=Number of items of Directory type to sort
0072+  1902 3D          			DEC		A								;Always process 1 less... we'll compre 2 items between them 
0073+  1903 21 2C DD    			LD		HL,TotalB
0074+  1906 77          			LD		(HL),A
0075+  1907 3C          			INC		A
0076+  1908 FE 02       			CP		2								; No sort if 0 or 1 item so compare against 2
0077+  190A 38 06       			JR		C,Sort_NoDirsEntries			;If no directories or only 1 dir, then no sort required
0078+  190C             
0079+  190C DD 21 12 19 			LD		IX,Sort_NoDirsEntries			;SortIY will return with JP(IX)
0080+  1910 18 36       			JR		SortIY
0081+  1912             
0082+  1912             Sort_NoDirsEntries: 
0083+  1912             
0084+  1912             ;Now for Files
0085+  1912 FD 2A 2D DD 			LD		IY,(PosFiles)					;Position with pointers to files
0086+  1916 FD F9       			LD		SP,IY
0087+  1918 2A 2F DD    			LD		HL,(HLPosFiles)					;Position for filenames
0088+  191B 11 22 00    			LD		DE,FILEENTRY_LEN
0089+  191E             
0090+  191E             FillupSort2: 
0091+  191E             ;				Fill IY table for files
0092+  191E 01 00 00    			LD		BC,0							;0 entries, also C=0 for later on
0093+  1921             			;PUSH	IY								;IY=Begining of Files data
0094+  1921             Sort_Fillup2: 
0095+  1921 7E          			LD		A,(HL)
0096+  1922 A7          			AND		A
0097+  1923 28 08       			JR		Z,Sort_EndFillup2				;When file type 0 we finish with files
0098+  1925 04          			INC		B
0099+  1926 33          > INC SP
0099+  1927 33          > INC SP
0100+  1928 E5          			PUSH	HL
0101+  1929 E1          			POP		HL
0102+  192A 19          			ADD		HL,DE							;So points to next entry
0103+  192B 18 F4       			JR		Sort_Fillup2	
0104+  192D             
0105+  192D             Sort_EndFillup2: 
0106+  192D D1          			POP		DE;.2		INC SP				;Move SP+2 (DE is discarded)
0107+  192E 11 00 00    			LD		DE,0
0108+  1931 D5          			PUSH	DE								;Assure ends in 0x00
0109+  1932             
0110+  1932 78          			LD		A,B								;B=Number of items
0111+  1933 3D          			DEC		A								;Always process 1 less... we'll compre 2 items between them 
0112+  1934 21 2C DD    			LD		HL,TotalB
0113+  1937 77          			LD		(HL),A
0114+  1938 3C          			INC		A
0115+  1939 FE 02       			CP		2								; No sort if 0 or 1 item so compare against 2
0116+  193B 38 06       			JR		C,Sort_NoFilesEntries			;If no files or only 1 file, then no sort required
0117+  193D             			
0118+  193D DD 21 43 19 			LD		IX,Sort_NoFilesEntries			;To return after SortIY -uses JP(IX)-
0119+  1941 18 05       			JR		SortIY							;Sort Files
0120+  1943             
0121+  1943             Sort_NoFilesEntries: 
0122+  1943             			
0123+  1943 ED 7B 31 DD 			LD		SP,(SortSP)						;restoring SP
0124+  1947             
0125+  1947 C9          			RET
0126+  1948             
0127+  1948             ;SortIY - IY points to 1st item for sorting... be sure there is a 0x00,0x00 after last item
0128+  1948             SortIY: 
0129+  1948 21 2C DD    			LD		HL,TotalB
0130+  194B             SortIY2: 
0131+  194B 46          			LD		B,(HL)
0132+  194C 0E 00       			LD		C,0
0133+  194E             ;				c)HL=1st entry, B=counted entries to sort (discarding "..")
0134+  194E FD F9       			LD		SP,IY
0135+  1950             Sort_sorting: 
0136+  1950 E1          			POP		HL
0137+  1951 D1          			POP		DE
0138+  1952 D5          			PUSH	DE
0139+  1953 E5          			PUSH	HL
0140+  1954             Sort_sorting_Loop: 
0141+  1954 23          			INC		HL
0142+  1955 13          			INC		DE
0143+  1956 1A          			LD		A,(DE)							;A=char for next entry
0144+  1957 BE          			CP		(HL)							;Char for next entry - char for this entry
0145+  1958 28 FA       			JR		Z,Sort_sorting_Loop				;While the same chars.... loop
0146+  195A 30 06       			JR		NC,Sort_NoSwap					;Next entry is not lower than this so no swap
0147+  195C             		;;Next entry is lower than this so have to swap
0148+  195C             Sort_Swap: 
0149+  195C 0E 01       			LD		C,1								;Mark as "swapped something"
0150+  195E E1          			POP		HL
0151+  195F D1          			POP		DE								;Extraced HL,DE
0152+  1960 E5          			PUSH	HL
0153+  1961 D5          			PUSH	DE								;Pushed in reverse so they are swapped in RAM
0154+  1962             		;here for no swap items
0155+  1962             Sort_NoSwap: 
0156+  1962 E1          			POP		HL								;HL discarded
0157+  1963 10 EB       			DJNZ	Sort_sorting					;Repeat upto last entry
0158+  1965             			
0159+  1965 79          			LD		A,C								;C=0 if nothing swapped, any other value if someone was swapped
0160+  1966 A7          			AND		A								;Test for C was 0 (nothing swapped)
0161+  1967             			;POP		IY
0162+  1967 28 06       			JR		Z,Sort_Dir_Ending				;If nothing was swapped then finish sorting directories
0163+  1969 21 2C DD    			LD		HL,TotalB
0164+  196C 35          			DEC		(HL)
0165+  196D 20 DC       			JR		NZ,SortIY2						;Repeat for a new "round"
0166+  196F             
0167+  196F             		;	JR		Sort_Dir_Ending
0168+  196F             			
0169+  196F             Sort_Dir_Ending: 
0170+  196F             
0171+  196F DD E9       			JP		(IX)							;return to caller
0172+  1971             			
0874   1971             SES: 
0875   1971             	IFDEF	debug
0876   1971~            		include "debug.asm"
0877   1971             	ENDIF	
0878   1971             
0879   1971             SB: 
0880   1971             		;SD Directory and Files routines
0881   1971             		include "resources/SDRoutines.asm"
0001+  1971             ;SD Card and files
0002+  1971             ;Different calls for dealing with Directories / Files
0003+  1971             
0004+  1971             ;ZX2SD_CD_ROOT - Return to root directory
0005+  1971             ;  IN - Nothing
0006+  1971             ;  Changes A and B, Flags are not affected
0007+  1971             ZX2SD_CD_ROOT: 
0008+  1971 3E 0A       			LD		A,CMD_ZX2SD_CD_ROOT
0009+  1973 C3 D4 32    			JP		SendSerByteLC					;Go to Root directory (return from there)
0010+  1976             			
0011+  1976             			
0012+  1976             			
0013+  1976             ;Command with Index and Long Confirmation (if Carry set) or Short Confirmation (if carry reset)
0014+  1976             ;	IN - A: Command to send
0015+  1976             ;	IN - D:	Data 1
0016+  1976             ;	IN - E: Data 2
0017+  1976             ;	IN - Flags: Carry activated for Long Confirmation, Carry inactive for Short Confirmation
0018+  1976             ;  Changes A and B, Flags are not affected
0019+  1976             ZX2SD_COMMAND: 
0020+  1976 CD D4 32    			CALL	SendSerByteLC					;Send A=Command
0021+  1979 7A          			LD		A,D
0022+  197A CD D4 32    			CALL	SendSerByteLC					
0023+  197D 7B          			LD		A,E
0024+  197E D2 04 33    			JP		NC,SendSerByte					;Send with Short Confirmation and return from there
0025+  1981 C3 D4 32    			JP		SendSerByteLC					;Send with Long Confirmation and return from there
0026+  1984             			
0027+  1984             
0028+  1984             
0029+  1984             
0030+  1984             
0031+  1984             
0882   1984             SE: 	
0883   1984             
0884   1984             showinfHB: 
0885   1984             		;Check Hardware ZX Spectrum type
0886   1984             		include "resources/checkhardware.asm"
0001+  1984             ;CheckHardware
0002+  1984             CheckHardware: 
0003+  1984 CD 0D 12    			CALL	GetMultiplyVer
0004+  1987             
0005+  1987             		;Now check if we're in 48 or 128k spectrum (16k is not allowed)
0006+  1987 3E 04       			LD		A,4
0007+  1989 01 FD 1F       			LD		BC,#1FFD
0008+  198C ED 79       			OUT		(C),A
0009+  198E AF          			XOR		A
0010+  198F 21 07 DD    			LD		HL,CHK_48K_VAR
0011+  1992 06 7F          			LD		B,#7F							;LD BC,7FFDh
0012+  1994 ED 79       			OUT		(C),A							;Bank 0
0013+  1996 3E 03       			LD		A,3								;A=8
0014+  1998 77          			LD		(HL),A							;3 in Bank 0
0015+  1999 3E 02       			LD		A,2								;A=2
0016+  199B ED 79       			OUT		(C),A							;Bank 2
0017+  199D 77          			LD		(HL),A							;2 in Bank 2
0018+  199E 3E 10       			LD		A,#10
0019+  19A0 ED 79       			OUT		(C),A							;Return to Bank 0
0020+  19A2 7E          			LD		A,(HL)							; A=2 (48k) / A=3 (128k) / A=#FF or maybe any other (16k)
0021+  19A3 FE 02       			CP		2								; A will be 2 if no RAM Page ocuurs (48k)
0022+  19A5 28 06       			JR		Z,CheckHardware_Set				;A=2 so it's 48k
0023+  19A7 FE 03       			CP		3								; A will be 3 if RAM Page was success (128k)
0024+  19A9 28 02       			JR		Z,CheckHardware_Set				;A=3 so it's 128k
0025+  19AB 3E 01       			LD		A,1								; A=1 (16k)
0026+  19AD             CheckHardware_Set: 
0027+  19AD             
0028+  19AD 57          			LD		D,A								;D=Hw model (1,2,3)
0029+  19AE 3E 03       			LD		A,CMD_ZX2SD_SETZXTYPE
0030+  19B0 CD D4 32    			CALL	SendSerByteLC					;Send Command
0031+  19B3 7A          			LD		A,D
0032+  19B4 C3 D4 32    			JP		SendSerByteLC					;Send Data (and return from there)
0033+  19B7             
0887   19B7             showinfHE: 
0888   19B7             
0889   19B7             		;Launch TAP routines
0890   19B7             Load_FT_TAP: 
0891   19B7             		include "resources/launchTAP.asm"
0001+  19B7             ;Launch_TAP routines for Multiply v1
0002+  19B7             
0003+  19B7             ;27-May-2020 Mad3001
0004+  19B7             
0005+  19B7             Launch_TAP: 
0006+  19B7             
0007+  19B7 7D          			LD		A,L
0008+  19B8 DD 6F       			LD		IXL,A
0009+  19BA 7C          			LD		A,H
0010+  19BB DD 67       			LD		IXH,A							;IX=HL
0011+  19BD             		;Request to open the file with Index (2 bytes)
0012+  19BD 3E 09       			LD		A,CMD_ZX2SD_OFREAD_IX				;Command = Open File (Relative Path)
0013+  19BF CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0014+  19C2 DD 7E 20    			LD		A,(IX+FILEINDEX)				;Low byte of index
0015+  19C5 CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file
0016+  19C8 DD 7E 21    			LD		A,(IX+FILEINDEX+1)				;High byte of index
0017+  19CB CD D4 32    			CALL	SendSerByteLC					;Command to ask for more info about file	
0018+  19CE             
0019+  19CE             		;PREPARE CORRECT RAM PAGES FOR 128K MODELS
0020+  19CE 3E 04       			LD		A,#04
0021+  19D0 01 FD 1F    			LD		BC,#1FFD
0022+  19D3 ED 79       			OUT		(C),A
0023+  19D5 3E 10       			LD		A,#10
0024+  19D7 01 FD 7F    			LD		BC,#7FFD
0025+  19DA ED 79       			OUT		(C),A
0026+  19DC             
0027+  19DC 3A 94 7F    			LD		A,(DanSnap_Val)					;Pause / Dansnap slot (valid 2-32)... TAP only allow PAUSE, no DanSnap
0028+  19DF FE 02       			CP		2
0029+  19E1 3E 02       			LD		A,2								;TAP does not allow DanSnap
0030+  19E3 D4 65 1A    			CALL	NC,ReenableButtonsA					;Reenable Left button as per Pause / DanSnap (if they exists in internal Dan EEPROM)
0031+  19E6             
0032+  19E6             		;Copy next routines to RAM as we have to change slot
0033+  19E6 21 00 1A    			LD		HL,BEGINTAP
0034+  19E9 11 00 80    			LD		DE,TAPRAM
0035+  19EC D5          			PUSH	DE
0036+  19ED 01 35 00    			LD		BC,ENDTAP-BEGINTAP
0037+  19F0 ED B0       			LDIR
0038+  19F2 3A EA 3F    			LD		A,(MLDoffset)					;Value 0..31 (slot number in which this MLD is)
0039+  19F5 3C          > INC A							
0039+  19F6 3C          > INC A							
0040+  19F7 47          			LD		B,A
0041+  19F8             			SLOT_B
0041+  19F8 23          >.slot_b		INC HL
0041+  19F9 2B          >			DEC HL
0041+  19FA 32 00 00    >			LD (0),A
0041+  19FD 10 F9       >			DJNZ .slot_b
0042+  19FF C9          			RET
0043+  1A00             			
0044+  1A00             BEGINTAP: 
0045+  1A00             			DISP	ScratchRAM
0046+  8000             TAPRAM: 		
0047+  8000             
0048+  8000             		WAIT_B		PAUSELOOPSN						;Wait for slot changed
0048+  8000 06 40       >			LD B,value
0048+  8002 10 FE       >.wait_b0	DJNZ .wait_b0
0049+  8004             		
0050+  8004             		;Lock Dandanator prior to jump to Patched ROM
0051+  8004             		DAN_BIG_COMMAND 46, 1, 1
0051+  8004 06 2E       >			LD	B,C1			; Command
0051+  8006 23          >.slot_b		INC HL
0051+  8007 2B          >			DEC HL
0051+  8008 32 00 00    >			LD (0),A
0051+  800B 10 F9       >			DJNZ .slot_b
0051+  800D 06 40       >			LD B,value
0051+  800F 10 FE       >.wait_b0	DJNZ .wait_b0
0051+  8011 06 01       >			LD	B,C2			; Data 1
0051+  8013 23          >.slot_b		INC HL
0051+  8014 2B          >			DEC HL
0051+  8015 32 00 00    >			LD (0),A
0051+  8018 10 F9       >			DJNZ .slot_b
0051+  801A 06 40       >			LD B,value
0051+  801C 10 FE       >.wait_b0	DJNZ .wait_b0
0051+  801E 06 01       >			LD  B,C3			; Data 2
0051+  8020 23          >.slot_b		INC HL
0051+  8021 2B          >			DEC HL
0051+  8022 32 00 00    >			LD (0),A
0051+  8025 10 F9       >			DJNZ .slot_b
0051+  8027 06 40       >			LD B,value
0051+  8029 10 FE       >.wait_b0	DJNZ .wait_b0
0051+  802B 32 00 00    >			LD 	(0),A
0052+  802E             		PAUSE_LONG
0052+  802E E3          >.pauselong: 	EX (SP),HL
0052+  802F E3          >			EX (SP),HL
0052+  8030 E3          >			EX (SP),HL
0052+  8031 E3          >			EX (SP),HL
0052+  8032 10 FA       >			DJNZ .pauselong
0053+  8034 C7          		RST	#0		;Launch patched slot (it have autoload so should load inmediatly)
0054+  8035             			ENT
0055+  1A35             ENDTAP: 
0892   1A35             ldtapE: 
0893   1A35             
0894   1A35             showinfSB: 
0895   1A35             		;Routines for buttons assignment
0896   1A35             		include "resources/setbuttons.asm"
0001+  1A35             ;setbuttons - Setting buttons
0002+  1A35             DisableButtons: 
0003+  1A35             		;change default buttons set by Dandanator main slot 1
0004+  1A35             
0005+  1A35             
0006+  1A35 06 29       			LD		B,41
0007+  1A37 2E 00       			LD		L,0								;0=Standard Launch (normal boot)
0008+  1A39 3A EA 3F    			LD		A,(MLDoffset)					;MLDoffset is bank of Multiply (0..31)
0009+  1A3C 3C          			INC		A								;Change to 1..32
0010+  1A3D 67          			LD		H,A
0011+  1A3E CD 6D 1A    			CALL	SENDSPCMDLC
0012+  1A41             
0013+  1A41             
0014+  1A41 06 31       			LD		B,49
0015+  1A43 2E 01       			LD		L,#01							;Allow receiving commands on boot
0016+  1A45 CD 6D 1A    			CALL	SENDSPCMDLC
0017+  1A48             
0018+  1A48 06 27       			LD		B,39							;Single command for asign reset to current slot
0019+  1A4A CD 84 1A    			CALL    SENDNRCMD						;Send command and return from there
0020+  1A4D             					
0021+  1A4D 06 2B       			LD		B,43							;Sw 2 behaviour
0022+  1A4F 2E 07       			LD		L,#07							;Enable as select ROM n + Reset + Enable & Unlock Commands
0023+  1A51 CD 6D 1A    			CALL	SENDSPCMDLC
0024+  1A54             
0025+  1A54 06 2A       			LD		B,42
0026+  1A56 21 00 01    			LD		HL,#0100						;Disable pause/dansnap in Multiply Menu
0027+  1A59 C3 6D 1A    			JP		SENDSPCMDLC						;Execute and return from there
0028+  1A5C             
0029+  1A5C             
0030+  1A5C             ;Launch set left button
0031+  1A5C             ReenableButtons: 	
0032+  1A5C 3A 94 7F    			LD		A,(DanSnap_Val)					;Pause / Dansnap slot (valid 2-32)
0033+  1A5F FE 02       			CP		2
0034+  1A61 D8          			RET		C								;Value below 2 is not valid, return
0035+  1A62 FE 21       			CP		33
0036+  1A64 D0          			RET		NC								;Value over 32 is not valid
0037+  1A65             ReenableButtonsA: 
0038+  1A65 06 2A       			LD		B,42							;Command Change button behaviour
0039+  1A67 67          			LD		H,A								;Data 1, bank of Pause / Dansnap
0040+  1A68 2E 02       			LD		L,2								;bits 0..2= 2 => Enable as ROM n + NMI + Enable Commands, bits 3..4=0 Short Click
0041+  1A6A C3 6D 1A    			JP		SENDSPCMDLC
0042+  1A6D             
0897   1A6D             showinfSE: 
0898   1A6D             
0899   1A6D             showinfHWB: 
0900   1A6D             		;Routines dan commands
0901   1A6D             		include "resources/dandanator_hw_90.asm"
0001+  1A6D             ;dandanator_hw_90 - Reduced versions of dandanator commands
0002+  1A6D             ;	using B for drift
0003+  1A6D             ;	using only HL as parameters
0004+  1A6D             ;	no other register is modified, Flags also not modified
0005+  1A6D             ; ----------------------------------------------------------------------------------------
0006+  1A6D             ; Send special command with long confirmation
0007+  1A6D             ; ----------------------------------------------------------------------------------------
0008+  1A6D CD 7C 1A    SENDSPCMDLC:  CALL SENDSPCMD
0009+  1A70             			 ;CALL LONGSPCONF
0010+  1A70             			 ;RET
0011+  1A70             
0012+  1A70             ; ----------------------------------------------------------------------------------------
0013+  1A70             ; Confirm Special Command and wait some ms ( > 5ms that PIC eeprom write operations require)
0014+  1A70             ; ----------------------------------------------------------------------------------------
0015+  1A70 32 00 00    LONGSPCONF: 	LD (0),A			; Signal Dandanator the command confirmation
0016+  1A73 06 00       			LD B,0					
0017+  1A75 E3          PAUSELCONF: 	EX (SP),HL
0018+  1A76 E3          			EX (SP),HL
0019+  1A77 E3          			EX (SP),HL
0020+  1A78 E3          			EX (SP),HL
0021+  1A79 10 FA       			DJNZ PAUSELCONF
0022+  1A7B C9          			RET
0023+  1A7C             ; ----------------------------------------------------------------------------------------
0024+  1A7C             
0025+  1A7C             ; ----------------------------------------------------------------------------------------
0026+  1A7C             
0027+  1A7C             ; ----------------------------------------------------------------------------------------
0028+  1A7C             ; Send Special Command to Dandanator - Sends Command (a), Data 1 (d) and Data 2 (e)- Prepare for Pulse
0029+  1A7C             ; Destroys HL, B.
0030+  1A7C             ; ----------------------------------------------------------------------------------------
0031+  1A7C             SENDSPCMD: 	
0032+  1A7C CD 84 1A    			CALL SENDNRCMD				; Send command 	
0033+  1A7F 44          			LD B,H						; Data 1
0034+  1A80 CD 84 1A    			CALL SENDNRCMD				; Send Data 1
0035+  1A83 45          			LD B,L						; Data 2
0036+  1A84             			;CALL SENDNRCMD				; Send Data 2
0037+  1A84             			;RET							; Now about 512us to confirm command with a pulse to DDNTRADDRCONF
0038+  1A84             ; ----------------------------------------------------------------------------------------
0039+  1A84             
0040+  1A84             ; ----------------------------------------------------------------------------------------
0041+  1A84             ; Send Normal Command to Dandanator - Sends Command/Data
0042+  1A84             ;     B  = Cmd/Data, H = Data 1, L = Data 2 
0043+  1A84             ; 	  Only touch B register (return with B=0). Flags unaffected
0044+  1A84             ; NOTE: 0 is signaled by 256 pulses
0045+  1A84             ; ----------------------------------------------------------------------------------------
0046+  1A84             SENDNRCMD: 	
0047+  1A84 23          .slot_b		INC HL
0048+  1A85 2B          			DEC HL
0049+  1A86 32 00 00    			LD (0),A
0050+  1A89 10 F9       			DJNZ .slot_b
0051+  1A8B             			
0052+  1A8B 06 40       			LD B, PAUSELOOPSN
0053+  1A8D 10 FE       .loop_b: 	DJNZ .loop_b
0054+  1A8F C9          			RET							; Will still take some time to perform actual slot change
0055+  1A90             ; ----------------------------------------------------------------------------------------
0056+  1A90             
0057+  1A90             
0902   1A90             showinfHWE: 
0903   1A90             
0904   1A90             showinfFB: 
0905   1A90             		include "resources/FiletypeTexts.asm"		;Additional text for Box
0001+  1A90             ;FiletypeTexts
0002+  1A90             
0003+  1A90             ;	Index 0x0C to 0x1D
0004+  1A90             ;
0005+  1A90             ;	1st index (1 byte)
0006+  1A90             ;	2nd pointer to related text
0007+  1A90             ;	Total: 3 bytes, also the size of text (variable, maximum 24 -small font 8x4-)
0008+  1A90             
0009+  1A90             ;Take care making this table... index byte have to be sorted, lower to upper !!!
0010+  1A90             
0011+  1A90             FileTypeTexts: 
0012+  1A90             ;	None of the below
0013+  1A90 0B          	defb	FT_DIRECTORY-1				;So if value < FT_DIRECTORY then it will be as None
0014+  1A91 D0 1A       	defw	FT_NONE
0015+  1A93             FileTypeTexts_Size	equ	$-FileTypeTexts
0016+  1A93             
0017+  1A93             ;	Folder
0018+  1A93 0C          	defb	FT_DIRECTORY
0019+  1A94 DC 1A       	defw	FT_DIRECTORY_text
0020+  1A96             
0021+  1A96             ;	SCREEN
0022+  1A96 10          	defb	FT_SCR
0023+  1A97 F0 1C       	defw	FT_SCR_text
0024+  1A99             
0025+  1A99             ;	Z80_16
0026+  1A99 11          	defb	FT_Z80_16K
0027+  1A9A 73 1B       	defw	FT_Z80_16K_text
0028+  1A9C             	
0029+  1A9C             ;	Z80_48
0030+  1A9C 12          	defb	FT_Z80_48K
0031+  1A9D BC 1B       	defw	FT_Z80_48K_text
0032+  1A9F             	
0033+  1A9F             ;	Z80_128
0034+  1A9F 13          	defb	FT_Z80_128K
0035+  1AA0 05 1C       	defw	FT_Z80_128K_text
0036+  1AA2             
0037+  1AA2             ;	SNA_48
0038+  1AA2 16          	defb	FT_SNA_48K
0039+  1AA3 4F 1C       	defw	FT_SNA_48K_text
0040+  1AA5             
0041+  1AA5             ;	SNA_48
0042+  1AA5 17          	defb	FT_SNA_128K
0043+  1AA6 9F 1C       	defw	FT_SNA_128K_text
0044+  1AA8             
0045+  1AA8             
0046+  1AA8             ;	TAP TAPE
0047+  1AA8 20          	defb	FT_TAP
0048+  1AA9 2D 1D       	defw	FT_TAP_text
0049+  1AAB             
0050+  1AAB             ;	BINARY
0051+  1AAB 28          	defb	FT_BINARY
0052+  1AAC 6A 1D       	defw	FT_BINARY_text
0053+  1AAE             
0054+  1AAE             
0055+  1AAE             ;	ROM
0056+  1AAE 30          	defb	FT_ROMSET	
0057+  1AAF 02 1B       	defw	FT_ROMSET_text
0058+  1AB1             
0059+  1AB1             ;	ROM
0060+  1AB1 31          	defb	FT_BASIC
0061+  1AB2 42 1B       	defw	FT_BASIC_text
0062+  1AB4             
0063+  1AB4             ;	None of the previous
0064+  1AB4 FF          	defb	#FF
0065+  1AB5 D0 1A       	defw	FT_NONE
0066+  1AB7             	
0067+  1AB7             ;Text strings.... each string ending with 0x00
0068+  1AB7             FT_EMPTY: 
0069+  1AB7             	defb	"                        ",0
0069+  1AB7 20202020202020202020202020202020202020202020202000
0070+  1AD0             FT_EMPTY_last: 	
0071+  1AD0             	
0072+  1AD0             FT_NONE: 
0073+  1AD0 2D 2D 2D 00 	defb	"---",0
0074+  1AD4 20 00       	defb	" ",0
0075+  1AD6 20 00       	defb	" ",0
0076+  1AD8 20 00       	defb	" ",0
0077+  1ADA 20 00       	defb	" ",0
0078+  1ADC             
0079+  1ADC             FT_DIRECTORY_text: 
0080+  1ADC             	defb	"FOLDER",0
0080+  1ADC 464F4C44455200
0081+  1AE3 20 00       	defb	" ",0
0082+  1AE5 20 00       	defb	" ",0
0083+  1AE7 20 00       	defb	" ",0
0084+  1AE9             	defb	"   ENTER or FIRE to OPEN",0
0084+  1AE9 202020454E544552206F72204649524520746F204F50454E00
0085+  1B02             	
0086+  1B02             FT_ROMSET_text: 
0087+  1B02             	defb	"ROM DANDANATOR",0
0087+  1B02 524F4D2044414E44414E41544F5200
0088+  1B11             FT_R_V: 
0089+  1B11             	defb	"Version:",0
0089+  1B11 56657273696F6E3A00
0090+  1B1A             FT_R_V2: 
0091+  1B1A             	defb	"     Games",0
0091+  1B1A 202020202047616D657300
0092+  1B25 20 00       	defb	" ",0		
0093+  1B27             FT_ROMSET_ENTER: 
0094+  1B27             	defb	" ENTER or FIRE for OPTIONS",0
0094+  1B27 20454E544552206F72204649524520666F72204F5054494F4E5300
0095+  1B42             
0096+  1B42             FT_BASIC_text: 
0097+  1B42             	defb	"Return to BASIC",0
0097+  1B42 52657475726E20746F20424153494300
0098+  1B52 20 00       	defb	" ",0
0099+  1B54 20 00       	defb	" ",0
0100+  1B56 20 00       	defb	" ",0
0101+  1B58             	defb	"   ENTER or FIRE for BASIC",0
0101+  1B58 202020454E544552206F72204649524520666F7220424153494300
0102+  1B73             
0103+  1B73             FT_Z80_16K_text: 
0104+  1B73             	defb	"GAME SNAPSHOT",0
0104+  1B73 47414D4520534E415053484F5400
0105+  1B81             	defb	"TYPE: Z80",0
0105+  1B81 545950453A205A383000
0106+  1B8B             	defb	"Size: 16k",0
0106+  1B8B 53697A653A2031366B00
0107+  1B95             FT_Z80_V: 
0108+  1B95             	defb	"Captured on: ",0
0108+  1B95 4361707475726564206F6E3A2000
0109+  1BA3             FT_Z80_V2: 
0110+  1BA3             	defb	"   ENTER or FIRE to PLAY",0
0110+  1BA3 202020454E544552206F72204649524520746F20504C415900
0111+  1BBC             	
0112+  1BBC             FT_Z80_48K_text: 
0113+  1BBC             	defb	"GAME SNAPSHOT",0
0113+  1BBC 47414D4520534E415053484F5400
0114+  1BCA             	defb	"TYPE: Z80",0
0114+  1BCA 545950453A205A383000
0115+  1BD4             	defb	"Size: 48k",0
0115+  1BD4 53697A653A2034386B00
0116+  1BDE             	defb	"Captured on: ",0
0116+  1BDE 4361707475726564206F6E3A2000
0117+  1BEC             	defb	"   ENTER or FIRE to PLAY",0
0117+  1BEC 202020454E544552206F72204649524520746F20504C415900
0118+  1C05             
0119+  1C05             FT_Z80_128K_text: 
0120+  1C05             	defb	"GAME SNAPSHOT",0
0120+  1C05 47414D4520534E415053484F5400
0121+  1C13             	defb	"TYPE: Z80",0
0121+  1C13 545950453A205A383000
0122+  1C1D             	defb	"Size: 128k",0
0122+  1C1D 53697A653A203132386B00
0123+  1C28             	defb	"Captured on: ",0
0123+  1C28 4361707475726564206F6E3A2000
0124+  1C36             	defb	"   ENTER or FIRE to PLAY",0
0124+  1C36 202020454E544552206F72204649524520746F20504C415900
0125+  1C4F             
0126+  1C4F             FT_SNA_48K_text: 
0127+  1C4F             	defb	"GAME SNAPSHOT",0
0127+  1C4F 47414D4520534E415053484F5400
0128+  1C5D             	defb	"TYPE: SNA",0
0128+  1C5D 545950453A20534E4100
0129+  1C67             	defb	"Size: 48k",0
0129+  1C67 53697A653A2034386B00
0130+  1C71             	defb	"Captured on: Unknown",0
0130+  1C71 4361707475726564206F6E3A20556E6B6E6F776E00
0131+  1C86             	defb	"   ENTER or FIRE to PLAY",0
0131+  1C86 202020454E544552206F72204649524520746F20504C415900
0132+  1C9F             
0133+  1C9F             FT_SNA_128K_text: 
0134+  1C9F             	defb	"GAME SNAPSHOT",0
0134+  1C9F 47414D4520534E415053484F5400
0135+  1CAD             	defb	"TYPE: SNA",0
0135+  1CAD 545950453A20534E4100
0136+  1CB7             	defb	"Size: 128k",0
0136+  1CB7 53697A653A203132386B00
0137+  1CC2             	defb	"Captured on: Unknown",0
0137+  1CC2 4361707475726564206F6E3A20556E6B6E6F776E00
0138+  1CD7             	defb	"   ENTER or FIRE to PLAY",0
0138+  1CD7 202020454E544552206F72204649524520746F20504C415900
0139+  1CF0             
0140+  1CF0             FT_SCR_text: 
0141+  1CF0             	defb	"SCREEN",0
0141+  1CF0 53435245454E00
0142+  1CF7             	defb	"TYPE: SCR",0
0142+  1CF7 545950453A2053435200
0143+  1D01             	defb	"Size: 6912 bytes",0
0143+  1D01 53697A653A203639313220627974657300
0144+  1D12 20 00       	defb	" ",0
0145+  1D14             	defb	"   ENTER or FIRE to VIEW",0
0145+  1D14 202020454E544552206F72204649524520746F205649455700
0146+  1D2D             
0147+  1D2D             FT_TAP_text: 
0148+  1D2D             	defb	"CASSETTE GAME",0
0148+  1D2D 43415353455454452047414D4500
0149+  1D3B             	defb	"Type: TAP",0
0149+  1D3B 547970653A2054415000
0150+  1D45 20 00       	defb	" ",0
0151+  1D47             FT_TAP_Program: 
0152+  1D47             	defb	" PROGRAM:",0			;xxx Entries
0152+  1D47 2050524F4752414D3A00
0153+  1D51             FT_TAP_Program2: 
0154+  1D51             	defb	"   ENTER or FIRE to PLAY",0
0154+  1D51 202020454E544552206F72204649524520746F20504C415900
0155+  1D6A             
0156+  1D6A             FT_BINARY_text: 
0157+  1D6A             	defb	"BINARY FILE",0
0157+  1D6A 42494E4152592046494C4500
0158+  1D76             	defb	"Size: xxxxx bytes",0	;Pendiente xxxxx cambiarlo por su tamao
0158+  1D76 53697A653A20787878787820627974657300
0159+  1D88 20 00       	defb	" ",0
0160+  1D8A 20 00       	defb	" ",0
0161+  1D8C             	defb	" ENTER or FIRE to pending",0
0161+  1D8C 20454E544552206F72204649524520746F2070656E64696E6700
0162+  1DA6             
0163+  1DA6             ;
0164+  1DA6             
0906   1DA6             showinfFE: 
0907   1DA6             
0908   1DA6             	DEFINE SHOWINF
0909   1DA6             
0910   1DA6             	IFDEF SHOWINF
0911   1DA6             		DISPLAY "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
0912   1DA6             		DISPLAY "loadroutines.asm: ",/A,LE-LB
0913   1DA6             		DISPLAY "dzx7_turbo.asm: ",/A,showinfdzxE-showinfdzxB
0914   1DA6             		DISPLAY "PathRoutines.asm: ",/A,PE-PB
0915   1DA6             		DISPLAY "Water_Effect.asm: ",/A,WE-WB
0916   1DA6             		DISPLAY "PreviewScreen.asm: ",/A,PEP-PBP
0917   1DA6             		DISPLAY "charset8x4.asm: ",/A,Charset8x4END-Charset8x4
0918   1DA6             		DISPLAY "IM2_routines.asm: ",/A,IME-IMB
0919   1DA6             		DISPLAY "IM2_routines Begin: ",IMB
0920   1DA6             		DISPLAY "IM2_routines End: ",IME
0921   1DA6             		DISPLAY "print.asm: ",/A,PEPR-PBPR
0922   1DA6             		DISPLAY "OtherTexts.asm: ",/A,OE-OB
0923   1DA6             		DISPLAY "Sorting.asm: ",/A,SES-SBS
0924   1DA6             		DISPLAY "SDRoutines.asm: ",/A,SE-SB
0925   1DA6             		DISPLAY "checkhardware.asm: ",/A,showinfHE-showinfHB
0926   1DA6             		DISPLAY "launchTAP.asm: ",/A,ldtapE-Load_FT_TAP
0927   1DA6             		DISPLAY "setbuttons.asm: ",/A,showinfSE-showinfSB
0928   1DA6             		DISPLAY "dandanator_hw_90.asm: ",/A,showinfHWE-showinfHWB
0929   1DA6             		DISPLAY "FiletypeTexts.asm: ",/A,showinfFE-showinfFB
0930   1DA6             		DISPLAY "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
0931   1DA6             		DISPLAY "FREE AREA #1000-2000: ",/A,#2000-$
0932   1DA6             		DISPLAY "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
0933   1DA6             	ENDIF
0934   1DA6             
0935   1DA6             	DISPLAY "Espacio libre: ",/A,#2000-$
0936   1DA6             
0937   1DA6 FF          			DEFS	#2000-$,#FF						;Scratch sector for final routines for launching (each launch uses 16 bytes)
0938   2000             ScratchSECT: 
0939   2000             
0940   2000 FF          			DEFS	#3000-$,#FF						;Data in last sector
0941   3000             
0942   3000             showinfKB: 
0943   3000             		;INT key routines
0944   3000             		include "resources/key_routines.asm"		;Routines for dealing with Keyboard/Joystick. 
0001+  3000             ;INT Key routine
0002+  3000             
0003+  3000             ;Check Joystick and keys. Store into (KeyToExe) if key pressed and if repeated only when
0004+  3000             ;		timing expired
0005+  3000             ; Value is	0 for no key pressed
0006+  3000             ;			5 for Right
0007+  3000             ;			4 for Left
0008+  3000             ;			3 for Down
0009+  3000             ;			2 for Up
0010+  3000             ;			1 for Fire
0011+  3000             
0012+  3000             ;ProcessKey - Read kempston joystick and keys and update bits in Kempston Style
0013+  3000             ProcessKey: 
0014+  3000 3A 43 9C    			LD		A,(CurKey)						;At this moment this really represent the previous value (not the current)
0015+  3003 32 42 9C    			LD		(LastKey),A						;Update last key pressed with previous value
0016+  3006             
0017+  3006 DB 1F       			IN		A,(#1F)							;Reading Kempston			
0018+  3008 E6 1F       			AND		%00011111						;Isolate Joy bits
0019+  300A 28 11       			JR		Z,NoJoy							;No Joy movement, continue with Keys
0020+  300C             		;Here for Any Joy movement... avoid multiple direction and/or fire combined, so let check in this precedence order: Left, Up, Right, Down, Fire
0021+  300C 21 83 30    			LD		HL,JoyTable
0022+  300F 47          			LD		B,A								;B=Bits for Joy (always value <>0)
0023+  3010             JoyTest: 
0024+  3010 7E          			LD		A,(HL)
0025+  3011 23          			INC		HL
0026+  3012 A0          			AND		B
0027+  3013 28 FB       			JR		Z,JoyTest						;If not this direction then maybe will be the next...always 1 of 5 meet
0028+  3015 FE 03       			CP		#03								;Check for Left+Right (Fire 2)
0029+  3017 20 18       			JR		NZ,KeyToJoy						;Jumping there A had only 1 bit activated (as A<>0 and A<>#03)
0030+  3019 3E 20       			LD		A,%00100000						;Fire2 like SPACE key is for going to ROOT
0031+  301B 18 14       			JR		KeyToJoy
0032+  301D             			
0033+  301D             NoJoy: 
0034+  301D 21 5E 30    			LD		HL,KeyTable
0035+  3020 0E FE       			LD		C,#FE							;BC=xxFE
0036+  3022             WaitForKeys_Loop: 
0037+  3022 46          			LD		B,(HL)							;Value xx for port to read key(s)
0038+  3023 23          			INC		HL
0039+  3024 ED 78       			IN		A,(C)
0040+  3026 B6          			OR		(HL)							;Isolate valid keys
0041+  3027 23          			INC		HL
0042+  3028 3C          			INC		A								;If valid key pressed then A<>0 after INC A
0043+  3029 7E          			LD		A,(HL)							;A=Code value as per Joystick (don't affect flags)
0044+  302A 23          			INC		HL								;Update HL for next time (don't affect flags)
0045+  302B 20 04       			JR		NZ,KeyToJoy						;Valid key pressed, jump there
0046+  302D             ;NoThisKey:
0047+  302D 7E          			LD		A,(HL)							;Next value xx for port
0048+  302E A7          			AND		A								;Check if 0 for end of testing
0049+  302F 20 F1       			JR		NZ,WaitForKeys_Loop				;No 0 still have to check
0050+  3031             		;Here with Z active if no key was pressed, Z inactive if joy/key was moved/pressed
0051+  3031             KeyToJoy: 
0052+  3031             		;Here with A=0 (no key) or bits 4,3,2,1,0 for directions/fire
0053+  3031             
0054+  3031 47          			LD		B,A								;Copy key pressed to B
0055+  3032 32 43 9C    			LD		(CurKey),A						;Update CurKey as Movement
0056+  3035 A7          			AND		A
0057+  3036 20 0A       			JR		NZ,TestKey						;any Key pressed jump there
0058+  3038             		;Here for no key pressed with A=0
0059+  3038             ReKey: 
0060+  3038 78          			LD		A,B								;Current key
0061+  3039 32 40 9C    			LD		(KeyToExe),A					;No key to process A=0
0062+  303C 3E 19       			LD		A,Time1Val						;Time 1st for repeating
0063+  303E 32 41 9C    			LD		(LastKeyTime),A					;Time for repeat
0064+  3041 C9          			RET
0065+  3042             			
0066+  3042             		;Key pressed, check if this is the 1st time or repeated or it's a different key
0067+  3042             TestKey: 
0068+  3042 3A 42 9C    			LD		A,(LastKey)						;Get LastKey so check if repeat or not
0069+  3045 B8          			CP		B
0070+  3046 20 F0       			JR		NZ,ReKey						;for different key... re-initialize time but also execute that key
0071+  3048             			
0072+  3048             Rep_Time: 
0073+  3048             		;Repeat Time countdown
0074+  3048 3A 41 9C    			LD		A,(LastKeyTime)					;Time for repeat
0075+  304B 3D          			DEC		A
0076+  304C 32 41 9C    			LD		(LastKeyTime),A					;decrease repeating time
0077+  304F 28 03       			JR		Z,Rep_Time_EXE					;Arriving to Zero execute
0078+  3051             	IF (1=0)
0079+  3051~            		;Added as pre-loading preview has "impact" with repeat key, if pre-loading repeat is decreased 2 times
0080+  3051~            			LD		A,(PreviewLoad)
0081+  3051~            			CP		PreviewSHOWING					;Check if PreviewStat was nn+1 so repeat time is the usual
0082+  3051~            			JR		Z,ToNoProc						;No loading preview time is the usual
0083+  3051~            			CP		1
0084+  3051~            			JR		NC,ToNoProc						;For value below 1: 0 or FF repeat time is the usual
0085+  3051~            		;pre-loading so repeat time is lowered to half time here
0086+  3051~            			LD		A,(LastKeyTime)
0087+  3051~            			DEC		A
0088+  3051~            			LD		(LastKeyTime),A					;decrease repeating time
0089+  3051~            			JR		Z,Rep_Time_EXE
0090+  3051~            ToNoProc: 
0091+  3051             	ENDIF
0092+  3051 AF          			XOR		A						 		;no process key
0093+  3052 18 06       			JR		End_Rep_Time
0094+  3054             		;Repeat Time expired.. repeat key
0095+  3054             Rep_Time_EXE: 
0096+  3054 3E 02       			LD		A,TimesVal
0097+  3056 32 41 9C    			LD		(LastKeyTime),A					;Repeating time for repetitions
0098+  3059 78          			LD		A,B
0099+  305A             End_Rep_Time: 
0100+  305A 32 40 9C    			LD		(KeyToExe),A					;Key to process
0101+  305D C9          			RET
0102+  305E             
0103+  305E             
0104+  305E             ;KeyTable - Table for Key-Joy correspondence
0105+  305E             ;	1st byte - High of Port xxFE. 1 key, or many kays of the row can be checked at a time
0106+  305E             ;	2nd byte - Mask for keys to test, 0=Test that key, 1=Key doesn't matter
0107+  305E             ;	3rd byte - Equivalent to Joystick value: Bit 0 for Right, 1 for Left, 2 for Down, 3 for Up, 4 for Fire
0108+  305E             ;		Table is revised so the 1st key detected that will be the key pressed ( precedence order Left, Up, Right, Down, Fire)
0109+  305E             KeyTable: 
0110+  305E             		;Scancodes for Left (Bit 1)
0111+  305E             		;	DEFB	#EF,%11101111,%00000010			;6 is like Joy LEFT (SJ1)
0112+  305E             		;	DEFB	#F7,%11111110,%00000010			;1 is like Joy LEFT (SJ2)
0113+  305E F7 EF 02    			DEFB	#F7,%11101111,%00000010			;5 is like Joy LEFT (Cursor)
0114+  3061             ;			DEFB	#FE,%11111110,%00000010			;CAPS is like Joy LEFT
0115+  3061 DF F5 02    			DEFB	#DF,%11110101,%00000010			;O, U  are like Joy LEFT
0116+  3064             		;Scancodes for UP (Bit 3)
0117+  3064             		;	DEFB	#EF,%11111101,%00001000			;9 is like Joy UP (SJ1)
0118+  3064             		;	DEFB	#F7,%11110111,%00001000			;4 is like Joy UP (SJ2)
0119+  3064 EF F7 08    			DEFB	#EF,%11110111,%00001000			;7 is like Joy UP (Cursor)
0120+  3067 FB E0 08    			DEFB	#FB,%11100000,%00001000			;QWERT are like Joy UP
0121+  306A             		;Scancodes for Right (Bit 0)
0122+  306A             		;	DEFB	#EF,%11110111,%00000001			;7 is like Joy RIGHT (SJ1) SJ is for Sinclair Joystick
0123+  306A             		;	DEFB	#F7,%11111101,%00000001			;2 is like Joy RIGHT (SJ2)
0124+  306A EF FB 01    			DEFB	#EF,%11111011,%00000001			;8 is like Joy RIGHT (Cursor)
0125+  306D 7F FD 01    			DEFB	#7F,%11111101,%00000001			;SYMBS is like Joy RIGHT
0126+  3070 DF FA 01    			DEFB	#DF,%11111010,%00000001			;P and I are like Joy RIGHT
0127+  3073             		;Scancodes for Down (Bit 2)
0128+  3073             		;	DEFB	#EF,%11111011,%00000100			;8 is like Joy DOWN (SJ1)
0129+  3073             		;	DEFB	#F7,%11111011,%00000100			;3 is like Joy DOWN (SJ2)
0130+  3073 EF EF 04    			DEFB	#EF,%11101111,%00000100			;6 is like Joy DOWN (Cursor)
0131+  3076 FD E0 04    			DEFB	#FD,%11100000,%00000100			;ASDFG are like Joy DOWN
0132+  3079             
0133+  3079 FE FE 02    			DEFB	#FE,%11111110,%00000010			;CAPS is like Joy LEFT
0134+  307C             
0135+  307C             		;Scancodes for FIRE (Bit 4)
0136+  307C             		;	DEFB	#EF,%11111110,%00010000			;0 is like Joy FIRE (SJ1)
0137+  307C             		;	DEFB	#F7,%11101111,%00010000			;5 is like Joy FIRE (SJ2)
0138+  307C BF FE 10    			DEFB	#BF,%11111110,%00010000			;ENTER is like Joy FIRE
0139+  307F             			
0140+  307F             		;Scancodes for ROOT (Bit 5)
0141+  307F 7F FE 20    			DEFB	#7F,%11111110,%00100000			;SPACE is for going to ROOT
0142+  3082             		;No more keys
0143+  3082 00          			DEFB	0	
0144+  3083             
0145+  3083             JoyTable: 
0146+  3083 03          			DEFB	%00000011						;Joy LEFT+RIGHT	0x03 (Fire 2)
0147+  3084             			;DEFB	%00000010						;Joy LEFT	0x02
0148+  3084 08          			DEFB	%00001000						;Joy UP		0x08
0149+  3085             			;DEFB	%00000001						;Joy RIGHT	0x01
0150+  3085 04          			DEFB	%00000100						;Joy DOWN	0x04
0151+  3086 10          			DEFB	%00010000						;Joy FIRE	0x10
0152+  3087 00          			DEFB	0								;No more moves to check			
0153+  3088             
0945   3088             showinfKE: 
0946   3088             
0947   3088             
0948   3088             showinfHTB: 
0949   3088             		include "resources/Hardware_table.asm"		;Hardware tables for Z80 snapshot as per v1/v2/v3
0001+  3088             ;Hardware_Tables
0002+  3088             
0003+  3088             HW_Table: 
0004+  3088 C2 30       	defw	HW_48k									;Index 0
0005+  308A C6 30       	defw	HW_48k_IF1								;Index 1
0006+  308C CE 30       	defw	SAMRAM									;Index 2
0007+  308E D5 30       	defw	HW_48k_MGT								;Index 3
0008+  3090 DD 30       	defw	HW_128k									;Index 4
0009+  3092 E2 30       	defw	HW_128k_IF1								;Index 5
0010+  3094 EB 30       	defw	HW_128k_MGT								;Index 6
0011+  3096 F4 30       	defw	HW_PLUS3								;Index 7
0012+  3098 F4 30       	defw	HW_PLUS3B								;Index 8
0013+  309A FC 30       	defw	HW_PENTAGON								;Index 9
0014+  309C 08 31       	defw	HW_SCORPION								;Index 10
0015+  309E 14 31       	defw	HW_DIDAKTIC								;Index 11
0016+  30A0 1D 31       	defw	HW_PLUS2								;Index 12
0017+  30A2 25 31       	defw	HW_PLUS2A								;Index 13
0018+  30A4 2E 31       	defw	HW_TC2048								;Index 14
0019+  30A6 3E 31       	defw	HW_TS2068								;Index 15
0020+  30A8             
0021+  30A8             ;table for "changed" machines
0022+  30A8 46 31       	defw	HW_16k									;Index 16
0023+  30AA 4A 31       	defw	HW_16k_IF1								;Index 17
0024+  30AC 52 31       	defw	SAMRAM16								;Index 18
0025+  30AE 5D 31       	defw	HW_16k_MGT								;Index 19
0026+  30B0 1D 31       	defw	HW_PLUS2								;Index 20
0027+  30B2 65 31       	defw	HW_PLUS2_IF1							;Index 21
0028+  30B4 71 31       	defw	HW_PLUS2_MGT							;Index 22
0029+  30B6 25 31       	defw	HW_PLUS2A								;Index 23
0030+  30B8 25 31       	defw	HW_PLUS2A								;Index 24
0031+  30BA             
0032+  30BA             HW_Unknown: 
0033+  30BA             	defb	"Unknown",0
0033+  30BA 556E6B6E6F776E00
0034+  30C2             
0035+  30C2             HW_48k: 
0036+  30C2 34 38 4B 00 	defb	"48K",0
0037+  30C6             	
0038+  30C6             HW_48k_IF1: 
0039+  30C6             	defb	"48K+IF1",0
0039+  30C6 34384B2B49463100
0040+  30CE             	
0041+  30CE             SAMRAM: 
0042+  30CE             	defb	"SamRam",0	
0042+  30CE 53616D52616D00
0043+  30D5             
0044+  30D5             HW_48k_MGT: 
0045+  30D5             	defb	"48K+MGT",0
0045+  30D5 34384B2B4D475400
0046+  30DD             
0047+  30DD             HW_128k: 
0048+  30DD 3132384B00  	defb	"128K",0
0049+  30E2             
0050+  30E2             HW_128k_IF1: 
0051+  30E2             	defb	"128K+IF1",0
0051+  30E2 3132384B2B49463100
0052+  30EB             
0053+  30EB             HW_128k_MGT: 
0054+  30EB             	defb	"128K+MGT",0
0054+  30EB 3132384B2B4D475400
0055+  30F4             
0056+  30F4             HW_PLUS3: 
0057+  30F4             HW_PLUS3B: 
0058+  30F4             	defb	"128K +3",0
0058+  30F4 3132384B202B3300
0059+  30FC             
0060+  30FC             HW_PENTAGON: 
0061+  30FC             	defb	"Pentagon128",0
0061+  30FC 50656E7461676F6E31323800
0062+  3108             	
0063+  3108             HW_SCORPION: 
0064+  3108             	defb	"Scorpion256",0	
0064+  3108 53636F7270696F6E32353600
0065+  3114             	
0066+  3114             HW_DIDAKTIC: 
0067+  3114             	defb	"Didaktic",0	
0067+  3114 446964616B74696300
0068+  311D             	
0069+  311D             HW_PLUS2: 
0070+  311D             	defb	"128K +2",0
0070+  311D 3132384B202B3200
0071+  3125             
0072+  3125             HW_PLUS2A: 
0073+  3125             	defb	"128K +2A",0
0073+  3125 3132384B202B324100
0074+  312E             
0075+  312E             HW_TC2048: 
0076+  312E             	defb	"TC 2048",0
0076+  312E 5443203230343800
0077+  3136             
0078+  3136             HW_TC2068: 
0079+  3136             	defb	"TC 2068",0
0079+  3136 5443203230363800
0080+  313E             
0081+  313E             HW_TS2068: 
0082+  313E             	defb	"TS 2068",0
0082+  313E 5453203230363800
0083+  3146             
0084+  3146             ;Extended machines (bit 7=1 for byte 0x25 and machine btw 0..8)
0085+  3146             HW_16k: 
0086+  3146 31 36 4B 00 	defb	"16K",0
0087+  314A             	
0088+  314A             HW_16k_IF1: 
0089+  314A             	defb	"16K+IF1",0
0089+  314A 31364B2B49463100
0090+  3152             	
0091+  3152             SAMRAM16: 
0092+  3152             	defb	"16k SamRam",0	
0092+  3152 31366B2053616D52616D00
0093+  315D             
0094+  315D             HW_16k_MGT: 
0095+  315D             	defb	"16K+MGT",0
0095+  315D 31364B2B4D475400
0096+  3165             
0097+  3165             HW_PLUS2_IF1: 
0098+  3165             	defb	"128K+2 +IF1",0
0098+  3165 3132384B2B32202B49463100
0099+  3171             
0100+  3171             HW_PLUS2_MGT: 
0101+  3171             	defb	"128K+2 +MGT",0
0101+  3171 3132384B2B32202B4D475400
0102+  317D             
0950   317D             showinfHTE: 
0951   317D             
0952   317D             showinfIB: 
0953   317D             		include "resources/iconos.asm"	;labels inside file
0001+  317D             ; Icons 
0002+  317D             ;	Index 0x0C to 0x1D
0003+  317D             ;
0004+  317D             ;	1st index (1 byte)
0005+  317D             ;	2nd Icon   (2 x 16 bytes), 4 for attributes -using 36 bytes-
0006+  317D             ;	3rd Thumbnail (1 x 8 bytes), 1 for Attribute - using 9 bytes-
0007+  317D             ;	Total: 46 bytes
0008+  317D             
0009+  317D             ;Take care making this table... index byte have to be sorted, lower to upper !!!
0010+  317D             
0011+  317D             Icons: 
0012+  317D             ;	Folder
0013+  317D 0C          	defb FT_DIRECTORY
0014+  317E             
0015+  317E             Icon16x16	equ	$-Icons			;Offset to Icon16x16
0016+  317E             	
0017+  317E             ;	.Folder
0018+  317E FF FF       	defb %11111111,%11111111 ; line 0
0019+  3180 C3 FF       	defb %11000011,%11111111 ; line 1
0020+  3182 BD FF       	defb %10111101,%11111111 ; line 2
0021+  3184 BC 01       	defb %10111100,%00000001 ; line 3
0022+  3186 BF FD       	defb %10111111,%11111101 ; line 4
0023+  3188 BF FD       	defb %10111111,%11111101 ; line 5
0024+  318A BF F9       	defb %10111111,%11111001 ; line 6
0025+  318C BF FD       	defb %10111111,%11111101 ; line 7
0026+  318E BF F9       	defb %10111111,%11111001 ; line 8
0027+  3190 BF FD       	defb %10111111,%11111101 ; line 9
0028+  3192 BF F9       	defb %10111111,%11111001 ; line 10
0029+  3194 BF F5       	defb %10111111,%11110101 ; line 11
0030+  3196 BF E9       	defb %10111111,%11101001 ; line 12
0031+  3198 BD 55       	defb %10111101,%01010101 ; line 13
0032+  319A 80 01       	defb %10000000,%00000001 ; line 14
0033+  319C FF FF       	defb %11111111,%11111111 ; line 15
0034+  319E             ;	.FolderAttributes
0035+  319E 45 45       	defb %01000101,%01000101 ; line 0
0036+  31A0 45 45       	defb %01000101,%01000101 ; line 1
0037+  31A2             
0038+  31A2             
0039+  31A2             Icon8x8		equ	$-Icons			;Offset to Icon8x8
0040+  31A2             
0041+  31A2             ;	.Folder_mini
0042+  31A2 00          	defb %00000000 ; line 0
0043+  31A3 70          	defb %01110000 ; line 1
0044+  31A4 70          	defb %01110000 ; line 2
0045+  31A5 7F          	defb %01111111 ; line 3
0046+  31A6 7F          	defb %01111111 ; line 4
0047+  31A7 7F          	defb %01111111 ; line 5
0048+  31A8 7F          	defb %01111111 ; line 6
0049+  31A9 7F          	defb %01111111 ; line 7
0050+  31AA             
0051+  31AA             ;	.Folder_miniAttributes
0052+  31AA 3C          	defb %00111100 ; line 0
0053+  31AB             
0054+  31AB             IconNext	equ	$-Icons			;Offset to Next Icon
0055+  31AB             
0056+  31AB             ;	SCR
0057+  31AB 10          	defb FT_SCR
0058+  31AC             
0059+  31AC             ;	.SCR
0060+  31AC 00 00       	defb %00000000,%00000000 ; line 0
0061+  31AE 7F FE       	defb %01111111,%11111110 ; line 1
0062+  31B0 40 02       	defb %01000000,%00000010 ; line 2
0063+  31B2 54 32       	defb %01010100,%00110010 ; line 3
0064+  31B4 4A 7A       	defb %01001010,%01111010 ; line 4
0065+  31B6 54 7A       	defb %01010100,%01111010 ; line 5
0066+  31B8 40 32       	defb %01000000,%00110010 ; line 6
0067+  31BA 40 02       	defb %01000000,%00000010 ; line 7
0068+  31BC 42 0A       	defb %01000010,%00001010 ; line 8
0069+  31BE 47 12       	defb %01000111,%00010010 ; line 9
0070+  31C0 4F 8A       	defb %01001111,%10001010 ; line 10
0071+  31C2 5F C2       	defb %01011111,%11000010 ; line 11
0072+  31C4 5F FA       	defb %01011111,%11111010 ; line 12
0073+  31C6 40 02       	defb %01000000,%00000010 ; line 13
0074+  31C8 7F FE       	defb %01111111,%11111110 ; line 14
0075+  31CA 00 00       	defb %00000000,%00000000 ; line 15
0076+  31CC             ;	.SCRAttributes
0077+  31CC 6B 6B       	defb %01101011,%01101011 ; line 0
0078+  31CE 6B 6B       	defb %01101011,%01101011 ; line 1
0079+  31D0             
0080+  31D0             
0081+  31D0             ;	.SCR_mini
0082+  31D0 00          	defb %00000000 ; line 0
0083+  31D1 7F          	defb %01111111 ; line 1
0084+  31D2 41          	defb %01000001 ; line 2
0085+  31D3 55          	defb %01010101 ; line 3
0086+  31D4 51          	defb %01010001 ; line 4
0087+  31D5 79          	defb %01111001 ; line 5
0088+  31D6 7F          	defb %01111111 ; line 6
0089+  31D7 7F          	defb %01111111 ; line 7
0090+  31D8             ;	.SCR_miniAttributes
0091+  31D8 3B          	defb %00111011 ; line 0
0092+  31D9             
0093+  31D9             
0094+  31D9             ;	SNA
0095+  31D9 17          	defb FT_SNA_128K
0096+  31DA             
0097+  31DA             ;	.SNA
0098+  31DA 00 00       	defb %00000000, %00000000
0099+  31DC 00 00       	defb %00000000, %00000000
0100+  31DE 1C 38       	defb %00011100, %00111000
0101+  31E0 77 FE       	defb %01110111, %11111110
0102+  31E2 5B FA       	defb %01011011, %11111010
0103+  31E4 77 FE       	defb %01110111, %11111110
0104+  31E6 1F F8       	defb %00011111, %11111000
0105+  31E8 77 FE       	defb %01110111, %11111110
0106+  31EA 5F FA       	defb %01011111, %11111010
0107+  31EC 77 FE       	defb %01110111, %11111110
0108+  31EE 1F F8       	defb %00011111, %11111000
0109+  31F0 7F FE       	defb %01111111, %11111110
0110+  31F2 5F FA       	defb %01011111, %11111010
0111+  31F4 7F FE       	defb %01111111, %11111110
0112+  31F6 1F F8       	defb %00011111, %11111000
0113+  31F8 00 00       	defb %00000000, %00000000
0114+  31FA             ;	.SNAAttributes
0115+  31FA 69 69       	defb %01101001, %01101001 ; line 0
0116+  31FC 69 69       	defb %01101001, %01101001 ; line 1
0117+  31FE             
0118+  31FE             ;	.SNA_mini
0119+  31FE 00          	defb %00000000 ; line 0
0120+  31FF 5D          	defb %01011101 ; line 1
0121+  3200 1C          	defb %00011100 ; line 2
0122+  3201 5D          	defb %01011101 ; line 3
0123+  3202 1C          	defb %00011100 ; line 4
0124+  3203 5D          	defb %01011101 ; line 5
0125+  3204 1C          	defb %00011100 ; line 6
0126+  3205 5D          	defb %01011101 ; line 7
0127+  3206             ;	.SNA_miniAttributes
0128+  3206 39          	defb %00111001
0129+  3207             
0130+  3207             ;	TAP
0131+  3207 20          	defb FT_TAP
0132+  3208             
0133+  3208             ;.TAP
0134+  3208             ; line based output of pixel data:
0135+  3208             
0136+  3208 00 00       	defb %00000000, %00000000
0137+  320A 00 00       	defb %00000000, %00000000
0138+  320C 00 00       	defb %00000000, %00000000
0139+  320E 00 00       	defb %00000000, %00000000
0140+  3210 00 00       	defb %00000000, %00000000
0141+  3212 7F FE       	defb %01111111, %11111110
0142+  3214 64 26       	defb %01100100, %00100110
0143+  3216 50 0A       	defb %01010000, %00001010
0144+  3218 4F F2       	defb %01001111, %11110010
0145+  321A 40 02       	defb %01000000, %00000010
0146+  321C 59 5A       	defb %01011001, %01011010
0147+  321E 5A 9A       	defb %01011010, %10011010
0148+  3220 40 02       	defb %01000000, %00000010
0149+  3222 40 02       	defb %01000000, %00000010
0150+  3224 7F FE       	defb %01111111, %11111110
0151+  3226 00 00       	defb %00000000, %00000000
0152+  3228             ;.TAPAttributes
0153+  3228 69 69       	defb %01101001, %01101001
0154+  322A 69 69       	defb %01101001, %01101001
0155+  322C             
0156+  322C             
0157+  322C             ;.TAP_mini
0158+  322C 00          	defb %00000000 ; line 0
0159+  322D 00          	defb %00000000 ; line 1
0160+  322E 7F          	defb %01111111 ; line 2
0161+  322F 5D          	defb %01011101 ; line 3
0162+  3230 41          	defb %01000001 ; line 4
0163+  3231 55          	defb %01010101 ; line 5
0164+  3232 41          	defb %01000001 ; line 6
0165+  3233 7F          	defb %01111111 ; line 7
0166+  3234             ;.TAP_miniAttributes
0167+  3234 39          	defb %00111001
0168+  3235             
0169+  3235             
0170+  3235             ;	BIN
0171+  3235 28          	defb FT_BINARY
0172+  3236             
0173+  3236             .BIN16x16
0174+  3236 00 00       	defb %00000000,%00000000 ; line 0
0175+  3238 7F FE       	defb %01111111,%11111110 ; line 1
0176+  323A 40 02       	defb %01000000,%00000010 ; line 2
0177+  323C 65 A2       	defb %01100101,%10100010 ; line 3
0178+  323E 45 A6       	defb %01000101,%10100110 ; line 4
0179+  3240 65 A2       	defb %01100101,%10100010 ; line 5
0180+  3242 40 06       	defb %01000000,%00000110 ; line 6
0181+  3244 60 02       	defb %01100000,%00000010 ; line 7
0182+  3246 40 06       	defb %01000000,%00000110 ; line 8
0183+  3248 6D 92       	defb %01101101,%10010010 ; line 9
0184+  324A 4D 96       	defb %01001101,%10010110 ; line 10
0185+  324C 6D 92       	defb %01101101,%10010010 ; line 11
0186+  324E 40 06       	defb %01000000,%00000110 ; line 12
0187+  3250 40 02       	defb %01000000,%00000010 ; line 13
0188+  3252 7F FE       	defb %01111111,%11111110 ; line 14
0189+  3254 00 00       	defb %00000000,%00000000 ; line 15
0190+  3256             ;.BINAttributes
0191+  3256 6A 6A       	defb %01101010,%01101010 ; line 0
0192+  3258 6A 6A       	defb %01101010,%01101010 ; line 1
0193+  325A             
0194+  325A             
0195+  325A             ;.BIN_mini
0196+  325A 00          	defb %00000000 ; line 0
0197+  325B 7F          	defb %01111111 ; line 1
0198+  325C 2A          	defb %00101010 ; line 2
0199+  325D 6B          	defb %01101011 ; line 3
0200+  325E 3E          	defb %00111110 ; line 4
0201+  325F 6B          	defb %01101011 ; line 5
0202+  3260 2A          	defb %00101010 ; line 6
0203+  3261 7F          	defb %01111111 ; line 7
0204+  3262             ;.BIN_miniAttributes
0205+  3262 0F          	defb %00001111 ; line 0
0206+  3263             
0207+  3263             
0208+  3263             ;	ROM
0209+  3263 30          	defb FT_ROMSET
0210+  3264             
0211+  3264             ;	.ROM
0212+  3264 00 00       	defb %00000000,%00000000 ; line 0
0213+  3266 3F FC       	defb %00111111,%11111100 ; line 1
0214+  3268 4F FE       	defb %01001111,%11111110 ; line 2
0215+  326A 5C 7E       	defb %01011100,%01111110 ; line 3
0216+  326C 7C BE       	defb %01111100,%10111110 ; line 4
0217+  326E 5C DE       	defb %01011100,%11011110 ; line 5
0218+  3270 7C DE       	defb %01111100,%11011110 ; line 6
0219+  3272 7C BE       	defb %01111100,%10111110 ; line 7
0220+  3274 7C 7E       	defb %01111100,%01111110 ; line 8
0221+  3276 7F FE       	defb %01111111,%11111110 ; line 9
0222+  3278 3F FC       	defb %00111111,%11111100 ; line 10
0223+  327A 00 00       	defb %00000000,%00000000 ; line 11
0224+  327C 1F F8       	defb %00011111,%11111000 ; line 12
0225+  327E 1F F8       	defb %00011111,%11111000 ; line 13
0226+  3280 1F F8       	defb %00011111,%11111000 ; line 14
0227+  3282 00 00       	defb %00000000,%00000000 ; line 15
0228+  3284             ;	.ROMAttributes
0229+  3284 6A 6A       	defb %01101010,%01101010 ; line 0
0230+  3286 6A 6A       	defb %01101010,%01101010 ; line 1
0231+  3288             
0232+  3288             
0233+  3288             ;	.ROM_mini
0234+  3288 00          	defb %00000000 ; line 0
0235+  3289 7F          	defb %01111111 ; line 1
0236+  328A 67          	defb %01100111 ; line 2
0237+  328B 6B          	defb %01101011 ; line 3
0238+  328C 67          	defb %01100111 ; line 4
0239+  328D 7F          	defb %01111111 ; line 5
0240+  328E 00          	defb %00000000 ; line 6
0241+  328F 3E          	defb %00111110 ; line 7
0242+  3290             ;	.ROM_miniAttributes
0243+  3290 3A          	defb %00111010 ; line 0
0244+  3291             
0245+  3291             ;	BASIC
0246+  3291 31          	defb FT_BASIC
0247+  3292             
0248+  3292             ;	.BASIC
0249+  3292 FF 00       	defb %11111111,%00000000 ; line 0
0250+  3294 FF 00       	defb %11111111,%00000000 ; line 1
0251+  3296 FF 00       	defb %11111111,%00000000 ; line 2
0252+  3298 FF 00       	defb %11111111,%00000000 ; line 3
0253+  329A F8 38       	defb %11111000,%00111000 ; line 4
0254+  329C F1 70       	defb %11110001,%01110000 ; line 5
0255+  329E E3 E0       	defb %11100011,%11100000 ; line 6
0256+  32A0 FF 00       	defb %11111111,%00000000 ; line 7
0257+  32A2 F8 C7       	defb %11111000,%11000111 ; line 8
0258+  32A4 F1 8F       	defb %11110001,%10001111 ; line 9
0259+  32A6 E3 1F       	defb %11100011,%00011111 ; line 10
0260+  32A8 FF FF       	defb %11111111,%11111111 ; line 11
0261+  32AA FF 16       	defb %11111111,%00010110 ; line 12
0262+  32AC FF 99       	defb %11111111,%10011001 ; line 13
0263+  32AE FF 79       	defb %11111111,%01111001 ; line 14
0264+  32B0 FF 16       	defb %11111111,%00010110 ; line 15
0265+  32B2             ;	.BASICAttributes
0266+  32B2 55 6E       	defb %01010101,%01101110 ; line 0
0267+  32B4 65 4D       	defb %01100101,%01001101 ; line 1
0268+  32B6             
0269+  32B6             ;	.BASIC_mini
0270+  32B6 E9          	defb %11101001 ; line 0
0271+  32B7 66          	defb %01100110 ; line 1
0272+  32B8 86          	defb %10000110 ; line 2
0273+  32B9 E9          	defb %11101001 ; line 3
0274+  32BA 00          	defb %00000000 ; line 4
0275+  32BB 6D          	defb %01101101 ; line 5
0276+  32BC DB          	defb %11011011 ; line 6
0277+  32BD B6          	defb %10110110 ; line 7
0278+  32BE             ;	.BASIC_miniAttributes
0279+  32BE 3A          	defb %00111010 ; line 0
0280+  32BF             
0954   32BF             showinfIE: 
0955   32BF             				
0956   32BF             showinf4bB: 
0957   32BF             		include "resources/4bits_load_relocatable.asm"
0001+  32BF             
0002+  32BF             		DEFINE NEWVERS			;Comment for Old Load4bitBlk version, uncomment for NEW version
0003+  32BF             
0004+  32BF             	
0005+  32BF             ;------------------------------------------------------------------------------------------------------------------------
0006+  32BF             ; Load 4bits block of data at address specified by HL, DE contains size
0007+  32BF             ;  IN HL:Beginning address to store data
0008+  32BF             ;  IN DE:Length of data to read
0009+  32BF             ;
0010+  32BF             ;	OUT HL:Beging address + Length
0011+  32BF             ;	OUT DE:0
0012+  32BF             ;	OUT A:0
0013+  32BF             ;	OUT Flags modified... Z=activated always
0014+  32BF             ;------------------------------------------------------------------------------------------------------------------------
0015+  32BF             ;Here for waiting a "1" to start / process next bit
0016+  32BF             	IFDEF NEWVERS
0017+  32BF             Load4bitBlk: 
0018+  32BF             
0019+  32BF 2B          		DEC HL
0020+  32C0             LoopByte: 
0021+  32C0             
0022+  32C0             LoopFor1: 
0023+  32C0 DB 1F       		IN		A,(#1F)				;11 Ts
0024+  32C2 1F          		RRA							;4 Ts - bit 0 to carry, load value shifted to bits 3,2,1,0
0025+  32C3 30 FB       		JR		NC,LoopFor1		;12/7 Ts - 1st nibble have always bit0=1
0026+  32C5             
0027+  32C5             EndLoopFor1: 
0028+  32C5 23          		INC		HL					;6 Ts
0029+  32C6 1B          		DEC		DE					;6 Ts
0030+  32C7 77          		LD (HL),A					;7 Ts - RLD							;18 Ts - Move LOW nibble of A (really is the HIGH nibble we need)  to (HL) into LOW nibble
0031+  32C8             
0032+  32C8             
0033+  32C8             LoopFor0: 
0034+  32C8 DB 1F       		IN		A,(#1F)				;11 Ts
0035+  32CA 1F          		RRA							;4 Ts - bit 0 to carry, load value shifted to bits 3,2,1,0
0036+  32CB 38 FB       		JR		C,LoopFor0			;12/7 Ts - 2nd nibble have always bit0=0
0037+  32CD             
0038+  32CD             EndLoopFor0: 
0039+  32CD ED 6F       		RLD							;18 Ts - Move LOW nibble to (HL) into LOW nibble, previous LOW nibble in (HL) goes to HIGH nibble in (HL)
0040+  32CF 7A          		LD		A,D					;4 Ts
0041+  32D0 B3          		OR		E					;4 Ts
0042+  32D1 20 ED       		JR		NZ,LoopByte			;12 Ts
0043+  32D3 C9          		RET								;Return with Z active
0044+  32D4             		
0045+  32D4             	ELSE
0046+  32D4~            Load4bitBlk: 
0047+  32D4~            		DEC HL
0048+  32D4~            trans_1: 
0049+  32D4~            		IN    A,(#1F)          ; 11 Ts = 3,142857143 uS    %XXX3210F
0050+  32D4~            		RRCA               ;  4 Ts = 1,142857143 uS  F goes to carry  %XXXX3210
0051+  32D4~            		JR NC,trans_1           ; 12 Ts = 3,428571429 uS (if met) // 7 Ts = 2 uS (not met)
0052+  32D4~            		.4 RRCA               ; 12 Ts = 3,428571429 uS    %3210FXXX
0053+  32D4~            		AND #F0              ;  7 Ts = 2           uS  %3210____
0054+  32D4~            		LD    B,A            ;  4 Ts = 1,142857143 uS  %3210____
0055+  32D4~            		INC HL               ;  6 Ts = 1,714285714 uS
0056+  32D4~            		DEC DE              ;  6 Ts = 1,714285714 uS
0057+  32D4~            0058+  32D4~            ;Here for waiting a "0" to process next bit
0059+  32D4~            trans_0: 
0060+  32D4~            		IN     A,(#1F)         ; 11 Ts = 3,142857143 uS    %XXX3210F
0061+  32D4~            		RRCA               ;  4 Ts = 1,142857143 uS  %____3210
0062+  32D4~            		JR C,trans_0           ; 12 Ts = 3,428571429 uS (if met) // 7 Ts = 2 uS (not met)
0063+  32D4~            		AND    #0F            ;  7 Ts = 2           uS  %____3210
0064+  32D4~            		OR    B            ;  4 Ts = 1,142857143 uS
0065+  32D4~            		LD (HL),A            ;  7 Ts = 2           uS   Final value
0066+  32D4~            		LD A,D               ;  4 Ts = 1,142857143 uS
0067+  32D4~            		OR E               ;  4 Ts = 1,142857143 uS
0068+  32D4~            		JR NZ,trans_1           ; 12 Ts = 3,428571429 uS (if met) // 7 Ts = 2 uS (not met)
0069+  32D4~              
0070+  32D4~            		RET
0071+  32D4             	ENDIF
0072+  32D4             ;------------------------------------------------------------------------------------------------------------------------
0073+  32D4             
0074+  32D4             	IF	(1=0)		;ROUTINE DISABLED, NOT USED
0075+  32D4~            ;------------------------------------------------------------------------------------------------------------------------
0076+  32D4~            ; Request a file Name pointed by HL. Must end in 0
0077+  32D4~            ;	IN - HL : Pointer to Name of file or Data to pass to command
0078+  32D4~            ;	IN - A : command for requesting file
0079+  32D4~            ;
0080+  32D4~            ;	OUT - HL : Next position after filename, (the address of the #00 after the text)
0081+  32D4~            ;	OUT - A : #00
0082+  32D4~            ;	OUT - Flags modified, Z=1 always
0083+  32D4~            ;
0084+  32D4~            ;------------------------------------------------------------------------------------------------------------------------
0085+  32D4~            ReqFileA: 
0086+  32D4~            		DAN_BIG_COMMAND_NOW DANCMD_MULTIPLY, DANDAT_MULTIPLY, A
0087+  32D4~            		PAUSE_LONG
0088+  32D4~            		AND		A
0089+  32D4~            		RET		Z
0090+  32D4~            		LD		A,(HL)
0091+  32D4~            		INC		HL
0092+  32D4~                    JR      ReqFileA
0093+  32D4             	ENDIF			;ROUTINE DISABLED, NOT USED
0094+  32D4             
0095+  32D4             ;------------------------------------------------------------------------------------------------------------------------
0096+  32D4             
0097+  32D4             
0098+  32D4             ;------------------------------------------------------------------------------------------------------------------------
0099+  32D4             ; Send a Serial Byte contained in A, with Long Confirmation. (Command DANCMD_MULTIPLY,DANDAT_MULTIPLY,A)
0100+  32D4             ;	IN - A : Value to send to serial
0101+  32D4             ;
0102+  32D4             ;	OUT - B: 0
0103+  32D4             ;	OUT - A: same value as input
0104+  32D4             ;	Flags are not affected, same value as input
0105+  32D4             ;	Equivalent to SENDSPCMDLC
0106+  32D4             ;------------------------------------------------------------------------------------------------------------------------
0107+  32D4             SendSerByteLC: 
0108+  32D4             ;        LD      E,A
0109+  32D4             ;        LD      A,DANCMD_MULTIPLY
0110+  32D4             ;        LD      D,DANDAT_MULTIPLY
0111+  32D4             ;        JP		SENDSPCMDLC
0112+  32D4             		DAN_BIG_COMMAND_NOW DANCMD_MULTIPLY, DANDAT_MULTIPLY, A
0112+  32D4 06 34       >			LD	B,C1			; Command
0112+  32D6 23          >.slot_b		INC HL
0112+  32D7 2B          >			DEC HL
0112+  32D8 32 00 00    >			LD (0),A
0112+  32DB 10 F9       >			DJNZ .slot_b
0112+  32DD 06 40       >			LD B,value
0112+  32DF 10 FE       >.wait_b0	DJNZ .wait_b0
0112+  32E1 06 01       >			LD	B,C2			; Data 1
0112+  32E3 23          >.slot_b		INC HL
0112+  32E4 2B          >			DEC HL
0112+  32E5 32 00 00    >			LD (0),A
0112+  32E8 10 F9       >			DJNZ .slot_b
0112+  32EA 06 40       >			LD B,value
0112+  32EC 10 FE       >.wait_b0	DJNZ .wait_b0
0112+  32EE 47          >			LD  B,C3			; Data 2
0112+  32EF 23          >.slot_b		INC HL
0112+  32F0 2B          >			DEC HL
0112+  32F1 32 00 00    >			LD (0),A
0112+  32F4 10 F9       >			DJNZ .slot_b
0112+  32F6 06 40       >			LD B,value
0112+  32F8 10 FE       >.wait_b0	DJNZ .wait_b0
0112+  32FA 32 00 00    >			LD 	(0),A
0113+  32FD             		PAUSE_LONG
0113+  32FD E3          >.pauselong: 	EX (SP),HL
0113+  32FE E3          >			EX (SP),HL
0113+  32FF E3          >			EX (SP),HL
0113+  3300 E3          >			EX (SP),HL
0113+  3301 10 FA       >			DJNZ .pauselong
0114+  3303 C9          		RET 
0115+  3304             		
0116+  3304             ;------------------------------------------------------------------------------------------------------------------------
0117+  3304             ; Send a Serial Byte contained in A with Short Confirmation. (Command DANCMD_MULTIPLY,DANDAT_MULTIPLY,A)
0118+  3304             ;	IN - A : Value to send to serial
0119+  3304             ;
0120+  3304             ;	OUT - B: 0
0121+  3304             ;	OUT - A: same value as input
0122+  3304             ;	Flags are not affected, same value as input
0123+  3304             ;
0124+  3304             ; ---- This is equivalente to CALL SENDSPCMD with A=DANCMD_MULTIPLY, D=DANDAT_MULTIPLY, E=register A
0125+  3304             ;------------------------------------------------------------------------------------------------------------------------
0126+  3304             SendSerByte: 
0127+  3304             		DAN_BIG_COMMAND_NOW DANCMD_MULTIPLY, DANDAT_MULTIPLY, A
0127+  3304 06 34       >			LD	B,C1			; Command
0127+  3306 23          >.slot_b		INC HL
0127+  3307 2B          >			DEC HL
0127+  3308 32 00 00    >			LD (0),A
0127+  330B 10 F9       >			DJNZ .slot_b
0127+  330D 06 40       >			LD B,value
0127+  330F 10 FE       >.wait_b0	DJNZ .wait_b0
0127+  3311 06 01       >			LD	B,C2			; Data 1
0127+  3313 23          >.slot_b		INC HL
0127+  3314 2B          >			DEC HL
0127+  3315 32 00 00    >			LD (0),A
0127+  3318 10 F9       >			DJNZ .slot_b
0127+  331A 06 40       >			LD B,value
0127+  331C 10 FE       >.wait_b0	DJNZ .wait_b0
0127+  331E 47          >			LD  B,C3			; Data 2
0127+  331F 23          >.slot_b		INC HL
0127+  3320 2B          >			DEC HL
0127+  3321 32 00 00    >			LD (0),A
0127+  3324 10 F9       >			DJNZ .slot_b
0127+  3326 06 40       >			LD B,value
0127+  3328 10 FE       >.wait_b0	DJNZ .wait_b0
0127+  332A 32 00 00    >			LD 	(0),A
0128+  332D C9          		RET
0129+  332E             
0130+  332E             	IF	(1=0)		;ROUTINE DISABLED, NOT USED
0131+  332E~            ;------------------------------------------------------------------------------------------------------------------------
0132+  332E~            ; Common routine for send a Serial Byte contained in A, without confirmation. (Command DANCMD_MULTIPLY,DANDAT_MULTIPLY,A)
0133+  332E~            ;	IN - A : Value to send to serial
0134+  332E~            ;
0135+  332E~            ;	OUT - B: 0
0136+  332E~            ;	OUT - A: same value as input
0137+  332E~            ;	Flags are not affected, same value as input
0138+  332E~            ;------------------------------------------------------------------------------------------------------------------------
0139+  332E~            SendSerCMD: 
0140+  332E~            		LD	B,DANCMD_MULTIPLY
0141+  332E~            		SLOT_B
0142+  332E~            		WAIT_B PAUSELOOPSN
0143+  332E~            		LD  B,DANDAT_MULTIPLY
0144+  332E~            		SLOT_B
0145+  332E~            		WAIT_B PAUSELOOPSN
0146+  332E~            		LD  B,A
0147+  332E~            ;		JR SendCMD_B	;not required as SendCMD_B is just next address
0148+  332E~            0149+  332E~            0150+  332E~            ;------------------------------------------------------------------------------------------------------------------------
0151+  332E~            ; Send command using only B register and don't affects to Flags
0152+  332E~            ;	IN - B : Value to send as command or data to Dandanator
0153+  332E~            ;	OUT - B : 0
0154+  332E~            ;------------------------------------------------------------------------------------------------------------------------
0155+  332E~            SendCMD_B: 
0156+  332E~            		SLOT_B
0157+  332E~            		WAIT_B PAUSELOOPSN
0158+  332E~            		RET
0159+  332E~            0160+  332E~            ;------------------------------------------------------------------------------------------------------------------------
0161+  332E             	ENDIF				;ROUTINE DISABLED, NOT USED
0162+  332E             	
0163+  332E             EndLoad4bitBlk: 
0164+  332E             
0165+  332E             
0958   332E             showinf4bE: 
0959   332E             
0960   332E             showinfEEB: 
0961   332E             
0962   332E             Load_FT_ROMSET: 
0963   332E 2A 39 DD    			LD		HL,(Rom2Write)					;Address of romset info to write
0964   3331             		include "resources/Multiply_eewriter.asm"
0001+  3331             ;Mult_eewriter.asm
0002+  3331             ; Routines for writing to eeprom from Multiply
0003+  3331             
0004+  3331             J5555			EQU $1555				; Jedec $5555 with a15,a14=0 to force rom write (PIC will set page 1 so final address will be $5555)
0005+  3331             J2AAA			EQU	$2AAA				; Jedec $2AAA, Pic will select page 0
0006+  3331             
0007+  3331 F3          			DI
0008+  3332 31 00 00    			LD SP,$0000					; Set Stack to Ramtop
0009+  3335             						
0010+  3335 E5          			PUSH	HL					;Save address of filename
0011+  3336             	
0012+  3336 AF          			XOR A
0013+  3337 D3 FE       			OUT ($FE),A
0014+  3339             
0015+  3339 21 51 36    			LD		HL,eew_scr
0016+  333C 11 00 40    			LD		DE,#4000
0017+  333F CD 88 09    			CALL	dzx7_turbo
0018+  3342             
0019+  3342 21 58 33    			LD HL, ROMROUTINE
0020+  3345 11 00 F0    			LD DE, RAMROUTINE
0021+  3348 01 F9 02    			LD BC, ENDROMROUTINE-ROMROUTINE
0022+  334B ED B0       			LDIR
0023+  334D 21 BF 32    			LD HL,Load4bitBlk
0024+  3350             			;LD DE,ENDROMROUTINE
0025+  3350 01 6F 00    			LD	BC,EndLoad4bitBlk-Load4bitBlk
0026+  3353 ED B0       			LDIR
0027+  3355 C3 2D F0    			JP CHECKROMOK
0028+  3358             			
0029+  3358             ROMROUTINE: 			
0030+  3358             	DISP #F000
0031+  F000             RAMROUTINE: 			
0032+  F000 3E 47       TOSBOMB: 	LD A, $47					; Bright White on paper 0
0033+  F002 06 06       			LD B, 6						; 6 chars in TOSBOMB Graphic 
0034+  F004 DD 21 27 F0 			LD IX, TBPOS
0035+  F008 21 00 58    			LD HL, $4000+$1800			; Attributes on Screen for TOSBOMB
0036+  F00B 16 00       			LD D,0
0037+  F00D DD 5E 00    PAINTTB: 	LD E, (IX)					; Get offset
0038+  F010 19          			ADD HL,DE					; Move HL to Attr position
0039+  F011 77          			LD (HL),A					; Change TOSBOMB Color
0040+  F012 DD 23       			INC IX						; Next icon offset
0041+  F014 10 F7       			DJNZ PAINTTB				; Loop
0042+  F016 3E 46       			LD A,%01000110				; Wick Bright yellow
0043+  F018             TBDLOCK: 	
0044+  F018 32 41 58    			LD (TOSBOMBATTR),A			; Change attribute to A colour
0045+  F01B 01 40 00    			LD BC,64
0046+  F01E             WAIT50ms: 
0047+  F01E 10 FE       			DJNZ WAIT50ms
0048+  F020 0D          			DEC C
0049+  F021 20 FB       			JR NZ,WAIT50ms
0050+  F023 EE 04       			XOR %00000100				; alternate yellow (110) with red (010)
0051+  F025 18 F1       			JR TBDLOCK					; Deadlock		
0052+  F027             TBPOS: 		DEFB	$41,$1,$1F,$1,$1,$1F; TOSBOMB attr relative position			
0052+  F027 41011F01011F
0053+  F02D             TOSBOMBATTR		equ		$5800+(2*32)+1	; Attribute of bomb's wick
0054+  F02D             
0055+  F02D             
0056+  F02D             CHECKROMOK: 								; Dandanator was detected and it's now ready to receive 
0057+  F02D             			;LD HL,1						; Select slot 0 and set it as reset slot
0058+  F02D             			
0059+  F02D 06 01       			LD B,1						;LD A,1	- Set slot 1 (required any EEP slot for correct programming)
0060+  F02F             			SENDNRCMD_B PAUSELOOPSN		;CALL SENDNRCMD
0060+  F02F 23          >.slot_b		INC HL
0060+  F030 2B          >			DEC HL
0060+  F031 32 00 00    >			LD (0),A
0060+  F034 10 F9       >			DJNZ .slot_b
0060+  F036 06 40       >			LD B,value
0060+  F038 10 FE       >.wait_b0	DJNZ .wait_b0
0061+  F03A             
0062+  F03A 06 27       			LD B,39						;LD A,39	- CMD_SET_RESETSLOT - Set Reset Slot. Current Slot is selected in case of an Spectrum-Triggered Reset.
0063+  F03C             			SENDNRCMD_B PAUSELOOPSN		;CALL SENDNRCMD
0063+  F03C 23          >.slot_b		INC HL
0063+  F03D 2B          >			DEC HL
0063+  F03E 32 00 00    >			LD (0),A
0063+  F041 10 F9       >			DJNZ .slot_b
0063+  F043 06 40       >			LD B,value
0063+  F045 10 FE       >.wait_b0	DJNZ .wait_b0
0064+  F047             			
0065+  F047 3E 01       			LD A,1
0066+  F049 32 D8 F0    			LD (NBLOCK),A
0067+  F04C             
0068+  F04C             			;LD A,CMD_ZX2SD_OFREAD
0069+  F04C             
0070+  F04C             			;POP	HL						; address of filename
0071+  F04C DD E1       			POP	IX						; address of filename
0072+  F04E             
0073+  F04E             			;LD HL, romset
0074+  F04E             			;CALL	RAMReqFileA			;	CALL ReqFileA
0075+  F04E             			
0076+  F04E 3E 09       			LD		A,CMD_ZX2SD_OFREAD_IX				;Command = Open File (Relative Path)
0077+  F050 CD 0E F3    			CALL	RAMSendSerByteLC					;Command to ask for more info about file
0078+  F053 DD 7E 20    			LD		A,(IX+32)							;1st byte of index
0079+  F056 CD 0E F3    			CALL	RAMSendSerByteLC					;Command to ask for more info about file
0080+  F059 DD 7E 21    			LD		A,(IX+33)							;2nd byte of index
0081+  F05C CD 0E F3    			CALL	RAMSendSerByteLC					;Command to ask for more info about file
0082+  F05F             			
0083+  F05F             BUC: 
0084+  F05F 3A D8 F0    			LD A,(NBLOCK)
0085+  F062 CD 0D F1    			CALL DISPADVANCE			;Show advance arrow
0086+  F065 3A D8 F0    			LD A,(NBLOCK)
0087+  F068 CD 8B F1    			CALL DISPDIGIT				; Show number of block processing (1..16)
0088+  F06B 3D          			DEC A						; A=0..15
0089+  F06C 87          			ADD A,A						;A*2
0090+  F06D 87          			ADD A,A						;A*4
0091+  F06E 87          			ADD A,A						;A*8
0092+  F06F 0E 01       			LD C,1						; 1 = LOADING, A = N.SECTOR
0093+  F071 06 08       			LD B,8
0094+  F073             BUCLOAD8: 
0095+  F073 CD 46 F1    			CALL DISPBAR				; DISPBAR returns with A=SECTOR Num (BC returns untouched PUSH-POP)
0096+  F076 3C          			INC A
0097+  F077 10 FA       			DJNZ BUCLOAD8
0098+  F079             			
0099+  F079             			
0100+  F079 3E 30       			LD A, CMD_ZX2SD_ROMSETBLK4B			; Command of request SD block
0101+  F07B D3 FE       			OUT (#FE),A
0102+  F07D CD 0E F3    		    CALL RAMSendSerByteLC		;CALL SendSerByteLC
0103+  F080 3A D8 F0    			LD A,(NBLOCK)
0104+  F083 CD 3E F3    			CALL RAMSendSerByte			;CALL SendSerByte			; Request Serial Block
0105+  F086             
0106+  F086 3E 01       			LD  A,1
0107+  F088 D3 FE       			OUT (#FE),A
0108+  F08A             
0109+  F08A 21 FD 6E    			LD HL,loadarea				; Destination of data 
0110+  F08D 11 03 80    			LD DE,loadsize				; Length of data (+1 for slot number + 2 for crc)
0111+  F090 CD F9 F2    LOADSERIAL: 	CALL RAMLoad4bitBlk ;Load4bitBlk ;LoadSerBlk				; Load block using Serial Kempston
0112+  F093             
0113+  F093 21 FD EE    AFTER_LOAD: 	LD HL,loadarea+loadsize-3	; Address of number of slot from file
0114+  F096 3A D8 F0    			LD A,(NBLOCK)				; number of 16k slot to write to eeprom (1-32)
0115+  F099 BE          			CP (HL)						; check if slot loaded is correct
0116+  F09A 20 23       			JR NZ,LOADERR				; If not the correct slot Show TOSBOMB
0117+  F09C             
0118+  F09C 11 FD 6E    			ld de,loadarea				; DE=Begining of loaded area
0119+  F09F 21 00 00    			ld hl,0						; HL will have the sum
0120+  F0A2 01 01 80    			ld bc,$8001					; $8000 + 1 (length of area and n.slot byte)
0121+  F0A5             bucCRC: 
0122+  F0A5 1A          			ld a,(de)
0123+  F0A6 85          			add	a,l
0124+  F0A7 6F          			ld l,a
0125+  F0A8 30 01       			jr nc,bucNOCarry
0126+  F0AA 24          			inc h						; Include Carry if existing
0127+  F0AB             bucNOCarry: 
0128+  F0AB 13          			inc de
0129+  F0AC 0B          			dec bc
0130+  F0AD 78          			ld a,b
0131+  F0AE B1          			or c
0132+  F0AF 20 F4       			jr nz,bucCRC
0133+  F0B1             			
0134+  F0B1 DD 6B DD 62 			ld ix,de
0135+  F0B5             			ld de,(ix)					; Load DE with CRC from file
0135+  F0B5 DD5E00DD5601
0136+  F0BB             
0137+  F0BB             			;or a						; clear carry flag - not needed as previous "or c" reset carry flag
0138+  F0BB ED 52       			sbc hl,de					; substract computed CRC
0139+  F0BD 28 03       			jr z, ALLGOOD				; ok, continue with burning
0140+  F0BF C3 00 F0    LOADERR: 	JP TOSBOMB					; Show Bomb and deadlock if CRC no ok
0141+  F0C2             			
0142+  F0C2             ALLGOOD: 
0143+  F0C2 AF          			XOR A
0144+  F0C3 D3 FE       			OUT (#FE),A
0145+  F0C5 21 FD 6E    			LD HL,loadarea				; First address is scratch area
0146+  F0C8 CD D9 F0    			CALL	PROGRAMSECTOR		; Erase and then burn 8 4k eeprom Sectors
0147+  F0CB 3A D8 F0    			LD A,(NBLOCK)
0148+  F0CE 3C          			INC A
0149+  F0CF 32 D8 F0    			LD (NBLOCK),A
0150+  F0D2 FE 11       			CP 17						
0151+  F0D4 DA 5F F0    			JP C,BUC					; Cycle all 16 Blocks
0152+  F0D7             			
0153+  F0D7             ENDEND: 
0154+  F0D7 C7          			RST 0
0155+  F0D8             			;JP DDNTRRESET				; Enable Dandanator and jumpt to menu
0156+  F0D8             
0157+  F0D8 00          NBLOCK: 		DEFB 0x00					; Reserve space for var 
0158+  F0D9             
0159+  F0D9             ;------------------------------------------------------------------------------
0160+  F0D9             ; VARS
0161+  F0D9             ;------------------------------------------------------------------------------
0162+  F0D9             loadsize		equ		$8003			; Length of data loaded = 32kbyte data + 1 byte + 2 bytes crc
0163+  F0D9             loadarea		equ		$6F00-3			; Destination of load data (aligned to EF00 when done)
0164+  F0D9             TXTSLOTCOUNTER	equ 	$5800+(8*32)+8	; Position of Slot Counter
0165+  F0D9             TXTSECTCOUNTER	equ 	$5800+(18*32)+8	; Position of Slot Counter
0166+  F0D9             				
0167+  F0D9             ;------------------------------------------------------------------------------
0168+  F0D9             ;PROGRAMSECTOR - 
0169+  F0D9             ; (NBLOCK) = Number of slot (1..16)
0170+  F0D9             ; HL = Address of data (32k = 8 sectors x 4K)
0171+  F0D9             ; C will be counting from 0 to 7
0172+  F0D9             ; Number in screen will be 1 to 8
0173+  F0D9             ; Combining (NBLOCK) and C will have the sector in range 0..127 stored in B register
0174+  F0D9             ; B will be copied to A prior to calling SECTOR_ERASE (old SSTSECERASE) and SECTOR_PROGRAM (old SSTSECTPROG)
0175+  F0D9             ; HL will begin with the address of first 4K sector and incremented 4k by 4k prior to calling SSTSECTPROG
0176+  F0D9             ;------------------------------------------------------------------------------
0177+  F0D9             PROGRAMSECTOR: 
0178+  F0D9             			;PUSH HL						; Page in External eeprom -> Needed for programming
0179+  F0D9             			;LD A,1
0180+  F0D9             			;LD HL,1
0181+  F0D9             			;CALL SENDNRCMD 
0182+  F0D9             			;POP HL
0183+  F0D9 0E 00       			LD C,0						; N.of sector in this programming area (0..7)
0184+  F0DB             BUCPROGRAMSECTOR: 
0185+  F0DB E5          			PUSH HL						; Save Initial address
0186+  F0DC 3A D8 F0    			LD A,(NBLOCK)				; N.slot (1..16), need to convert in sector (*8)
0187+  F0DF 3D          			DEC A						; Convert to 0..15
0188+  F0E0 87          			ADD A,A						; *2
0189+  F0E1 87          			ADD A,A						; *4
0190+  F0E2 87          			ADD A,A						; *8
0191+  F0E3 81          			ADD C						; Add sector subnumber(0..7) to acummulator A
0192+  F0E4 47          			LD B,A						; Copy Sector (0-127) from A to B for next usage
0193+  F0E5 C5          			PUSH BC						; Save copy of B and C
0194+  F0E6             
0195+  F0E6 0E 02       			LD C,2						; 2 = WRITING, A = N.SECTOR
0196+  F0E8 CD 46 F1    			CALL DISPBAR				; DISPBAR returns with A=N.SECTOR
0197+  F0EB             
0198+  F0EB C1          			POP BC						; We need B=sector (0-127)
0199+  F0EC C5          			PUSH BC						; Save copy of B and C
0200+  F0ED             			
0201+  F0ED             			
0202+  F0ED CD 44 F2    			CALL SECTOR_ERASE			; Using B=sector (0..127)
0203+  F0F0 C1          			POP BC						; Retrieve copy of B and C
0204+  F0F1 E1          			POP HL						; Recuperate Address of data
0205+  F0F2 E5          			PUSH HL						; Save this Address of data (4 of 32k)
0206+  F0F3 C5          			PUSH BC						; Save copy of B and C
0207+  F0F4             
0208+  F0F4 CD A3 F2    			CALL SECTOR_PROGRAM			;Using only C value (0..7) with that it calculate correct sector address for programming
0209+  F0F7 C1          			POP BC						; Retrieve copy of B and C (only C is needed this time, B is n.sector 0..127)
0210+  F0F8 C5          			PUSH BC						; Save copy of B and C
0211+  F0F9 78          			LD A,B						; A = N.Sector
0212+  F0FA 0E 03       			LD C,3						; 3 = FINISHED, A = N.SECTOR
0213+  F0FC CD 46 F1    			CALL DISPBAR				; DISPBAR returns with A=N.SECTOR
0214+  F0FF             
0215+  F0FF C1          			POP BC						; Retrieve copy of B and C (only C is needed this time, B is discarded now)
0216+  F100 E1          			POP HL						; Recuperate Address of data
0217+  F101             
0218+  F101 11 00 10    			LD DE,$1000					; Lenght of sectors = 4Kbyte = 1024*4 = 4096 = $1000
0219+  F104 19          			ADD HL,DE					; Calculate next address
0220+  F105 0C          			INC C						; Next subsector 0..7
0221+  F106 79          			LD A,C						; Copy the value of this sector to acumulator A
0222+  F107 FE 08       			CP 8						; Check A<8 (only 0..7 is valid)
0223+  F109 38 D0       			JR C,BUCPROGRAMSECTOR		; REPEAT WHILE subsector<8
0224+  F10B             			
0225+  F10B C9          			RET
0226+  F10C             
0227+  F10C             
0228+  F10C             
0229+  F10C             ; ----------------------------------------------------------------------------------------
0230+  F10C             ; Send special command with long confirmation
0231+  F10C             ; ----------------------------------------------------------------------------------------
0232+  F10C             ;SENDSPCMDLC: CALL SENDSPCMD
0233+  F10C             ;			 CALL LONGSPCONF
0234+  F10C             ;			 RET
0235+  F10C             ; ----------------------------------------------------------------------------------------
0236+  F10C             
0237+  F10C             ; ----------------------------------------------------------------------------------------
0238+  F10C             ; Confirm Special Command and wait some ms ( > 5ms that PIC eeprom write operations require)
0239+  F10C             ; ----------------------------------------------------------------------------------------
0240+  F10C             ;LONGSPCONF:	LD (0),A		; Signal Dandanator the command confirmation (any A value for ZESARUX)
0241+  F10C             ;			LD B,0					
0242+  F10C             ;PAUSELCONF:	EX (SP),HL
0243+  F10C             ;			EX (SP),HL
0244+  F10C             ;			EX (SP),HL
0245+  F10C             ;			EX (SP),HL
0246+  F10C             ;			DJNZ PAUSELCONF
0247+  F10C             ;			RET
0248+  F10C             ; ----------------------------------------------------------------------------------------
0249+  F10C             
0250+  F10C             cursector: 
0251+  F10C 00          		DEFB	0
0252+  F10D             
0253+  F10D             			include "resources/digits_v1.asm"
0001++ F10D             ;digits_v1.asm - modified version for Multiply_v1 - mad3001 April 2020
0002++ F10D             
0003++ F10D             ;------------------------------------------------------------------------------
0004++ F10D             ;DISPADVANCE - Display arrows of advance bar
0005++ F10D             ;------------------------------------------------------------------------------
0006++ F10D             ; A = Number to show (1..16)
0007++ F10D             ;------------------------------------------------------------------------------
0008++ F10D             
0009++ F10D             ;DISPDIGIT Local Variables	
0010++ F10D             RowLine		equ		15					;Row (0..23) of Line (line is only 12 char length)
0011++ F10D             ColLine		equ		6					;1 less than Col (0..32) of Line (line is only 14 char length)
0012++ F10D             DISPADVANCE: 
0013++ F10D FE 10       			CP  16
0014++ F10F 20 00       			JR  NZ,DISPADVANCE_Nolast
0015++ F111             DISPADVANCE_Nolast: 
0016++ F111 3D          			DEC A						;A=1..15 to 0..14 (16 was discarded)
0017++ F112 C8          			RET Z						;Nothing to do with 1st block (now value was 0)
0018++ F113 47          			LD	B,A						;Copy 0..14 into B
0019++ F114             			RowCol2PIX  HL,RowLine,ColLine		;Pixel address for Row RowLine, Column ColLine:  After Rectangle
0019++ F114 21 E6 48    >				LD Reg, Col + ((Row & 7)<<5) + (($40 | (Row & #18)) <<8 )
0020++ F117 7D          			LD  A,L
0021++ F118 80          			ADD A,B
0022++ F119 6F          			LD  L,A
0023++ F11A 05          			DEC B
0024++ F11B 28 09       			JR  Z,DISPADVANCE_ClearPrev	;1st time we have not to "clear" previous arrow
0025++ F11D 11 36 F1    			LD DE,CharsLine
0026++ F120 E5          			PUSH HL
0027++ F121 2B          			DEC HL						;Clear previous Arrow
0028++ F122 CD 2D F1    			CALL Printmichar
0029++ F125 E1          			POP HL
0030++ F126             DISPADVANCE_ClearPrev: 			
0031++ F126 11 3E F1    			LD DE,CharsArrow
0032++ F129             			
0033++ F129 CD 2D F1    			CALL Printmichar
0034++ F12C C9          			RET
0035++ F12D             
0036++ F12D             ;Mini routine to print directly with pixel address (no attribute changes)
0037++ F12D             Printmichar: 
0038++ F12D 06 08       			LD	B,8
0039++ F12F             DISPADVANCE_Char: 
0040++ F12F 1A          			LD	A,(DE)
0041++ F130 77          			LD	(HL),A
0042++ F131 13          			INC	DE
0043++ F132 24          			INC	H
0044++ F133 10 FA       			DJNZ	DISPADVANCE_Char
0045++ F135 C9          			RET
0046++ F136             CharsLine: 
0047++ F136             		defb 0, 0, 0, 0, 255, 0, 0, 0; used for line in ROMSET WRITER
0047++ F136 00000000FF000000
0048++ F13E             CharsArrow: 
0049++ F13E             		defb 0, 160, 80, 40, 20, 40, 80, 160; Used for Arrow in ROMSET WRITER 
0049++ F13E 00A05028142850A0
0050++ F146             
0051++ F146             
0052++ F146             
0053++ F146             ;------------------------------------------------------------------------------
0054++ F146             ; DISPBAR - Colorize Progress Bar
0055++ F146             ;------------------------------------------------------------------------------
0056++ F146             ; A = Number of Sector (0..127)
0057++ F146             ; C = Colour of attribute (0:PEND, 1:LOAD, 2:WRIT, 3:FINIS)
0058++ F146             ;------------------------------------------------------------------------------
0059++ F146             DISPBAR: 
0060++ F146 F5          			PUSH AF						;Send A to Stack to recuperate at the end
0061++ F147 C5          			PUSH BC						;Send C to Stack to recuperate at the end
0062++ F148             			;First convert A=N.Sector to Row/Col (in reg D/E)
0063++ F148 16 01       			LD D,BARROW					;D=Row, begin in that ROW
0064++ F14A             BUCROWS: 
0065++ F14A FE 18       			CP BARWIDTH					;Check if C>BARWIDTH
0066++ F14C 38 05       			JR C,DISPLASTROW			;if not then this is the last row
0067++ F14E D6 18       			SUB BARWIDTH				;if C>BARWIDTH, substract BARWIDTH...
0068++ F150 14          			INC D						;...and One Row more
0069++ F151 18 F7       			JR BUCROWS					;Continue until C<=BARWIDTH
0070++ F153             DISPLASTROW: 
0071++ F153             			;LD E,A						;Residual of substractions
0072++ F153 C6 04       			ADD BARCOL					;Add BARCOL
0073++ F155             			;We have D=Row, E=Col for this sector
0074++ F155             			; now we need D*32+E
0075++ F155 26 00       			LD H,0						;High byte of 16bit address to 0
0076++ F157 6A          			LD L,D						;Low byte of 16bit address store ROW
0077++ F158 CB 15       			RL L						;L<32 (no carry)		L*2
0078++ F15A CB 15       			RL L						;L<64 (no carry)		L*4
0079++ F15C CB 15       			RL L						;L<128 (no carry)		L*8
0080++ F15E CB 15       			RL L						;We can have carry...	L*16
0081++ F160 CB 14       			RL H						;so pass to H the Carry (if any)
0082++ F162 CB 15       			RL L						;We can have carry...	L*32
0083++ F164 CB 14       			RL H						;so pass to H the Carry (if any)
0084++ F166 85          			ADD L						;Add Column to attribute calculated
0085++ F167 6F          			LD L,A						;Store column to L
0086++ F168 30 01       			JR NC,DISPBAR1
0087++ F16A 24          			INC H						;If there was a carry then add 1 to High Address
0088++ F16B             DISPBAR1: 
0089++ F16B 11 00 58    			LD DE,$5800					;Begin of attribute screen zone
0090++ F16E 19          			ADD HL,DE					;
0091++ F16F             			;We have the attribute pointer in HL
0092++ F16F 79          			LD A,C
0093++ F170 B7          			OR A
0094++ F171 20 04       			JR NZ,DISPNOPEND
0095++ F173 0E 47       			LD C,COLPEND
0096++ F175 18 10       			JR DISPBARCOL
0097++ F177             DISPNOPEND: 
0098++ F177 3D          			DEC A
0099++ F178 20 04       			JR NZ,DISPNOLOAD
0100++ F17A 0E 46       			LD C,COLLOAD
0101++ F17C 18 09       			JR DISPBARCOL
0102++ F17E             DISPNOLOAD: 
0103++ F17E 3D          			DEC A
0104++ F17F 20 04       			JR NZ,DISPNOWRIT
0105++ F181 0E 42       			LD C,COLWRIT
0106++ F183 18 02       			JR DISPBARCOL
0107++ F185             DISPNOWRIT: 
0108++ F185 0E 44       			LD C,COLFINI
0109++ F187             DISPBARCOL: 
0110++ F187 71          			LD (HL),C					;Store colour of attribute
0111++ F188 C1          			POP BC						;Recuperate initial C
0112++ F189 F1          			POP AF						;Recuperate initial A
0113++ F18A C9          			RET
0114++ F18B             			
0115++ F18B             ; DISPBAR LOCAL CONSTANS
0116++ F18B             BARROW		equ 	1
0117++ F18B             BARCOL		equ		4
0118++ F18B             BARATTR		equ		$5800+(BARROW*32+BARCOL);Row BARROW, Column BARCOL (Row 0-23, Column 0-31)
0119++ F18B             BARWIDTH	equ		24					;Number of Blocks per row (center rows)
0120++ F18B             COLPEND		equ		%01000111			;Bright, Paper black, Ink White
0121++ F18B             COLLOAD		equ		%01000110			;Bright, Paper black, Ink Yellow
0122++ F18B             COLWRIT		equ		%01000010			;Bright, Paper black, Ink Red
0123++ F18B             COLFINI		equ		%01000100			;Bright, Paper black, Ink Green
0124++ F18B             			
0125++ F18B             ;------------------------------------------------------------------------------
0126++ F18B             ; DISPDIGIT - 
0127++ F18B             ;------------------------------------------------------------------------------
0128++ F18B             ; A = Number to show (1..16)
0129++ F18B             ; DIGIATTR = Left-Top corner of 6x5 AREA of Digits
0130++ F18B             ;------------------------------------------------------------------------------
0131++ F18B             DISPDIGIT: 
0132++ F18B F5          			PUSH AF						;Save A to Stack
0133++ F18C             
0134++ F18C 21 26 F2    			LD HL,ZONE6X5
0135++ F18F 36 2D       			LD (HL),DIGIOFF
0136++ F191 E5          			PUSH HL
0137++ F192 D1          			POP DE
0138++ F193 13          			INC DE
0139++ F194 01 1D 00    			LD BC,ENDZONE-ZONE6X5-1
0140++ F197 ED B0       			LDIR						;Fill table with 0
0141++ F199 21 ED F1    			LD HL,TABLEDIGITS-1
0142++ F19C 47          			LD B,A						;Load B with copy of A for lookup in TABLEDIGITS
0143++ F19D             LOOKTABLEDIGITS: 
0144++ F19D 23          			INC HL
0145++ F19E 10 FD       			DJNZ LOOKTABLEDIGITS
0146++ F1A0             			; Now lookup to attributes to be painted in zone6x6
0147++ F1A0 DD 21 FE F1 			LD IX,TABLEATTRS
0148++ F1A4 06 08       			LD B,8						;Process the 8 bits of A
0149++ F1A6             DISPSEGMENT: 
0150++ F1A6 CB 0E       			RRC	(HL)					;Rotate right (bit 0 -> bit 7 , bit 0-> Carry)
0151++ F1A8 30 20       			JR NC,THISSEGMEND			;No bit = no change attributes 0
0152++ F1AA             			
0153++ F1AA             			;Bit for segment activated, lets process upto 5 segments for this bit
0154++ F1AA 0E 05       			LD C,5						;Process up to 5 data for attribute offset
0155++ F1AC             THISSEGM: 
0156++ F1AC FD 21 26 F2 			LD IY,ZONE6X5				;IY will be used to locate in attribute to be changed
0157++ F1B0 DD 7E 00    			LD A,(IX)
0158++ F1B3 3C          			INC A						;if A=255 -> 0
0159++ F1B4 28 0D       			JR Z,NOTSEGMENT
0160++ F1B6 3D          			DEC A						;return A to it's value before INC A
0161++ F1B7 FD 85       			ADD A,IYL
0162++ F1B9 FD 6F       			LD IYL,A
0163++ F1BB 30 02       			JR NC,NOHIGH
0164++ F1BD FD 24       			INC IYH
0165++ F1BF             NOHIGH: 
0166++ F1BF FD 36 00 29 			LD (IY),DIGICOLOR			;Change this attribute to DIGICOLOR (green ink)
0167++ F1C3             NOTSEGMENT: 			
0168++ F1C3 DD 23       			INC IX						;Next value from IX table
0169++ F1C5 0D          			DEC C						;Next digit
0170++ F1C6 20 E4       			JR NZ,THISSEGM				;Repeat until C=0
0171++ F1C8 18 0A       			JR ENDTHISSEGM
0172++ F1CA             THISSEGMEND: 
0173++ F1CA DD 23       			INC IX
0174++ F1CC DD 23       			INC IX
0175++ F1CE DD 23       			INC IX
0176++ F1D0 DD 23       			INC IX
0177++ F1D2 DD 23       			INC IX						;Next Segment (next bit)
0178++ F1D4             ENDTHISSEGM: 
0179++ F1D4 10 D0       			DJNZ DISPSEGMENT
0180++ F1D6             			
0181++ F1D6             			;Copy ZONE6X5 to screen (6 lines of 5 attributes)
0182++ F1D6 3E 06       			LD A,6
0183++ F1D8 21 26 F2    			LD HL,ZONE6X5
0184++ F1DB 11 B9 59    			LD DE,DIGIATTR
0185++ F1DE             BUCPAINTATTR: 			
0186++ F1DE 01 05 00    			LD BC,5
0187++ F1E1 ED B0       			LDIR
0188++ F1E3 01 1B 00    			LD BC,32-5
0189++ F1E6 EB          			EX DE,HL
0190++ F1E7 09          			ADD HL,BC
0191++ F1E8 EB          			EX DE,HL
0192++ F1E9 3D          			DEC A
0193++ F1EA 20 F2       			JR NZ,BUCPAINTATTR
0194++ F1EC             
0195++ F1EC F1          			POP AF						;Restore initial A Value
0196++ F1ED C9          			RET
0197++ F1EE             ; DIGITS From 1 to 16
0198++ F1EE             TABLEDIGITS: 
0199++ F1EE             			DEFB	18,61,59,90,107,111,50,127,123,247,146,189,187,218,235,239	;Coded for 1..16
0199++ F1EE 123D3B5A6B6F327F7BF792BDBBDAEBEF
0200++ F1FE             			
0201++ F1FE             TABLEATTRS: 
0202++ F1FE 16171B1CFF  			DEFB	22,23,27,28,255		;Segment 7		(BIT 6)
0203++ F203 1318FFFFFF  			DEFB	19,24,255,255,255	;Segment 6		(BIT 5)
0204++ F208 1015FFFFFF  			DEFB	16,21,255,255,255	;Segment 5		(BIT 4)
0205++ F20D 0C0D1112FF  			DEFB	12,13,17,18,255		;Segment 4		(BIT 3)
0206++ F212 04090EFFFF  			DEFB	4,9,14,255,255		;Segment 3		(BIT 2)
0207++ F217 0203FFFFFF  			DEFB	2,3,255,255,255		;Segment 2		(BIT 1)
0208++ F21C 01060BFFFF  			DEFB	1,6,11,255,255		;Segment 1		(BIT 0)
0209++ F221 00050A0F14  			DEFB	0,5,10,15,20		;Segments A/B	(BIT 7)
0210++ F226             
0211++ F226 00          ZONE6X5: 	BLOCK	5*6,0				;Scratch area to prepare attributes
0212++ F244             ENDZONE: 			
0213++ F244             	
0214++ F244             ;DISPDIGIT Local Variables	
0215++ F244             ;DIGIATTR	equ	$5800+(11*32)+22		;Row 11, Column 22 (Row 0-23, Column 0-31)
0216++ F244             DIGIATTR	equ	$5800+(13*32)+25		;Row 13, Column 25 (Row 0-23, Column 0-31)
0217++ F244             DIGICOLOR	equ	%00101001				;Paper 5 (cyan), Ink 1 (blue), no bright
0218++ F244             DIGIOFF		equ	%00101101				;Paper 5 (cyan), Ink 5 (cyan), no bright
0219++ F244             
0220++ F244             	
0254+  F244             	
0255+  F244             ;			include "sstwriter_romset_6.5MODED.ASM"
0256+  F244             ;RAM Routines for dealing with Erasing and Writing Dandanator's EEPROM			
0257+  F244             ;   This routine is relocatable and have to be in RAM (can't be called from EEPROM-will hang the speccy)
0258+  F244             
0259+  F244             ; SECTOR_ERASE
0260+  F244             ;	IN - B=value 0..127 for sector to erase	
0261+  F244             ;		 with that we calculte DE= Address of zone in sector to erase (#0000-#3FFF)
0262+  F244             SECTOR_ERASE: 
0263+  F244 CD EE F2    			CALL ADDR_SECTOR			;With B=0..127 returns DE=Address in sector (#0000,#1000,#2000,#3000)
0264+  F247             
0265+  F247 78          			LD A,B						;B=sector number 0..127
0266+  F248             			DAN_BIG_COMMAND 48, 16, A	;Command 48, Data 1=16, Data 2=sector number
0266+  F248 06 30       >			LD	B,C1			; Command
0266+  F24A 23          >.slot_b		INC HL
0266+  F24B 2B          >			DEC HL
0266+  F24C 32 00 00    >			LD (0),A
0266+  F24F 10 F9       >			DJNZ .slot_b
0266+  F251 06 40       >			LD B,value
0266+  F253 10 FE       >.wait_b0	DJNZ .wait_b0
0266+  F255 06 10       >			LD	B,C2			; Data 1
0266+  F257 23          >.slot_b		INC HL
0266+  F258 2B          >			DEC HL
0266+  F259 32 00 00    >			LD (0),A
0266+  F25C 10 F9       >			DJNZ .slot_b
0266+  F25E 06 40       >			LD B,value
0266+  F260 10 FE       >.wait_b0	DJNZ .wait_b0
0266+  F262 47          >			LD  B,C3			; Data 2
0266+  F263 23          >.slot_b		INC HL
0266+  F264 2B          >			DEC HL
0266+  F265 32 00 00    >			LD (0),A
0266+  F268 10 F9       >			DJNZ .slot_b
0266+  F26A 06 40       >			LD B,value
0266+  F26C 10 FE       >.wait_b0	DJNZ .wait_b0
0266+  F26E 32 00 00    >			LD 	(0),A
0267+  F271             			WAIT_B PAUSELOOPSN
0267+  F271 06 40       >			LD B,value
0267+  F273 10 FE       >.wait_b0	DJNZ .wait_b0
0268+  F275             			
0269+  F275 3E AA       SE_Step1: 	LD A, $AA
0270+  F277 32 55 15    			LD (J5555),A			
0271+  F27A 0F          SE_Step2: 	RRCA						;LD A, $55	; replaced as $AA >> is $55
0272+  F27B 32 AA 2A    			LD (J2AAA),A	
0273+  F27E 3E 80       SE_Step3: 	LD A, $80
0274+  F280 32 55 15    			LD (J5555),A
0275+  F283 3E AA       SE_Step4: 	LD A, $AA
0276+  F285 32 55 15    			LD (J5555),A
0277+  F288 0F          SE_Step5: 	RRCA						;LD A, $55	; replaced as $AA >> is $55
0278+  F289 32 AA 2A    			LD (J2AAA),A
0279+  F28C 3E 30       SE_Step6: 	LD A, $30					; Actual sector erase		
0280+  F28E 12          			LD (DE),A					; First Address of zone in sector to erase
0281+  F28F             
0282+  F28F             		IFDEF OldWriteSST
0283+  F28F~            			LD BC,1400					; wait over 25 ms for Sector erase to complete (datasheet pag 13) -> 1400*18us= 25,2 ms
0284+  F28F~            WAITSEC: 								; Loop ts = 64ts -> aprox 18us on 128k machines
0285+  F28F~            			EX (SP),HL					; 19ts
0286+  F28F~            			EX (SP),HL					; 19ts
0287+  F28F~            			DEC BC						; 6ts
0288+  F28F~            			LD A,B						; 4ts
0289+  F28F~            			OR C						; 4ts
0290+  F28F~            			JR NZ, WAITSEC				; 12ts / 7ts		
0291+  F28F             		ELSE
0292+  F28F             SECTOR_ERASE_loop: 						;This new wait routine use the toggle bit of EEPROM (see SST39SF040 datasheet)
0293+  F28F 1A          			LD A,(DE)
0294+  F290 67          			LD H,A
0295+  F291 1A          			LD A,(DE)
0296+  F292 BC          			CP H						;toggle bit of EEPROM return alternate values for each reading when it's Erasing
0297+  F293 20 FA       			JR NZ, SECTOR_ERASE_loop
0298+  F295             			; Finally return to correct slot.
0299+  F295             		ENDIF
0300+  F295             Ret_Slot: 
0301+  F295 06 01       			LD B,1
0302+  F297             			SENDNRCMD_B	PAUSELOOPSN		;Assure we're in 1 slot (required for writing)
0302+  F297 23          >.slot_b		INC HL
0302+  F298 2B          >			DEC HL
0302+  F299 32 00 00    >			LD (0),A
0302+  F29C 10 F9       >			DJNZ .slot_b
0302+  F29E 06 40       >			LD B,value
0302+  F2A0 10 FE       >.wait_b0	DJNZ .wait_b0
0303+  F2A2 C9          			RET
0304+  F2A3             
0305+  F2A3             ;Prepare sector for programming
0306+  F2A3             ;	HL=ORIGIN OF DATA
0307+  F2A3             ;		- B=0..127 sector to program, with that calculate DE= Address of zone to program (#0000,#1000,#2000,#3000)
0308+  F2A3             ;		- Length to write is always #4000
0309+  F2A3             SECTOR_PROGRAM: 
0310+  F2A3 CD EE F2    			CALL ADDR_SECTOR			;With B=0..127 return DE=Address in sector (#0000,#1000,#2000,#3000)
0311+  F2A6 78          			LD A,B						;B=sector number 0..127
0312+  F2A7             			DAN_BIG_COMMAND 48, 32, A	;Command 48, Data 1=16, Data 2=sector number
0312+  F2A7 06 30       >			LD	B,C1			; Command
0312+  F2A9 23          >.slot_b		INC HL
0312+  F2AA 2B          >			DEC HL
0312+  F2AB 32 00 00    >			LD (0),A
0312+  F2AE 10 F9       >			DJNZ .slot_b
0312+  F2B0 06 40       >			LD B,value
0312+  F2B2 10 FE       >.wait_b0	DJNZ .wait_b0
0312+  F2B4 06 20       >			LD	B,C2			; Data 1
0312+  F2B6 23          >.slot_b		INC HL
0312+  F2B7 2B          >			DEC HL
0312+  F2B8 32 00 00    >			LD (0),A
0312+  F2BB 10 F9       >			DJNZ .slot_b
0312+  F2BD 06 40       >			LD B,value
0312+  F2BF 10 FE       >.wait_b0	DJNZ .wait_b0
0312+  F2C1 47          >			LD  B,C3			; Data 2
0312+  F2C2 23          >.slot_b		INC HL
0312+  F2C3 2B          >			DEC HL
0312+  F2C4 32 00 00    >			LD (0),A
0312+  F2C7 10 F9       >			DJNZ .slot_b
0312+  F2C9 06 40       >			LD B,value
0312+  F2CB 10 FE       >.wait_b0	DJNZ .wait_b0
0312+  F2CD 32 00 00    >			LD 	(0),A
0313+  F2D0             			WAIT_B PAUSELOOPSN
0313+  F2D0 06 40       >			LD B,value
0313+  F2D2 10 FE       >.wait_b0	DJNZ .wait_b0
0314+  F2D4             
0315+  F2D4             ;Write the data in sector
0316+  F2D4             SECTLP: 									; Sector Loop BC times
0317+  F2D4 3E AA       			LD A, $AA
0318+  F2D6 32 55 15    			LD (J5555),A
0319+  F2D9 0F          PB_Step2:  	RRCA						;LD A, $55	; replaced as $AA >> is $55
0320+  F2DA 32 AA 2A    			LD (J2AAA),A
0321+  F2DD 3E A0       PB_Step3:  	LD A, $A0
0322+  F2DF 32 55 15    			LD (J5555),A	
0323+  F2E2 7E          PB_Step4: 	LD A,(HL)					; Write actual byte
0324+  F2E3 12          			LD (DE),A
0325+  F2E4             										; Datasheet asks for 14us write time, but loop takes longer between actual writes
0326+  F2E4 23          			INC HL						; Next Data byte
0327+  F2E5 13          			INC DE						; Next Byte in sector
0328+  F2E6 7A          			LD A,D						; Check for 4096 iterations (D=0x_0, E=0x00)
0329+  F2E7 E6 0F       			AND 15						; Get 4 lower bits
0330+  F2E9 B3          			OR E						; Now also check for a 0x00 in E
0331+  F2EA 20 E8       			JR NZ, SECTLP
0332+  F2EC             
0333+  F2EC 18 A7       			JR Ret_Slot 				;Be sure slot 1 is active and return to caller
0334+  F2EE             
0335+  F2EE             ;ADDR_SECTOR - With C=0..7 
0336+  F2EE             ;	IN B - Number 0..127 (value for sector)
0337+  F2EE             ;  OUT DE=Address in sector (#0000,#1000,#2000,#3000)
0338+  F2EE             ;  OUT  A=scratch value #00,#10,#20,#30
0339+  F2EE             ADDR_SECTOR: 
0340+  F2EE 78          			LD A,B
0341+  F2EF E6 03       			AND 3									;We have value #00,#01,#02,#03
0342+  F2F1 87          			ADD A,A									;*2
0343+  F2F2 87          			ADD A,A									;*4
0344+  F2F3 87          			ADD A,A									;*8
0345+  F2F4 87          			ADD A,A									;*16	so we have value #00, #10, #20, #30
0346+  F2F5 57          			LD D,A
0347+  F2F6 1E 00       			LD E,0									;DE=address of zone in sector to erase #0000-#3FFF
0348+  F2F8 C9          			RET
0349+  F2F9             LastRAMRoutine: 
0350+  F2F9             	ENT
0351+  3651             ENDROMROUTINE: 
0352+  3651             RAMLoad4bitBlk	EQU	LastRAMRoutine					;Load4bitBlk will be copy in ENDROMROUTINE address
0353+  3651             ;RAMReqFileA		EQU	RAMLoad4bitBlk+(ReqFileA-Load4bitBlk)	;Equivalent address	; DISABLED AS IT'S NOT USED
0354+  3651             RAMSendSerByteLC EQU RAMLoad4bitBlk+(SendSerByteLC-Load4bitBlk)	;Equivalent address
0355+  3651             RAMSendSerByte EQU RAMLoad4bitBlk+(SendSerByte-Load4bitBlk)	;Equivalent address
0356+  3651             eew_scr: 
0357+  3651             		incbin "resources/romsetwriter_v1.scr.zx7"
0358+  3A66             
0965   3A66             showinfEEE: 
0966   3A66             
0967   3A66             showinfCB: 
0968   3A66             		;Clear Row
0969   3A66             		include "resources/clearrow.asm"
0001+  3A66             ;Clear SemiRow-Left
0002+  3A66             ;	IN	A=row				%000RRrrr
0003+  3A66             ;	IN	B=Colour
0004+  3A66             ;	IN	C=1 less of Length to clear
0005+  3A66             ;Pixel
0006+  3A66             ;			Address (High)	76543210	(Low) 76543210
0007+  3A66             ;							010RRsss		  rrrccccc
0008+  3A66             
0009+  3A66             ;Attr
0010+  3A66             ;			Address (High)	76543210  (Low) 76543210
0011+  3A66             ;							010110RR		rrrccccc
0012+  3A66             ClearRow: 
0013+  3A66 0F          > RRCA			
0013+  3A67 0F          > RRCA			
0013+  3A68 0F          > RRCA			
0014+  3A69 6F          			LD	L,A				;save for later %rrr000RR
0015+  3A6A E6 03       			AND %00000011		;%000000RR
0016+  3A6C F6 58       			OR	%01011000		;%010110RR
0017+  3A6E 67          			LD	H,A
0018+  3A6F             
0019+  3A6F 7D          			LD	A,L				;%rrr000RR
0020+  3A70 E6 E0       			AND	%11100000		;%rrr00000
0021+  3A72 6F          			LD	L,A
0022+  3A73             			
0023+  3A73 E5          			PUSH	HL			;HL=Attr address
0024+  3A74 54          			LD		D,H
0025+  3A75 5D          			LD		E,L
0026+  3A76 13          			INC		DE			;DE=Attr address + 1
0027+  3A77 70          			LD		(HL),B		;B=Colour
0028+  3A78 06 00       			LD		B,0
0029+  3A7A C5          			PUSH	BC			;B=0, C=1 less of Length to clear
0030+  3A7B ED B0       			LDIR
0031+  3A7D             
0032+  3A7D C1          			POP		BC			;B=0, C=1 less of Length to clear
0033+  3A7E E1          			POP		HL			;H=%010110RR L=rrr00000
0034+  3A7F 7C          			LD		A,H			;A=%010110RR
0035+  3A80 07          > RLCA		
0035+  3A81 07          > RLCA		
0035+  3A82 07          > RLCA		
0036+  3A83 E6 58       			AND		%01011000	;A=%010RR000
0037+  3A85 67          			LD		H,A
0038+  3A86             			
0039+  3A86 3E 08       			LD		A,8
0040+  3A88             Pix_Loop_Zero: 
0041+  3A88             
0042+  3A88 54          			LD		D,H
0043+  3A89 5D          			LD		E,L			;HL=Pix Address
0044+  3A8A 13          			INC		DE			;DE=Pix Address + 1
0045+  3A8B 70          			LD		(HL),B
0046+  3A8C E5 D5 C5    			PUSH	HL,DE,BC
0047+  3A8F ED B0       			LDIR
0048+  3A91             
0049+  3A91 C1 D1 E1    			POP		BC,DE,HL
0050+  3A94 24          			INC		H
0051+  3A95 14          			INC		D
0052+  3A96             
0053+  3A96 3D          			DEC		A
0054+  3A97 20 EF       			JR		NZ,Pix_Loop_Zero
0055+  3A99             			
0056+  3A99 C9          			RET
0057+  3A9A             			
0058+  3A9A             ClsFiles: 
0059+  3A9A 3E 17       			LD		A,MaxRowFiles					;Beginning a new folder 
0060+  3A9C             ClsFiles_Loop: 
0061+  3A9C F5          			PUSH	AF
0062+  3A9D 01 0F 38    			LD		BC,15+(NoSel_Color<<8)
0063+  3AA0 CD 66 3A    			CALL	ClearRow
0064+  3AA3 F1          			POP		AF
0065+  3AA4 3D          			DEC		A
0066+  3AA5 20 F5       			JR		NZ,ClsFiles_Loop
0067+  3AA7 C9          			RET
0068+  3AA8             
0970   3AA8             showinfCE: 
0971   3AA8             
0972   3AA8             PBB: 
0973   3AA8             		;Browsing Directories
0974   3AA8             		include "resources/browse_dir.asm"
0001+  3AA8             ; Browsing directories
0002+  3AA8             ; ----------------------------------------------------------------------------------------
0003+  3AA8             						
0004+  3AA8             ;Load_FT_DIRECTORY - Change to subdir (or return to previous if ".." selected)
0005+  3AA8             Load_FT_DIRECTORY: 
0006+  3AA8 F3          			DI
0007+  3AA9 23          			INC		HL								;Skip File Type
0008+  3AAA 7E          			LD		A,(HL)							;1st Char of directory choosen (or .. )
0009+  3AAB FE 2E       			CP		"."								;Check Name... Is it ".." ?
0010+  3AAD C2 46 3B    			JP		NZ,Load_FT_DIRECTORY_GoInto		;If no "." jump there to Go inside subdir
0011+  3AB0             
0012+  3AB0             	;Here for going to previous dir... It's a Nightmare because we have to begin in ROOT and going down into subdirectories
0013+  3AB0             ;Load_FT_DIRECTORY_GotoParent - Entry for returning to Parent
0014+  3AB0             Load_FT_DIRECTORY_GotoParent: 					
0015+  3AB0             		;1st thing is going to root
0016+  3AB0 CD 71 19    			CALL	ZX2SD_CD_ROOT					;Go to Root directory (Long confirmation)
0017+  3AB3 3A 06 DD    			LD		A,(PathIndexLast)				;A will be >0 (never 0 if entered here, as 0 is for root and don't have ".." )
0018+  3AB6 3D          			DEC		A
0019+  3AB7 32 06 DD    			LD		(PathIndexLast),A				;Update with 1 less so will go up in directories
0020+  3ABA CA 2A 00    			JP		Z,Goto_PostROOT					; If we had only 1 directory now we're in ROOT so jump there (after CD_ROOT commmand)
0021+  3ABD             					
0022+  3ABD 47          			LD		B,A								;Copy to B (PathIndexLast)
0023+  3ABE             
0024+  3ABE             			;Initializing current Path
0025+  3ABE AF          			XOR		A
0026+  3ABF 32 08 DB    			LD		(PathBuffer),A					;Root is Empty Directory (64 bytes with 0x00)
0027+  3AC2 32 45 DB    			LD		(LenPath),A						;Length of current Path to show
0028+  3AC5             
0029+  3AC5             		;Now going deep inside subdirectories upto the last level
0030+  3AC5 78          			LD		A,B								;Copy to A (PathIndexLast)
0031+  3AC6 DD 21 43 DC 			LD		IX,PathIndex-3					;PathIndex is Space with 192 bytes: 64 x 3 :Up to 63 directory entre levels (1 byte name len, 2 bytes index)
0032+  3ACA 11 03 00    			LD		DE,3							;Length of each entry
0033+  3ACD             GoingDeeperDirectory: 
0034+  3ACD DD 19       			ADD		IX,DE							;Go to next index (deep)
0035+  3ACF 10 FC       			DJNZ	GoingDeeperDirectory
0036+  3AD1             		;We arrived to the very deeper directory
0037+  3AD1             		
0038+  3AD1 11 FD FF    			LD		DE,-3							;So we can use ADD instead of SBC
0039+  3AD4             		;Here for arrived to Deeper Directory, now return to "surface" until we arrive either the upper or len>59 (we  have to add a "~" so no 60 but 59 available)
0040+  3AD4 47          			LD		B,A								;B=Num of levels we went inside (for not going beyond) (PathIndexLast)
0041+  3AD5             
0042+  3AD5 3E FF       			LD		A,#FF							;Initialize Len of Dirnames with -1 (1st directory don't add a "/")
0043+  3AD7             LoopMoreRoom: 
0044+  3AD7 DD 86 00    			ADD		A,(IX)							;Len of this Directory name (It's update when getting into)
0045+  3ADA 3C          			INC		A								;Each directory add a "/" so it's 1 char more
0046+  3ADB FE 3B       			CP		MaxLenPath-1					;Compare against 59 char maximum
0047+  3ADD 30 04       			JR		NC,NoMoreRoom					;If len greater or equal then finish (> = 59 finish)
0048+  3ADF DD 19       			ADD		IX,DE							;Go to previous index (shallow)
0049+  3AE1 10 F4       			DJNZ	LoopMoreRoom
0050+  3AE3             
0051+  3AE3             		;Here for arrived to 1st level and path still is less than MaxLenPath-1
0052+  3AE3             			
0053+  3AE3             NoMoreRoom: 	;Here for path greater or equal than MaxlenPath-1
0054+  3AE3             
0055+  3AE3 DD 21 46 DC 			LD		IX,PathIndex					;Begin in 1st level to skip indexes of non used
0056+  3AE7             
0057+  3AE7             		;So we're in the 1st index to use for path. B is the num of levels to discard => B=0 if we have to use all levels, B>0 if we have to discard B indexes
0058+  3AE7 3A 06 DD    			LD		A,(PathIndexLast)				;A=Total of levels
0059+  3AEA 90          			SUB		B								;A=Total levels-Leves to discard = Num of levels to use
0060+  3AEB 5F          			LD		E,A								;E=Number of levels to use
0061+  3AEC             			
0062+  3AEC 50          			LD		D,B								;D=B=Number of levels to discard... It can be 0..63
0063+  3AED             			
0064+  3AED 78          			LD		A,B								;A=Total of levels to discard
0065+  3AEE A7          			AND		A
0066+  3AEF 28 17       			JR		Z,NoSkipLevels					;If we have to use all levels (len path not greater than MaxLenPath) then jump
0067+  3AF1             
0068+  3AF1             SkipLevels: 
0069+  3AF1             		;Loop for geting subdirectories (D=Number of levels to discard)
0070+  3AF1 3E 0C       			LD		A,CMD_ZX2SD_CD_IX				;Command to change to subdir by Index (IX+3,IX+2)
0071+  3AF3 D5          			PUSH	DE
0072+  3AF4 DD 56 01    			LD		D,(IX+1)						;Data1: Low byte of Index			
0073+  3AF7 DD 5E 02    			LD		E,(IX+2)						;Data2: High byte of Index
0074+  3AFA 37          			SCF										;Carry for send commmand and Long Confirmation
0075+  3AFB CD 76 19    			CALL	ZX2SD_COMMAND					;Send command with Long Confirmation
0076+  3AFE D1          			POP		DE
0077+  3AFF 15          			DEC		D
0078+  3B00 DD 23       > INC IX							
0078+  3B02 DD 23       > INC IX							
0078+  3B04 DD 23       > INC IX							
0079+  3B06 20 E9       			JR		NZ,SkipLevels
0080+  3B08             NoSkipLevels: 
0081+  3B08             
0082+  3B08 D5          			PUSH	DE
0083+  3B09 3E 0D       			LD		A,CMD_ZX2SD_GETDIR
0084+  3B0B CD 04 33    			CALL	SendSerByte						;Command to ask for name of current dir
0085+  3B0E             			
0086+  3B0E 21 46 DB    			LD		HL,BuffGetDir
0087+  3B11 11 00 01    			LD		DE,maxFLen						;last byte have to be always 0x00 so ask for 1 less (max file Length in FAT32 is 255 and of course plus a final 0x00)				
0088+  3B14 CD BF 32    			CALL	Load4bitBlk						;Receiving Name in BuffGetDir, maximum length is maxFLen	
0089+  3B17             			
0090+  3B17 CD E0 09    			CALL	UpdatePath						;Update string for showing Path adding current dir updates
0091+  3B1A D1          			POP		DE
0092+  3B1B             			
0093+  3B1B             		;Here we're in the directory to begin to get pathnumber so go on
0094+  3B1B 43          			LD		B,E								;D=Number of levels to use ... It can be 1..63
0095+  3B1C             FillingPath: 
0096+  3B1C C5          			PUSH	BC
0097+  3B1D             		
0098+  3B1D 3E 0C       			LD		A,CMD_ZX2SD_CD_IX				;Command to change to subdir by Index (IX+1,IX+2)
0099+  3B1F DD 56 01    			LD		D,(IX+1)						;Data1: Low byte of Index			
0100+  3B22 DD 5E 02    			LD		E,(IX+2)						;Data2: High byte of Index
0101+  3B25 37          			SCF										;Carry for send commmand and Long Confirmation
0102+  3B26 CD 76 19    			CALL	ZX2SD_COMMAND					;Send command with Long Confirmation
0103+  3B29             ;			.3		INC IX							;Next level
0104+  3B29             			
0105+  3B29 3E 0D       			LD		A,CMD_ZX2SD_GETDIR
0106+  3B2B CD 04 33    			CALL	SendSerByte						;Command to ask for name of current dir
0107+  3B2E             			
0108+  3B2E 21 46 DB    			LD		HL,BuffGetDir
0109+  3B31 11 00 01    			LD		DE,maxFLen						;last byte have to be always 0x00 so ask for 1 less (max file Length in FAT32 is 255 and of course plus a final 0x00)				
0110+  3B34 CD BF 32    			CALL	Load4bitBlk						;Receiving Name in BuffGetDir, maximum length is maxFLen	
0111+  3B37             			
0112+  3B37 CD E0 09    			CALL	UpdatePath						;Update string for showing Path adding current dir updates
0113+  3B3A             			
0114+  3B3A C1          			POP		BC
0115+  3B3B DD 23       > INC IX							
0115+  3B3D DD 23       > INC IX							
0115+  3B3F DD 23       > INC IX							
0116+  3B41 10 D9       			DJNZ	FillingPath						;Continue filling the path with the num of index required
0117+  3B43             
0118+  3B43             		;Here we have updated the Path and Arduino is located is the last directory
0119+  3B43             		;		so we can jump to update path string in screen and get new listing 
0120+  3B43 C3 7A 00    			JP		GoTo_Dir						;Go to update file names with current dir
0121+  3B46             			
0122+  3B46             	;----------------End of going to previous directory in path		
0123+  3B46             	
0124+  3B46             	;----------------Going to next directory in path		
0125+  3B46             Load_FT_DIRECTORY_GoInto: 
0126+  3B46 11 1F 00    			LD		DE,FILEENTRY_NAME+1				;Skips Name and 0x00
0127+  3B49 19          			ADD		HL,DE							;HL points to required index to get into	
0128+  3B4A             
0129+  3B4A             		;Now we have to go deep inside subdirectories upto the last level
0130+  3B4A 3A 06 DD    			LD		A,(PathIndexLast)				;If here if will be A>0 (1..64)
0131+  3B4D FE 40       			CP		MAXSUBDIRS						;Don't allow more than 64 directories
0132+  3B4F CA 7A 00    			JP		Z,GoTo_Dir
0133+  3B52 3C          			INC		A
0134+  3B53 32 06 DD    			LD		(PathIndexLast),A				;So adding a new index
0135+  3B56 47          			LD		B,A								;Copy to b for DJNZ usage
0136+  3B57 DD 21 43 DC 			LD		IX,PathIndex-3					;PathIndex is Space with 192 bytes: 64 x 3 :Up to 63 directory entre levels (1 byte name len, 2 bytes index)
0137+  3B5B             													;		using -3 as B=A=1 will be for the 1st index
0138+  3B5B 11 03 00    			LD		DE,3							;Length of each entry
0139+  3B5E             GoingDeeperDirectory2: 
0140+  3B5E DD 19       			ADD		IX,DE							;Go to next index (deep)
0141+  3B60 10 FC       			DJNZ	GoingDeeperDirectory2
0142+  3B62             			
0143+  3B62             		;We arrived to IX= Position for the deeper directory (IX+0 is for name len, IX+1/2 for index)
0144+  3B62 7E          			LD		A,(HL)
0145+  3B63 DD 77 01    			LD		(IX+1),A
0146+  3B66 57          			LD		D,A								;Next command Data1: Low byte of Index
0147+  3B67 23          			INC		HL
0148+  3B68 7E          			LD		A,(HL)
0149+  3B69 DD 77 02    			LD		(IX+2),A						;Update index
0150+  3B6C 5F          			LD		E,A								;Next command Data2: High byte of Index
0151+  3B6D             		;Now get filename dir
0152+  3B6D             
0153+  3B6D             				
0154+  3B6D 3E 0C       			LD		A,CMD_ZX2SD_CD_IX				;CD by index as per reg DE
0155+  3B6F 37          			SCF										;Carry for send commmand and Long Confirmation
0156+  3B70 CD 76 19    			CALL	ZX2SD_COMMAND
0157+  3B73             		
0158+  3B73             		
0159+  3B73 3E 0D       			LD		A,CMD_ZX2SD_GETDIR
0160+  3B75 CD 04 33    			CALL	SendSerByte						;Command to ask for name of current dir
0161+  3B78             			
0162+  3B78 21 46 DB    			LD		HL,BuffGetDir
0163+  3B7B 11 00 01    			LD		DE,maxFLen						;last byte have to be always 0x00 so ask for 1 less (max file Length in FAT32 is 255 and of course plus a final 0x00)				
0164+  3B7E CD BF 32    			CALL	Load4bitBlk						;Receiving Name in BuffGetDir, maximum length is maxFLen	
0165+  3B81             			
0166+  3B81 CD E0 09    			CALL	UpdatePath						;Update string for showing Path adding current dir (return with C=Len of Directory Name)
0167+  3B84 DD 71 00    			LD		(IX),C							;Saving C=Len of Directory Name into the current Entry
0168+  3B87             
0169+  3B87             		;Here we have updated the Path and Arduino is located is the last directory
0170+  3B87             		;		so we can jump to update path string in screen and get new listing 
0171+  3B87             		
0172+  3B87 C3 7A 00    			JP		GoTo_Dir						;Go to update file names with current dir
0173+  3B8A             
0174+  3B8A             	;----------------End of going to next  directory in path
0175+  3B8A             	
0176+  3B8A             	
0177+  3B8A             ;Routines to adjust Chapter/Page/Row
0178+  3B8A             
0179+  3B8A             ;SetCurPageOff - Adjust CurPageOff (1..11) as per CurrPages (1..99) so browsing correct page
0180+  3B8A             ;SetCurPageOff_RegA - Adjust CurPageOff (1..11) as per register A
0181+  3B8A             SetCurPageOff: 
0182+  3B8A 3A 1B 9C    			LD		A,(CurrPages)
0183+  3B8D             
0184+  3B8D             SetCurPageOff_RegA: 
0185+  3B8D 47          			LD		B,A								;Times to count for CurPageOff
0186+  3B8E 3E E9       			LD		A,-FilesPerPag
0187+  3B90             UpdateCurPageOff_Loop: 
0188+  3B90 C6 17       			ADD		FilesPerPag
0189+  3B92 10 FC       			DJNZ	UpdateCurPageOff_Loop
0189+  3B94             			
0190+  3B94              
0191+  3B94 32 35 DD    			LD		(CurPageOff),A
0192+  3B97 C9          			RET
0193+  3B98             
0975   3B98             PEB: 	
0976   3B98             
0977   3B98             ReturnTOBASIC: 
0978   3B98             		include "resources/ZXBasic.asm"
0001+  3B98             ;Lauch ZX Basic
0002+  3B98             
0003+  3B98 21 A5 3B    		LD		HL,BasicROM
0004+  3B9B 11 00 80    		LD		DE,ScratchRAM
0005+  3B9E 01 18 00    		LD		BC,ENDBasicROM-BasicROM
0006+  3BA1 D5          		PUSH	DE
0007+  3BA2 ED B0       		LDIR
0008+  3BA4 C9          		RET
0009+  3BA5             		
0010+  3BA5             BasicROM: 
0011+  3BA5             		DISP	ScratchRAM
0012+  8000             		
0013+  8000 AF          		XOR 	A
0014+  8001 01 FD 1F    		LD		BC,#1FFD
0015+  8004 ED 79       		OUT		(C),A			;If Spectrum type Amstrad (+2A/+2B/+3) then be sure paged #1FFD=0 (as per initial reset)
0016+  8006 06 7F       		LD		B,#7F			;BC=#7FFD
0017+  8008 ED 79       		OUT		(C),A			;be sure paged #7FFD=0 (as per initial reset)
0018+  800A 06 22       		LD		B,34			;locked internal spectrum rom
0019+  800C             		SLOT_B
0019+  800C 23          >.slot_b		INC HL
0019+  800D 2B          >			DEC HL
0019+  800E 32 00 00    >			LD (0),A
0019+  8011 10 F9       >			DJNZ .slot_b
0020+  8013             		WAIT_B	PAUSELOOPSN
0020+  8013 06 40       >			LD B,value
0020+  8015 10 FE       >.wait_b0	DJNZ .wait_b0
0021+  8017 C7          		RST 	#0				;Jump to address 0 (so launch basic... 48 or 128 as per model)
0022+  8018             		
0023+  8018             		ENT
0024+  3BBD             ENDBasicROM: 
0979   3BBD             ENDReturnTOBASIC: 
0980   3BBD             
0981   3BBD             ;;;;;ADDITIONAL DATA FOR MLD-FOOTER
0982   3BBD             
0983   3BBD             screenzx7: 
0984   3BBD             		incbin "resources/Menu.scr.zx7"
0985   3D8C             screenzx7end: 
0986   3D8C             
0987   3D8C             DataTable: 
0988   3D8C 00          			defb	0
0989   3D8D             ENDDataTable: 
0990   3D8D             DataSize	EQU ENDDataTable-DataTable
0991   3D8D             DataTableE: 
0992   3D8D             
0993   3D8D             
0994   3D8D             	IFDEF SHOWINF
0995   3D8D             		DISPLAY "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
0996   3D8D             		DISPLAY "key_routines.asm: ",/A,showinfKE-showinfKB
0997   3D8D             		DISPLAY "Hardware_table.asm: ",/A,showinfHTE-showinfHTB
0998   3D8D             		DISPLAY "Iconos.asm: ",/A,showinfIE-showinfIB
0999   3D8D             		DISPLAY "4bits_load_relocatable.asm: ",/A,showinf4bE-showinf4bB
1000   3D8D             		DISPLAY "Multiply_eewriter.asm: ",/A,showinfEEE-showinfEEB
1001   3D8D             		DISPLAY "clearrow.asm: ",/A,showinfCE-showinfCB
1002   3D8D             		DISPLAY "browse_dir.asm: ",/A,PEB-PBB
1003   3D8D             		DISPLAY "ZXBasic.asm: ",/A,ENDReturnTOBASIC-ReturnTOBASIC
1004   3D8D             		DISPLAY "Menu.scr.zx7: ",/A,screenzx7end-screenzx7
1005   3D8D             		DISPLAY "DataTable: ",/A,DataTableE-DataTable
1006   3D8D             		DISPLAY "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
1007   3D8D             		DISPLAY "FREE AREA #3000-Footer: ",/A,16362-$
1008   3D8D             		DISPLAY "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
1009   3D8D             	ENDIF
1010   3D8D             
1011   3D8D             ; _      _     ___         ____  ___   ___  _____  ____  ___
1012   3D8D             ;| |\/| | |   | | \  ___  | |_  / / \ / / \  | |  | |_  | |_)
1013   3D8D             ;|_|  | |_|__ |_|_/ |___| |_|   \_\_/ \_\_/  |_|  |_|__ |_| \
1014   3D8D FF          			DEFS	16362-$,#FF		;Fill block up to data required at the end of this MLD slot
1015   3FEA 00          MLDoffset	DEFB	0				;Value to be modified by java generator. Value 0..31 (slot number in which this MLD is)
1016   3FEB 83          MLDtype		DEFB	#83				;#83 = 48k // #88 = 128k // #C8 = +2A
1017   3FEC 00          nsectors	DEFB	0				;Num. of sectors requered for saving special data (0=not used, 1..4=n. sectors)
1018   3FED 00          sector0		DEFB	0				;1st sector for saving data 4Kb (0=not used)
1019   3FEE 00          sector1		DEFB	0				;2nd sector 4k (0=no usado)
1020   3FEF 00          sector2		DEFB	0				;3rd sector 4k (0=no usado)
1021   3FF0 00          sector3		DEFB	0				;4rd sector 4k (0=no usado)
1022   3FF1 8C 3D       			DEFW	DataTable		;Data Table address (relative to 1st slot)
1023   3FF3 01 00       			DEFW	DataSize				;Length of each row of DataTable
1024   3FF5 01 00       			DEFW	(ENDDataTable-DataTable)/DataSize	;Total rows of Data in DataTable
1025   3FF7 00          			DEFB	0				;Slot is in +1 (byte offset in row of Data)
1026   3FF8 BD 3B       			DEFW screenzx7;screenzx7-MENUBEGIN+scroffset		; addr=begin screen zx7 
1027   3FFA CF 01       			DEFW screenzx7end-screenzx7				; size=len screen zx7	
1028   3FFC             
1029   3FFC 4D 4C 44 00 			DEFB	"MLD",0			;MLDn n=version 
1030   4000             
1031   4000             ;Next slot is the Patched ROM for LaunchTAP
1032   4000             			incbin	"../Multiply TAP Gen rom modif/ROMMULTTAP.BIN"
1033   8000             

Value    Label
------ - -----------------------------------------------------------
0x0019   MAXGAMES
0x0009   MaxChapter
0x000B   MaxPageChap
0x0017   MaxFilePage
0x0001   MinRowFiles
0x0017   MaxRowFiles
0x0017   FilesPerPag
0x0002   MinColFiles
0x001E   MaxColFiles
0x0010   Sel_Bar_Len
0x0000   PosRowPath
0x0004   PosColPath
0x003F   MaxColPath
0x003C   MaxLenPath
0x0001   RowPage
0x001A   ColPage
0x001E   FILEENTRY_NAME
0x0022   FILEENTRY_LEN
0x001F X FILEEMPTY
0x0020   FILEINDEX
0x00FD   MAXNFILES
0x0100   maxFLen
0x0007   BorderMenu
0x0040   MAXSUBDIRS
0x0008   PreviewMax
0x0003   PreviewLoadWait
0x00FA   PreviewMaxROM
0xC000   ScreensSCR
0x8000   ScratchRAM
0xDB00   MultiplyVer
0xDB08   PathBuffer
0xDB45   LenPath
0xDB46   BuffGetDir
0xDC46   PathIndex
0xDD06   PathIndexLast
0xDD07   CHK_48K_VAR
0xDD08   BufLines
0xDD1D   MovedLines
0xDD1E   PreviewIX
0xDD20   PreviewFT
0xDD21   PreviewStat
0xDD22   PreviewCnt
0xDD23   PreviewLoad
0xDD24   RepSRC
0xDD26   RepDest
0xDD28   PreviewSP
0xDD2A   LastMove
0xDD2C   TotalB
0xDD2D   PosFiles
0xDD2F   HLPosFiles
0xDD31   SortSP
0xDD33   NumOfFiles
0xDD34   CurPage
0xDD35   CurPageOff
0xDD36   PrevROMPag
0xDD37   PrevROMxPag
0xDD38   PrevROMTime
0xDD39   Rom2Write
0xDD3B   SubMenuOpt
0xBE04   SortBuffer
0x9C48   Buffer
0x9C47   CurRow
0x9C46   AuxCurRow
0x9C45   MaxRow
0x9C44   RowNewPage
0x9C43   CurKey
0x9C42   LastKey
0x9C41   LastKeyTime
0x9C40   KeyToExe
0x9C3F   InfoShown
0x9C33   BufGetInfo
0x9C2A   InfoVersion
0x9C27   TXTNumber
0x9C1E   ROMVersion
0x9C1D   CurrChapter
0x9C1C   LastChapter
0x9C1B   CurrPages
0x9C1A   LastPages
0x9C19   CurrFile
0x9C18   LastFile
0x9C06   ChapTable
0x9C05   MsgDegrad
0x0002   Chap1Chapt
0x0003 X Chap1Pages
0x0004   Chap1LastF
0x000A   Chap1Offset
0x001C X ChapDegrad
0xFFF4   SP_VALUE
0xFFF4   IM2ADDR
0x0078   Selec_Color
0x0038   NoSel_Color
0x0078   Page_Color
0x0019   Time1Val
0x0002   TimesVal
0x0E00   GAMEDATATABADDR
0x3FE0   VINFOTXT
0x8000   RAMAREAPG2
0x8000   TOPRAMMAP
0x7F00   RAM_VARS
0x7F04   SEL_GAME_NUM
0x7F8E   AUTOBOOTCHK
0x3FFF   DANSNAP_PAUSE
0x0040   PAUSELOOPSN
0x0001   CMD_ZX2INO_REQ_ID
0x0002 X CMD_ZX2INO_REQ_RESET
0x0003   CMD_ZX2SD_SETZXTYPE
0x0006 X CMD_ZX2SD_OFWRITE
0x0007 X CMD_ZX2SD_OFWRITE_IX
0x0008 X CMD_ZX2SD_OFREAD
0x0009   CMD_ZX2SD_OFREAD_IX
0x000A   CMD_ZX2SD_CD_ROOT
0x000B X CMD_ZX2SD_CD
0x000C   CMD_ZX2SD_CD_IX
0x000D   CMD_ZX2SD_GETDIR
0x000E   CMD_ZX2SD_LS_RELATIVE
0x000F X CMD_ZX2SD_LS_ABSOLUTE
0x0010   CMD_ZX2SD_SCR
0x0011 X CMD_ZX2SD_Z80_16K
0x0012 X CMD_ZX2SD_Z80_48K
0x0013 X CMD_ZX2SD_Z80_128K
0x0014 X CMD_ZX2SD_SCR_FROM_Z80
0x0016 X CMD_ZX2SD_SNA_48K
0x0017 X CMD_ZX2SD_SNA_128K
0x0018 X CMD_ZX2SD_SCR_FROM_SNA
0x001E   CMD_ZX2SD_GETINFO
0x0020 X CMD_ZX2SD_TAP
0x0021 X CMD_ZX2SD_TAP2
0x0022 X CMD_ZX2SD_TAP_ULA
0x0023   CMD_ZX2SD_SCRTAP
0x0024 X CMD_ZX2SD_TZX
0x0025 X CMD_ZX2SD_TZX2
0x0026 X CMD_ZX2SD_TZX_ULA
0x0028 X CMD_ZX2SD_BINARY_INFO
0x0029 X CMD_ZX2SD_BINARY_DATA
0x0030   CMD_ZX2SD_ROMSETBLK4B
0x0031 X CMD_ZX2SD_ROMSETBLKSER
0x00ED X CMD_PC2AR_ROMSET_TUNNEL
0x00F3 X CMD_PC2AR_ROMSET_TUN2
0x00EF X CMD_PC2AR_BIN_TUNNEL
0x0000   FT_END_DIRECTORY
0x000C   FT_DIRECTORY
0x0010   FT_SCR
0x0011   FT_Z80_16K
0x0012   FT_Z80_48K
0x0013   FT_Z80_128K
0x0014   FT_Z80_SCR
0x0016   FT_SNA_48K
0x0017   FT_SNA_128K
0x0018   FT_SNA_SCR
0x0020   FT_TAP
0x0028   FT_BINARY
0x0030   FT_ROMSET
0x0031   FT_BASIC
0x0034   DANCMD_MULTIPLY
0x0001   DANDAT_MULTIPLY
0x0009   SNAP_HEADER
0x000A   SNAP_CHUNK
0x1874   GetDANMENUData
0x1984   CheckHardware
0x3BBD   screenzx7
0x0988   dzx7_turbo
0x0B19   PreviewInitial
0x001C X Goto_ROOT
0x0A50   InitLines
0x1971   ZX2SD_CD_ROOT
0x002A   Goto_PostROOT
0x0077   Continue
0x003A   TXTClearPath
0x007A   GoTo_Dir
0x0088   GoTo_Chapter
0x3B8A   SetCurPageOff
0x3A9A   ClsFiles
0x16CC   PrintIXText
0x1729   TXTLoading
0x0011   ColIconSel
0x0002   RowDescSel
0x1633   PrintIXText_Spaces
0x00D5   ChapterIX
0x00E1   LoadChapters
0x1976   ZX2SD_COMMAND
0x00F0   LoopGetList
0x32BF   Load4bitBlk
0x0100   EndGetList
0x010D   Chapter0
0x0137   Chapter1
0x0155   NoRootGetList
0x170F   TXTDanPath
0x000D   SizeEndTXTDanPath
0x0153   ShowRootFirst
0x171C   TXTZXPath
0x000D   SizeEndTXTZXPath
0x016C   NoLast
0x016E   SetNumFiles
0x1742   TXTSorting
0x0022   ColOPTSel
0x18C6   Sort
0x017E   Printing_PAGE
0x169E   NumberAtoIX
0x019E   Printing
0x01DC   EndPrinting
0x1276   PrintIcon8x8
0x175A   TXTMaxPageEmpty
0x01F3   ToShowPage
0x1753   TXTPageof
0x01F5   ToShowPage.loop
0x021C   NoShowPage
0x021F   MenuUpdateSelected
0x1679   RowAttr
0x0B0E   PreviewInit
0x022F   MenuWaitChange
0x0A5C   INTLines
0x0B3A   INTpreview
0x3000   ProcessKey
0x048E   ROMSET_SubMenu
0x037D   KeyRIGHT
0x0315   KeyLEFT
0x02EA   KeyDOWN
0x02B9   KeyUP
0x0294   KeyFIRE
0x03DF   KeyROOT
0x0260   AfterCheckKeys
0x027C   PrintIconSel_Loop
0x0285   PrintIconSel
0x1344   PrintIXInfo
0x02B0   CalcFile_End
0x02AA   CalcFile
0x040B   ProcessFIRE
0x02DE   KeyUP_Cont
0x02D7   KeyUP_SomePages
0x0321   KeyLEFT_after
0x02FF   KeyDOWN_MovePages
0x0340   KeyGoLastPage
0x0373   KeyLEFT_Page
0x0346   KeyGoLastPage_Subpage
0x034E   KeyGoLastPage_EndSubpage
0x0354   KeyGoLastPage_SubFile
0x035C   KeyGoLastPage_EndSubFile
0x03D1   LEFT_RIGHT_UPDPage
0x03AA   KeyGo1stPage
0x03C9   KeyRIGHT_Page
0x03FB   KeyROOT_no1st_NoRepaint
0x3AB0   Load_FT_DIRECTORY_GotoParent
0x3B98   ReturnTOBASIC
0x04F4   NextProcessFIRE
0x0443   ROMSET_pre
0x0424   Goto_Dan1stSlot
0x0431   RAMTOINTERNAL
0x0443   ENDRAMTOINTERNAL
0x0433   2>slot_b
0x043C   4.3>wait_b0
0x0458   noROMSETver
0x046B   ROMSET_pre2
0x0026   ColDescSel
0x166B   RowAttrMod
0x179A   TXTROM10
0x177F   TXTROMWRITE
0x0008   TXTROMWRoffNO
0x0488   ROMSET_SM
0x04A6   ROMSET_SubMenuChange
0x04C1   ROMSET_SubMenuEND
0x04B9   ROMSET_SubMenuENTER
0x04A3   ROMSET_SubMenu_Ret
0x332E   Load_FT_ROMSET
0x04C6   ROMSET_SubMenuEND.clear
0x1B27   FT_ROMSET_ENTER
0x1AB7   FT_EMPTY
0x3AA8   Load_FT_DIRECTORY
0x08F0   Load_FT_SCR
0x19B7   Load_FT_TAP
0x0503 X LaunchSnap
0x0040   SNALEN
0x001D   SNA7FFD
0x001E   SNA1FFD
0x001F   SNATYPE
0x0020   SNAAY
0x0200   LENCHUNK
0x8000   ADDRSP
0x7E00   ADDRRAM
0x053A   BeginRAM
0x06CE   EndRAM
0x7F94   DanSnap_Val
0x7F64   CLS_ATTR
0x7F6E   RAMSPAGEDE
0x7F74   RAMSPAGEE
0x7E1E   StartRoutine
0x0531   WAIT_B
0x0534   WAITING
0x7F7C   File_FTYPE
0x7E3D   ENDSNA
0x06CE   LoadBlock
0x7DFD   ADDRSNA
0x7F89   LastHL
0x7F8D   LastDE
0x7F90   LastBC
0x7F7D   LastINT
0x7E6F   noBit7
0x7F7E   LastR
0x7F7F   LastAF
0x7F81   LastSP
0x7EFF   LastBorder
0x7E87   OkBorderLoad
0x7E91 X IM_EndSet
0x7F84   LastPreHL
0x7E9C   HavePUSHDE
0x7F87   LastRET
0x7F10   Table16K
0x7EBD   LoadBlocks
0x7F15   Table48K
0x7F22   Table128K
0x7F43   Table128KShadow
0x7ED7   NowLoadChunk
0x7F75   RAMSPAGEA
0x7EE8   RESTAY128_Loop
0x7F03 X Begin_LaunchSAV
0x07DC   LaunchSAVESECT
0x7F06   End_LaunchSAV
0x7EA0   ENDRAMSECTOR
0x1A5C   ReenableButtons
0x7E9E   PAYLOAD_addr
0x06DE   SLOT0_TOGAME
0x003E   CHK
0x7F7B X DanSnap
0x7F81 X LastRoutine
0x7F8C X LasftFast
0x7F94   EndLastRoutine
0x06D1   LoadBlockDirect1Par
0x32D4   SendSerByteLC
0x06D4 X LoadBlockDirect
0x3304   SendSerByte
0x06E3   11.10.9>slot_b
0x06EC   13.12.10.9>wait_b0
0x06F0   14.10.9>slot_b
0x06F9   16.15.10.9>wait_b0
0x06FC   17.10.9>slot_b
0x0705   19.18.10.9>wait_b0
0x070A   SLOT0_TOGAME.mypauselong
0x071A   22.21.20>slot_b
0x0723   24.23.21.20>wait_b0
0x0727   25.21.20>slot_b
0x0730   27.26.21.20>wait_b0
0x0734   28.21.20>slot_b
0x073D   30.29.21.20>wait_b0
0x0748 X FINALLoad4bitBlk
0x0749   FINALLoopByte
0x0749   FINALLoopFor1
0x0751   FINALLoopFor0
0x0782   LocaRET_Loop
0x0798   RetValid
0x0796   RetValid2
0x079C   32.31>slot_b
0x07A5   34.33.31>wait_b0
0x07A9   35.31>slot_b
0x07B2   37.36.31>wait_b0
0x07B6   38.31>slot_b
0x07BF   40.39.31>wait_b0
0x07CC   setIM1
0x07D1   setDI
0x7E00   RAMSECTOR
0x0850   SECROUTINES
0x08F0   ENDSECROUTINES
0x3FEA   MLDoffset
0x7E9D   LAUNCH_MyCurMLD
0x0811   AfterErase
0x07FD   Loop32
0x0800   Loop8
0x0809   LastBitActive
0x0804 X BitIs1
0x081F   SaveZone
0x080E X EraseSecExe
0x7E00   EraseSectorRegE
0x7E5E   WriteValueRegE
0x082B   AfterWriteLocByte
0x0840   LoopWriteBytes
0x7E02   42.41>slot_b
0x7E0B   44.43.41>wait_b0
0x7E0F   45.41>slot_b
0x7E18   47.46.41>wait_b0
0x7E1B   48.41>slot_b
0x7E24   50.49.41>wait_b0
0x2000   ScratchSECT
0x7E29 X LaunchSECTOR_ERASE
0x7E2E   52.51>wait_b0
0x1555   J5555
0x2AAA   J2AAA
0x7E4A   LaunchSECTOR_ERASE_loop
0x7E4E   LaunchRet_Slot
0x7E52   53>slot_b
0x7E5B   55.54>wait_b0
0x7E60   57.56>slot_b
0x7E69   59.58.56>wait_b0
0x7E6D   60.56>slot_b
0x7E76   62.61.56>wait_b0
0x7E79   63.56>slot_b
0x7E82   65.64.56>wait_b0
0x7E84 X SECTOR_WRITE1BYTE
0x7E89   67.66>wait_b0
0x08F0   LB
0x0011   PreviewSHOWING
0x08FF   FullLoad
0x0974   Swap_Screen
0x093B   WaitNKey1st
0x0942   WaitN2Key1st
0x094A   WaitKey
0x095B   WaitNKey
0x0962   WaitN2Key
0x096A X Load_FT_SCR_END
0x097D   Swapping
0x0988   LE
0x0988   showinfdzxB
0x098A   dzx7t_copy_byte_loop
0x098C   dzx7t_main_loop
0x09DC   dzx7t_load_bits
0x0997   dzx7t_len_size_loop
0x09AB   dzx7t_len_value_start
0x09A1   dzx7t_len_value_loop
0x09D8   dzx7t_exit
0x09CF   dzx7t_offset_end
0x09E0   showinfdzxE
0x09E0   PB
0x09E0   UpdatePath
0x09E9 X Fill_NoRoot
0x09EB   UpdatePath_Locate0
0x09F2   UpdatePath_Pos0
0x0A17   UpdatePath_NewLess60
0x0A03   UpdatePath_NewGE60
0x0A10 X UpdatePath_NoMaxLen
0x0A4E   EndUpdatePath
0x0A30   PathCopy
0x0A36   AfterCopy
0x0A50   PE
0x0A50   WB
0x0AF9   PosLines
0x0B0E   EndPosLines
0x0A7A   MovingLines
0x0007   LineLENDATA
0x0005   LineCnt
0x0006   LineMXC
0x0002   LineDir
0x0AC6   LinesToLeft
0x0000   LineAdd
0x0A9F   LoopLines
0x0AAF   LoopLines_a
0x0001   LineVal
0x0004   LineMax
0x0AF8   End_Lines
0x0AD2   LoopLines_b
0x0AE2   LoopLines_c
0x0003   LineMin
0x0B00   PosLine2
0x0B07 X PosLine3
0x0B0E   WE
0x0B0E   PBP
0x0008   PreviewRow
0x0010   PreviewCol
0x000C   UsedRows
0x0014   LastRow
0x5AA0   HLRow
0xD800   SCRAttr
0x00D8   SRC1TH
0x00D9   SRC2TH
0x00DA X SRC3TH
0x00C0 X SRC1PX
0x00C8   SRC2PX
0x00D0   SRC3PX
0x01B0   SCR_BLKSIZE
0x0012   PreviewROMSET
0x0013   PreviewROMDone
0x0B1C   PreviewInit_NoHadPreview
0x12E8   MiniScreenCloud
0x0C94   TableMove
0x1528   PrintMyROMSET
0x0B87   Preview_Show
0x0B70   INTpreview_NoFirst
0x0B85   Preview_Busy
0x0B6A X INTpreview_Open
0x0B98   Preview_ExitZ
0x0B9A   Preview_Subload
0x0BB7   LoopRoutine
0x0BA4   Preview_Subload_Loop
0x0BB1   BeginRoutine
0x165B   XYtoAttr
0x0BD0 X PreviewScreen
0x0BDB   Loop1
0x0BEC   BucleAttr
0x0C15   SrcThird
0x0C29   BucleAttr_EndThird
0x0C2D   BuclePOPU
0x0C50 X NextRow
0x0C61   BuclePix_EndThird
0x0C75   BuclePix_EndYThird
0x0C87 X EndPaint
0x0D05   PEP
0x0D05   Charset8x4
0x1065   Charset8x4END
0x1065   IMB
0x1065   Init_IM2
0x1100   FalseIM2Table
0x1201   ROMFalseIM2
0x1075   Spare_IM2
0x120D   GetMultiplyVer
0x1216   GetMultiplyVer_Loop
0x1219   GetMultiplyVer_Loop.loopB
0x1239   GetMultiplyCheck_Retry
0x125F   GetMultiplyCheck
0x1761   TXTNOMultiply
0x124A   GetMultiplyVer_Game
0x1258   GetMultiplyVer_Loop_Wait
0x1272   MultString
0x1267   GetMultiplyCheck_Loop
0x1A35   DisableButtons
0x1276   IME
0x1276   PBPR
0x0002   RowIconSel
0x0018 X WidthDesc
0x006F   Colour_Cloud
0x004F   Colour_ROMSET
0x317D   Icons
0x002E   IconNext
0x127D   Icon_Loop8x8
0x1284   Icon_Located8x8
0x0025   Icon8x8
0x164C   XYtoAddr
0x1291   PrintIcon8x8_Loop
0x129F   PrintIcon16x16
0x12A5   Icon_Loop16x16
0x12AC   Icon_Located16x16
0x12C8   Print8x16
0x12CA   PrintIcon16x16_Loop
0x12D6   MiniScreenAttrs
0x12DE   PrintClrPreview_Loop
0x12DF   PrintClrPreview2_Loop
0x12F5   MSC_Next
0x12F6   MSC_Scan
0x12F9   MSC_Row
0x1315   MSC_NoThirdChg
0x131A   MiniScreenEmpty
0x1325   MSE_Next
0x1326   MSE_Scan
0x1329   MSE_Row
0x133F   MSE_NoThirdChg
0x134A X PrintFileType
0x1366   PrintFileType_SCR
0x1370   PrintFileType_NoPreview
0x135F   PrintFileType_Z80
0x1369 X PrintFileType_Preview
0x1610   Print_RQ_Preview
0x13AE   ChaptMsg_End
0x13A7   ChaptMsgShown
0x17C0   TXTDEGRA
0x138E   ChaptMsg
0x1818   TXTTOODEGRA
0x1A90   FileTypeTexts
0x0003   FileTypeTexts_Size
0x13BB   PrintFileType_Search
0x13C2   PrintFileType_Found
0x142D   PrintF_NoTAP
0x161C   DO_GetInfo
0x1415   Tap_nopreview
0x1D51   FT_TAP_Program2
0x1D47   FT_TAP_Program
0x17AF   TXTTAPnoScreen
0x15B6   PrintF_NoROMSET
0x144C   Do_ROMSETINFO
0x1462   Do_ROMSETPrint
0x1485   Valid_ROMSE
0x1489   Text_ROMSE
0x1B1A   FT_R_V2
0x1B11   FT_R_V
0x14A8   Valid_Games
0x14CE   PrintGames
0x14AF   TestTens
0x14BA   No_Tens
0x14E0   NoInternalROMSET
0x1516   NoInternalROMSET.nomore
0x151B   PrintMyROMSET_NextPage
0x1535   PMR_Page
0x157A   PMR_Page.nopages
0x177D   TXTROMPage
0x16C0   UnitAtoIX
0x158F   PMR_Page.pages
0x1599   PMR_Page.games
0x159C   PrintGames_ROM_Loop
0x1616   Z80_Unk
0x313E   HW_TS2068
0x160A   PrintF_Z80
0x3088   HW_Table
0x15F2   NoV2
0x15F1   IsV2
0x15FE   HW_Machine
0x1BA3   FT_Z80_V2
0x1B95   FT_Z80_V
0x30BA   HW_Unknown
0x163E   PrintFileType_Spaces
0x1646   PrintFileType_printit
0x1649 X PrintFileType_End
0x169B   RowAttrNo1st
0x16A1   NumberAtoIX_Loop
0x16A8   NumberAtoIX_NoTens
0x16B5   NumberAtoIX_TenIsZero
0x16B7   NumberAtoIX_TenNoZero
0x16D8   CharEven
0x16DC   PrintIXText_Loop
0x16E9   PrintChar
0x16F8   CharLoop
0x170F   PEPR
0x170F   OB
0x178F   TXTROMWRITENO
0x1874   OE
0x1881   GetRDMData
0x8000   RAMRDMData
0x18C6   ENDGetRDMData
0x8044   GetRDMData_MLD
0x8009   74>slot_b
0x8012   76.75>wait_b0
0x8028   ValidDanMENU
0x8034   GetRDMData_Rt
0x8038   77>slot_b
0x8041   79.78>wait_b0
0x18C6   SBS
0x18E5   FillupSort
0x18E8   Sort_Fillup
0x18F5   Sort_EndFillup
0x1912   Sort_NoDirsEntries
0x1948   SortIY
0x191E X FillupSort2
0x1921   Sort_Fillup2
0x192D   Sort_EndFillup2
0x1943   Sort_NoFilesEntries
0x194B   SortIY2
0x1950   Sort_sorting
0x1954   Sort_sorting_Loop
0x1962   Sort_NoSwap
0x195C X Sort_Swap
0x196F   Sort_Dir_Ending
0x1971   SES
0x1971   SB
0x1984   SE
0x1984   showinfHB
0x19AD   CheckHardware_Set
0x19B7   showinfHE
0x19B7 X Launch_TAP
0x1A65   ReenableButtonsA
0x1A00   BEGINTAP
0x8000   TAPRAM
0x1A35   ENDTAP
0x19F8   80>slot_b
0x8002   82.81>wait_b0
0x8006   86.85.84.83>slot_b
0x800F   88.87.85.84.83>wait_b0
0x8013   89.85.84.83>slot_b
0x801C   91.90.85.84.83>wait_b0
0x8020   92.85.84.83>slot_b
0x8029   94.93.85.84.83>wait_b0
0x802E   95>pauselong
0x1A35   ldtapE
0x1A35   showinfSB
0x1A6D   SENDSPCMDLC
0x1A84   SENDNRCMD
0x1A6D   showinfSE
0x1A6D   showinfHWB
0x1A7C   SENDSPCMD
0x1A70 X LONGSPCONF
0x1A75   PAUSELCONF
0x1A84   SENDNRCMD.slot_b
0x1A8D   SENDNRCMD.loop_b
0x1A90   showinfHWE
0x1A90   showinfFB
0x1AD0   FT_NONE
0x1ADC   FT_DIRECTORY_text
0x1CF0   FT_SCR_text
0x1B73   FT_Z80_16K_text
0x1BBC   FT_Z80_48K_text
0x1C05   FT_Z80_128K_text
0x1C4F   FT_SNA_48K_text
0x1C9F   FT_SNA_128K_text
0x1D2D   FT_TAP_text
0x1D6A   FT_BINARY_text
0x1B02   FT_ROMSET_text
0x1B42   FT_BASIC_text
0x1AD0 X FT_EMPTY_last
0x1DA6   showinfFE
0x3000   showinfKB
0x301D   NoJoy
0x3083   JoyTable
0x3010   JoyTest
0x3031   KeyToJoy
0x305E   KeyTable
0x3022   WaitForKeys_Loop
0x3042   TestKey
0x3038   ReKey
0x3048 X Rep_Time
0x3054   Rep_Time_EXE
0x305A   End_Rep_Time
0x3088   showinfKE
0x3088   showinfHTB
0x30C2   HW_48k
0x30C6   HW_48k_IF1
0x30CE   SAMRAM
0x30D5   HW_48k_MGT
0x30DD   HW_128k
0x30E2   HW_128k_IF1
0x30EB   HW_128k_MGT
0x30F4   HW_PLUS3
0x30F4   HW_PLUS3B
0x30FC   HW_PENTAGON
0x3108   HW_SCORPION
0x3114   HW_DIDAKTIC
0x311D   HW_PLUS2
0x3125   HW_PLUS2A
0x312E   HW_TC2048
0x3146   HW_16k
0x314A   HW_16k_IF1
0x3152   SAMRAM16
0x315D   HW_16k_MGT
0x3165   HW_PLUS2_IF1
0x3171   HW_PLUS2_MGT
0x3136 X HW_TC2068
0x317D   showinfHTE
0x317D   showinfIB
0x0001 X Icon16x16
0x3236 X IconNext.BIN16x16
0x32BF   showinfIE
0x32BF   showinf4bB
0x32C0   LoopByte
0x32C0   LoopFor1
0x32C5 X EndLoopFor1
0x32C8   LoopFor0
0x32CD X EndLoopFor0
0x32D6   98.97.96>slot_b
0x32DF   100.99.97.96>wait_b0
0x32E3   101.97.96>slot_b
0x32EC   103.102.97.96>wait_b0
0x32EF   104.97.96>slot_b
0x32F8   106.105.97.96>wait_b0
0x32FD   107>pauselong
0x3306   110.109.108>slot_b
0x330F   112.111.109.108>wait_b0
0x3313   113.109.108>slot_b
0x331C   115.114.109.108>wait_b0
0x331F   116.109.108>slot_b
0x3328   118.117.109.108>wait_b0
0x332E   EndLoad4bitBlk
0x332E   showinf4bE
0x332E   showinfEEB
0x3651   eew_scr
0x3358   ROMROUTINE
0xF000   RAMROUTINE
0x3651   ENDROMROUTINE
0xF02D   CHECKROMOK
0xF000   TOSBOMB
0xF027   TBPOS
0xF00D   PAINTTB
0xF018   TBDLOCK
0x5841   TOSBOMBATTR
0xF01E   WAIT50ms
0xF02F   120.119>slot_b
0xF038   122.121.119>wait_b0
0xF03C   124.123>slot_b
0xF045   126.125.123>wait_b0
0xF0D8   NBLOCK
0xF30E   RAMSendSerByteLC
0xF05F   BUC
0xF10D   DISPADVANCE
0xF18B   DISPDIGIT
0xF073   BUCLOAD8
0xF146   DISPBAR
0xF33E   RAMSendSerByte
0x6EFD   loadarea
0x8003   loadsize
0xF090 X LOADSERIAL
0xF2F9   RAMLoad4bitBlk
0xF093 X AFTER_LOAD
0xF0BF   LOADERR
0xF0A5   bucCRC
0xF0AB   bucNOCarry
0xF0C2   ALLGOOD
0xF0D9   PROGRAMSECTOR
0xF0D7 X ENDEND
0x5908 X TXTSLOTCOUNTER
0x5A48 X TXTSECTCOUNTER
0xF0DB   BUCPROGRAMSECTOR
0xF244   SECTOR_ERASE
0xF2A3   SECTOR_PROGRAM
0xF10C X cursector
0x000F   RowLine
0x0006   ColLine
0xF111   DISPADVANCE_Nolast
0xF126   DISPADVANCE_ClearPrev
0xF136   CharsLine
0xF12D   Printmichar
0xF13E   CharsArrow
0xF12F   DISPADVANCE_Char
0x0001   BARROW
0xF14A   BUCROWS
0x0018   BARWIDTH
0xF153   DISPLASTROW
0x0004   BARCOL
0xF16B   DISPBAR1
0xF177   DISPNOPEND
0x0047   COLPEND
0xF187   DISPBARCOL
0xF17E   DISPNOLOAD
0x0046   COLLOAD
0xF185   DISPNOWRIT
0x0042   COLWRIT
0x0044   COLFINI
0x5824 X BARATTR
0xF226   ZONE6X5
0x002D   DIGIOFF
0xF244   ENDZONE
0xF1EE   TABLEDIGITS
0xF19D   LOOKTABLEDIGITS
0xF1FE   TABLEATTRS
0xF1A6   DISPSEGMENT
0xF1CA   THISSEGMEND
0xF1AC   THISSEGM
0xF1C3   NOTSEGMENT
0xF1BF   NOHIGH
0x0029   DIGICOLOR
0xF1D4   ENDTHISSEGM
0x59B9   DIGIATTR
0xF1DE   BUCPAINTATTR
0xF2EE   ADDR_SECTOR
0xF24A   131.130.129.128>slot_b
0xF253   133.132.130.129.128>wait_b0
0xF257   134.130.129.128>slot_b
0xF260   136.135.130.129.128>wait_b0
0xF263   137.130.129.128>slot_b
0xF26C   139.138.130.129.128>wait_b0
0xF273   141.140>wait_b0
0xF275 X SE_Step1
0xF27A X SE_Step2
0xF27E X SE_Step3
0xF283 X SE_Step4
0xF288 X SE_Step5
0xF28C X SE_Step6
0xF28F   SECTOR_ERASE_loop
0xF295   Ret_Slot
0xF297   143.142>slot_b
0xF2A0   145.144.142>wait_b0
0xF2A9   149.148.147.146>slot_b
0xF2B2   151.150.148.147.146>wait_b0
0xF2B6   152.148.147.146>slot_b
0xF2BF   154.153.148.147.146>wait_b0
0xF2C2   155.148.147.146>slot_b
0xF2CB   157.156.148.147.146>wait_b0
0xF2D2   159.158>wait_b0
0xF2D4   SECTLP
0xF2D9 X PB_Step2
0xF2DD X PB_Step3
0xF2E2 X PB_Step4
0xF2F9   LastRAMRoutine
0x3A66   showinfEEE
0x3A66   showinfCB
0x3A66   ClearRow
0x3A88   Pix_Loop_Zero
0x3A9C   ClsFiles_Loop
0x3AA8   showinfCE
0x3AA8   PBB
0x3B46   Load_FT_DIRECTORY_GoInto
0x3ACD   GoingDeeperDirectory
0x3AD7   LoopMoreRoom
0x3AE3   NoMoreRoom
0x3B08   NoSkipLevels
0x3AF1   SkipLevels
0x3B1C   FillingPath
0x3B5E   GoingDeeperDirectory2
0x3B8D X SetCurPageOff_RegA
0x3B90   UpdateCurPageOff_Loop
0x3B98   PEB
0x3BA5   BasicROM
0x3BBD   ENDBasicROM
0x800C   160>slot_b
0x8015   162.161>wait_b0
0x3BBD   ENDReturnTOBASIC
0x3D8C   screenzx7end
0x3D8C   DataTable
0x3D8D   ENDDataTable
0x0001   DataSize
0x3D8D   DataTableE
0x3FEB X MLDtype
0x3FEC X nsectors
0x3FED X sector0
0x3FEE X sector1
0x3FEF X sector2
0x3FF0 X sector3
