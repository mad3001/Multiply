00001   0000                     DEFINE  autocarga	;For Autoload ROM
00002   0000             		DEFINE  nocheckram	;Does not execute ram checking
00003   0000             OVERALL_COLOURS	EQU	%00111111		;White paper, black ink for loading
00004   0000             LOADBORDER		EQU	%00001001		; Border White, does not touch bits for EAR/MIC, not required
00005   0000              
00006   0000             ;************************************************************************
00007   0000             ;** An Assembly File Listing to generate a 16K ROM for the ZX Spectrum **
00008   0000             ;************************************************************************
00009   0000             
00010   0000             ; -------------------------
00011   0000             ; Last updated: 13-DEC-2004
00012   0000             ; -------------------------
00013   0000             
00014   0000             ; TASM cross-assembler directives. 
00015   0000             ; ( comment out, perhaps, for other assemblers - see Notes at end.)
00016   0000             	IF (1=0)
00017   0000~            #define DEFB .BYTE      
00018   0000~            #define DEFW .WORD
00019   0000~            #define DEFM .TEXT
00020   0000~            #define ORG  .ORG
00021   0000~            #define EQU  .EQU
00022   0000~            #define equ  .EQU
00023   0000             	ENDIF
00024   0000             ;   It is always a good idea to anchor, using ORGs, important sections such as 
00025   0000             ;   the character bitmaps so that they don't move as code is added and removed.
00026   0000             
00027   0000             ;   Generally most approaches try to maintain main entry points as they are
00028   0000             ;   often used by third-party software. 
00029   0000             
00030   0000             		ORG 0000
00031   0000             	;;IFDEF autocarga
00032   0000             	;;	output "48k_AUTOLOAD.rom"
00033   0000             	;;ELSE
00034   0000             		output "48k.rom"
00035   0000             	;;ENDIF
00036   0000             
00037   0000             	IFDEF nocheckram
00038   0000             HLclrPAG	EQU		#FE	;Apparently is enough clearing from #4000-#CDCD, anyway will clear upto #FEFE
00039   0000             HLfrom		EQU		(HLclrPAG<<8)+(HLclrPAG)+1
00040   0000             BCfrom		EQU		HLfrom -#4000
00041   0000             	ELSE
00042   0000~            HLfrom		EQU		$FFFF
00043   0000~            	
00044   0000             	ENDIF
00045   0000             ;*****************************************
00046   0000             ;** Part 1. RESTART ROUTINES AND TABLES **
00047   0000             ;*****************************************
00048   0000             
00049   0000             ; -----------
00050   0000             ; THE 'START'
00051   0000             ; -----------
00052   0000             ;   At switch on, the Z80 chip is in Interrupt Mode 0.
00053   0000             ;   The Spectrum uses Interrupt Mode 1.
00054   0000             ;   This location can also be 'called' to reset the machine.
00055   0000             ;   Typically with PRINT USR 0.
00056   0000             
00057   0000             ;; START
00058   0000 F3          L0000:   DI                      ; Disable Interrupts.
00059   0001 AF                  XOR     A               ; Signal coming from START.
00060   0002                   IFDEF autocarga
00061   0002 21 FF FE    		LD      HL,HLfrom       ; Set pointer to top of possible physical RAM.
00062   0005 C3 C8 11            JP      L11C8           ; Jump forward to common code at START-NEW.
00063   0008                   ELSE
00064   0008~            		LD      DE,$FFFF     ; Set pointer to top of possible physical RAM.
00065   0008~                    JP      L11CB           ; Jump forward to common code at START-NEW.
00066   0008                   ENDIF
00067   0008             
00068   0008             ; -------------------
00069   0008             ; THE 'ERROR' RESTART
00070   0008             ; -------------------
00071   0008             ;   The error pointer is made to point to the position of the error to enable
00072   0008             ;   the editor to highlight the error position if it occurred during syntax 
00073   0008             ;   checking.  It is used at 37 places in the program.  An instruction fetch 
00074   0008             ;   on address $0008 may page in a peripheral ROM such as the Sinclair 
00075   0008             ;   Interface 1 or Disciple Disk Interface.  This was not an original design 
00076   0008             ;   concept and not all errors pass through here.
00077   0008             
00078   0008             ;; ERROR-1
00079   0008 2A 5D 5C    L0008:   LD      HL,($5C5D)      ; Fetch the character address from CH_ADD.
00080   000B 22 5F 5C            LD      ($5C5F),HL      ; Copy it to the error pointer X_PTR.
00081   000E 18 43               JR      L0053           ; Forward to continue at ERROR-2.
00082   0010             
00083   0010             ; -----------------------------
00084   0010             ; THE 'PRINT CHARACTER' RESTART
00085   0010             ; -----------------------------
00086   0010             ;   The A register holds the code of the character that is to be sent to
00087   0010             ;   the output stream of the current channel.  The alternate register set is 
00088   0010             ;   used to output a character in the A register so there is no need to 
00089   0010             ;   preserve any of the current main registers (HL, DE, BC).  
00090   0010             ;   This restart is used 21 times.
00091   0010             
00092   0010             ;; PRINT-A
00093   0010 C3 F2 15    L0010:   JP      L15F2           ; Jump forward to continue at PRINT-A-2.
00094   0013             
00095   0013             ; ---
00096   0013             
00097   0013 FF FF FF            DEFB    $FF, $FF, $FF   ; Five unused locations.
00098   0016 FF FF               DEFB    $FF, $FF        ;
00099   0018             
00100   0018             ; -------------------------------
00101   0018             ; THE 'COLLECT CHARACTER' RESTART
00102   0018             ; -------------------------------
00103   0018             ;   The contents of the location currently addressed by CH_ADD are fetched.
00104   0018             ;   A return is made if the value represents a character that has
00105   0018             ;   relevance to the BASIC parser. Otherwise CH_ADD is incremented and the
00106   0018             ;   tests repeated. CH_ADD will be addressing somewhere -
00107   0018             ;   1) in the BASIC program area during line execution.
00108   0018             ;   2) in workspace if evaluating, for example, a string expression.
00109   0018             ;   3) in the edit buffer if parsing a direct command or a new BASIC line.
00110   0018             ;   4) in workspace if accepting input but not that from INPUT LINE.
00111   0018             
00112   0018             ;; GET-CHAR
00113   0018 2A 5D 5C    L0018:   LD      HL,($5C5D)      ; fetch the address from CH_ADD.
00114   001B 7E                  LD      A,(HL)          ; use it to pick up current character.
00115   001C             
00116   001C             ;; TEST-CHAR
00117   001C CD 7D 00    L001C:   CALL    L007D           ; routine SKIP-OVER tests if the character is
00118   001F                                             ; relevant.
00119   001F D0                  RET     NC              ; Return if it is significant.
00120   0020             
00121   0020             ; ------------------------------------
00122   0020             ; THE 'COLLECT NEXT CHARACTER' RESTART
00123   0020             ; ------------------------------------
00124   0020             ;   As the BASIC commands and expressions are interpreted, this routine is
00125   0020             ;   called repeatedly to step along the line.  It is used 83 times.
00126   0020             
00127   0020             ;; NEXT-CHAR
00128   0020 CD 74 00    L0020:   CALL    L0074           ; routine CH-ADD+1 fetches the next immediate
00129   0023                                             ; character.
00130   0023 18 F7               JR      L001C           ; jump back to TEST-CHAR until a valid
00131   0025                                             ; character is found.
00132   0025             
00133   0025             ; ---
00134   0025             
00135   0025 FF FF FF            DEFB    $FF, $FF, $FF   ; unused
00136   0028             
00137   0028             ; -----------------------
00138   0028             ; THE 'CALCULATE' RESTART
00139   0028             ; -----------------------
00140   0028             ;   This restart enters the Spectrum's internal, floating-point, stack-based, 
00141   0028             ;   FORTH-like language.
00142   0028             ;   It is further used recursively from within the calculator.
00143   0028             ;   It is used on 77 occasions.
00144   0028             
00145   0028             ;; FP-CALC
00146   0028 C3 5B 33    L0028:   JP      L335B           ; jump forward to the CALCULATE routine.
00147   002B             
00148   002B             ; ---
00149   002B             
00150   002B FF FF FF            DEFB    $FF, $FF, $FF   ; spare - note that on the ZX81, space being a 
00151   002E FF FF               DEFB    $FF, $FF        ; little cramped, these same locations were
00152   0030                                             ; used for the five-byte end-calc literal.
00153   0030             
00154   0030             ; ------------------------------
00155   0030             ; THE 'CREATE BC SPACES' RESTART
00156   0030             ; ------------------------------
00157   0030             ;   This restart is used on only 12 occasions to create BC spaces
00158   0030             ;   between workspace and the calculator stack.
00159   0030             
00160   0030             ;; BC-SPACES
00161   0030 C5          L0030:   PUSH    BC              ; Save number of spaces.
00162   0031 2A 61 5C            LD      HL,($5C61)      ; Fetch WORKSP.
00163   0034 E5                  PUSH    HL              ; Save address of workspace.
00164   0035 C3 9E 16            JP      L169E           ; Jump forward to continuation code RESERVE.
00165   0038             
00166   0038             ; --------------------------------
00167   0038             ; THE 'MASKABLE INTERRUPT' ROUTINE
00168   0038             ; --------------------------------
00169   0038             ;   This routine increments the Spectrum's three-byte FRAMES counter fifty 
00170   0038             ;   times a second (sixty times a second in the USA ).
00171   0038             ;   Both this routine and the called KEYBOARD subroutine use the IY register 
00172   0038             ;   to access system variables and flags so a user-written program must 
00173   0038             ;   disable interrupts to make use of the IY register.
00174   0038             
00175   0038             ;; MASK-INT
00176   0038 F5          L0038:   PUSH    AF              ; Save the registers that will be used but not
00177   0039 E5                  PUSH    HL              ; the IY register unfortunately.
00178   003A 2A 78 5C            LD      HL,($5C78)      ; Fetch the first two bytes at FRAMES1.
00179   003D 23                  INC     HL              ; Increment lowest two bytes of counter.
00180   003E 22 78 5C            LD      ($5C78),HL      ; Place back in FRAMES1.
00181   0041 7C                  LD      A,H             ; Test if the result was zero.
00182   0042 B5                  OR      L               ;            
00183   0043 20 03               JR      NZ,L0048        ; Forward, if not, to KEY-INT
00184   0045             
00185   0045 FD 34 40            INC     (IY+$40)        ; otherwise increment FRAMES3 the third byte.
00186   0048             
00187   0048             ;   Now save the rest of the main registers and read and decode the keyboard.
00188   0048             
00189   0048             ;; KEY-INT
00190   0048 C5          L0048:   PUSH    BC              ; Save the other main registers.
00191   0049 D5                  PUSH    DE              ;                 
00192   004A             
00193   004A CD BF 02            CALL    L02BF           ; Routine KEYBOARD executes a stage in the 
00194   004D                                             ; process of reading a key-press.
00195   004D D1                  POP     DE              ;
00196   004E C1                  POP     BC              ; Restore registers.
00197   004F             
00198   004F E1                  POP     HL              ;
00199   0050 F1                  POP     AF              ;
00200   0051             
00201   0051 FB                  EI                      ; Enable Interrupts.
00202   0052 C9                  RET                     ; Return.
00203   0053             
00204   0053             ; ---------------------
00205   0053             ; THE 'ERROR-2' ROUTINE
00206   0053             ; ---------------------
00207   0053             ;   A continuation of the code at 0008.
00208   0053             ;   The error code is stored and after clearing down stacks, an indirect jump 
00209   0053             ;   is made to MAIN-4, etc. to handle the error.
00210   0053             
00211   0053             ;; ERROR-2
00212   0053 E1          L0053:   POP     HL              ; drop the return address - the location
00213   0054                                             ; after the RST 08H instruction.
00214   0054 6E                  LD      L,(HL)          ; fetch the error code that follows.
00215   0055                                             ; (nice to see this instruction used.)
00216   0055             
00217   0055             ;   Note. this entry point is used when out of memory at REPORT-4.
00218   0055             ;   The L register has been loaded with the report code but X-PTR is not
00219   0055             ;   updated.
00220   0055             
00221   0055             ;; ERROR-3
00222   0055 FD 75 00    L0055:   LD      (IY+$00),L      ; Store it in the system variable ERR_NR.
00223   0058 ED 7B 3D 5C         LD      SP,($5C3D)      ; ERR_SP points to an error handler on the
00224   005C                                             ; machine stack. There may be a hierarchy
00225   005C                                             ; of routines.
00226   005C                                             ; To MAIN-4 initially at base.
00227   005C                                             ; or REPORT-G on line entry.
00228   005C                                             ; or  ED-ERROR when editing.
00229   005C                                             ; or   ED-FULL during ed-enter.
00230   005C                                             ; or  IN-VAR-1 during runtime input etc.
00231   005C             
00232   005C C3 C5 16            JP      L16C5           ; Jump to SET-STK to clear the calculator stack 
00233   005F                                             ; and reset MEM to usual place in the systems 
00234   005F                                             ; variables area and then indirectly to MAIN-4, 
00235   005F                                             ; etc.
00236   005F             
00237   005F             ; ---
00238   005F             
00239   005F FF FF FF            DEFB    $FF, $FF, $FF   ; Unused locations
00240   0062 FF FF FF            DEFB    $FF, $FF, $FF   ; before the fixed-position
00241   0065 FF                  DEFB    $FF             ; NMI routine.
00242   0066             
00243   0066             ; ------------------------------------
00244   0066             ; THE 'NON-MASKABLE INTERRUPT' ROUTINE
00245   0066             ; ------------------------------------
00246   0066             ;   
00247   0066             ;   There is no NMI switch on the standard Spectrum or its peripherals.
00248   0066             ;   When the NMI line is held low, then no matter what the Z80 was doing at 
00249   0066             ;   the time, it will now execute the code at 66 Hex.
00250   0066             ;   This Interrupt Service Routine will jump to location zero if the contents 
00251   0066             ;   of the system variable NMIADD are zero or return if the location holds a
00252   0066             ;   non-zero address.   So attaching a simple switch to the NMI as in the book 
00253   0066             ;   "Spectrum Hardware Manual" causes a reset.  The logic was obviously 
00254   0066             ;   intended to work the other way.  Sinclair Research said that, since they
00255   0066             ;   had never advertised the NMI, they had no plans to fix the error "until 
00256   0066             ;   the opportunity arose".
00257   0066             ;   
00258   0066             ;   Note. The location NMIADD was, in fact, later used by Sinclair Research 
00259   0066             ;   to enhance the text channel on the ZX Interface 1.
00260   0066             ;   On later Amstrad-made Spectrums, and the Brazilian Spectrum, the logic of 
00261   0066             ;   this routine was indeed reversed but not as at first intended.
00262   0066             ;
00263   0066             ;   It can be deduced by looking elsewhere in this ROM that the NMIADD system
00264   0066             ;   variable pointed to L121C and that this enabled a Warm Restart to be 
00265   0066             ;   performed at any time, even while playing machine code games, or while 
00266   0066             ;   another Spectrum has been allowed to gain control of this one. 
00267   0066             ;
00268   0066             ;   Software houses would have been able to protect their games from attack by
00269   0066             ;   placing two zeros in the NMIADD system variable.
00270   0066             
00271   0066             ;; RESET
00272   0066 F5          L0066:   PUSH    AF              ; save the
00273   0067 E5                  PUSH    HL              ; registers.
00274   0068 2A B0 5C            LD      HL,($5CB0)      ; fetch the system variable NMIADD.
00275   006B 7C                  LD      A,H             ; test address
00276   006C B5                  OR      L               ; for zero.
00277   006D             
00278   006D 20 01               JR      NZ,L0070        ; skip to NO-RESET if NOT ZERO
00279   006F             
00280   006F E9                  JP      (HL)            ; jump to routine ( i.e. L0000 )
00281   0070             
00282   0070             ;; NO-RESET
00283   0070 E1          L0070:   POP     HL              ; restore the
00284   0071 F1                  POP     AF              ; registers.
00285   0072 ED 45               RETN                    ; return to previous interrupt state.
00286   0074             
00287   0074             ; ---------------------------
00288   0074             ; THE 'CH ADD + 1' SUBROUTINE
00289   0074             ; ---------------------------
00290   0074             ;   This subroutine is called from RST 20, and three times from elsewhere
00291   0074             ;   to fetch the next immediate character following the current valid character
00292   0074             ;   address and update the associated system variable.
00293   0074             ;   The entry point TEMP-PTR1 is used from the SCANNING routine.
00294   0074             ;   Both TEMP-PTR1 and TEMP-PTR2 are used by the READ command routine.
00295   0074             
00296   0074             ;; CH-ADD+1
00297   0074 2A 5D 5C    L0074:   LD      HL,($5C5D)      ; fetch address from CH_ADD.
00298   0077             
00299   0077             ;; TEMP-PTR1
00300   0077 23          L0077:   INC     HL              ; increase the character address by one.
00301   0078             
00302   0078             ;; TEMP-PTR2
00303   0078 22 5D 5C    L0078:   LD      ($5C5D),HL      ; update CH_ADD with character address.
00304   007B             
00305   007B 7E          X007B:   LD      A,(HL)          ; load character to A from HL.
00306   007C C9                  RET                     ; and return.
00307   007D             
00308   007D             ; --------------------------
00309   007D             ; THE 'SKIP OVER' SUBROUTINE
00310   007D             ; --------------------------
00311   007D             ;   This subroutine is called once from RST 18 to skip over white-space and
00312   007D             ;   other characters irrelevant to the parsing of a BASIC line etc. .
00313   007D             ;   Initially the A register holds the character to be considered
00314   007D             ;   and HL holds its address which will not be within quoted text
00315   007D             ;   when a BASIC line is parsed.
00316   007D             ;   Although the 'tab' and 'at' characters will not appear in a BASIC line,
00317   007D             ;   they could be present in a string expression, and in other situations.
00318   007D             ;   Note. although white-space is usually placed in a program to indent loops
00319   007D             ;   and make it more readable, it can also be used for the opposite effect and
00320   007D             ;   spaces may appear in variable names although the parser never sees them.
00321   007D             ;   It is this routine that helps make the variables 'Anum bEr5 3BUS' and
00322   007D             ;   'a number 53 bus' appear the same to the parser.
00323   007D             
00324   007D             ;; SKIP-OVER
00325   007D FE 21       L007D:   CP      $21             ; test if higher than space.
00326   007F D0                  RET     NC              ; return with carry clear if so.
00327   0080             
00328   0080 FE 0D               CP      $0D             ; carriage return ?
00329   0082 C8                  RET     Z               ; return also with carry clear if so.
00330   0083             
00331   0083                                             ; all other characters have no relevance
00332   0083                                             ; to the parser and must be returned with
00333   0083                                             ; carry set.
00334   0083             
00335   0083 FE 10               CP      $10             ; test if 0-15d
00336   0085 D8                  RET     C               ; return, if so, with carry set.
00337   0086             
00338   0086 FE 18               CP      $18             ; test if 24-32d
00339   0088 3F                  CCF                     ; complement carry flag.
00340   0089 D8                  RET     C               ; return with carry set if so.
00341   008A             
00342   008A                                             ; now leaves 16d-23d
00343   008A             
00344   008A 23                  INC     HL              ; all above have at least one extra character
00345   008B                                             ; to be stepped over.
00346   008B             
00347   008B FE 16               CP      $16             ; controls 22d ('at') and 23d ('tab') have two.
00348   008D 38 01               JR      C,L0090         ; forward to SKIPS with ink, paper, flash,
00349   008F                                             ; bright, inverse or over controls.
00350   008F                                             ; Note. the high byte of tab is for RS232 only.
00351   008F                                             ; it has no relevance on this machine.
00352   008F             
00353   008F 23                  INC     HL              ; step over the second character of 'at'/'tab'.
00354   0090             
00355   0090             ;; SKIPS
00356   0090 37          L0090:   SCF                     ; set the carry flag
00357   0091 22 5D 5C            LD      ($5C5D),HL      ; update the CH_ADD system variable.
00358   0094 C9                  RET                     ; return with carry set.
00359   0095             
00360   0095             
00361   0095             ; ------------------
00362   0095             ; THE 'TOKEN' TABLES
00363   0095             ; ------------------
00364   0095             ;   The tokenized characters 134d (RND) to 255d (COPY) are expanded using
00365   0095             ;   this table. The last byte of a token is inverted to denote the end of
00366   0095             ;   the word. The first is an inverted step-over byte.
00367   0095             
00368   0095             ;; TKN-TABLE
00369   0095 BF          L0095:   DEFB    '?'+$80
00370   0096 52 4E               DEFM    "RN"
00371   0098 C4                  DEFB    'D'+$80
00372   0099 494E4B4559          DEFM    "INKEY"
00373   009E A4                  DEFB    '$'+$80
00374   009F 50 C9               DEFB    'P','I'+$80
00375   00A1 46 CE               DEFB    'F','N'+$80
00376   00A3 50 4F 49 4E         DEFM    "POIN"
00377   00A7 D4                  DEFB    'T'+$80
00378   00A8                     DEFM    "SCREEN"
00378   00A8 53435245454E
00379   00AE A4                  DEFB    '$'+$80
00380   00AF 41 54 54            DEFM    "ATT"
00381   00B2 D2                  DEFB    'R'+$80
00382   00B3 41 D4               DEFB    'A','T'+$80
00383   00B5 54 41               DEFM    "TA"
00384   00B7 C2                  DEFB    'B'+$80
00385   00B8 56 41 4C            DEFM    "VAL"
00386   00BB A4                  DEFB    '$'+$80
00387   00BC 43 4F 44            DEFM    "COD"
00388   00BF C5                  DEFB    'E'+$80
00389   00C0 56 41               DEFM    "VA"
00390   00C2 CC                  DEFB    'L'+$80
00391   00C3 4C 45               DEFM    "LE"
00392   00C5 CE                  DEFB    'N'+$80
00393   00C6 53 49               DEFM    "SI"
00394   00C8 CE                  DEFB    'N'+$80
00395   00C9 43 4F               DEFM    "CO"
00396   00CB D3                  DEFB    'S'+$80
00397   00CC 54 41               DEFM    "TA"
00398   00CE CE                  DEFB    'N'+$80
00399   00CF 41 53               DEFM    "AS"
00400   00D1 CE                  DEFB    'N'+$80
00401   00D2 41 43               DEFM    "AC"
00402   00D4 D3                  DEFB    'S'+$80
00403   00D5 41 54               DEFM    "AT"
00404   00D7 CE                  DEFB    'N'+$80
00405   00D8 4C CE               DEFB    'L','N'+$80
00406   00DA 45 58               DEFM    "EX"
00407   00DC D0                  DEFB    'P'+$80
00408   00DD 49 4E               DEFM    "IN"
00409   00DF D4                  DEFB    'T'+$80
00410   00E0 53 51               DEFM    "SQ"
00411   00E2 D2                  DEFB    'R'+$80
00412   00E3 53 47               DEFM    "SG"
00413   00E5 CE                  DEFB    'N'+$80
00414   00E6 41 42               DEFM    "AB"
00415   00E8 D3                  DEFB    'S'+$80
00416   00E9 50 45 45            DEFM    "PEE"
00417   00EC CB                  DEFB    'K'+$80
00418   00ED 49 CE               DEFB    'I','N'+$80
00419   00EF 55 53               DEFM    "US"
00420   00F1 D2                  DEFB    'R'+$80
00421   00F2 53 54 52            DEFM    "STR"
00422   00F5 A4                  DEFB    '$'+$80
00423   00F6 43 48 52            DEFM    "CHR"
00424   00F9 A4                  DEFB    '$'+$80
00425   00FA 4E 4F               DEFM    "NO"
00426   00FC D4                  DEFB    'T'+$80
00427   00FD 42 49               DEFM    "BI"
00428   00FF CE                  DEFB    'N'+$80
00429   0100             
00430   0100             ;   The previous 32 function-type words are printed without a leading space
00431   0100             ;   The following have a leading space if they begin with a letter
00432   0100             
00433   0100 4F D2               DEFB    'O','R'+$80
00434   0102 41 4E               DEFM    "AN"
00435   0104 C4                  DEFB    'D'+$80
00436   0105 3C BD               DEFB    $3C,'='+$80             ; <=
00437   0107 3E BD               DEFB    $3E,'='+$80             ; >=
00438   0109 3C BE               DEFB    $3C,$3E+$80             ; <>
00439   010B 4C 49 4E            DEFM    "LIN"
00440   010E C5                  DEFB    'E'+$80
00441   010F 54 48 45            DEFM    "THE"
00442   0112 CE                  DEFB    'N'+$80
00443   0113 54 CF               DEFB    'T','O'+$80
00444   0115 53 54 45            DEFM    "STE"
00445   0118 D0                  DEFB    'P'+$80
00446   0119 4445462046          DEFM    "DEF F"
00447   011E CE                  DEFB    'N'+$80
00448   011F 43 41               DEFM    "CA"
00449   0121 D4                  DEFB    'T'+$80
00450   0122 464F524D41          DEFM    "FORMA"
00451   0127 D4                  DEFB    'T'+$80
00452   0128 4D 4F 56            DEFM    "MOV"
00453   012B C5                  DEFB    'E'+$80
00454   012C 45 52 41 53         DEFM    "ERAS"
00455   0130 C5                  DEFB    'E'+$80
00456   0131 4F50454E20          DEFM    "OPEN "
00457   0136 A3                  DEFB    '#'+$80
00458   0137                     DEFM    "CLOSE "
00458   0137 434C4F534520
00459   013D A3                  DEFB    '#'+$80
00460   013E 4D 45 52 47         DEFM    "MERG"
00461   0142 C5                  DEFB    'E'+$80
00462   0143 5645524946          DEFM    "VERIF"
00463   0148 D9                  DEFB    'Y'+$80
00464   0149 42 45 45            DEFM    "BEE"
00465   014C D0                  DEFB    'P'+$80
00466   014D 434952434C          DEFM    "CIRCL"
00467   0152 C5                  DEFB    'E'+$80
00468   0153 49 4E               DEFM    "IN"
00469   0155 CB                  DEFB    'K'+$80
00470   0156 50 41 50 45         DEFM    "PAPE"
00471   015A D2                  DEFB    'R'+$80
00472   015B 46 4C 41 53         DEFM    "FLAS"
00473   015F C8                  DEFB    'H'+$80
00474   0160 4252494748          DEFM    "BRIGH"
00475   0165 D4                  DEFB    'T'+$80
00476   0166                     DEFM    "INVERS"
00476   0166 494E56455253
00477   016C C5                  DEFB    'E'+$80
00478   016D 4F 56 45            DEFM    "OVE"
00479   0170 D2                  DEFB    'R'+$80
00480   0171 4F 55               DEFM    "OU"
00481   0173 D4                  DEFB    'T'+$80
00482   0174 4C5052494E          DEFM    "LPRIN"
00483   0179 D4                  DEFB    'T'+$80
00484   017A 4C 4C 49 53         DEFM    "LLIS"
00485   017E D4                  DEFB    'T'+$80
00486   017F 53 54 4F            DEFM    "STO"
00487   0182 D0                  DEFB    'P'+$80
00488   0183 52 45 41            DEFM    "REA"
00489   0186 C4                  DEFB    'D'+$80
00490   0187 44 41 54            DEFM    "DAT"
00491   018A C1                  DEFB    'A'+$80
00492   018B                     DEFM    "RESTOR"
00492   018B 524553544F52
00493   0191 C5                  DEFB    'E'+$80
00494   0192 4E 45               DEFM    "NE"
00495   0194 D7                  DEFB    'W'+$80
00496   0195 424F524445          DEFM    "BORDE"
00497   019A D2                  DEFB    'R'+$80
00498   019B                     DEFM    "CONTINU"
00498   019B 434F4E54494E55
00499   01A2 C5                  DEFB    'E'+$80
00500   01A3 44 49               DEFM    "DI"
00501   01A5 CD                  DEFB    'M'+$80
00502   01A6 52 45               DEFM    "RE"
00503   01A8 CD                  DEFB    'M'+$80
00504   01A9 46 4F               DEFM    "FO"
00505   01AB D2                  DEFB    'R'+$80
00506   01AC 47 4F 20 54         DEFM    "GO T"
00507   01B0 CF                  DEFB    'O'+$80
00508   01B1 474F205355          DEFM    "GO SU"
00509   01B6 C2                  DEFB    'B'+$80
00510   01B7 49 4E 50 55         DEFM    "INPU"
00511   01BB D4                  DEFB    'T'+$80
00512   01BC 4C 4F 41            DEFM    "LOA"
00513   01BF C4                  DEFB    'D'+$80
00514   01C0 4C 49 53            DEFM    "LIS"
00515   01C3 D4                  DEFB    'T'+$80
00516   01C4 4C 45               DEFM    "LE"
00517   01C6 D4                  DEFB    'T'+$80
00518   01C7 50 41 55 53         DEFM    "PAUS"
00519   01CB C5                  DEFB    'E'+$80
00520   01CC 4E 45 58            DEFM    "NEX"
00521   01CF D4                  DEFB    'T'+$80
00522   01D0 50 4F 4B            DEFM    "POK"
00523   01D3 C5                  DEFB    'E'+$80
00524   01D4 50 52 49 4E         DEFM    "PRIN"
00525   01D8 D4                  DEFB    'T'+$80
00526   01D9 50 4C 4F            DEFM    "PLO"
00527   01DC D4                  DEFB    'T'+$80
00528   01DD 52 55               DEFM    "RU"
00529   01DF CE                  DEFB    'N'+$80
00530   01E0 53 41 56            DEFM    "SAV"
00531   01E3 C5                  DEFB    'E'+$80
00532   01E4                     DEFM    "RANDOMIZ"
00532   01E4 52414E444F4D495A
00533   01EC C5                  DEFB    'E'+$80
00534   01ED 49 C6               DEFB    'I','F'+$80
00535   01EF 43 4C               DEFM    "CL"
00536   01F1 D3                  DEFB    'S'+$80
00537   01F2 44 52 41            DEFM    "DRA"
00538   01F5 D7                  DEFB    'W'+$80
00539   01F6 43 4C 45 41         DEFM    "CLEA"
00540   01FA D2                  DEFB    'R'+$80
00541   01FB 5245545552          DEFM    "RETUR"
00542   0200 CE                  DEFB    'N'+$80
00543   0201 43 4F 50            DEFM    "COP"
00544   0204 D9                  DEFB    'Y'+$80
00545   0205             
00546   0205             ; ----------------
00547   0205             ; THE 'KEY' TABLES
00548   0205             ; ----------------
00549   0205             ;   These six look-up tables are used by the keyboard reading routine
00550   0205             ;   to decode the key values.
00551   0205             ;
00552   0205             ;   The first table contains the maps for the 39 keys of the standard
00553   0205             ;   40-key Spectrum keyboard. The remaining key [SHIFT $27] is read directly.
00554   0205             ;   The keys consist of the 26 upper-case alphabetic characters, the 10 digit
00555   0205             ;   keys and the space, ENTER and symbol shift key.
00556   0205             ;   Unshifted alphabetic keys have $20 added to the value.
00557   0205             ;   The keywords for the main alphabetic keys are obtained by adding $A5 to
00558   0205             ;   the values obtained from this table.
00559   0205             
00560   0205             ;; MAIN-KEYS
00561   0205 42          L0205:   DEFB    $42             ; B
00562   0206 48                  DEFB    $48             ; H
00563   0207 59                  DEFB    $59             ; Y
00564   0208 36                  DEFB    $36             ; 6
00565   0209 35                  DEFB    $35             ; 5
00566   020A 54                  DEFB    $54             ; T
00567   020B 47                  DEFB    $47             ; G
00568   020C 56                  DEFB    $56             ; V
00569   020D 4E                  DEFB    $4E             ; N
00570   020E 4A                  DEFB    $4A             ; J
00571   020F 55                  DEFB    $55             ; U
00572   0210 37                  DEFB    $37             ; 7
00573   0211 34                  DEFB    $34             ; 4
00574   0212 52                  DEFB    $52             ; R
00575   0213 46                  DEFB    $46             ; F
00576   0214 43                  DEFB    $43             ; C
00577   0215 4D                  DEFB    $4D             ; M
00578   0216 4B                  DEFB    $4B             ; K
00579   0217 49                  DEFB    $49             ; I
00580   0218 38                  DEFB    $38             ; 8
00581   0219 33                  DEFB    $33             ; 3
00582   021A 45                  DEFB    $45             ; E
00583   021B 44                  DEFB    $44             ; D
00584   021C 58                  DEFB    $58             ; X
00585   021D 0E                  DEFB    $0E             ; SYMBOL SHIFT
00586   021E 4C                  DEFB    $4C             ; L
00587   021F 4F                  DEFB    $4F             ; O
00588   0220 39                  DEFB    $39             ; 9
00589   0221 32                  DEFB    $32             ; 2
00590   0222 57                  DEFB    $57             ; W
00591   0223 53                  DEFB    $53             ; S
00592   0224 5A                  DEFB    $5A             ; Z
00593   0225 20                  DEFB    $20             ; SPACE
00594   0226 0D                  DEFB    $0D             ; ENTER
00595   0227 50                  DEFB    $50             ; P
00596   0228 30                  DEFB    $30             ; 0
00597   0229 31                  DEFB    $31             ; 1
00598   022A 51                  DEFB    $51             ; Q
00599   022B 41                  DEFB    $41             ; A
00600   022C             
00601   022C             
00602   022C             ;; E-UNSHIFT
00603   022C             ;  The 26 unshifted extended mode keys for the alphabetic characters.
00604   022C             ;  The green keywords on the original keyboard.
00605   022C E3          L022C:   DEFB    $E3             ; READ
00606   022D C4                  DEFB    $C4             ; BIN
00607   022E E0                  DEFB    $E0             ; LPRINT
00608   022F E4                  DEFB    $E4             ; DATA
00609   0230 B4                  DEFB    $B4             ; TAN
00610   0231 BC                  DEFB    $BC             ; SGN
00611   0232 BD                  DEFB    $BD             ; ABS
00612   0233 BB                  DEFB    $BB             ; SQR
00613   0234 AF                  DEFB    $AF             ; CODE
00614   0235 B0                  DEFB    $B0             ; VAL
00615   0236 B1                  DEFB    $B1             ; LEN
00616   0237 C0                  DEFB    $C0             ; USR
00617   0238 A7                  DEFB    $A7             ; PI
00618   0239 A6                  DEFB    $A6             ; INKEY$
00619   023A BE                  DEFB    $BE             ; PEEK
00620   023B AD                  DEFB    $AD             ; TAB
00621   023C B2                  DEFB    $B2             ; SIN
00622   023D BA                  DEFB    $BA             ; INT
00623   023E E5                  DEFB    $E5             ; RESTORE
00624   023F A5                  DEFB    $A5             ; RND
00625   0240 C2                  DEFB    $C2             ; CHR$
00626   0241 E1                  DEFB    $E1             ; LLIST
00627   0242 B3                  DEFB    $B3             ; COS
00628   0243 B9                  DEFB    $B9             ; EXP
00629   0244 C1                  DEFB    $C1             ; STR$
00630   0245 B8                  DEFB    $B8             ; LN
00631   0246             
00632   0246             
00633   0246             ;; EXT-SHIFT
00634   0246             ;  The 26 shifted extended mode keys for the alphabetic characters.
00635   0246             ;  The red keywords below keys on the original keyboard.
00636   0246 7E          L0246:   DEFB    $7E             ; ~
00637   0247 DC                  DEFB    $DC             ; BRIGHT
00638   0248 DA                  DEFB    $DA             ; PAPER
00639   0249 5C                  DEFB    $5C             ; \
00640   024A B7                  DEFB    $B7             ; ATN
00641   024B 7B                  DEFB    $7B             ; {
00642   024C 7D                  DEFB    $7D             ; }
00643   024D D8                  DEFB    $D8             ; CIRCLE
00644   024E BF                  DEFB    $BF             ; IN
00645   024F AE                  DEFB    $AE             ; VAL$
00646   0250 AA                  DEFB    $AA             ; SCREEN$
00647   0251 AB                  DEFB    $AB             ; ATTR
00648   0252 DD                  DEFB    $DD             ; INVERSE
00649   0253 DE                  DEFB    $DE             ; OVER
00650   0254 DF                  DEFB    $DF             ; OUT
00651   0255 7F                  DEFB    $7F             ; (Copyright character)
00652   0256 B5                  DEFB    $B5             ; ASN
00653   0257 D6                  DEFB    $D6             ; VERIFY
00654   0258 7C                  DEFB    $7C             ; |
00655   0259 D5                  DEFB    $D5             ; MERGE
00656   025A 5D                  DEFB    $5D             ; ]
00657   025B DB                  DEFB    $DB             ; FLASH
00658   025C B6                  DEFB    $B6             ; ACS
00659   025D D9                  DEFB    $D9             ; INK
00660   025E 5B                  DEFB    $5B             ; [
00661   025F D7                  DEFB    $D7             ; BEEP
00662   0260             
00663   0260             
00664   0260             ;; CTL-CODES
00665   0260             ;  The ten control codes assigned to the top line of digits when the shift 
00666   0260             ;  key is pressed.
00667   0260 0C          L0260:   DEFB    $0C             ; DELETE
00668   0261 07                  DEFB    $07             ; EDIT
00669   0262 06                  DEFB    $06             ; CAPS LOCK
00670   0263 04                  DEFB    $04             ; TRUE VIDEO
00671   0264 05                  DEFB    $05             ; INVERSE VIDEO
00672   0265 08                  DEFB    $08             ; CURSOR LEFT
00673   0266 0A                  DEFB    $0A             ; CURSOR DOWN
00674   0267 0B                  DEFB    $0B             ; CURSOR UP
00675   0268 09                  DEFB    $09             ; CURSOR RIGHT
00676   0269 0F                  DEFB    $0F             ; GRAPHICS
00677   026A             
00678   026A             
00679   026A             ;; SYM-CODES
00680   026A             ;  The 26 red symbols assigned to the alphabetic characters of the keyboard.
00681   026A             ;  The ten single-character digit symbols are converted without the aid of
00682   026A             ;  a table using subtraction and minor manipulation. 
00683   026A E2          L026A:   DEFB    $E2             ; STOP
00684   026B 2A                  DEFB    $2A             ; *
00685   026C 3F                  DEFB    $3F             ; ?
00686   026D CD                  DEFB    $CD             ; STEP
00687   026E C8                  DEFB    $C8             ; >=
00688   026F CC                  DEFB    $CC             ; TO
00689   0270 CB                  DEFB    $CB             ; THEN
00690   0271 5E                  DEFB    $5E             ; ^
00691   0272 AC                  DEFB    $AC             ; AT
00692   0273 2D                  DEFB    $2D             ; -
00693   0274 2B                  DEFB    $2B             ; +
00694   0275 3D                  DEFB    $3D             ; =
00695   0276 2E                  DEFB    $2E             ; .
00696   0277 2C                  DEFB    $2C             ; ,
00697   0278 3B                  DEFB    $3B             ; ;
00698   0279 22                  DEFB    $22             ; "
00699   027A C7                  DEFB    $C7             ; <=
00700   027B 3C                  DEFB    $3C             ; <
00701   027C C3                  DEFB    $C3             ; NOT
00702   027D 3E                  DEFB    $3E             ; >
00703   027E C5                  DEFB    $C5             ; OR
00704   027F 2F                  DEFB    $2F             ; /
00705   0280 C9                  DEFB    $C9             ; <>
00706   0281 60                  DEFB    $60             ; pound
00707   0282 C6                  DEFB    $C6             ; AND
00708   0283 3A                  DEFB    $3A             ; :
00709   0284             
00710   0284             ;; E-DIGITS
00711   0284             ;  The ten keywords assigned to the digits in extended mode.
00712   0284             ;  The remaining red keywords below the keys.
00713   0284 D0          L0284:   DEFB    $D0             ; FORMAT
00714   0285 CE                  DEFB    $CE             ; DEF FN
00715   0286 A8                  DEFB    $A8             ; FN
00716   0287 CA                  DEFB    $CA             ; LINE
00717   0288 D3                  DEFB    $D3             ; OPEN #
00718   0289 D4                  DEFB    $D4             ; CLOSE #
00719   028A D1                  DEFB    $D1             ; MOVE
00720   028B D2                  DEFB    $D2             ; ERASE
00721   028C A9                  DEFB    $A9             ; POINT
00722   028D CF                  DEFB    $CF             ; CAT
00723   028E             
00724   028E             
00725   028E             ;*******************************
00726   028E             ;** Part 2. KEYBOARD ROUTINES **
00727   028E             ;*******************************
00728   028E             
00729   028E             ;   Using shift keys and a combination of modes the Spectrum 40-key keyboard
00730   028E             ;   can be mapped to 256 input characters
00731   028E             
00732   028E             ; ---------------------------------------------------------------------------
00733   028E             ;
00734   028E             ;         0     1     2     3     4 -Bits-  4     3     2     1     0
00735   028E             ; PORT                                                                    PORT
00736   028E             ;
00737   028E             ; F7FE  [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]  |  [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 0 ]   EFFE
00738   028E             ;  ^                                   |                                   v
00739   028E             ; FBFE  [ Q ] [ W ] [ E ] [ R ] [ T ]  |  [ Y ] [ U ] [ I ] [ O ] [ P ]   DFFE
00740   028E             ;  ^                                   |                                   v
00741   028E             ; FDFE  [ A ] [ S ] [ D ] [ F ] [ G ]  |  [ H ] [ J ] [ K ] [ L ] [ ENT ] BFFE
00742   028E             ;  ^                                   |                                   v
00743   028E             ; FEFE  [SHI] [ Z ] [ X ] [ C ] [ V ]  |  [ B ] [ N ] [ M ] [sym] [ SPC ] 7FFE
00744   028E             ;  ^     $27                                                 $18           v
00745   028E             ; Start                                                                   End
00746   028E             ;        00100111                                            00011000
00747   028E             ;
00748   028E             ; ---------------------------------------------------------------------------
00749   028E             ;   The above map may help in reading.
00750   028E             ;   The neat arrangement of ports means that the B register need only be
00751   028E             ;   rotated left to work up the left hand side and then down the right
00752   028E             ;   hand side of the keyboard. When the reset bit drops into the carry
00753   028E             ;   then all 8 half-rows have been read. Shift is the first key to be
00754   028E             ;   read. The lower six bits of the shifts are unambiguous.
00755   028E             
00756   028E             ; -------------------------------
00757   028E             ; THE 'KEYBOARD SCANNING' ROUTINE
00758   028E             ; -------------------------------
00759   028E             ;   From keyboard and s-inkey$
00760   028E             ;   Returns 1 or 2 keys in DE, most significant shift first if any
00761   028E             ;   key values 0-39 else 255
00762   028E             
00763   028E             ;; KEY-SCAN
00764   028E 2E 2F       L028E:   LD      L,$2F           ; initial key value
00765   0290                                             ; valid values are obtained by subtracting
00766   0290                                             ; eight five times.
00767   0290 11 FF FF            LD      DE,$FFFF        ; a buffer to receive 2 keys.
00768   0293             
00769   0293 01 FE FE            LD      BC,$FEFE        ; the commencing port address
00770   0296                                             ; B holds 11111110 initially and is also
00771   0296                                             ; used to count the 8 half-rows
00772   0296             ;; KEY-LINE
00773   0296 ED 78       L0296:   IN      A,(C)           ; read the port to A - bits will be reset
00774   0298                                             ; if a key is pressed else set.
00775   0298 2F                  CPL                     ; complement - pressed key-bits are now set
00776   0299 E6 1F               AND     $1F             ; apply 00011111 mask to pick up the
00777   029B                                             ; relevant set bits.
00778   029B             
00779   029B 28 0E               JR      Z,L02AB         ; forward to KEY-DONE if zero and therefore
00780   029D                                             ; no keys pressed in row at all.
00781   029D             
00782   029D 67                  LD      H,A             ; transfer row bits to H
00783   029E 7D                  LD      A,L             ; load the initial key value to A
00784   029F             
00785   029F             ;; KEY-3KEYS
00786   029F 14          L029F:   INC     D               ; now test the key buffer
00787   02A0 C0                  RET     NZ              ; if we have collected 2 keys already
00788   02A1                                             ; then too many so quit.
00789   02A1             
00790   02A1             ;; KEY-BITS
00791   02A1 D6 08       L02A1:   SUB     $08             ; subtract 8 from the key value
00792   02A3                                             ; cycling through key values (top = $27)
00793   02A3                                             ; e.g. 2F>   27>1F>17>0F>07
00794   02A3                                             ;      2E>   26>1E>16>0E>06
00795   02A3 CB 3C               SRL     H               ; shift key bits right into carry.
00796   02A5 30 FA               JR      NC,L02A1        ; back to KEY-BITS if not pressed
00797   02A7                                             ; but if pressed we have a value (0-39d)
00798   02A7             
00799   02A7 53                  LD      D,E             ; transfer a possible previous key to D
00800   02A8 5F                  LD      E,A             ; transfer the new key to E
00801   02A9 20 F4               JR      NZ,L029F        ; back to KEY-3KEYS if there were more
00802   02AB                                             ; set bits - H was not yet zero.
00803   02AB             
00804   02AB             ;; KEY-DONE
00805   02AB 2D          L02AB:   DEC     L               ; cycles 2F>2E>2D>2C>2B>2A>29>28 for
00806   02AC                                             ; each half-row.
00807   02AC CB 00               RLC     B               ; form next port address e.g. FEFE > FDFE
00808   02AE 38 E6               JR      C,L0296         ; back to KEY-LINE if still more rows to do.
00809   02B0             
00810   02B0 7A                  LD      A,D             ; now test if D is still FF ?
00811   02B1 3C                  INC     A               ; if it is zero we have at most 1 key
00812   02B2                                             ; range now $01-$28  (1-40d)
00813   02B2 C8                  RET     Z               ; return if one key or no key.
00814   02B3             
00815   02B3 FE 28               CP      $28             ; is it capsshift (was $27) ?
00816   02B5 C8                  RET     Z               ; return if so.
00817   02B6             
00818   02B6 FE 19               CP      $19             ; is it symbol shift (was $18) ?
00819   02B8 C8                  RET     Z               ; return also
00820   02B9             
00821   02B9 7B                  LD      A,E             ; now test E
00822   02BA 5A                  LD      E,D             ; but first switch
00823   02BB 57                  LD      D,A             ; the two keys.
00824   02BC FE 18               CP      $18             ; is it symbol shift ?
00825   02BE C9                  RET                     ; return (with zero set if it was).
00826   02BF                                             ; but with symbol shift now in D
00827   02BF             
00828   02BF             ; ----------------------
00829   02BF             ; THE 'KEYBOARD' ROUTINE
00830   02BF             ; ----------------------
00831   02BF             ;   Called from the interrupt 50 times a second.
00832   02BF             ;
00833   02BF             
00834   02BF             ;; KEYBOARD
00835   02BF CD 8E 02    L02BF:   CALL    L028E           ; routine KEY-SCAN
00836   02C2 C0                  RET     NZ              ; return if invalid combinations
00837   02C3             
00838   02C3             ;   then decrease the counters within the two key-state maps
00839   02C3             ;   as this could cause one to become free.
00840   02C3             ;   if the keyboard has not been pressed during the last five interrupts
00841   02C3             ;   then both sets will be free.
00842   02C3             
00843   02C3             
00844   02C3 21 00 5C            LD      HL,$5C00        ; point to KSTATE-0
00845   02C6             
00846   02C6             ;; K-ST-LOOP
00847   02C6 CB 7E       L02C6:   BIT     7,(HL)          ; is it free ?  (i.e. $FF)
00848   02C8 20 07               JR      NZ,L02D1        ; forward to K-CH-SET if so
00849   02CA             
00850   02CA 23                  INC     HL              ; address the 5-counter
00851   02CB 35                  DEC     (HL)            ; decrease the counter
00852   02CC 2B                  DEC     HL              ; step back
00853   02CD             
00854   02CD 20 02               JR      NZ,L02D1        ; forward to K-CH-SET if not at end of count
00855   02CF             
00856   02CF 36 FF               LD      (HL),$FF        ; else mark this particular map free.
00857   02D1             
00858   02D1             ;; K-CH-SET
00859   02D1 7D          L02D1:   LD      A,L             ; make a copy of the low address byte.
00860   02D2 21 04 5C            LD      HL,$5C04        ; point to KSTATE-4
00861   02D5                                             ; (ld l,$04 would do)
00862   02D5 BD                  CP      L               ; have both sets been considered ?
00863   02D6 20 EE               JR      NZ,L02C6        ; back to K-ST-LOOP to consider this 2nd set
00864   02D8             
00865   02D8             ;   now the raw key (0-38d) is converted to a main key (uppercase).
00866   02D8             
00867   02D8 CD 1E 03            CALL    L031E           ; routine K-TEST to get main key in A
00868   02DB             
00869   02DB D0                  RET     NC              ; return if just a single shift
00870   02DC             
00871   02DC 21 00 5C            LD      HL,$5C00        ; point to KSTATE-0
00872   02DF BE                  CP      (HL)            ; does the main key code match ?
00873   02E0 28 2E               JR      Z,L0310         ; forward to K-REPEAT if so
00874   02E2             
00875   02E2             ;   if not consider the second key map.
00876   02E2             
00877   02E2 EB                  EX      DE,HL           ; save kstate-0 in de
00878   02E3 21 04 5C            LD      HL,$5C04        ; point to KSTATE-4
00879   02E6 BE                  CP      (HL)            ; does the main key code match ?
00880   02E7 28 27               JR      Z,L0310         ; forward to K-REPEAT if so
00881   02E9             
00882   02E9             ;   having excluded a repeating key we can now consider a new key.
00883   02E9             ;   the second set is always examined before the first.
00884   02E9             
00885   02E9 CB 7E               BIT     7,(HL)          ; is the key map free ?
00886   02EB 20 04               JR      NZ,L02F1        ; forward to K-NEW if so.
00887   02ED             
00888   02ED EB                  EX      DE,HL           ; bring back KSTATE-0
00889   02EE CB 7E               BIT     7,(HL)          ; is it free ?
00890   02F0 C8                  RET     Z               ; return if not.
00891   02F1                                             ; as we have a key but nowhere to put it yet.
00892   02F1             
00893   02F1             ;   continue or jump to here if one of the buffers was free.
00894   02F1             
00895   02F1             ;; K-NEW
00896   02F1 5F          L02F1:   LD      E,A             ; store key in E
00897   02F2 77                  LD      (HL),A          ; place in free location
00898   02F3 23                  INC     HL              ; advance to the interrupt counter
00899   02F4 36 05               LD      (HL),$05        ; and initialize counter to 5
00900   02F6 23                  INC     HL              ; advance to the delay
00901   02F7 3A 09 5C            LD      A,($5C09)       ; pick up the system variable REPDEL
00902   02FA 77                  LD      (HL),A          ; and insert that for first repeat delay.
00903   02FB 23                  INC     HL              ; advance to last location of state map.
00904   02FC             
00905   02FC FD 4E 07            LD      C,(IY+$07)      ; pick up MODE  (3 bytes)
00906   02FF FD 56 01            LD      D,(IY+$01)      ; pick up FLAGS (3 bytes)
00907   0302 E5                  PUSH    HL              ; save state map location
00908   0303                                             ; Note. could now have used, to avoid IY,
00909   0303                                             ; ld l,$41; ld c,(hl); ld l,$3B; ld d,(hl).
00910   0303                                             ; six and two threes of course.
00911   0303             
00912   0303 CD 33 03            CALL    L0333           ; routine K-DECODE
00913   0306             
00914   0306 E1                  POP     HL              ; restore map pointer
00915   0307 77                  LD      (HL),A          ; put the decoded key in last location of map.
00916   0308             
00917   0308             ;; K-END
00918   0308 32 08 5C    L0308:   LD      ($5C08),A       ; update LASTK system variable.
00919   030B FD CB 01 EE         SET     5,(IY+$01)      ; update FLAGS  - signal a new key.
00920   030F C9                  RET                     ; return to interrupt routine.
00921   0310             
00922   0310             ; -----------------------
00923   0310             ; THE 'REPEAT KEY' BRANCH
00924   0310             ; -----------------------
00925   0310             ;   A possible repeat has been identified. HL addresses the raw key.
00926   0310             ;   The last location of the key map holds the decoded key from the first 
00927   0310             ;   context.  This could be a keyword and, with the exception of NOT a repeat 
00928   0310             ;   is syntactically incorrect and not really desirable.
00929   0310             
00930   0310             ;; K-REPEAT
00931   0310 23          L0310:   INC     HL              ; increment the map pointer to second location.
00932   0311 36 05               LD      (HL),$05        ; maintain interrupt counter at 5.
00933   0313 23                  INC     HL              ; now point to third location.
00934   0314 35                  DEC     (HL)            ; decrease the REPDEL value which is used to
00935   0315                                             ; time the delay of a repeat key.
00936   0315             
00937   0315 C0                  RET     NZ              ; return if not yet zero.
00938   0316             
00939   0316 3A 0A 5C            LD      A,($5C0A)       ; fetch the system variable value REPPER.
00940   0319 77                  LD      (HL),A          ; for subsequent repeats REPPER will be used.
00941   031A             
00942   031A 23                  INC     HL              ; advance
00943   031B                                             ;
00944   031B 7E                  LD      A,(HL)          ; pick up the key decoded possibly in another
00945   031C                                             ; context.
00946   031C                                             ; Note. should compare with $A5 (RND) and make
00947   031C                                             ; a simple return if this is a keyword.
00948   031C                                             ; e.g. cp $a5; ret nc; (3 extra bytes)
00949   031C 18 EA               JR      L0308           ; back to K-END
00950   031E             
00951   031E             ; ----------------------
00952   031E             ; THE 'KEY-TEST' ROUTINE
00953   031E             ; ----------------------
00954   031E             ;   also called from s-inkey$
00955   031E             ;   begin by testing for a shift with no other.
00956   031E             
00957   031E             ;; K-TEST
00958   031E 42          L031E:   LD      B,D             ; load most significant key to B
00959   031F                                             ; will be $FF if not shift.
00960   031F 16 00               LD      D,$00           ; and reset D to index into main table
00961   0321 7B                  LD      A,E             ; load least significant key from E
00962   0322 FE 27               CP      $27             ; is it higher than 39d   i.e. FF
00963   0324 D0                  RET     NC              ; return with just a shift (in B now)
00964   0325             
00965   0325 FE 18               CP      $18             ; is it symbol shift ?
00966   0327 20 03               JR      NZ,L032C        ; forward to K-MAIN if not
00967   0329             
00968   0329             ;   but we could have just symbol shift and no other
00969   0329             
00970   0329 CB 78               BIT     7,B             ; is other key $FF (ie not shift)
00971   032B C0                  RET     NZ              ; return with solitary symbol shift
00972   032C             
00973   032C             
00974   032C             ;; K-MAIN
00975   032C 21 05 02    L032C:   LD      HL,L0205        ; address: MAIN-KEYS
00976   032F 19                  ADD     HL,DE           ; add offset 0-38
00977   0330 7E                  LD      A,(HL)          ; pick up main key value
00978   0331 37                  SCF                     ; set carry flag
00979   0332 C9                  RET                     ; return    (B has other key still)
00980   0333             
00981   0333             ; ----------------------------------
00982   0333             ; THE 'KEYBOARD DECODING' SUBROUTINE
00983   0333             ; ----------------------------------
00984   0333             ;   also called from s-inkey$
00985   0333             
00986   0333             ;; K-DECODE
00987   0333 7B          L0333:   LD      A,E             ; pick up the stored main key
00988   0334 FE 3A               CP      $3A             ; an arbitrary point between digits and letters
00989   0336 38 2F               JR      C,L0367         ; forward to K-DIGIT with digits, space, enter.
00990   0338             
00991   0338 0D                  DEC     C               ; decrease MODE ( 0='KLC', 1='E', 2='G')
00992   0339             
00993   0339 FA 4F 03            JP      M,L034F         ; to K-KLC-LET if was zero
00994   033C             
00995   033C 28 03               JR      Z,L0341         ; to K-E-LET if was 1 for extended letters.
00996   033E             
00997   033E             ;   proceed with graphic codes.
00998   033E             ;   Note. should selectively drop return address if code > 'U' ($55).
00999   033E             ;   i.e. abort the KEYBOARD call.
01000   033E             ;   e.g. cp 'V'; jr c,addit; pop af ;pop af ;;addit etc. (6 extra bytes).
01001   033E             ;   (s-inkey$ never gets into graphics mode.)
01002   033E               
01003   033E             ;; addit
01004   033E C6 4F               ADD     A,$4F           ; add offset to augment 'A' to graphics A say.
01005   0340 C9                  RET                     ; return.
01006   0341                                             ; Note. ( but [GRAPH] V gives RND, etc ).
01007   0341             
01008   0341             ; ---
01009   0341             
01010   0341             ;   the jump was to here with extended mode with uppercase A-Z.
01011   0341             
01012   0341             ;; K-E-LET
01013   0341 21 EB 01    L0341:   LD      HL,L022C-$41    ; base address of E-UNSHIFT L022c.
01014   0344                                             ; ( $01EB in standard ROM ).
01015   0344 04                  INC     B               ; test B is it empty i.e. not a shift.
01016   0345 28 03               JR      Z,L034A         ; forward to K-LOOK-UP if neither shift.
01017   0347             
01018   0347 21 05 02            LD      HL,L0246-$41    ; Address: $0205 L0246-$41 EXT-SHIFT base
01019   034A             
01020   034A             ;; K-LOOK-UP
01021   034A 16 00       L034A:   LD      D,$00           ; prepare to index.
01022   034C 19                  ADD     HL,DE           ; add the main key value.
01023   034D 7E                  LD      A,(HL)          ; pick up other mode value.
01024   034E C9                  RET                     ; return.
01025   034F             
01026   034F             ; ---
01027   034F             
01028   034F             ;   the jump was here with mode = 0
01029   034F             
01030   034F             ;; K-KLC-LET
01031   034F 21 29 02    L034F:   LD      HL,L026A-$41    ; prepare base of sym-codes
01032   0352 CB 40               BIT     0,B             ; shift=$27 sym-shift=$18
01033   0354 28 F4               JR      Z,L034A         ; back to K-LOOK-UP with symbol-shift
01034   0356             
01035   0356 CB 5A               BIT     3,D             ; test FLAGS is it 'K' mode (from OUT-CURS)
01036   0358 28 0A               JR      Z,L0364         ; skip to K-TOKENS if so
01037   035A             
01038   035A FD CB 30 5E         BIT     3,(IY+$30)      ; test FLAGS2 - consider CAPS LOCK ?
01039   035E C0                  RET     NZ              ; return if so with main code.
01040   035F             
01041   035F 04                  INC     B               ; is shift being pressed ?
01042   0360                                             ; result zero if not
01043   0360 C0                  RET     NZ              ; return if shift pressed.
01044   0361             
01045   0361 C6 20               ADD     A,$20           ; else convert the code to lower case.
01046   0363 C9                  RET                     ; return.
01047   0364             
01048   0364             ; ---
01049   0364             
01050   0364             ;   the jump was here for tokens
01051   0364             
01052   0364             ;; K-TOKENS
01053   0364 C6 A5       L0364:   ADD     A,$A5           ; add offset to main code so that 'A'
01054   0366                                             ; becomes 'NEW' etc.
01055   0366             
01056   0366 C9                  RET                     ; return.
01057   0367             
01058   0367             ; ---
01059   0367             
01060   0367             ;   the jump was here with digits, space, enter and symbol shift (< $xx)
01061   0367             
01062   0367             ;; K-DIGIT
01063   0367 FE 30       L0367:   CP      $30             ; is it '0' or higher ?
01064   0369 D8                  RET     C               ; return with space, enter and symbol-shift
01065   036A             
01066   036A 0D                  DEC     C               ; test MODE (was 0='KLC', 1='E', 2='G')
01067   036B FA 9D 03            JP      M,L039D         ; jump to K-KLC-DGT if was 0.
01068   036E             
01069   036E 20 19               JR      NZ,L0389        ; forward to K-GRA-DGT if mode was 2.
01070   0370             
01071   0370             ;   continue with extended digits 0-9.
01072   0370             
01073   0370 21 54 02            LD      HL,L0284-$30    ; $0254 - base of E-DIGITS
01074   0373 CB 68               BIT     5,B             ; test - shift=$27 sym-shift=$18
01075   0375 28 D3               JR      Z,L034A         ; to K-LOOK-UP if sym-shift
01076   0377             
01077   0377 FE 38               CP      $38             ; is character '8' ?
01078   0379 30 07               JR      NC,L0382        ; to K-8-&-9 if greater than '7'
01079   037B             
01080   037B D6 20               SUB     $20             ; reduce to ink range $10-$17
01081   037D 04                  INC     B               ; shift ?
01082   037E C8                  RET     Z               ; return if not.
01083   037F             
01084   037F C6 08               ADD     A,$08           ; add 8 to give paper range $18 - $1F
01085   0381 C9                  RET                     ; return
01086   0382             
01087   0382             ; ---
01088   0382             
01089   0382             ;   89
01090   0382             
01091   0382             ;; K-8-&-9
01092   0382 D6 36       L0382:   SUB     $36             ; reduce to 02 and 03  bright codes
01093   0384 04                  INC     B               ; test if shift pressed.
01094   0385 C8                  RET     Z               ; return if not.
01095   0386             
01096   0386 C6 FE               ADD     A,$FE           ; subtract 2 setting carry
01097   0388 C9                  RET                     ; to give 0 and 1    flash codes.
01098   0389             
01099   0389             ; ---
01100   0389             
01101   0389             ;   graphics mode with digits
01102   0389             
01103   0389             ;; K-GRA-DGT
01104   0389 21 30 02    L0389:   LD      HL,L0260-$30    ; $0230 base address of CTL-CODES
01105   038C             
01106   038C FE 39               CP      $39             ; is key '9' ?
01107   038E 28 BA               JR      Z,L034A         ; back to K-LOOK-UP - changed to $0F, GRAPHICS.
01108   0390             
01109   0390 FE 30               CP      $30             ; is key '0' ?
01110   0392 28 B6               JR      Z,L034A         ; back to K-LOOK-UP - changed to $0C, delete.
01111   0394             
01112   0394             ;   for keys '0' - '7' we assign a mosaic character depending on shift.
01113   0394             
01114   0394 E6 07               AND     $07             ; convert character to number. 0 - 7.
01115   0396 C6 80               ADD     A,$80           ; add offset - they start at $80
01116   0398             
01117   0398 04                  INC     B               ; destructively test for shift
01118   0399 C8                  RET     Z               ; and return if not pressed.
01119   039A             
01120   039A EE 0F               XOR     $0F             ; toggle bits becomes range $88-$8F
01121   039C C9                  RET                     ; return.
01122   039D             
01123   039D             ; ---
01124   039D             
01125   039D             ;   now digits in 'KLC' mode
01126   039D             
01127   039D             ;; K-KLC-DGT
01128   039D 04          L039D:   INC     B               ; return with digit codes if neither
01129   039E C8                  RET     Z               ; shift key pressed.
01130   039F             
01131   039F CB 68               BIT     5,B             ; test for caps shift.
01132   03A1             
01133   03A1 21 30 02            LD      HL,L0260-$30    ; prepare base of table CTL-CODES.
01134   03A4 20 A4               JR      NZ,L034A        ; back to K-LOOK-UP if shift pressed.
01135   03A6             
01136   03A6             ;   must have been symbol shift
01137   03A6             
01138   03A6 D6 10               SUB     $10             ; for ASCII most will now be correct
01139   03A8                                             ; on a standard typewriter.
01140   03A8             
01141   03A8 FE 22               CP      $22             ; but '@' is not - see below.
01142   03AA 28 06               JR      Z,L03B2         ; forward to K-@-CHAR if so
01143   03AC             
01144   03AC FE 20               CP      $20             ; '_' is the other one that fails
01145   03AE C0                  RET     NZ              ; return if not.
01146   03AF             
01147   03AF 3E 5F               LD      A,$5F           ; substitute ASCII '_'
01148   03B1 C9                  RET                     ; return.
01149   03B2             
01150   03B2             ; ---
01151   03B2             
01152   03B2             ;; K-@-CHAR
01153   03B2 3E 40       L03B2:   LD      A,$40           ; substitute ASCII '@'
01154   03B4 C9                  RET                     ; return.
01155   03B5             
01156   03B5             
01157   03B5             ; ------------------------------------------------------------------------
01158   03B5             ;   The Spectrum Input character keys. One or two are abbreviated.
01159   03B5             ;   From $00 Flash 0 to $FF COPY. The routine above has decoded all these.
01160   03B5             
01161   03B5             ;  | 00 Fl0| 01 Fl1| 02 Br0| 03 Br1| 04 In0| 05 In1| 06 CAP| 07 EDT|
01162   03B5             ;  | 08 LFT| 09 RIG| 0A DWN| 0B UP | 0C DEL| 0D ENT| 0E SYM| 0F GRA|
01163   03B5             ;  | 10 Ik0| 11 Ik1| 12 Ik2| 13 Ik3| 14 Ik4| 15 Ik5| 16 Ik6| 17 Ik7|
01164   03B5             ;  | 18 Pa0| 19 Pa1| 1A Pa2| 1B Pa3| 1C Pa4| 1D Pa5| 1E Pa6| 1F Pa7|
01165   03B5             ;  | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
01166   03B5             ;  | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
01167   03B5             ;  | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
01168   03B5             ;  | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
01169   03B5             ;  | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
01170   03B5             ;  | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
01171   03B5             ;  | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
01172   03B5             ;  | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
01173   03B5             ;  | 60  £ | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
01174   03B5             ;  | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
01175   03B5             ;  | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
01176   03B5             ;  | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F  © |
01177   03B5             ;  | 80 128| 81 129| 82 130| 83 131| 84 132| 85 133| 86 134| 87 135|
01178   03B5             ;  | 88 136| 89 137| 8A 138| 8B 139| 8C 140| 8D 141| 8E 142| 8F 143|
01179   03B5             ;  | 90 [A]| 91 [B]| 92 [C]| 93 [D]| 94 [E]| 95 [F]| 96 [G]| 97 [H]|
01180   03B5             ;  | 98 [I]| 99 [J]| 9A [K]| 9B [L]| 9C [M]| 9D [N]| 9E [O]| 9F [P]|
01181   03B5             ;  | A0 [Q]| A1 [R]| A2 [S]| A3 [T]| A4 [U]| A5 RND| A6 IK$| A7 PI |
01182   03B5             ;  | A8 FN | A9 PNT| AA SC$| AB ATT| AC AT | AD TAB| AE VL$| AF COD|
01183   03B5             ;  | B0 VAL| B1 LEN| B2 SIN| B3 COS| B4 TAN| B5 ASN| B6 ACS| B7 ATN|
01184   03B5             ;  | B8 LN | B9 EXP| BA INT| BB SQR| BC SGN| BD ABS| BE PEK| BF IN |
01185   03B5             ;  | C0 USR| C1 ST$| C2 CH$| C3 NOT| C4 BIN| C5 OR | C6 AND| C7 <= |
01186   03B5             ;  | C8 >= | C9 <> | CA LIN| CB THN| CC TO | CD STP| CE DEF| CF CAT|
01187   03B5             ;  | D0 FMT| D1 MOV| D2 ERS| D3 OPN| D4 CLO| D5 MRG| D6 VFY| D7 BEP|
01188   03B5             ;  | D8 CIR| D9 INK| DA PAP| DB FLA| DC BRI| DD INV| DE OVR| DF OUT|
01189   03B5             ;  | E0 LPR| E1 LLI| E2 STP| E3 REA| E4 DAT| E5 RES| E6 NEW| E7 BDR|
01190   03B5             ;  | E8 CON| E9 DIM| EA REM| EB FOR| EC GTO| ED GSB| EE INP| EF LOA|
01191   03B5             ;  | F0 LIS| F1 LET| F2 PAU| F3 NXT| F4 POK| F5 PRI| F6 PLO| F7 RUN|
01192   03B5             ;  | F8 SAV| F9 RAN| FA IF | FB CLS| FC DRW| FD CLR| FE RET| FF CPY|
01193   03B5             
01194   03B5             ;   Note that for simplicity, Sinclair have located all the control codes
01195   03B5             ;   below the space character.
01196   03B5             ;   ASCII DEL, $7F, has been made a copyright symbol.
01197   03B5             ;   Also $60, '`', not used in BASIC but used in other languages, has been
01198   03B5             ;   allocated the local currency symbol for the relevant country -
01199   03B5             ;    £  in most Spectrums.
01200   03B5             
01201   03B5             ; ------------------------------------------------------------------------
01202   03B5             
01203   03B5             
01204   03B5             ;**********************************
01205   03B5             ;** Part 3. LOUDSPEAKER ROUTINES **
01206   03B5             ;**********************************
01207   03B5             
01208   03B5             ; Documented by Alvin Albrecht.
01209   03B5             
01210   03B5             ; ------------------------------
01211   03B5             ; Routine to control loudspeaker
01212   03B5             ; ------------------------------
01213   03B5             ; Outputs a square wave of given duration and frequency
01214   03B5             ; to the loudspeaker.
01215   03B5             ;   Enter with: DE = #cycles - 1
01216   03B5             ;               HL = tone period as described next
01217   03B5             ;
01218   03B5             ; The tone period is measured in T states and consists of
01219   03B5             ; three parts: a coarse part (H register), a medium part
01220   03B5             ; (bits 7..2 of L) and a fine part (bits 1..0 of L) which
01221   03B5             ; contribute to the waveform timing as follows:
01222   03B5             ;
01223   03B5             ;                          coarse    medium       fine
01224   03B5             ; duration of low  = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
01225   03B5             ; duration of hi   = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
01226   03B5             ; Tp = tone period = 236 + 2048*H + 32*(L>>2) + 8*(L&0x3)
01227   03B5             ;                  = 236 + 2048*H + 8*L = 236 + 8*HL
01228   03B5             ;
01229   03B5             ; As an example, to output five seconds of middle C (261.624 Hz):
01230   03B5             ;   (a) Tone period = 1/261.624 = 3.822ms
01231   03B5             ;   (b) Tone period in T-States = 3.822ms*fCPU = 13378
01232   03B5             ;         where fCPU = clock frequency of the CPU = 3.5MHz
01233   03B5             ;    ©  Find H and L for desired tone period:
01234   03B5             ;         HL = (Tp - 236) / 8 = (13378 - 236) / 8 = 1643 = 0x066B
01235   03B5             ;   (d) Tone duration in cycles = 5s/3.822ms = 1308 cycles
01236   03B5             ;         DE = 1308 - 1 = 0x051B
01237   03B5             ;
01238   03B5             ; The resulting waveform has a duty ratio of exactly 50%.
01239   03B5             ;
01240   03B5             ;
01241   03B5             ;; BEEPER
01242   03B5 F3          L03B5:   DI                      ; Disable Interrupts so they don't disturb timing
01243   03B6 7D                  LD      A,L             ;
01244   03B7 CB 3D               SRL     L               ;
01245   03B9 CB 3D               SRL     L               ; L = medium part of tone period
01246   03BB 2F                  CPL                     ;
01247   03BC E6 03               AND     $03             ; A = 3 - fine part of tone period
01248   03BE 4F                  LD      C,A             ;
01249   03BF 06 00               LD      B,$00           ;
01250   03C1 DD 21 D1 03         LD      IX,L03D1        ; Address: BE-IX+3
01251   03C5 DD 09               ADD     IX,BC           ;   IX holds address of entry into the loop
01252   03C7                                             ;   the loop will contain 0-3 NOPs, implementing
01253   03C7                                             ;   the fine part of the tone period.
01254   03C7 3A 48 5C            LD      A,($5C48)       ; BORDCR
01255   03CA E6 38               AND     $38             ; bits 5..3 contain border colour
01256   03CC 0F                  RRCA                    ; border colour bits moved to 2..0
01257   03CD 0F                  RRCA                    ;   to match border bits on port #FE
01258   03CE 0F                  RRCA                    ;
01259   03CF F6 08               OR       $08            ; bit 3 set (tape output bit on port #FE)
01260   03D1                                             ;   for loud sound output
01261   03D1             ;; BE-IX+3
01262   03D1 00          L03D1:   NOP              ;(4)   ; optionally executed NOPs for small
01263   03D2                                             ;   adjustments to tone period
01264   03D2             ;; BE-IX+2
01265   03D2 00          L03D2:   NOP              ;(4)   ;
01266   03D3             
01267   03D3             ;; BE-IX+1
01268   03D3 00          L03D3:   NOP              ;(4)   ;
01269   03D4             
01270   03D4             ;; BE-IX+0
01271   03D4 04          L03D4:   INC     B        ;(4)   ;
01272   03D5 0C                  INC     C        ;(4)   ;
01273   03D6             
01274   03D6             ;; BE-H&L-LP
01275   03D6 0D          L03D6:   DEC     C        ;(4)   ; timing loop for duration of
01276   03D7 20 FD               JR      NZ,L03D6 ;(12/7);   high or low pulse of waveform
01277   03D9             
01278   03D9 0E 3F               LD      C,$3F    ;(7)   ;
01279   03DB 05                  DEC     B        ;(4)   ;
01280   03DC C2 D6 03            JP      NZ,L03D6 ;(10)  ; to BE-H&L-LP
01281   03DF             
01282   03DF EE 10               XOR     $10      ;(7)   ; toggle output beep bit
01283   03E1 D3 FE               OUT     ($FE),A  ;(11)  ; output pulse
01284   03E3 44                  LD      B,H      ;(4)   ; B = coarse part of tone period
01285   03E4 4F                  LD      C,A      ;(4)   ; save port #FE output byte
01286   03E5 CB 67               BIT     4,A      ;(8)   ; if new output bit is high, go
01287   03E7 20 09               JR      NZ,L03F2 ;(12/7);   to BE-AGAIN
01288   03E9             
01289   03E9 7A                  LD      A,D      ;(4)   ; one cycle of waveform has completed
01290   03EA B3                  OR      E        ;(4)   ;   (low->low). if cycle countdown = 0
01291   03EB 28 09               JR      Z,L03F6  ;(12/7);   go to BE-END
01292   03ED             
01293   03ED 79                  LD      A,C      ;(4)   ; restore output byte for port #FE
01294   03EE 4D                  LD      C,L      ;(4)   ; C = medium part of tone period
01295   03EF 1B                  DEC     DE       ;(6)   ; decrement cycle count
01296   03F0 DD E9               JP      (IX)     ;(8)   ; do another cycle
01297   03F2             
01298   03F2             ;; BE-AGAIN                     ; halfway through cycle
01299   03F2 4D          L03F2:   LD      C,L      ;(4)   ; C = medium part of tone period
01300   03F3 0C                  INC     C        ;(4)   ; adds 16 cycles to make duration of high = duration of low
01301   03F4 DD E9               JP      (IX)     ;(8)   ; do high pulse of tone
01302   03F6             
01303   03F6             ;; BE-END
01304   03F6 FB          L03F6:   EI                      ; Enable Interrupts
01305   03F7 C9                  RET                     ;
01306   03F8             
01307   03F8             
01308   03F8             ; ------------------
01309   03F8             ; THE 'BEEP' COMMAND
01310   03F8             ; ------------------
01311   03F8             ; BASIC interface to BEEPER subroutine.
01312   03F8             ; Invoked in BASIC with:
01313   03F8             ;   BEEP dur, pitch
01314   03F8             ;   where dur   = duration in seconds
01315   03F8             ;         pitch = # of semitones above/below middle C
01316   03F8             ;
01317   03F8             ; Enter with: pitch on top of calculator stack
01318   03F8             ;             duration next on calculator stack
01319   03F8             ;
01320   03F8             ;; beep
01321   03F8 EF          L03F8:   RST     28H             ;; FP-CALC
01322   03F9 31                  DEFB    $31             ;;duplicate                  ; duplicate pitch
01323   03FA 27                  DEFB    $27             ;;int                        ; convert to integer
01324   03FB C0                  DEFB    $C0             ;;st-mem-0                   ; store integer pitch to memory 0
01325   03FC 03                  DEFB    $03             ;;subtract                   ; calculate fractional part of pitch = fp_pitch - int_pitch
01326   03FD 34                  DEFB    $34             ;;stk-data                   ; push constant
01327   03FE EC                  DEFB    $EC             ;;Exponent: $7C, Bytes: 4    ; constant = 0.05762265
01328   03FF 6C 98 1F F5         DEFB    $6C,$98,$1F,$F5 ;;($6C,$98,$1F,$F5)
01329   0403 04                  DEFB    $04             ;;multiply                   ; compute:
01330   0404 A1                  DEFB    $A1             ;;stk-one                    ; 1 + 0.05762265 * fraction_part(pitch)
01331   0405 0F                  DEFB    $0F             ;;addition
01332   0406 38                  DEFB    $38             ;;end-calc                   ; leave on calc stack
01333   0407             
01334   0407 21 92 5C            LD      HL,$5C92        ; MEM-0: number stored here is in 16 bit integer format (pitch)
01335   040A                                             ;   0, 0/FF (pos/neg), LSB, MSB, 0
01336   040A                                             ;   LSB/MSB is stored in two's complement
01337   040A                                             ; In the following, the pitch is checked if it is in the range -128<=p<=127
01338   040A 7E                  LD      A,(HL)          ; First byte must be zero, otherwise
01339   040B A7                  AND     A               ;   error in integer conversion
01340   040C 20 5E               JR      NZ,L046C        ; to REPORT-B
01341   040E             
01342   040E 23                  INC     HL              ;
01343   040F 4E                  LD      C,(HL)          ; C = pos/neg flag = 0/FF
01344   0410 23                  INC     HL              ;
01345   0411 46                  LD      B,(HL)          ; B = LSB, two's complement
01346   0412 78                  LD      A,B             ;
01347   0413 17                  RLA                     ;
01348   0414 9F                  SBC     A,A             ; A = 0/FF if B is pos/neg
01349   0415 B9                  CP      C               ; must be the same as C if the pitch is -128<=p<=127
01350   0416 20 54               JR      NZ,L046C        ; if no, error REPORT-B
01351   0418             
01352   0418 23                  INC     HL              ; if -128<=p<=127, MSB will be 0/FF if B is pos/neg
01353   0419 BE                  CP      (HL)            ; verify this
01354   041A 20 50               JR      NZ,L046C        ; if no, error REPORT-B
01355   041C                                             ; now we know -128<=p<=127
01356   041C 78                  LD      A,B             ; A = pitch + 60
01357   041D C6 3C               ADD     A,$3C           ; if -60<=pitch<=67,
01358   041F F2 25 04            JP      P,L0425         ;   goto BE-i-OK
01359   0422             
01360   0422 E2 6C 04            JP      PO,L046C        ; if pitch <= 67 goto REPORT-B
01361   0425                                             ;   lower bound of pitch set at -60
01362   0425             
01363   0425             ;; BE-I-OK                      ; here, -60<=pitch<=127
01364   0425                                             ; and A=pitch+60 -> 0<=A<=187
01365   0425             
01366   0425 06 FA       L0425:   LD      B,$FA           ; 6 octaves below middle C
01367   0427             
01368   0427             ;; BE-OCTAVE                    ; A=# semitones above 5 octaves below middle C
01369   0427 04          L0427:   INC     B               ; increment octave
01370   0428 D6 0C               SUB     $0C             ; 12 semitones = one octave
01371   042A 30 FB               JR      NC,L0427        ; to BE-OCTAVE
01372   042C             
01373   042C C6 0C               ADD     A,$0C           ; A = # semitones above C (0-11)
01374   042E C5                  PUSH    BC              ; B = octave displacement from middle C, 2's complement: -5<=B<=10
01375   042F 21 6E 04            LD      HL,L046E        ; Address: semi-tone
01376   0432 CD 06 34            CALL    L3406           ; routine LOC-MEM
01377   0435                                             ;   HL = 5*A + $046E
01378   0435 CD B4 33            CALL    L33B4           ; routine STACK-NUM
01379   0438                                             ;   read FP value (freq) from semitone table (HL) and push onto calc stack
01380   0438             
01381   0438 EF                  RST     28H             ;; FP-CALC
01382   0439 04                  DEFB    $04             ;;multiply   mult freq by 1 + 0.0576 * fraction_part(pitch) stacked earlier
01383   043A                                             ;;             thus taking into account fractional part of pitch.
01384   043A                                             ;;           the number 0.0576*frequency is the distance in Hz to the next
01385   043A                                             ;;             note (verify with the frequencies recorded in the semitone
01386   043A                                             ;;             table below) so that the fraction_part of the pitch does
01387   043A                                             ;;             indeed represent a fractional distance to the next note.
01388   043A 38                  DEFB    $38             ;;end-calc   HL points to first byte of fp num on stack = middle frequency to generate
01389   043B             
01390   043B F1                  POP     AF              ; A = octave displacement from middle C, 2's complement: -5<=A<=10
01391   043C 86                  ADD     A,(HL)          ; increase exponent by A (equivalent to multiplying by 2^A)
01392   043D 77                  LD      (HL),A          ;
01393   043E             
01394   043E EF                  RST     28H             ;; FP-CALC
01395   043F C0                  DEFB    $C0             ;;st-mem-0          ; store frequency in memory 0
01396   0440 02                  DEFB    $02             ;;delete            ; remove from calc stack
01397   0441 31                  DEFB    $31             ;;duplicate         ; duplicate duration (seconds)
01398   0442 38                  DEFB    $38             ;;end-calc
01399   0443             
01400   0443 CD 94 1E            CALL    L1E94           ; routine FIND-INT1 ; FP duration to A
01401   0446 FE 0B               CP      $0B             ; if dur > 10 seconds,
01402   0448 30 22               JR      NC,L046C        ;   goto REPORT-B
01403   044A             
01404   044A                     ;;; The following calculation finds the tone period for HL and the cycle count
01405   044A                     ;;; for DE expected in the BEEPER subroutine.  From the example in the BEEPER comments,
01406   044A                     ;;;
01407   044A                     ;;; HL = ((fCPU / f) - 236) / 8 = fCPU/8/f - 236/8 = 437500/f -29.5
01408   044A                     ;;; DE = duration * frequency - 1
01409   044A                     ;;;
01410   044A                     ;;; Note the different constant (30.125) used in the calculation of HL
01411   044A                     ;;; below.  This is probably an error.
01412   044A             
01413   044A EF                  RST     28H             ;; FP-CALC
01414   044B E0                  DEFB    $E0             ;;get-mem-0                 ; push frequency
01415   044C 04                  DEFB    $04             ;;multiply                  ; result1: #cycles = duration * frequency
01416   044D E0                  DEFB    $E0             ;;get-mem-0                 ; push frequency
01417   044E 34                  DEFB    $34             ;;stk-data                  ; push constant
01418   044F 80                  DEFB    $80             ;;Exponent $93, Bytes: 3    ; constant = 437500
01419   0450 43 55 9F 80         DEFB    $43,$55,$9F,$80 ;;($55,$9F,$80,$00)
01420   0454 01                  DEFB    $01             ;;exchange                  ; frequency on top
01421   0455 05                  DEFB    $05             ;;division                  ; 437500 / frequency
01422   0456 34                  DEFB    $34             ;;stk-data                  ; push constant
01423   0457 35                  DEFB    $35             ;;Exponent: $85, Bytes: 1   ; constant = 30.125
01424   0458 71                  DEFB    $71             ;;($71,$00,$00,$00)
01425   0459 03                  DEFB    $03             ;;subtract                  ; result2: tone_period(HL) = 437500 / freq - 30.125
01426   045A 38                  DEFB    $38             ;;end-calc
01427   045B             
01428   045B CD 99 1E            CALL    L1E99           ; routine FIND-INT2
01429   045E C5                  PUSH    BC              ;   BC = tone_period(HL)
01430   045F CD 99 1E            CALL    L1E99           ; routine FIND-INT2, BC = #cycles to generate
01431   0462 E1                  POP     HL              ; HL = tone period
01432   0463 50                  LD      D,B             ;
01433   0464 59                  LD      E,C             ; DE = #cycles
01434   0465 7A                  LD      A,D             ;
01435   0466 B3                  OR      E               ;
01436   0467 C8                  RET     Z               ; if duration = 0, skip BEEP and avoid 65536 cycle
01437   0468                                             ;   boondoggle that would occur next
01438   0468 1B                  DEC     DE              ; DE = #cycles - 1
01439   0469 C3 B5 03            JP      L03B5           ; to BEEPER
01440   046C             
01441   046C             ; ---
01442   046C             
01443   046C             
01444   046C             ;; REPORT-B
01445   046C CF          L046C:   RST     08H             ; ERROR-1
01446   046D 0A                  DEFB    $0A             ; Error Report: Integer out of range
01447   046E             
01448   046E             
01449   046E             
01450   046E             ; ---------------------
01451   046E             ; THE 'SEMI-TONE' TABLE
01452   046E             ; ---------------------
01453   046E             ;
01454   046E             ;   Holds frequencies corresponding to semitones in middle octave.
01455   046E             ;   To move n octaves higher or lower, frequencies are multiplied by 2^n.
01456   046E             
01457   046E             ;; semi-tone         five byte fp         decimal freq     note (middle)
01458   046E 8902D01286  L046E:   DEFB    $89, $02, $D0, $12, $86;  261.625565290         C
01459   0473 890A976075          DEFB    $89, $0A, $97, $60, $75;  277.182631135         C#
01460   0478 8912D5171F          DEFB    $89, $12, $D5, $17, $1F;  293.664768100         D
01461   047D 891B904102          DEFB    $89, $1B, $90, $41, $02;  311.126983881         D#
01462   0482 8924D053CA          DEFB    $89, $24, $D0, $53, $CA;  329.627557039         E
01463   0487 892E9D36B1          DEFB    $89, $2E, $9D, $36, $B1;  349.228231549         F
01464   048C 8938FF493E          DEFB    $89, $38, $FF, $49, $3E;  369.994422674         F#
01465   0491 8943FF6A73          DEFB    $89, $43, $FF, $6A, $73;  391.995436072         G
01466   0496 894FA70054          DEFB    $89, $4F, $A7, $00, $54;  415.304697513         G#
01467   049B 895C000000          DEFB    $89, $5C, $00, $00, $00;  440.000000000         A
01468   04A0 896914F624          DEFB    $89, $69, $14, $F6, $24;  466.163761616         A#
01469   04A5 8976F11005          DEFB    $89, $76, $F1, $10, $05;  493.883301378         B
01470   04AA             
01471   04AA             
01472   04AA             ;   "Music is the hidden mathematical endeavour of a soul unconscious it 
01473   04AA             ;    is calculating" - Gottfried Wilhelm Liebnitz 1646 - 1716
01474   04AA             
01475   04AA             
01476   04AA             ;****************************************
01477   04AA             ;** Part 4. CASSETTE HANDLING ROUTINES **
01478   04AA             ;****************************************
01479   04AA             
01480   04AA             ;   These routines begin with the service routines followed by a single
01481   04AA             ;   command entry point.
01482   04AA             ;   The first of these service routines is a curiosity.
01483   04AA             
01484   04AA             ; -----------------------
01485   04AA             ; THE 'ZX81 NAME' ROUTINE
01486   04AA             ; -----------------------
01487   04AA             ;   This routine fetches a filename in ZX81 format and is not used by the 
01488   04AA             ;   cassette handling routines in this ROM.
01489   04AA             
01490   04AA             ;; zx81-name
01491   04AA CD FB 24    L04AA:   CALL    L24FB           ; routine SCANNING to evaluate expression.
01492   04AD 3A 3B 5C            LD      A,($5C3B)       ; fetch system variable FLAGS.
01493   04B0 87                  ADD     A,A             ; test bit 7 - syntax, bit 6 - result type.
01494   04B1 FA 8A 1C            JP      M,L1C8A         ; to REPORT-C if not string result
01495   04B4                                             ; 'Nonsense in BASIC'.
01496   04B4             
01497   04B4 E1                  POP     HL              ; drop return address.
01498   04B5 D0                  RET     NC              ; return early if checking syntax.
01499   04B6             
01500   04B6 E5                  PUSH    HL              ; re-save return address.
01501   04B7 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH fetches string parameters.
01502   04BA 62                  LD      H,D             ; transfer start of filename
01503   04BB 6B                  LD      L,E             ; to the HL register.
01504   04BC 0D                  DEC     C               ; adjust to point to last character and
01505   04BD F8                  RET     M               ; return if the null string.
01506   04BE                                             ; or multiple of 256!
01507   04BE             
01508   04BE 09                  ADD     HL,BC           ; find last character of the filename.
01509   04BF                                             ; and also clear carry.
01510   04BF CB FE               SET     7,(HL)          ; invert it.
01511   04C1 C9                  RET                     ; return.
01512   04C2             
01513   04C2             ; =========================================
01514   04C2             ;
01515   04C2             ; PORT 254 ($FE)
01516   04C2             ;
01517   04C2             ;                      spk mic { border  }  
01518   04C2             ;          ___ ___ ___ ___ ___ ___ ___ ___ 
01519   04C2             ; PORT    |   |   |   |   |   |   |   |   |
01520   04C2             ; 254     |   |   |   |   |   |   |   |   |
01521   04C2             ; $FE     |___|___|___|___|___|___|___|___|
01522   04C2             ;           7   6   5   4   3   2   1   0
01523   04C2             ;
01524   04C2             
01525   04C2             ; ----------------------------------
01526   04C2             ; Save header and program/data bytes
01527   04C2             ; ----------------------------------
01528   04C2             ;   This routine saves a section of data. It is called from SA-CTRL to save the
01529   04C2             ;   seventeen bytes of header data. It is also the exit route from that routine
01530   04C2             ;   when it is set up to save the actual data.
01531   04C2             ;   On entry -
01532   04C2             ;   HL points to start of data.
01533   04C2             ;   IX points to descriptor.
01534   04C2             ;   The accumulator is set to  $00 for a header, $FF for data.
01535   04C2             
01536   04C2             ;; SA-BYTES
01537   04C2 21 3F 05    L04C2:   LD      HL,L053F        ; address: SA/LD-RET
01538   04C5 E5                  PUSH    HL              ; is pushed as common exit route.
01539   04C6                                             ; however there is only one non-terminal exit 
01540   04C6                                             ; point.
01541   04C6             
01542   04C6 21 80 1F            LD      HL,$1F80        ; a timing constant H=$1F, L=$80
01543   04C9                                             ; inner and outer loop counters
01544   04C9                                             ; a five second lead-in is used for a header.
01545   04C9             
01546   04C9 CB 7F               BIT     7,A             ; test one bit of accumulator.
01547   04CB                                             ; (AND A ?)
01548   04CB 28 03               JR      Z,L04D0         ; skip to SA-FLAG if a header is being saved.
01549   04CD             
01550   04CD             ;   else is data bytes and a shorter lead-in is used.
01551   04CD             
01552   04CD 21 98 0C            LD      HL,$0C98        ; another timing value H=$0C, L=$98.
01553   04D0                                             ; a two second lead-in is used for the data.
01554   04D0             
01555   04D0             
01556   04D0             ;; SA-FLAG
01557   04D0 08          L04D0:   EX      AF,AF			; save flag
01558   04D1 13                  INC     DE              ; increase length by one.
01559   04D2 DD 2B               DEC     IX              ; decrease start.
01560   04D4             
01561   04D4 F3                  DI                      ; disable interrupts
01562   04D5             
01563   04D5 3E 02               LD      A,$02           ; select red for border, microphone bit on.
01564   04D7 47                  LD      B,A             ; also does as an initial slight counter value.
01565   04D8             
01566   04D8             ;; SA-LEADER
01567   04D8 10 FE       L04D8:   DJNZ    L04D8           ; self loop to SA-LEADER for delay.
01568   04DA                                             ; after initial loop, count is $A4 (or $A3)
01569   04DA             
01570   04DA D3 FE               OUT     ($FE),A         ; output byte $02/$0D to tape port.
01571   04DC             
01572   04DC EE 0F               XOR     $0F             ; switch from RED (mic on) to CYAN (mic off).
01573   04DE             
01574   04DE 06 A4               LD      B,$A4           ; hold count. also timed instruction.
01575   04E0             
01576   04E0 2D                  DEC     L               ; originally $80 or $98.
01577   04E1                                             ; but subsequently cycles 256 times.
01578   04E1 20 F5               JR      NZ,L04D8        ; back to SA-LEADER until L is zero.
01579   04E3             
01580   04E3             ;   the outer loop is counted by H
01581   04E3             
01582   04E3 05                  DEC     B               ; decrement count
01583   04E4 25                  DEC     H               ; originally  twelve or thirty-one.
01584   04E5 F2 D8 04            JP      P,L04D8         ; back to SA-LEADER until H becomes $FF
01585   04E8             
01586   04E8             ;   now send a sync pulse. At this stage mic is off and A holds value
01587   04E8             ;   for mic on.
01588   04E8             ;   A sync pulse is much shorter than the steady pulses of the lead-in.
01589   04E8             
01590   04E8 06 2F               LD      B,$2F           ; another short timed delay.
01591   04EA             
01592   04EA             ;; SA-SYNC-1
01593   04EA 10 FE       L04EA:   DJNZ    L04EA           ; self loop to SA-SYNC-1
01594   04EC             
01595   04EC D3 FE               OUT     ($FE),A         ; switch to mic on and red.
01596   04EE 3E 0D               LD      A,$0D           ; prepare mic off - cyan
01597   04F0 06 37               LD      B,$37           ; another short timed delay.
01598   04F2             
01599   04F2             ;; SA-SYNC-2
01600   04F2 10 FE       L04F2:   DJNZ    L04F2           ; self loop to SA-SYNC-2
01601   04F4             
01602   04F4 D3 FE               OUT     ($FE),A         ; output mic off, cyan border.
01603   04F6 01 0E 3B            LD      BC,$3B0E        ; B=$3B time(*), C=$0E, YELLOW, MIC OFF.
01604   04F9             
01605   04F9             ; 
01606   04F9             
01607   04F9 08                  EX      AF,AF			; restore saved flag
01608   04FA                                             ; which is 1st byte to be saved.
01609   04FA             
01610   04FA 6F                  LD      L,A             ; and transfer to L.
01611   04FB                                             ; the initial parity is A, $FF or $00.
01612   04FB C3 07 05            JP      L0507           ; JUMP forward to SA-START     ->
01613   04FE                                             ; the mid entry point of loop.
01614   04FE             
01615   04FE             ; -------------------------
01616   04FE             ;   During the save loop a parity byte is maintained in H.
01617   04FE             ;   the save loop begins by testing if reduced length is zero and if so
01618   04FE             ;   the final parity byte is saved reducing count to $FFFF.
01619   04FE             
01620   04FE             ;; SA-LOOP
01621   04FE 7A          L04FE:   LD      A,D             ; fetch high byte
01622   04FF B3                  OR      E               ; test against low byte.
01623   0500 28 0C               JR      Z,L050E         ; forward to SA-PARITY if zero.
01624   0502             
01625   0502 DD 6E 00            LD      L,(IX+$00)      ; load currently addressed byte to L.
01626   0505             
01627   0505             ;; SA-LOOP-P
01628   0505 7C          L0505:   LD      A,H             ; fetch parity byte.
01629   0506 AD                  XOR     L               ; exclusive or with new byte.
01630   0507             
01631   0507             ; -> the mid entry point of loop.
01632   0507             
01633   0507             ;; SA-START
01634   0507 67          L0507:   LD      H,A             ; put parity byte in H.
01635   0508 3E 01               LD      A,$01           ; prepare blue, mic=on.
01636   050A 37                  SCF                     ; set carry flag ready to rotate in.
01637   050B C3 25 05            JP      L0525           ; JUMP forward to SA-8-BITS            -8->
01638   050E             
01639   050E             ; ---
01640   050E             
01641   050E             ;; SA-PARITY
01642   050E 6C          L050E:   LD      L,H             ; transfer the running parity byte to L and
01643   050F 18 F4               JR      L0505           ; back to SA-LOOP-P 
01644   0511                                             ; to output that byte before quitting normally.
01645   0511             
01646   0511             ; ---
01647   0511             
01648   0511             ;   The entry point to save yellow part of bit.
01649   0511             ;   A bit consists of a period with mic on and blue border followed by 
01650   0511             ;   a period of mic off with yellow border. 
01651   0511             ;   Note. since the DJNZ instruction does not affect flags, the zero flag is 
01652   0511             ;   used to indicate which of the two passes is in effect and the carry 
01653   0511             ;   maintains the state of the bit to be saved.
01654   0511             
01655   0511             ;; SA-BIT-2
01656   0511 79          L0511:   LD      A,C             ; fetch 'mic on and yellow' which is 
01657   0512                                             ; held permanently in C.
01658   0512 CB 78               BIT     7,B             ; set the zero flag. B holds $3E.
01659   0514             
01660   0514             ;   The entry point to save 1 entire bit. For first bit B holds $3B(*).
01661   0514             ;   Carry is set if saved bit is 1. zero is reset NZ on entry.
01662   0514             
01663   0514             ;; SA-BIT-1
01664   0514 10 FE       L0514:   DJNZ    L0514           ; self loop for delay to SA-BIT-1
01665   0516             
01666   0516 30 04               JR      NC,L051C        ; forward to SA-OUT if bit is 0.
01667   0518             
01668   0518             ;   but if bit is 1 then the mic state is held for longer.
01669   0518             
01670   0518 06 42               LD      B,$42           ; set timed delay. (66 decimal)
01671   051A             
01672   051A             ;; SA-SET
01673   051A 10 FE       L051A:   DJNZ    L051A           ; self loop to SA-SET 
01674   051C                                             ; (roughly an extra 66*13 clock cycles)
01675   051C             
01676   051C             ;; SA-OUT
01677   051C D3 FE       L051C:   OUT     ($FE),A         ; blue and mic on OR  yellow and mic off.
01678   051E             
01679   051E 06 3E               LD      B,$3E           ; set up delay
01680   0520 20 EF               JR      NZ,L0511        ; back to SA-BIT-2 if zero reset NZ (first pass)
01681   0522             
01682   0522             ;   proceed when the blue and yellow bands have been output.
01683   0522             
01684   0522 05                  DEC     B               ; change value $3E to $3D.
01685   0523 AF                  XOR     A               ; clear carry flag (ready to rotate in).
01686   0524 3C                  INC     A               ; reset zero flag i.e. NZ.
01687   0525             
01688   0525             ; -8-> 
01689   0525             
01690   0525             ;; SA-8-BITS
01691   0525 CB 15       L0525:   RL      L               ; rotate left through carry
01692   0527                                             ; C<76543210<C  
01693   0527 C2 14 05            JP      NZ,L0514        ; JUMP back to SA-BIT-1 
01694   052A                                             ; until all 8 bits done.
01695   052A             
01696   052A             ;   when the initial set carry is passed out again then a byte is complete.
01697   052A             
01698   052A 1B                  DEC     DE              ; decrease length
01699   052B DD 23               INC     IX              ; increase byte pointer
01700   052D 06 31               LD      B,$31           ; set up timing.
01701   052F             
01702   052F 3E 7F               LD      A,$7F           ; test the space key and
01703   0531 DB FE               IN      A,($FE)         ; return to common exit (to restore border)
01704   0533 1F                  RRA                     ; if a space is pressed
01705   0534 D0                  RET     NC              ; return to SA/LD-RET.   - - >
01706   0535             
01707   0535             ;   now test if byte counter has reached $FFFF.
01708   0535             
01709   0535 7A                  LD      A,D             ; fetch high byte
01710   0536 3C                  INC     A               ; increment.
01711   0537 C2 FE 04            JP      NZ,L04FE        ; JUMP to SA-LOOP if more bytes.
01712   053A             
01713   053A 06 3B               LD      B,$3B           ; a final delay. 
01714   053C             
01715   053C             ;; SA-DELAY
01716   053C 10 FE       L053C:   DJNZ    L053C           ; self loop to SA-DELAY
01717   053E             
01718   053E C9                  RET                     ; return - - >
01719   053F             
01720   053F             ; ------------------------------
01721   053F             ; THE 'SAVE/LOAD RETURN' ROUTINE
01722   053F             ; ------------------------------
01723   053F             ;   The address of this routine is pushed on the stack prior to any load/save
01724   053F             ;   operation and it handles normal completion with the restoration of the
01725   053F             ;   border and also abnormal termination when the break key, or to be more
01726   053F             ;   precise the space key is pressed during a tape operation.
01727   053F             ;
01728   053F             ; - - >
01729   053F             
01730   053F             ;; SA/LD-RET
01731   053F F5          L053F:   PUSH    AF              ; preserve accumulator throughout.
01732   0540 3A 48 5C            LD      A,($5C48)       ; fetch border colour from BORDCR.
01733   0543 E6 38               AND     $38             ; mask off paper bits.
01734   0545 0F                  RRCA                    ; rotate
01735   0546 0F                  RRCA                    ; to the
01736   0547 0F                  RRCA                    ; range 0-7.
01737   0548             
01738   0548 D3 FE               OUT     ($FE),A         ; change the border colour.
01739   054A             
01740   054A 3E 7F               LD      A,$7F           ; read from port address $7FFE the
01741   054C DB FE               IN      A,($FE)         ; row with the space key at outside.
01742   054E              
01743   054E 1F                  RRA                     ; test for space key pressed.
01744   054F FB                  EI                      ; enable interrupts
01745   0550 38 02               JR      C,L0554         ; forward to SA/LD-END if not
01746   0552             
01747   0552             
01748   0552             ;; REPORT-Da
01749   0552 CF          L0552:   RST     08H             ; ERROR-1
01750   0553 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
01751   0554             
01752   0554             ; ---
01753   0554             
01754   0554             ;; SA/LD-END
01755   0554 F1          L0554:   POP     AF              ; restore the accumulator.
01756   0555 C9                  RET                     ; return.
01757   0556             
01758   0556             ; ------------------------------------
01759   0556             ; Load header or block of information
01760   0556             ; ------------------------------------
01761   0556             ;   This routine is used to load bytes and on entry A is set to $00 for a 
01762   0556             ;   header or to $FF for data.  IX points to the start of receiving location 
01763   0556             ;   and DE holds the length of bytes to be loaded. If, on entry the carry flag 
01764   0556             ;   is set then data is loaded, if reset then it is verified.
01765   0556             
01766   0556             ;; LD-BYTES
01767   0556 14          L0556:   INC     D               ; reset the zero flag without disturbing carry.
01768   0557 08                  EX      AF,AF			; preserve entry flags.
01769   0558 15                  DEC     D               ; restore high byte of length.
01770   0559             
01771   0559 F3                  DI                      ; disable interrupts
01772   055A             
01773   055A 3E 09               LD      A,LOADBORDER	; $0F           ; make the border white and mic off.
01774   055C D3 FE               OUT     ($FE),A         ; output to port.
01775   055E             
01776   055E 21 3F 05            LD      HL,L053F        ; Address: SA/LD-RET
01777   0561 E5                  PUSH    HL              ; is saved on stack as terminating routine.
01778   0562             
01779   0562             ;   the reading of the EAR bit (D6) will always be preceded by a test of the 
01780   0562             ;   space key (D0), so store the initial post-test state.
01781   0562             
01782   0562 DB FE               IN      A,($FE)         ; read the ear state - bit 6.
01783   0564 1F                  RRA                     ; rotate to bit 5.
01784   0565 E6 20               AND     $20             ; isolate this bit.
01785   0567 F6 02               OR      $02             ; combine with red border colour.
01786   0569 4F                  LD      C,A             ; and store initial state long-term in C.
01787   056A BF                  CP      A               ; set the zero flag.
01788   056B             
01789   056B             ; 
01790   056B             
01791   056B             ;; LD-BREAK
01792   056B C0          L056B:   RET     NZ              ; return if at any time space is pressed.
01793   056C             
01794   056C             ;; LD-START
01795   056C CD E7 05    L056C:   CALL    L05E7           ; routine LD-EDGE-1
01796   056F 30 FA               JR      NC,L056B        ; back to LD-BREAK with time out and no
01797   0571                                             ; edge present on tape.
01798   0571             
01799   0571             ;   but continue when a transition is found on tape.
01800   0571             
01801   0571 21 15 04            LD      HL,$0415        ; set up 16-bit outer loop counter for 
01802   0574                                             ; approx 1 second delay.
01803   0574             
01804   0574             ;; LD-WAIT
01805   0574 10 FE       L0574:   DJNZ    L0574           ; self loop to LD-WAIT (for 256 times)
01806   0576             
01807   0576 2B                  DEC     HL              ; decrease outer loop counter.
01808   0577 7C                  LD      A,H             ; test for
01809   0578 B5                  OR      L               ; zero.
01810   0579 20 F9               JR      NZ,L0574        ; back to LD-WAIT, if not zero, with zero in B.
01811   057B             
01812   057B             ;   continue after delay with H holding zero and B also.
01813   057B             ;   sample 256 edges to check that we are in the middle of a lead-in section. 
01814   057B             
01815   057B CD E3 05            CALL    L05E3           ; routine LD-EDGE-2
01816   057E 30 EB               JR      NC,L056B        ; back to LD-BREAK
01817   0580                                             ; if no edges at all.
01818   0580             
01819   0580             ;; LD-LEADER
01820   0580 06 9C       L0580:   LD      B,$9C           ; set timing value.
01821   0582 CD E3 05            CALL    L05E3           ; routine LD-EDGE-2
01822   0585 30 E4               JR      NC,L056B        ; back to LD-BREAK if time-out
01823   0587             
01824   0587 3E C6               LD      A,$C6           ; two edges must be spaced apart.
01825   0589 B8                  CP      B               ; compare
01826   058A 30 E0               JR      NC,L056C        ; back to LD-START if too close together for a 
01827   058C                                             ; lead-in.
01828   058C             
01829   058C 24                  INC     H               ; proceed to test 256 edged sample.
01830   058D 20 F1               JR      NZ,L0580        ; back to LD-LEADER while more to do.
01831   058F             
01832   058F             ;   sample indicates we are in the middle of a two or five second lead-in.
01833   058F             ;   Now test every edge looking for the terminal sync signal.
01834   058F             
01835   058F             ;; LD-SYNC
01836   058F 06 C9       L058F:   LD      B,$C9           ; initial timing value in B.
01837   0591 CD E7 05            CALL    L05E7           ; routine LD-EDGE-1
01838   0594 30 D5               JR      NC,L056B        ; back to LD-BREAK with time-out.
01839   0596             
01840   0596 78                  LD      A,B             ; fetch augmented timing value from B.
01841   0597 FE D4               CP      $D4             ; compare 
01842   0599 30 F4               JR      NC,L058F        ; back to LD-SYNC if gap too big, that is,
01843   059B                                             ; a normal lead-in edge gap.
01844   059B             
01845   059B             ;   but a short gap will be the sync pulse.
01846   059B             ;   in which case another edge should appear before B rises to $FF
01847   059B             
01848   059B CD E7 05            CALL    L05E7           ; routine LD-EDGE-1
01849   059E D0                  RET     NC              ; return with time-out.
01850   059F             
01851   059F             ; proceed when the sync at the end of the lead-in is found.
01852   059F             ; We are about to load data so change the border colours.
01853   059F             
01854   059F 79                  LD      A,C             ; fetch long-term mask from C
01855   05A0 EE 03               XOR     $03             ; and make blue/yellow.
01856   05A2             
01857   05A2 4F                  LD      C,A             ; store the new long-term byte.
01858   05A3             
01859   05A3 26 00               LD      H,$00           ; set up parity byte as zero.
01860   05A5 06 B0               LD      B,$B0           ; timing.
01861   05A7 18 1F               JR      L05C8           ; forward to LD-MARKER 
01862   05A9                                             ; the loop mid entry point with the alternate 
01863   05A9                                             ; zero flag reset to indicate first byte 
01864   05A9                                             ; is discarded.
01865   05A9             
01866   05A9             ; --------------
01867   05A9             ;   the loading loop loads each byte and is entered at the mid point.
01868   05A9             
01869   05A9             ;; LD-LOOP
01870   05A9 08          L05A9:   EX      AF,AF			; restore entry flags and type in A.
01871   05AA 20 07               JR      NZ,L05B3        ; forward to LD-FLAG if awaiting initial flag
01872   05AC                                             ; which is to be discarded.
01873   05AC             
01874   05AC 30 0F               JR      NC,L05BD        ; forward to LD-VERIFY if not to be loaded.
01875   05AE             
01876   05AE DD 75 00            LD      (IX+$00),L      ; place loaded byte at memory location.
01877   05B1 18 0F               JR      L05C2           ; forward to LD-NEXT
01878   05B3             
01879   05B3             ; ---
01880   05B3             
01881   05B3             ;; LD-FLAG
01882   05B3 CB 11       L05B3:   RL      C               ; preserve carry (verify) flag in long-term
01883   05B5                                             ; state byte. Bit 7 can be lost.
01884   05B5             
01885   05B5 AD                  XOR     L               ; compare type in A with first byte in L.
01886   05B6 C0                  RET     NZ              ; return if no match e.g. CODE vs. DATA.
01887   05B7             
01888   05B7             ;   continue when data type matches.
01889   05B7             
01890   05B7 79                  LD      A,C             ; fetch byte with stored carry
01891   05B8 1F                  RRA                     ; rotate it to carry flag again
01892   05B9 4F                  LD      C,A             ; restore long-term port state.
01893   05BA             
01894   05BA 13                  INC     DE              ; increment length ??
01895   05BB 18 07               JR      L05C4           ; forward to LD-DEC.
01896   05BD                                             ; but why not to location after ?
01897   05BD             
01898   05BD             ; ---
01899   05BD             ;   for verification the byte read from tape is compared with that in memory.
01900   05BD             
01901   05BD             ;; LD-VERIFY
01902   05BD DD 7E 00    L05BD:   LD      A,(IX+$00)      ; fetch byte from memory.
01903   05C0 AD                  XOR     L               ; compare with that on tape
01904   05C1 C0                  RET     NZ              ; return if not zero. 
01905   05C2             
01906   05C2             ;; LD-NEXT
01907   05C2 DD 23       L05C2:   INC     IX              ; increment byte pointer.
01908   05C4             
01909   05C4             ;; LD-DEC
01910   05C4 1B          L05C4:   DEC     DE              ; decrement length.
01911   05C5 08                  EX      AF,AF			; store the flags.
01912   05C6 06 B2               LD      B,$B2           ; timing.
01913   05C8             
01914   05C8             ;   when starting to read 8 bits the receiving byte is marked with bit at right.
01915   05C8             ;   when this is rotated out again then 8 bits have been read.
01916   05C8             
01917   05C8             ;; LD-MARKER
01918   05C8 2E 01       L05C8:   LD      L,$01           ; initialize as %00000001
01919   05CA             
01920   05CA             ;; LD-8-BITS
01921   05CA CD E3 05    L05CA:   CALL    L05E3           ; routine LD-EDGE-2 increments B relative to
01922   05CD                                             ; gap between 2 edges.
01923   05CD D0                  RET     NC              ; return with time-out.
01924   05CE             
01925   05CE 3E CB               LD      A,$CB           ; the comparison byte.
01926   05D0 B8                  CP      B               ; compare to incremented value of B.
01927   05D1                                             ; if B is higher then bit on tape was set.
01928   05D1                                             ; if <= then bit on tape is reset. 
01929   05D1             
01930   05D1 CB 15               RL      L               ; rotate the carry bit into L.
01931   05D3             
01932   05D3 06 B0               LD      B,$B0           ; reset the B timer byte.
01933   05D5 D2 CA 05            JP      NC,L05CA        ; JUMP back to LD-8-BITS
01934   05D8             
01935   05D8             ;   when carry set then marker bit has been passed out and byte is complete.
01936   05D8             
01937   05D8 7C                  LD      A,H             ; fetch the running parity byte.
01938   05D9 AD                  XOR     L               ; include the new byte.
01939   05DA 67                  LD      H,A             ; and store back in parity register.
01940   05DB             
01941   05DB 7A                  LD      A,D             ; check length of
01942   05DC B3                  OR      E               ; expected bytes.
01943   05DD 20 CA               JR      NZ,L05A9        ; back to LD-LOOP 
01944   05DF                                             ; while there are more.
01945   05DF             
01946   05DF             ;   when all bytes loaded then parity byte should be zero.
01947   05DF             
01948   05DF 7C                  LD      A,H             ; fetch parity byte.
01949   05E0 FE 01               CP      $01             ; set carry if zero.
01950   05E2 C9                  RET                     ; return
01951   05E3                                             ; in no carry then error as checksum disagrees.
01952   05E3             
01953   05E3             ; -------------------------
01954   05E3             ; Check signal being loaded
01955   05E3             ; -------------------------
01956   05E3             ;   An edge is a transition from one mic state to another.
01957   05E3             ;   More specifically a change in bit 6 of value input from port $FE.
01958   05E3             ;   Graphically it is a change of border colour, say, blue to yellow.
01959   05E3             ;   The first entry point looks for two adjacent edges. The second entry point
01960   05E3             ;   is used to find a single edge.
01961   05E3             ;   The B register holds a count, up to 256, within which the edge (or edges) 
01962   05E3             ;   must be found. The gap between two edges will be more for a '1' than a '0'
01963   05E3             ;   so the value of B denotes the state of the bit (two edges) read from tape.
01964   05E3             
01965   05E3             ; ->
01966   05E3             
01967   05E3             ;; LD-EDGE-2
01968   05E3 CD E7 05    L05E3:   CALL    L05E7           ; call routine LD-EDGE-1 below.
01969   05E6 D0                  RET     NC              ; return if space pressed or time-out.
01970   05E7                                             ; else continue and look for another adjacent 
01971   05E7                                             ; edge which together represent a bit on the 
01972   05E7                                             ; tape.
01973   05E7             
01974   05E7             ; -> 
01975   05E7             ;   this entry point is used to find a single edge from above but also 
01976   05E7             ;   when detecting a read-in signal on the tape.
01977   05E7             
01978   05E7             ;; LD-EDGE-1
01979   05E7 3E 16       L05E7:   LD      A,$16           ; a delay value of twenty two.
01980   05E9             
01981   05E9             ;; LD-DELAY
01982   05E9 3D          L05E9:   DEC     A               ; decrement counter
01983   05EA 20 FD               JR      NZ,L05E9        ; loop back to LD-DELAY 22 times.
01984   05EC             
01985   05EC A7                  AND      A              ; clear carry.
01986   05ED             
01987   05ED             ;; LD-SAMPLE
01988   05ED 04          L05ED:   INC     B               ; increment the time-out counter.
01989   05EE C8                  RET     Z               ; return with failure when $FF passed.
01990   05EF             
01991   05EF 3E 7F               LD      A,$7F           ; prepare to read keyboard and EAR port
01992   05F1 DB FE               IN      A,($FE)         ; row $7FFE. bit 6 is EAR, bit 0 is SPACE key.
01993   05F3 1F                  RRA                     ; test outer key the space. (bit 6 moves to 5)
01994   05F4 D0                  RET     NC              ; return if space pressed.  >>>
01995   05F5             
01996   05F5 A9                  XOR     C               ; compare with initial long-term state.
01997   05F6 E6 20               AND     $20             ; isolate bit 5
01998   05F8 28 F3               JR      Z,L05ED         ; back to LD-SAMPLE if no edge.
01999   05FA             
02000   05FA             ;   but an edge, a transition of the EAR bit, has been found so switch the
02001   05FA             ;   long-term comparison byte containing both border colour and EAR bit. 
02002   05FA             
02003   05FA 79                  LD      A,C             ; fetch comparison value.
02004   05FB 2F                  CPL                     ; switch the bits
02005   05FC 4F                  LD      C,A             ; and put back in C for long-term.
02006   05FD             
02007   05FD E6 07               AND     $07             ; isolate new colour bits.
02008   05FF F6 08               OR      $08             ; set bit 3 - MIC off.
02009   0601 D3 FE               OUT     ($FE),A         ; send to port to effect the change of colour. 
02010   0603             
02011   0603 37                  SCF                     ; set carry flag signaling edge found within
02012   0604                                             ; time allowed.
02013   0604 C9                  RET                     ; return.
02014   0605             
02015   0605             ; ---------------------------------
02016   0605             ; Entry point for all tape commands
02017   0605             ; ---------------------------------
02018   0605             ;   This is the single entry point for the four tape commands.
02019   0605             ;   The routine first determines in what context it has been called by examining
02020   0605             ;   the low byte of the Syntax table entry which was stored in T_ADDR.
02021   0605             ;   Subtracting $EO (the present arrangement) gives a value of
02022   0605             ;   $00 - SAVE
02023   0605             ;   $01 - LOAD
02024   0605             ;   $02 - VERIFY
02025   0605             ;   $03 - MERGE
02026   0605             ;   As with all commands the address STMT-RET is on the stack.
02027   0605             
02028   0605             ;; SAVE-ETC
02029   0605 F1          L0605:   POP     AF              ; discard address STMT-RET.
02030   0606 3A 74 5C            LD      A,($5C74)       ; fetch T_ADDR
02031   0609             
02032   0609             ;   Now reduce the low byte of the Syntax table entry to give command.
02033   0609             ;   Note. For ZASM use SUB $E0 as next instruction.
02034   0609             
02035   0609 D6 E0       L0609:   SUB     LOW (L1ADF + 1)  ; subtract the known offset.
02036   060B                                             ; ( is SUB $E0 in standard ROM )
02037   060B             
02038   060B 32 74 5C            LD      ($5C74),A       ; and put back in T_ADDR as 0,1,2, or 3
02039   060E                                             ; for future reference.
02040   060E             
02041   060E CD 8C 1C            CALL    L1C8C           ; routine EXPT-EXP checks that a string
02042   0611                                             ; expression follows and stacks the
02043   0611                                             ; parameters in run-time.
02044   0611             
02045   0611 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
02046   0614 28 3C               JR      Z,L0652         ; forward to SA-DATA if checking syntax.
02047   0616             
02048   0616 01 11 00            LD      BC,$0011        ; presume seventeen bytes for a header.
02049   0619 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
02050   061C A7                  AND     A               ; test for zero - SAVE.
02051   061D 28 02               JR      Z,L0621         ; forward to SA-SPACE if so.
02052   061F             
02053   061F 0E 22               LD      C,$22           ; else double length to thirty four.
02054   0621             
02055   0621             ;; SA-SPACE
02056   0621 F7          L0621:   RST     30H             ; BC-SPACES creates 17/34 bytes in workspace.
02057   0622             
02058   0622 D5                  PUSH    DE              ; transfer the start of new space to
02059   0623 DD E1               POP     IX              ; the available index register.
02060   0625             
02061   0625             ;   ten spaces are required for the default filename but it is simpler to
02062   0625             ;   overwrite the first file-type indicator byte as well.
02063   0625             
02064   0625 06 0B               LD      B,$0B           ; set counter to eleven.
02065   0627 3E 20               LD      A,$20           ; prepare a space.
02066   0629             
02067   0629             ;; SA-BLANK
02068   0629 12          L0629:   LD      (DE),A          ; set workspace location to space.
02069   062A 13                  INC     DE              ; next location.
02070   062B 10 FC               DJNZ    L0629           ; loop back to SA-BLANK till all eleven done.
02071   062D             
02072   062D DD 36 01 FF         LD      (IX+$01),$FF    ; set first byte of ten character filename
02073   0631                                             ; to $FF as a default to signal null string.
02074   0631             
02075   0631 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH fetches the filename
02076   0634                                             ; parameters from the calculator stack.
02077   0634                                             ; length of string in BC.
02078   0634                                             ; start of string in DE.
02079   0634             
02080   0634 21 F6 FF            LD      HL,$FFF6        ; prepare the value minus ten.
02081   0637 0B                  DEC     BC              ; decrement length.
02082   0638                                             ; ten becomes nine, zero becomes $FFFF.
02083   0638 09                  ADD     HL,BC           ; trial addition.
02084   0639 03                  INC     BC              ; restore true length.
02085   063A 30 0F               JR      NC,L064B        ; forward to SA-NAME if length is one to ten.
02086   063C             
02087   063C             ;   the filename is more than ten characters in length or the null string.
02088   063C             
02089   063C 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
02090   063F A7                  AND     A               ; test for zero - SAVE.
02091   0640 20 02               JR      NZ,L0644        ; forward to SA-NULL if not the SAVE command.
02092   0642             
02093   0642             ;   but no more than ten characters are allowed for SAVE.
02094   0642             ;   The first ten characters of any other command parameter are acceptable.
02095   0642             ;   Weird, but necessary, if saving to sectors.
02096   0642             ;   Note. the golden rule that there are no restriction on anything is broken.
02097   0642             
02098   0642             ;; REPORT-Fa
02099   0642 CF          L0642:   RST     08H             ; ERROR-1
02100   0643 0E                  DEFB    $0E             ; Error Report: Invalid file name
02101   0644             
02102   0644             ;   continue with LOAD, MERGE, VERIFY and also SAVE within ten character limit.
02103   0644             
02104   0644             ;; SA-NULL
02105   0644 78          L0644:   LD      A,B             ; test length of filename
02106   0645 B1                  OR      C               ; for zero.
02107   0646 28 0A               JR      Z,L0652         ; forward to SA-DATA if so using the 255 
02108   0648                                             ; indicator followed by spaces.
02109   0648             
02110   0648 01 0A 00            LD      BC,$000A        ; else trim length to ten.
02111   064B             
02112   064B             ;   other paths rejoin here with BC holding length in range 1 - 10.
02113   064B             
02114   064B             ;; SA-NAME
02115   064B DD E5       L064B:   PUSH    IX              ; push start of file descriptor.
02116   064D E1                  POP     HL              ; and pop into HL.
02117   064E             
02118   064E 23                  INC     HL              ; HL now addresses first byte of filename.
02119   064F EB                  EX      DE,HL           ; transfer destination address to DE, start
02120   0650                                             ; of string in command to HL.
02121   0650 ED B0               LDIR                    ; copy up to ten bytes
02122   0652                                             ; if less than ten then trailing spaces follow.
02123   0652             
02124   0652             ;   the case for the null string rejoins here.
02125   0652             
02126   0652             ;; SA-DATA
02127   0652 DF          L0652:   RST     18H             ; GET-CHAR
02128   0653 FE E4               CP      $E4             ; is character after filename the token 'DATA' ?
02129   0655 20 49               JR      NZ,L06A0        ; forward to SA-SCR$ to consider SCREEN$ if
02130   0657                                             ; not.
02131   0657             
02132   0657             ;   continue to consider DATA.
02133   0657             
02134   0657 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
02135   065A FE 03               CP      $03             ; is it 'VERIFY' ?
02136   065C CA 8A 1C            JP      Z,L1C8A         ; jump forward to REPORT-C if so.
02137   065F                                             ; 'Nonsense in BASIC'
02138   065F                                             ; VERIFY "d" DATA is not allowed.
02139   065F             
02140   065F             ;   continue with SAVE, LOAD, MERGE of DATA.
02141   065F             
02142   065F E7                  RST     20H             ; NEXT-CHAR
02143   0660 CD B2 28            CALL    L28B2           ; routine LOOK-VARS searches variables area
02144   0663                                             ; returning with carry reset if found or
02145   0663                                             ; checking syntax.
02146   0663 CB F9               SET     7,C             ; this converts a simple string to a 
02147   0665                                             ; string array. The test for an array or string
02148   0665                                             ; comes later.
02149   0665 30 0B               JR      NC,L0672        ; forward to SA-V-OLD if variable found.
02150   0667             
02151   0667 21 00 00            LD      HL,$0000        ; set destination to zero as not fixed.
02152   066A 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
02153   066D 3D                  DEC     A               ; test for 1 - LOAD
02154   066E 28 15               JR      Z,L0685         ; forward to SA-V-NEW with LOAD DATA.
02155   0670                                             ; to load a new array.
02156   0670             
02157   0670             ;   otherwise the variable was not found in run-time with SAVE/MERGE.
02158   0670             
02159   0670             ;; REPORT-2a
02160   0670 CF          L0670:   RST     08H             ; ERROR-1
02161   0671 01                  DEFB    $01             ; Error Report: Variable not found
02162   0672             
02163   0672             ;   continue with SAVE/LOAD  DATA
02164   0672             
02165   0672             ;; SA-V-OLD
02166   0672 C2 8A 1C    L0672:   JP      NZ,L1C8A        ; to REPORT-C if not an array variable.
02167   0675                                             ; or erroneously a simple string.
02168   0675                                             ; 'Nonsense in BASIC'
02169   0675             
02170   0675             
02171   0675 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
02172   0678 28 18               JR      Z,L0692         ; forward to SA-DATA-1 if checking syntax.
02173   067A             
02174   067A 23                  INC     HL              ; step past single character variable name.
02175   067B 7E                  LD      A,(HL)          ; fetch low byte of length.
02176   067C DD 77 0B            LD      (IX+$0B),A      ; place in descriptor.
02177   067F 23                  INC     HL              ; point to high byte.
02178   0680 7E                  LD      A,(HL)          ; and transfer that
02179   0681 DD 77 0C            LD      (IX+$0C),A      ; to descriptor.
02180   0684 23                  INC     HL              ; increase pointer within variable.
02181   0685             
02182   0685             ;; SA-V-NEW
02183   0685 DD 71 0E    L0685:   LD      (IX+$0E),C      ; place character array name in  header.
02184   0688 3E 01               LD      A,$01           ; default to type numeric.
02185   068A CB 71               BIT     6,C             ; test result from look-vars.
02186   068C 28 01               JR      Z,L068F         ; forward to SA-V-TYPE if numeric.
02187   068E             
02188   068E 3C                  INC     A               ; set type to 2 - string array.
02189   068F             
02190   068F             ;; SA-V-TYPE
02191   068F DD 77 00    L068F:   LD      (IX+$00),A      ; place type 0, 1 or 2 in descriptor.
02192   0692             
02193   0692             ;; SA-DATA-1
02194   0692 EB          L0692:   EX      DE,HL           ; save var pointer in DE
02195   0693             
02196   0693 E7                  RST     20H             ; NEXT-CHAR
02197   0694 FE 29               CP      $29             ; is character ')' ?
02198   0696 20 DA               JR      NZ,L0672        ; back if not to SA-V-OLD to report
02199   0698                                             ; 'Nonsense in BASIC'
02200   0698             
02201   0698 E7                  RST     20H             ; NEXT-CHAR advances character address.
02202   0699 CD EE 1B            CALL    L1BEE           ; routine CHECK-END errors if not end of
02203   069C                                             ; the statement.
02204   069C             
02205   069C EB                  EX      DE,HL           ; bring back variables data pointer.
02206   069D C3 5A 07            JP      L075A           ; jump forward to SA-ALL
02207   06A0             
02208   06A0             ; ---
02209   06A0             ;   the branch was here to consider a 'SCREEN$', the display file.
02210   06A0             
02211   06A0             ;; SA-SCR$
02212   06A0 FE AA       L06A0:   CP      $AA             ; is character the token 'SCREEN$' ?
02213   06A2 20 1F               JR      NZ,L06C3        ; forward to SA-CODE if not.
02214   06A4             
02215   06A4 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
02216   06A7 FE 03               CP      $03             ; is it MERGE ?
02217   06A9 CA 8A 1C            JP       Z,L1C8A        ; jump to REPORT-C if so.
02218   06AC                                             ; 'Nonsense in BASIC'
02219   06AC             
02220   06AC             ;   continue with SAVE/LOAD/VERIFY SCREEN$.
02221   06AC             
02222   06AC E7                  RST     20H             ; NEXT-CHAR
02223   06AD CD EE 1B            CALL    L1BEE           ; routine CHECK-END errors if not at end of
02224   06B0                                             ; statement.
02225   06B0             
02226   06B0             ;   continue in runtime.
02227   06B0             
02228   06B0 DD 36 0B 00         LD      (IX+$0B),$00    ; set descriptor length
02229   06B4 DD 36 0C 1B         LD      (IX+$0C),$1B    ; to $1b00 to include bitmaps and attributes.
02230   06B8             
02231   06B8 21 00 40            LD      HL,$4000        ; set start to display file start.
02232   06BB DD 75 0D            LD      (IX+$0D),L      ; place start in
02233   06BE DD 74 0E            LD      (IX+$0E),H      ; the descriptor.
02234   06C1 18 4D               JR      L0710           ; forward to SA-TYPE-3
02235   06C3             
02236   06C3             ; ---
02237   06C3             ;   the branch was here to consider CODE.
02238   06C3             
02239   06C3             ;; SA-CODE
02240   06C3 FE AF       L06C3:   CP      $AF             ; is character the token 'CODE' ?
02241   06C5 20 4F               JR      NZ,L0716        ; forward if not to SA-LINE to consider an
02242   06C7                                             ; auto-started BASIC program.
02243   06C7             
02244   06C7 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
02245   06CA FE 03               CP      $03             ; is it MERGE ?
02246   06CC CA 8A 1C            JP      Z,L1C8A         ; jump forward to REPORT-C if so.
02247   06CF                                             ; 'Nonsense in BASIC'
02248   06CF             
02249   06CF             
02250   06CF E7                  RST     20H             ; NEXT-CHAR advances character address.
02251   06D0 CD 48 20            CALL    L2048           ; routine PR-ST-END checks if a carriage
02252   06D3                                             ; return or ':' follows.
02253   06D3 20 0C               JR      NZ,L06E1        ; forward to SA-CODE-1 if there are parameters.
02254   06D5             
02255   06D5 3A 74 5C            LD      A,($5C74)       ; else fetch the command from T_ADDR.
02256   06D8 A7                  AND     A               ; test for zero - SAVE without a specification.
02257   06D9 CA 8A 1C            JP      Z,L1C8A         ; jump to REPORT-C if so.
02258   06DC                                             ; 'Nonsense in BASIC'
02259   06DC             
02260   06DC             ;   for LOAD/VERIFY put zero on stack to signify handle at location saved from.
02261   06DC             
02262   06DC CD E6 1C            CALL    L1CE6           ; routine USE-ZERO
02263   06DF 18 0F               JR      L06F0           ; forward to SA-CODE-2
02264   06E1             
02265   06E1             ; ---
02266   06E1             
02267   06E1             ;   if there are more characters after CODE expect start and possibly length.
02268   06E1             
02269   06E1             ;; SA-CODE-1
02270   06E1 CD 82 1C    L06E1:   CALL    L1C82           ; routine EXPT-1NUM checks for numeric
02271   06E4                                             ; expression and stacks it in run-time.
02272   06E4             
02273   06E4 DF                  RST     18H             ; GET-CHAR
02274   06E5 FE 2C               CP      $2C             ; does a comma follow ?
02275   06E7 28 0C               JR      Z,L06F5         ; forward if so to SA-CODE-3
02276   06E9             
02277   06E9             ;   else allow saved code to be loaded to a specified address.
02278   06E9             
02279   06E9 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR.
02280   06EC A7                  AND     A               ; is the command SAVE which requires length ?
02281   06ED CA 8A 1C            JP      Z,L1C8A         ; jump to REPORT-C if so.
02282   06F0                                             ; 'Nonsense in BASIC'
02283   06F0             
02284   06F0             ;   the command LOAD code may rejoin here with zero stacked as start.
02285   06F0             
02286   06F0             ;; SA-CODE-2
02287   06F0 CD E6 1C    L06F0:   CALL    L1CE6           ; routine USE-ZERO stacks zero for length.
02288   06F3 18 04               JR      L06F9           ; forward to SA-CODE-4
02289   06F5             
02290   06F5             ; ---
02291   06F5             ;   the branch was here with SAVE CODE start, 
02292   06F5             
02293   06F5             ;; SA-CODE-3
02294   06F5 E7          L06F5:   RST     20H             ; NEXT-CHAR advances character address.
02295   06F6 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM checks for expression
02296   06F9                                             ; and stacks in run-time.
02297   06F9             
02298   06F9             ;   paths converge here and nothing must follow.
02299   06F9             
02300   06F9             ;; SA-CODE-4
02301   06F9 CD EE 1B    L06F9:   CALL    L1BEE           ; routine CHECK-END errors with extraneous
02302   06FC                                             ; characters and quits if checking syntax.
02303   06FC             
02304   06FC             ;   in run-time there are two 16-bit parameters on the calculator stack.
02305   06FC             
02306   06FC CD 99 1E            CALL    L1E99           ; routine FIND-INT2 gets length.
02307   06FF DD 71 0B            LD      (IX+$0B),C      ; place length 
02308   0702 DD 70 0C            LD      (IX+$0C),B      ; in descriptor.
02309   0705 CD 99 1E            CALL    L1E99           ; routine FIND-INT2 gets start.
02310   0708 DD 71 0D            LD      (IX+$0D),C      ; place start
02311   070B DD 70 0E            LD      (IX+$0E),B      ; in descriptor.
02312   070E 60                  LD      H,B             ; transfer the
02313   070F 69                  LD      L,C             ; start to HL also.
02314   0710             
02315   0710             ;; SA-TYPE-3
02316   0710 DD 36 00 03 L0710:   LD      (IX+$00),$03    ; place type 3 - code in descriptor. 
02317   0714 18 44               JR      L075A           ; forward to SA-ALL.
02318   0716             
02319   0716             ; ---
02320   0716             ;   the branch was here with BASIC to consider an optional auto-start line
02321   0716             ;   number.
02322   0716             
02323   0716             ;; SA-LINE
02324   0716 FE CA       L0716:   CP      $CA             ; is character the token 'LINE' ?
02325   0718 28 09               JR      Z,L0723         ; forward to SA-LINE-1 if so.
02326   071A             
02327   071A             ;   else all possibilities have been considered and nothing must follow.
02328   071A             
02329   071A CD EE 1B            CALL    L1BEE           ; routine CHECK-END
02330   071D             
02331   071D             ;   continue in run-time to save BASIC without auto-start.
02332   071D             
02333   071D DD 36 0E 80         LD      (IX+$0E),$80    ; place high line number in descriptor to
02334   0721                                             ; disable auto-start.
02335   0721 18 17               JR      L073A           ; forward to SA-TYPE-0 to save program.
02336   0723             
02337   0723             ; ---
02338   0723             ;   the branch was here to consider auto-start.
02339   0723             
02340   0723             ;; SA-LINE-1
02341   0723 3A 74 5C    L0723:   LD      A,($5C74)       ; fetch command from T_ADDR
02342   0726 A7                  AND     A               ; test for SAVE.
02343   0727 C2 8A 1C            JP      NZ,L1C8A        ; jump forward to REPORT-C with anything else.
02344   072A                                             ; 'Nonsense in BASIC'
02345   072A             
02346   072A             ; 
02347   072A             
02348   072A E7                  RST     20H             ; NEXT-CHAR
02349   072B CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM checks for numeric
02350   072E                                             ; expression and stacks in run-time.
02351   072E CD EE 1B            CALL    L1BEE           ; routine CHECK-END quits if syntax path.
02352   0731 CD 99 1E            CALL    L1E99           ; routine FIND-INT2 fetches the numeric
02353   0734                                             ; expression.
02354   0734 DD 71 0D            LD      (IX+$0D),C      ; place the auto-start
02355   0737 DD 70 0E            LD      (IX+$0E),B      ; line number in the descriptor.
02356   073A             
02357   073A             ;   Note. this isn't checked, but is subsequently handled by the system.
02358   073A             ;   If the user typed 40000 instead of 4000 then it won't auto-start
02359   073A             ;   at line 4000, or indeed, at all.
02360   073A             
02361   073A             ;   continue to save program and any variables.
02362   073A             
02363   073A             ;; SA-TYPE-0
02364   073A DD 36 00 00 L073A:   LD      (IX+$00),$00    ; place type zero - program in descriptor.
02365   073E 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE to HL.
02366   0741 ED 5B 53 5C         LD      DE,($5C53)      ; fetch PROG to DE.
02367   0745 37                  SCF                     ; set carry flag to calculate from end of
02368   0746                                             ; variables E_LINE -1.
02369   0746 ED 52               SBC     HL,DE           ; subtract to give total length.
02370   0748             
02371   0748 DD 75 0B            LD      (IX+$0B),L      ; place total length
02372   074B DD 74 0C            LD      (IX+$0C),H      ; in descriptor.
02373   074E 2A 4B 5C            LD      HL,($5C4B)      ; load HL from system variable VARS
02374   0751 ED 52               SBC     HL,DE           ; subtract to give program length.
02375   0753 DD 75 0F            LD      (IX+$0F),L      ; place length of program
02376   0756 DD 74 10            LD      (IX+$10),H      ; in the descriptor.
02377   0759 EB                  EX      DE,HL           ; start to HL, length to DE.
02378   075A             
02379   075A             ;; SA-ALL
02380   075A 3A 74 5C    L075A:   LD      A,($5C74)       ; fetch command from T_ADDR
02381   075D A7                  AND     A               ; test for zero - SAVE.
02382   075E CA 70 09            JP      Z,L0970         ; jump forward to SA-CONTRL with SAVE  ->
02383   0761             
02384   0761             ; ---
02385   0761             ;   continue with LOAD, MERGE and VERIFY.
02386   0761             
02387   0761 E5                  PUSH    HL              ; save start.
02388   0762 01 11 00            LD      BC,$0011        ; prepare to add seventeen
02389   0765 DD 09               ADD     IX,BC           ; to point IX at second descriptor.
02390   0767             
02391   0767             ;; LD-LOOK-H
02392   0767 DD E5       L0767:   PUSH    IX              ; save IX
02393   0769 11 11 00            LD      DE,$0011        ; seventeen bytes
02394   076C AF                  XOR     A               ; reset zero flag
02395   076D 37                  SCF                     ; set carry flag
02396   076E CD 56 05            CALL    L0556           ; routine LD-BYTES loads a header from tape
02397   0771                                             ; to second descriptor.
02398   0771 DD E1               POP     IX              ; restore IX.
02399   0773 30 F2               JR      NC,L0767        ; loop back to LD-LOOK-H until header found.
02400   0775             
02401   0775 3E FE               LD      A,$FE           ; select system channel 'S'
02402   0777 CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it.
02403   077A             
02404   077A FD 36 52 03         LD      (IY+$52),$03    ; set SCR_CT to 3 lines.
02405   077E             
02406   077E 0E 80               LD      C,$80           ; C has bit 7 set to indicate type mismatch as
02407   0780                                             ; a default startpoint.
02408   0780             
02409   0780 DD 7E 00            LD      A,(IX+$00)      ; fetch loaded header type to A
02410   0783 DD BE EF            CP      (IX-$11)        ; compare with expected type.
02411   0786 20 02               JR      NZ,L078A        ; forward to LD-TYPE with mis-match.
02412   0788             
02413   0788 0E F6               LD      C,$F6           ; set C to minus ten - will count characters
02414   078A                                             ; up to zero.
02415   078A             
02416   078A             ;; LD-TYPE
02417   078A FE 04       L078A:   CP      $04             ; check if type in acceptable range 0 - 3.
02418   078C 30 D9               JR      NC,L0767        ; back to LD-LOOK-H with 4 and over.
02419   078E             
02420   078E             ;   else A indicates type 0-3.
02421   078E             
02422   078E 11 C0 09            LD      DE,L09C0        ; address base of last 4 tape messages
02423   0791 C5                  PUSH    BC              ; save BC
02424   0792 CD 0A 0C            CALL    L0C0A           ; routine PO-MSG outputs relevant message.
02425   0795                                             ; Note. all messages have a leading newline.
02426   0795 C1                  POP     BC              ; restore BC
02427   0796             
02428   0796 DD E5               PUSH    IX              ; transfer IX,
02429   0798 D1                  POP     DE              ; the 2nd descriptor, to DE.
02430   0799 21 F0 FF            LD      HL,$FFF0        ; prepare minus seventeen.
02431   079C 19                  ADD     HL,DE           ; add to point HL to 1st descriptor.
02432   079D 06 0A               LD      B,$0A           ; the count will be ten characters for the
02433   079F                                             ; filename.
02434   079F             
02435   079F 7E                  LD      A,(HL)          ; fetch first character and test for 
02436   07A0 3C                  INC     A               ; value 255.
02437   07A1 20 03               JR      NZ,L07A6        ; forward to LD-NAME if not the wildcard.
02438   07A3             
02439   07A3             ;   but if it is the wildcard, then add ten to C which is minus ten for a type
02440   07A3             ;   match or -128 for a type mismatch. Although characters have to be counted
02441   07A3             ;   bit 7 of C will not alter from state set here.
02442   07A3             
02443   07A3 79                  LD      A,C             ; transfer $F6 or $80 to A
02444   07A4 80                  ADD     A,B             ; add $0A
02445   07A5 4F                  LD      C,A             ; place result, zero or -118, in C.
02446   07A6             
02447   07A6             ;   At this point we have either a type mismatch, a wildcard match or ten
02448   07A6             ;   characters to be counted. The characters must be shown on the screen.
02449   07A6             
02450   07A6             ;; LD-NAME
02451   07A6 13          L07A6:   INC     DE              ; address next input character
02452   07A7 1A                  LD      A,(DE)          ; fetch character
02453   07A8 BE                  CP      (HL)            ; compare to expected
02454   07A9 23                  INC     HL              ; address next expected character
02455   07AA 20 01               JR      NZ,L07AD        ; forward to LD-CH-PR with mismatch
02456   07AC             
02457   07AC 0C                  INC     C               ; increment matched character count
02458   07AD             
02459   07AD             ;; LD-CH-PR
02460   07AD D7          L07AD:   RST     10H             ; PRINT-A prints character
02461   07AE 10 F6               DJNZ    L07A6           ; loop back to LD-NAME for ten characters.
02462   07B0             
02463   07B0             ;   if ten characters matched and the types previously matched then C will 
02464   07B0             ;   now hold zero.
02465   07B0             
02466   07B0 CB 79               BIT     7,C             ; test if all matched
02467   07B2 20 B3               JR      NZ,L0767        ; back to LD-LOOK-H if not
02468   07B4             
02469   07B4             ;   else print a terminal carriage return.
02470   07B4             
02471   07B4 3E 0D               LD      A,$0D           ; prepare carriage return.
02472   07B6 D7                  RST     10H             ; PRINT-A outputs it.
02473   07B7             
02474   07B7             ;   The various control routines for LOAD, VERIFY and MERGE are executed 
02475   07B7             ;   during the one-second gap following the header on tape.
02476   07B7             
02477   07B7 E1                  POP     HL              ; restore xx
02478   07B8 DD 7E 00            LD      A,(IX+$00)      ; fetch incoming type 
02479   07BB FE 03               CP      $03             ; compare with CODE
02480   07BD 28 0C               JR      Z,L07CB         ; forward to VR-CONTRL if it is CODE.
02481   07BF             
02482   07BF             ;  type is a program or an array.
02483   07BF             
02484   07BF 3A 74 5C            LD      A,($5C74)       ; fetch command from T_ADDR
02485   07C2 3D                  DEC     A               ; was it LOAD ?
02486   07C3 CA 08 08            JP      Z,L0808         ; JUMP forward to LD-CONTRL if so to 
02487   07C6                                             ; load BASIC or variables.
02488   07C6             
02489   07C6 FE 02               CP      $02             ; was command MERGE ?
02490   07C8 CA B6 08            JP      Z,L08B6         ; jump forward to ME-CONTRL if so.
02491   07CB             
02492   07CB             ;   else continue into VERIFY control routine to verify.
02493   07CB             
02494   07CB             ; ----------------------------
02495   07CB             ; THE 'VERIFY CONTROL' ROUTINE
02496   07CB             ; ----------------------------
02497   07CB             ;   There are two branches to this routine.
02498   07CB             ;   1) From above to verify a program or array
02499   07CB             ;   2) from earlier with no carry to load or verify code.
02500   07CB             
02501   07CB             ;; VR-CONTRL
02502   07CB E5          L07CB:   PUSH    HL              ; save pointer to data.
02503   07CC DD 6E FA            LD      L,(IX-$06)      ; fetch length of old data 
02504   07CF DD 66 FB            LD      H,(IX-$05)      ; to HL.
02505   07D2 DD 5E 0B            LD      E,(IX+$0B)      ; fetch length of new data
02506   07D5 DD 56 0C            LD      D,(IX+$0C)      ; to DE.
02507   07D8 7C                  LD      A,H             ; check length of old
02508   07D9 B5                  OR      L               ; for zero.
02509   07DA 28 0D               JR      Z,L07E9         ; forward to VR-CONT-1 if length unspecified
02510   07DC                                             ; e.g. LOAD "x" CODE
02511   07DC             
02512   07DC             ;   as opposed to, say, LOAD 'x' CODE 32768,300.
02513   07DC             
02514   07DC ED 52               SBC     HL,DE           ; subtract the two lengths.
02515   07DE 38 26               JR      C,L0806         ; forward to REPORT-R if the length on tape is 
02516   07E0                                             ; larger than that specified in command.
02517   07E0                                             ; 'Tape loading error'
02518   07E0             
02519   07E0 28 07               JR      Z,L07E9         ; forward to VR-CONT-1 if lengths match.
02520   07E2             
02521   07E2             ;   a length on tape shorter than expected is not allowed for CODE
02522   07E2             
02523   07E2 DD 7E 00            LD      A,(IX+$00)      ; else fetch type from tape.
02524   07E5 FE 03               CP      $03             ; is it CODE ?
02525   07E7 20 1D               JR      NZ,L0806        ; forward to REPORT-R if so
02526   07E9                                             ; 'Tape loading error'
02527   07E9             
02528   07E9             ;; VR-CONT-1
02529   07E9 E1          L07E9:   POP     HL              ; pop pointer to data
02530   07EA 7C                  LD      A,H             ; test for zero
02531   07EB B5                  OR      L               ; e.g. LOAD 'x' CODE
02532   07EC 20 06               JR      NZ,L07F4        ; forward to VR-CONT-2 if destination specified.
02533   07EE             
02534   07EE DD 6E 0D            LD      L,(IX+$0D)      ; else use the destination in the header
02535   07F1 DD 66 0E            LD      H,(IX+$0E)      ; and load code at address saved from.
02536   07F4             
02537   07F4             ;; VR-CONT-2
02538   07F4 E5          L07F4:   PUSH    HL              ; push pointer to start of data block.
02539   07F5 DD E1               POP     IX              ; transfer to IX.
02540   07F7 3A 74 5C            LD      A,($5C74)       ; fetch reduced command from T_ADDR
02541   07FA FE 02               CP      $02             ; is it VERIFY ?
02542   07FC 37                  SCF                     ; prepare a set carry flag
02543   07FD 20 01               JR      NZ,L0800        ; skip to VR-CONT-3 if not
02544   07FF             
02545   07FF A7                  AND     A               ; clear carry flag for VERIFY so that 
02546   0800                                             ; data is not loaded.
02547   0800             
02548   0800             ;; VR-CONT-3
02549   0800 3E FF       L0800:   LD      A,$FF           ; signal data block to be loaded
02550   0802             
02551   0802             ; -----------------
02552   0802             ; Load a data block
02553   0802             ; -----------------
02554   0802             ;   This routine is called from 3 places other than above to load a data block.
02555   0802             ;   In all cases the accumulator is first set to $FF so the routine could be 
02556   0802             ;   called at the previous instruction.
02557   0802             
02558   0802             ;; LD-BLOCK
02559   0802 CD 56 05    L0802:   CALL    L0556           ; routine LD-BYTES
02560   0805 D8                  RET     C               ; return if successful.
02561   0806             
02562   0806             
02563   0806             ;; REPORT-R
02564   0806 CF          L0806:   RST     08H             ; ERROR-1
02565   0807 1A                  DEFB    $1A             ; Error Report: Tape loading error
02566   0808             
02567   0808             ; --------------------------
02568   0808             ; THE 'LOAD CONTROL' ROUTINE
02569   0808             ; --------------------------
02570   0808             ;   This branch is taken when the command is LOAD with type 0, 1 or 2. 
02571   0808             
02572   0808             ;; LD-CONTRL
02573   0808 DD 5E 0B    L0808:   LD      E,(IX+$0B)      ; fetch length of found data block 
02574   080B DD 56 0C            LD      D,(IX+$0C)      ; from 2nd descriptor.
02575   080E E5                  PUSH    HL              ; save destination
02576   080F 7C                  LD      A,H             ; test for zero
02577   0810 B5                  OR      L               ;
02578   0811 20 06               JR      NZ,L0819        ; forward if not to LD-CONT-1
02579   0813             
02580   0813 13                  INC     DE              ; increase length
02581   0814 13                  INC     DE              ; for letter name
02582   0815 13                  INC     DE              ; and 16-bit length
02583   0816 EB                  EX      DE,HL           ; length to HL, 
02584   0817 18 0C               JR      L0825           ; forward to LD-CONT-2
02585   0819             
02586   0819             ; ---
02587   0819             
02588   0819             ;; LD-CONT-1
02589   0819 DD 6E FA    L0819:   LD      L,(IX-$06)      ; fetch length from 
02590   081C DD 66 FB            LD      H,(IX-$05)      ; the first header.
02591   081F EB                  EX      DE,HL           ;
02592   0820 37                  SCF                     ; set carry flag
02593   0821 ED 52               SBC     HL,DE           ;
02594   0823 38 09               JR      C,L082E         ; to LD-DATA
02595   0825             
02596   0825             ;; LD-CONT-2
02597   0825 11 05 00    L0825:   LD      DE,$0005        ; allow overhead of five bytes.
02598   0828 19                  ADD     HL,DE           ; add in the difference in data lengths.
02599   0829 44                  LD      B,H             ; transfer to
02600   082A 4D                  LD      C,L             ; the BC register pair
02601   082B CD 05 1F            CALL    L1F05           ; routine TEST-ROOM fails if not enough room.
02602   082E             
02603   082E             ;; LD-DATA
02604   082E E1          L082E:   POP     HL              ; pop destination
02605   082F DD 7E 00            LD      A,(IX+$00)      ; fetch type 0, 1 or 2.
02606   0832 A7                  AND     A               ; test for program and variables.
02607   0833 28 3E               JR      Z,L0873         ; forward if so to LD-PROG
02608   0835             
02609   0835             ;   the type is a numeric or string array.
02610   0835             
02611   0835 7C                  LD      A,H             ; test the destination for zero
02612   0836 B5                  OR      L               ; indicating variable does not already exist.
02613   0837 28 13               JR      Z,L084C         ; forward if so to LD-DATA-1
02614   0839             
02615   0839             ;   else the destination is the first dimension within the array structure
02616   0839             
02617   0839 2B                  DEC     HL              ; address high byte of total length
02618   083A 46                  LD      B,(HL)          ; transfer to B.
02619   083B 2B                  DEC     HL              ; address low byte of total length.
02620   083C 4E                  LD      C,(HL)          ; transfer to C.
02621   083D 2B                  DEC     HL              ; point to letter of variable.
02622   083E 03                  INC     BC              ; adjust length to
02623   083F 03                  INC     BC              ; include these
02624   0840 03                  INC     BC              ; three bytes also.
02625   0841 DD 22 5F 5C         LD      ($5C5F),IX      ; save header pointer in X_PTR.
02626   0845 CD E8 19            CALL    L19E8           ; routine RECLAIM-2 reclaims the old variable
02627   0848                                             ; sliding workspace including the two headers 
02628   0848                                             ; downwards.
02629   0848 DD 2A 5F 5C         LD      IX,($5C5F)      ; reload IX from X_PTR which will have been
02630   084C                                             ; adjusted down by POINTERS routine.
02631   084C             
02632   084C             ;; LD-DATA-1
02633   084C 2A 59 5C    L084C:   LD      HL,($5C59)      ; address E_LINE
02634   084F 2B                  DEC     HL              ; now point to the $80 variables end-marker.
02635   0850 DD 4E 0B            LD      C,(IX+$0B)      ; fetch new data length 
02636   0853 DD 46 0C            LD      B,(IX+$0C)      ; from 2nd header.
02637   0856 C5                  PUSH    BC              ; * save it.
02638   0857 03                  INC     BC              ; adjust the 
02639   0858 03                  INC     BC              ; length to include
02640   0859 03                  INC     BC              ; letter name and total length.
02641   085A DD 7E FD            LD      A,(IX-$03)      ; fetch letter name from old header.
02642   085D F5                  PUSH    AF              ; preserve accumulator though not corrupted.
02643   085E             
02644   085E CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates space for variable
02645   0861                                             ; sliding workspace up. IX no longer addresses
02646   0861                                             ; anywhere meaningful.
02647   0861 23                  INC     HL              ; point to first new location.
02648   0862             
02649   0862 F1                  POP     AF              ; fetch back the letter name.
02650   0863 77                  LD      (HL),A          ; place in first new location.
02651   0864 D1                  POP     DE              ; * pop the data length.
02652   0865 23                  INC     HL              ; address 2nd location
02653   0866 73                  LD      (HL),E          ; store low byte of length.
02654   0867 23                  INC     HL              ; address next.
02655   0868 72                  LD      (HL),D          ; store high byte.
02656   0869 23                  INC     HL              ; address start of data.
02657   086A E5                  PUSH    HL              ; transfer address
02658   086B DD E1               POP     IX              ; to IX register pair.
02659   086D 37                  SCF                     ; set carry flag indicating load not verify.
02660   086E 3E FF               LD      A,$FF           ; signal data not header.
02661   0870 C3 02 08            JP      L0802           ; JUMP back to LD-BLOCK
02662   0873             
02663   0873             ; -----------------
02664   0873             ;   the branch is here when a program as opposed to an array is to be loaded.
02665   0873             
02666   0873             ;; LD-PROG
02667   0873 EB          L0873:   EX      DE,HL           ; transfer dest to DE.
02668   0874 2A 59 5C            LD      HL,($5C59)      ; address E_LINE
02669   0877 2B                  DEC     HL              ; now variables end-marker.
02670   0878 DD 22 5F 5C         LD      ($5C5F),IX      ; place the IX header pointer in X_PTR
02671   087C DD 4E 0B            LD      C,(IX+$0B)      ; get new length
02672   087F DD 46 0C            LD      B,(IX+$0C)      ; from 2nd header
02673   0882 C5                  PUSH    BC              ; and save it.
02674   0883             
02675   0883 CD E5 19            CALL    L19E5           ; routine RECLAIM-1 reclaims program and vars.
02676   0886                                             ; adjusting X-PTR.
02677   0886             
02678   0886 C1                  POP     BC              ; restore new length.
02679   0887 E5                  PUSH    HL              ; * save start
02680   0888 C5                  PUSH    BC              ; ** and length.
02681   0889             
02682   0889 CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates the space.
02683   088C             
02684   088C DD 2A 5F 5C         LD      IX,($5C5F)      ; reload IX from adjusted X_PTR
02685   0890 23                  INC     HL              ; point to start of new area.
02686   0891 DD 4E 0F            LD      C,(IX+$0F)      ; fetch length of BASIC on tape
02687   0894 DD 46 10            LD      B,(IX+$10)      ; from 2nd descriptor
02688   0897 09                  ADD     HL,BC           ; add to address the start of variables.
02689   0898 22 4B 5C            LD      ($5C4B),HL      ; set system variable VARS
02690   089B             
02691   089B DD 66 0E            LD      H,(IX+$0E)      ; fetch high byte of autostart line number.
02692   089E 7C                  LD      A,H             ; transfer to A
02693   089F E6 C0               AND     $C0             ; test if greater than $3F.
02694   08A1 20 0A               JR      NZ,L08AD        ; forward to LD-PROG-1 if so with no autostart.
02695   08A3             
02696   08A3 DD 6E 0D            LD      L,(IX+$0D)      ; else fetch the low byte.
02697   08A6 22 42 5C            LD      ($5C42),HL      ; set system variable to line number NEWPPC
02698   08A9 FD 36 0A 00         LD      (IY+$0A),$00    ; set statement NSPPC to zero.
02699   08AD             
02700   08AD             ;; LD-PROG-1
02701   08AD D1          L08AD:   POP     DE              ; ** pop the length
02702   08AE DD E1               POP     IX              ; * and start.
02703   08B0 37                  SCF                     ; set carry flag
02704   08B1 3E FF               LD      A,$FF           ; signal data as opposed to a header.
02705   08B3 C3 02 08            JP      L0802           ; jump back to LD-BLOCK
02706   08B6             
02707   08B6             ; ---------------------------
02708   08B6             ; THE 'MERGE CONTROL' ROUTINE
02709   08B6             ; ---------------------------
02710   08B6             ;   the branch was here to merge a program and its variables or an array.
02711   08B6             ;
02712   08B6             
02713   08B6             ;; ME-CONTRL
02714   08B6 DD 4E 0B    L08B6:   LD      C,(IX+$0B)      ; fetch length
02715   08B9 DD 46 0C            LD      B,(IX+$0C)      ; of data block on tape.
02716   08BC C5                  PUSH    BC              ; save it.
02717   08BD 03                  INC     BC              ; one for the pot.
02718   08BE             
02719   08BE F7                  RST     30H             ; BC-SPACES creates room in workspace.
02720   08BF                                             ; HL addresses last new location.
02721   08BF 36 80               LD      (HL),$80        ; place end-marker at end.
02722   08C1 EB                  EX      DE,HL           ; transfer first location to HL.
02723   08C2 D1                  POP     DE              ; restore length to DE.
02724   08C3 E5                  PUSH    HL              ; save start.
02725   08C4             
02726   08C4 E5                  PUSH    HL              ; and transfer it
02727   08C5 DD E1               POP     IX              ; to IX register.
02728   08C7 37                  SCF                     ; set carry flag to load data on tape.
02729   08C8 3E FF               LD      A,$FF           ; signal data not a header.
02730   08CA CD 02 08            CALL    L0802           ; routine LD-BLOCK loads to workspace.
02731   08CD E1                  POP     HL              ; restore first location in workspace to HL.
02732   08CE ED 5B 53 5C X08CE   LD      DE,($5C53)      ; set DE from system variable PROG.
02733   08D2             
02734   08D2             ;   now enter a loop to merge the data block in workspace with the program and 
02735   08D2             ;   variables. 
02736   08D2             
02737   08D2             ;; ME-NEW-LP
02738   08D2 7E          L08D2:   LD      A,(HL)          ; fetch next byte from workspace.
02739   08D3 E6 C0               AND     $C0             ; compare with $3F.
02740   08D5 20 19               JR      NZ,L08F0        ; forward to ME-VAR-LP if a variable or 
02741   08D7                                             ; end-marker.
02742   08D7             
02743   08D7             ;   continue when HL addresses a BASIC line number.
02744   08D7             
02745   08D7             ;; ME-OLD-LP
02746   08D7 1A          L08D7:   LD      A,(DE)          ; fetch high byte from program area.
02747   08D8 13                  INC     DE              ; bump prog address.
02748   08D9 BE                  CP      (HL)            ; compare with that in workspace.
02749   08DA 23                  INC     HL              ; bump workspace address.
02750   08DB 20 02               JR      NZ,L08DF        ; forward to ME-OLD-L1 if high bytes don't match
02751   08DD             
02752   08DD 1A                  LD      A,(DE)          ; fetch the low byte of program line number.
02753   08DE BE                  CP      (HL)            ; compare with that in workspace.
02754   08DF             
02755   08DF             ;; ME-OLD-L1
02756   08DF 1B          L08DF:   DEC     DE              ; point to start of
02757   08E0 2B                  DEC     HL              ; respective lines again.
02758   08E1 30 08               JR      NC,L08EB        ; forward to ME-NEW-L2 if line number in 
02759   08E3                                             ; workspace is less than or equal to current
02760   08E3                                             ; program line as has to be added to program.
02761   08E3             
02762   08E3 E5                  PUSH    HL              ; else save workspace pointer. 
02763   08E4 EB                  EX      DE,HL           ; transfer prog pointer to HL
02764   08E5 CD B8 19            CALL    L19B8           ; routine NEXT-ONE finds next line in DE.
02765   08E8 E1                  POP     HL              ; restore workspace pointer
02766   08E9 18 EC               JR      L08D7           ; back to ME-OLD-LP until destination position 
02767   08EB                                             ; in program area found.
02768   08EB             
02769   08EB             ; ---
02770   08EB             ;   the branch was here with an insertion or replacement point.
02771   08EB             
02772   08EB             ;; ME-NEW-L2
02773   08EB CD 2C 09    L08EB:   CALL    L092C           ; routine ME-ENTER enters the line
02774   08EE 18 E2               JR      L08D2           ; loop back to ME-NEW-LP.
02775   08F0             
02776   08F0             ; ---
02777   08F0             ;   the branch was here when the location in workspace held a variable.
02778   08F0             
02779   08F0             ;; ME-VAR-LP
02780   08F0 7E          L08F0:   LD      A,(HL)          ; fetch first byte of workspace variable.
02781   08F1 4F                  LD      C,A             ; copy to C also.
02782   08F2 FE 80               CP      $80             ; is it the end-marker ?
02783   08F4 C8                  RET     Z               ; return if so as complete.  >>>>>
02784   08F5             
02785   08F5 E5                  PUSH    HL              ; save workspace area pointer.
02786   08F6 2A 4B 5C            LD      HL,($5C4B)      ; load HL with VARS - start of variables area.
02787   08F9             
02788   08F9             ;; ME-OLD-VP
02789   08F9 7E          L08F9:   LD      A,(HL)          ; fetch first byte.
02790   08FA FE 80               CP      $80             ; is it the end-marker ?
02791   08FC 28 25               JR      Z,L0923         ; forward if so to ME-VAR-L2 to add
02792   08FE                                             ; variable at end of variables area.
02793   08FE             
02794   08FE B9                  CP      C               ; compare with variable in workspace area.
02795   08FF 28 08               JR      Z,L0909         ; forward to ME-OLD-V2 if a match to replace.
02796   0901             
02797   0901             ;   else entire variables area has to be searched.
02798   0901             
02799   0901             ;; ME-OLD-V1
02800   0901 C5          L0901:   PUSH    BC              ; save character in C.
02801   0902 CD B8 19            CALL    L19B8           ; routine NEXT-ONE gets following variable 
02802   0905                                             ; address in DE.
02803   0905 C1                  POP     BC              ; restore character in C
02804   0906 EB                  EX      DE,HL           ; transfer next address to HL.
02805   0907 18 F0               JR      L08F9           ; loop back to ME-OLD-VP
02806   0909             
02807   0909             ; --- 
02808   0909             ;   the branch was here when first characters of name matched. 
02809   0909             
02810   0909             ;; ME-OLD-V2
02811   0909 E6 E0       L0909:   AND     $E0             ; keep bits 11100000
02812   090B FE A0               CP      $A0             ; compare   10100000 - a long-named variable.
02813   090D             
02814   090D 20 12               JR      NZ,L0921        ; forward to ME-VAR-L1 if just one-character.
02815   090F             
02816   090F             ;   but long-named variables have to be matched character by character.
02817   090F             
02818   090F D1                  POP     DE              ; fetch workspace 1st character pointer
02819   0910 D5                  PUSH    DE              ; and save it on the stack again.
02820   0911 E5                  PUSH    HL              ; save variables area pointer on stack.
02821   0912             
02822   0912             ;; ME-OLD-V3
02823   0912 23          L0912:   INC     HL              ; address next character in vars area.
02824   0913 13                  INC     DE              ; address next character in workspace area.
02825   0914 1A                  LD      A,(DE)          ; fetch workspace character.
02826   0915 BE                  CP      (HL)            ; compare to variables character.
02827   0916 20 06               JR      NZ,L091E        ; forward to ME-OLD-V4 with a mismatch.
02828   0918             
02829   0918 17                  RLA                     ; test if the terminal inverted character.
02830   0919 30 F7               JR      NC,L0912        ; loop back to ME-OLD-V3 if more to test.
02831   091B             
02832   091B             ;   otherwise the long name matches in its entirety.
02833   091B             
02834   091B E1                  POP     HL              ; restore pointer to first character of variable
02835   091C 18 03               JR      L0921           ; forward to ME-VAR-L1
02836   091E             
02837   091E             ; ---
02838   091E             ;   the branch is here when two characters don't match
02839   091E             
02840   091E             ;; ME-OLD-V4
02841   091E E1          L091E:   POP     HL              ; restore the prog/vars pointer.
02842   091F 18 E0               JR      L0901           ; back to ME-OLD-V1 to resume search.
02843   0921             
02844   0921             ; ---
02845   0921             ;   branch here when variable is to replace an existing one
02846   0921             
02847   0921             ;; ME-VAR-L1
02848   0921 3E FF       L0921:   LD      A,$FF           ; indicate a replacement.
02849   0923             
02850   0923             ;   this entry point is when A holds $80 indicating a new variable.
02851   0923             
02852   0923             ;; ME-VAR-L2
02853   0923 D1          L0923:   POP     DE              ; pop workspace pointer.
02854   0924 EB                  EX      DE,HL           ; now make HL workspace pointer, DE vars pointer
02855   0925 3C                  INC     A               ; zero flag set if replacement.
02856   0926 37                  SCF                     ; set carry flag indicating a variable not a
02857   0927                                             ; program line.
02858   0927 CD 2C 09            CALL    L092C           ; routine ME-ENTER copies variable in.
02859   092A 18 C4               JR      L08F0           ; loop back to ME-VAR-LP
02860   092C             
02861   092C             ; ------------------------
02862   092C             ; Merge a Line or Variable
02863   092C             ; ------------------------
02864   092C             ;   A BASIC line or variable is inserted at the current point. If the line 
02865   092C             ;   number or variable names match (zero flag set) then a replacement takes 
02866   092C             ;   place.
02867   092C             
02868   092C             ;; ME-ENTER
02869   092C 20 10       L092C:   JR      NZ,L093E        ; forward to ME-ENT-1 for insertion only.
02870   092E             
02871   092E             ;   but the program line or variable matches so old one is reclaimed.
02872   092E             
02873   092E 08                  EX      AF,AF			; save flag??
02874   092F 22 5F 5C            LD      ($5C5F),HL      ; preserve workspace pointer in dynamic X_PTR
02875   0932 EB                  EX      DE,HL           ; transfer program dest pointer to HL.
02876   0933 CD B8 19            CALL    L19B8           ; routine NEXT-ONE finds following location
02877   0936                                             ; in program or variables area.
02878   0936 CD E8 19            CALL    L19E8           ; routine RECLAIM-2 reclaims the space between.
02879   0939 EB                  EX      DE,HL           ; transfer program dest pointer back to DE.
02880   093A 2A 5F 5C            LD      HL,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
02881   093D 08                  EX      AF,AF			; restore flags.
02882   093E             
02883   093E             ;   now the new line or variable is entered.
02884   093E             
02885   093E             ;; ME-ENT-1
02886   093E 08          L093E:   EX      AF,AF			; save or re-save flags.
02887   093F D5                  PUSH    DE              ; save dest pointer in prog/vars area.
02888   0940 CD B8 19            CALL    L19B8           ; routine NEXT-ONE finds next in workspace.
02889   0943                                             ; gets next in DE, difference in BC.
02890   0943                                             ; prev addr in HL
02891   0943 22 5F 5C            LD      ($5C5F),HL      ; store pointer in X_PTR
02892   0946 2A 53 5C            LD      HL,($5C53)      ; load HL from system variable PROG
02893   0949 E3                  EX      (SP),HL         ; swap with prog/vars pointer on stack. 
02894   094A C5                  PUSH    BC              ; ** save length of new program line/variable.
02895   094B 08                  EX      AF,AF			; fetch flags back.
02896   094C 38 07               JR      C,L0955         ; skip to ME-ENT-2 if variable
02897   094E             
02898   094E 2B                  DEC     HL              ; address location before pointer
02899   094F CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates room for BASIC line
02900   0952 23                  INC     HL              ; address next.
02901   0953 18 03               JR      L0958           ; forward to ME-ENT-3
02902   0955             
02903   0955             ; ---
02904   0955             
02905   0955             ;; ME-ENT-2
02906   0955 CD 55 16    L0955:   CALL    L1655           ; routine MAKE-ROOM creates room for variable.
02907   0958             
02908   0958             ;; ME-ENT-3
02909   0958 23          L0958:   INC     HL              ; address next?
02910   0959             
02911   0959 C1                  POP     BC              ; ** pop length
02912   095A D1                  POP     DE              ; * pop value for PROG which may have been 
02913   095B                                             ; altered by POINTERS if first line.
02914   095B ED 53 53 5C         LD      ($5C53),DE      ; set PROG to original value.
02915   095F ED 5B 5F 5C         LD      DE,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
02916   0963 C5                  PUSH    BC              ; save length
02917   0964 D5                  PUSH    DE              ; and workspace pointer
02918   0965 EB                  EX      DE,HL           ; make workspace pointer source, prog/vars
02919   0966                                             ; pointer the destination
02920   0966 ED B0               LDIR                    ; copy bytes of line or variable into new area.
02921   0968 E1                  POP     HL              ; restore workspace pointer.
02922   0969 C1                  POP     BC              ; restore length.
02923   096A D5                  PUSH    DE              ; save new prog/vars pointer.
02924   096B CD E8 19            CALL    L19E8           ; routine RECLAIM-2 reclaims the space used
02925   096E                                             ; by the line or variable in workspace block
02926   096E                                             ; as no longer required and space could be 
02927   096E                                             ; useful for adding more lines.
02928   096E D1                  POP     DE              ; restore the prog/vars pointer
02929   096F C9                  RET                     ; return.
02930   0970             
02931   0970             ; --------------------------
02932   0970             ; THE 'SAVE CONTROL' ROUTINE
02933   0970             ; --------------------------
02934   0970             ;   A branch from the main SAVE-ETC routine at SAVE-ALL.
02935   0970             ;   First the header data is saved. Then after a wait of 1 second
02936   0970             ;   the data itself is saved.
02937   0970             ;   HL points to start of data.
02938   0970             ;   IX points to start of descriptor.
02939   0970             
02940   0970             ;; SA-CONTRL
02941   0970 E5          L0970:   PUSH    HL              ; save start of data
02942   0971             
02943   0971 3E FD               LD      A,$FD           ; select system channel 'S'
02944   0973 CD 01 16            CALL    L1601           ; routine CHAN-OPEN
02945   0976             
02946   0976 AF                  XOR     A               ; clear to address table directly
02947   0977 11 A1 09            LD      DE,L09A1        ; address: tape-msgs
02948   097A CD 0A 0C            CALL    L0C0A           ; routine PO-MSG -
02949   097D                                             ; 'Start tape then press any key.'
02950   097D             
02951   097D FD CB 02 EE         SET     5,(IY+$02)      ; TV_FLAG  - Signal lower screen requires
02952   0981                                             ; clearing
02953   0981 CD D4 15            CALL    L15D4           ; routine WAIT-KEY
02954   0984             
02955   0984 DD E5               PUSH    IX              ; save pointer to descriptor.
02956   0986 11 11 00            LD      DE,$0011        ; there are seventeen bytes.
02957   0989 AF                  XOR     A               ; signal a header.
02958   098A CD C2 04            CALL    L04C2           ; routine SA-BYTES
02959   098D             
02960   098D DD E1               POP     IX              ; restore descriptor pointer.
02961   098F             
02962   098F 06 32               LD      B,$32           ; wait for a second - 50 interrupts.
02963   0991             
02964   0991             ;; SA-1-SEC
02965   0991 76          L0991:   HALT                    ; wait for interrupt
02966   0992 10 FD               DJNZ    L0991           ; back to SA-1-SEC until pause complete.
02967   0994             
02968   0994 DD 5E 0B            LD      E,(IX+$0B)      ; fetch length of bytes from the
02969   0997 DD 56 0C            LD      D,(IX+$0C)      ; descriptor.
02970   099A             
02971   099A 3E FF               LD      A,$FF           ; signal data bytes.
02972   099C             
02973   099C DD E1               POP     IX              ; retrieve pointer to start
02974   099E C3 C2 04            JP      L04C2           ; jump back to SA-BYTES
02975   09A1             
02976   09A1             
02977   09A1             ;   Arrangement of two headers in workspace.
02978   09A1             ;   Originally IX addresses first location and only one header is required
02979   09A1             ;   when saving.
02980   09A1             ;
02981   09A1             ;   OLD     NEW         PROG   DATA  DATA  CODE 
02982   09A1             ;   HEADER  HEADER             num   chr          NOTES.
02983   09A1             ;   ------  ------      ----   ----  ----  ----   -----------------------------
02984   09A1             ;   IX-$11  IX+$00      0      1     2     3      Type.
02985   09A1             ;   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
02986   09A1             ;   IX-$0F  IX+$02      x      x     x     x      i
02987   09A1             ;   IX-$0E  IX+$03      x      x     x     x      l
02988   09A1             ;   IX-$0D  IX+$04      x      x     x     x      e
02989   09A1             ;   IX-$0C  IX+$05      x      x     x     x      n
02990   09A1             ;   IX-$0B  IX+$06      x      x     x     x      a
02991   09A1             ;   IX-$0A  IX+$07      x      x     x     x      m
02992   09A1             ;   IX-$09  IX+$08      x      x     x     x      e
02993   09A1             ;   IX-$08  IX+$09      x      x     x     x      .
02994   09A1             ;   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
02995   09A1             ;   IX-$06  IX+$0B      lo     lo    lo    lo     Total  
02996   09A1             ;   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
02997   09A1             ;   IX-$04  IX+$0D      Auto   -     -     Start  Various
02998   09A1             ;   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
02999   09A1             ;   IX-$02  IX+$0F      lo     -     -     -      Length of Program 
03000   09A1             ;   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.
03001   09A1             ;
03002   09A1             
03003   09A1             
03004   09A1             ; ------------------------
03005   09A1             ; Canned cassette messages
03006   09A1             ; ------------------------
03007   09A1             ;   The last-character-inverted Cassette messages.
03008   09A1             ;   Starts with normal initial step-over byte.
03009   09A1             
03010   09A1             ;; tape-msgs
03011   09A1 80          L09A1:   DEFB    $80
03012   09A2                     DEFM    "Start tape, then press any key"
03012   09A2 537461727420746170652C207468656E20707265737320616E79206B6579
03013   09C0 AE          L09C0:   DEFB    '.'+$80
03014   09C1 0D                  DEFB    $0D
03015   09C2                     DEFM    "Program:"
03015   09C2 50726F6772616D3A
03016   09CA A0                  DEFB    ' '+$80
03017   09CB 0D                  DEFB    $0D
03018   09CC                     DEFM    "Number array:"
03018   09CC 4E756D6265722061727261793A
03019   09D9 A0                  DEFB    ' '+$80
03020   09DA 0D                  DEFB    $0D
03021   09DB                     DEFM    "Character array:"
03021   09DB 4368617261637465722061727261793A
03022   09EB A0                  DEFB    ' '+$80
03023   09EC 0D                  DEFB    $0D
03024   09ED                     DEFM    "Bytes:"
03024   09ED 42797465733A
03025   09F3 A0                  DEFB    ' '+$80
03026   09F4             
03027   09F4             
03028   09F4             ;**************************************************
03029   09F4             ;** Part 5. SCREEN AND PRINTER HANDLING ROUTINES **
03030   09F4             ;**************************************************
03031   09F4             
03032   09F4             ; --------------------------
03033   09F4             ; THE 'PRINT OUTPUT' ROUTINE
03034   09F4             ; --------------------------
03035   09F4             ;   This is the routine most often used by the RST 10 restart although the
03036   09F4             ;   subroutine is on two occasions called directly when it is known that
03037   09F4             ;   output will definitely be to the lower screen.
03038   09F4             
03039   09F4             ;; PRINT-OUT
03040   09F4 CD 03 0B    L09F4:   CALL    L0B03           ; routine PO-FETCH fetches print position
03041   09F7                                             ; to HL register pair.
03042   09F7 FE 20               CP      $20             ; is character a space or higher ?
03043   09F9 D2 D9 0A            JP      NC,L0AD9        ; jump forward to PO-ABLE if so.
03044   09FC             
03045   09FC FE 06               CP      $06             ; is character in range 00-05 ?
03046   09FE 38 69               JR      C,L0A69         ; to PO-QUEST to print '?' if so.
03047   0A00             
03048   0A00 FE 18               CP      $18             ; is character in range 24d - 31d ?
03049   0A02 30 65               JR      NC,L0A69        ; to PO-QUEST to also print '?' if so.
03050   0A04             
03051   0A04 21 0B 0A            LD      HL,L0A11 - 6    ; address 0A0B - the base address of control
03052   0A07                                             ; character table - where zero would be.
03053   0A07 5F                  LD      E,A             ; control character 06 - 23d
03054   0A08 16 00               LD      D,$00           ; is transferred to DE.
03055   0A0A             
03056   0A0A 19                  ADD     HL,DE           ; index into table.
03057   0A0B             
03058   0A0B 5E                  LD      E,(HL)          ; fetch the offset to routine.
03059   0A0C 19                  ADD     HL,DE           ; add to make HL the address.
03060   0A0D E5                  PUSH    HL              ; push the address.
03061   0A0E             
03062   0A0E C3 03 0B            JP      L0B03           ; Jump forward to PO-FETCH, 
03063   0A11                                             ; as the screen/printer position has been 
03064   0A11                                             ; disturbed, and then indirectly to the PO-STORE
03065   0A11                                             ; routine on stack.
03066   0A11             
03067   0A11             ; -----------------------------
03068   0A11             ; THE 'CONTROL CHARACTER' TABLE
03069   0A11             ; -----------------------------
03070   0A11             ;   For control characters in the range 6 - 23d the following table
03071   0A11             ;   is indexed to provide an offset to the handling routine that
03072   0A11             ;   follows the table.
03073   0A11             
03074   0A11             ;; ctlchrtab
03075   0A11 4E          L0A11:   DEFB    L0A5F - $       ; 06d offset $4E to Address: PO-COMMA
03076   0A12 57                  DEFB    L0A69 - $       ; 07d offset $57 to Address: PO-QUEST
03077   0A13 10                  DEFB    L0A23 - $       ; 08d offset $10 to Address: PO-BACK-1
03078   0A14 29                  DEFB    L0A3D - $       ; 09d offset $29 to Address: PO-RIGHT
03079   0A15 54                  DEFB    L0A69 - $       ; 10d offset $54 to Address: PO-QUEST
03080   0A16 53                  DEFB    L0A69 - $       ; 11d offset $53 to Address: PO-QUEST
03081   0A17 52                  DEFB    L0A69 - $       ; 12d offset $52 to Address: PO-QUEST
03082   0A18 37                  DEFB    L0A4F - $       ; 13d offset $37 to Address: PO-ENTER
03083   0A19 50                  DEFB    L0A69 - $       ; 14d offset $50 to Address: PO-QUEST
03084   0A1A 4F                  DEFB    L0A69 - $       ; 15d offset $4F to Address: PO-QUEST
03085   0A1B 5F                  DEFB    L0A7A - $       ; 16d offset $5F to Address: PO-1-OPER
03086   0A1C 5E                  DEFB    L0A7A - $       ; 17d offset $5E to Address: PO-1-OPER
03087   0A1D 5D                  DEFB    L0A7A - $       ; 18d offset $5D to Address: PO-1-OPER
03088   0A1E 5C                  DEFB    L0A7A - $       ; 19d offset $5C to Address: PO-1-OPER
03089   0A1F 5B                  DEFB    L0A7A - $       ; 20d offset $5B to Address: PO-1-OPER
03090   0A20 5A                  DEFB    L0A7A - $       ; 21d offset $5A to Address: PO-1-OPER
03091   0A21 54                  DEFB    L0A75 - $       ; 22d offset $54 to Address: PO-2-OPER
03092   0A22 53                  DEFB    L0A75 - $       ; 23d offset $53 to Address: PO-2-OPER
03093   0A23             
03094   0A23             
03095   0A23             ; -------------------------
03096   0A23             ; THE 'CURSOR LEFT' ROUTINE
03097   0A23             ; -------------------------
03098   0A23             ;   Backspace and up a line if that action is from the left of screen.
03099   0A23             ;   For ZX printer backspace up to first column but not beyond.
03100   0A23             
03101   0A23             ;; PO-BACK-1
03102   0A23 0C          L0A23:   INC     C               ; move left one column.
03103   0A24 3E 22               LD      A,$22           ; value $21 is leftmost column.
03104   0A26 B9                  CP      C               ; have we passed ?
03105   0A27 20 11               JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
03106   0A29             
03107   0A29 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03108   0A2D 20 09               JR      NZ,L0A38        ; to PO-BACK-2 if so, as we are unable to
03109   0A2F                                             ; backspace from the leftmost position.
03110   0A2F             
03111   0A2F             
03112   0A2F 04                  INC     B               ; move up one screen line
03113   0A30 0E 02               LD      C,$02           ; the rightmost column position.
03114   0A32 3E 18               LD      A,$18           ; Note. This should be $19
03115   0A34                                             ; credit. Dr. Frank O'Hara, 1982
03116   0A34             
03117   0A34 B8                  CP      B               ; has position moved past top of screen ?
03118   0A35 20 03               JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
03119   0A37             
03120   0A37 05                  DEC     B               ; else back to $18.
03121   0A38             
03122   0A38             ;; PO-BACK-2
03123   0A38 0E 21       L0A38:   LD      C,$21           ; the leftmost column position.
03124   0A3A             
03125   0A3A             ;; PO-BACK-3
03126   0A3A C3 D9 0D    L0A3A:   JP      L0DD9           ; to CL-SET and PO-STORE to save new
03127   0A3D                                             ; position in system variables.
03128   0A3D             
03129   0A3D             ; --------------------------
03130   0A3D             ; THE 'CURSOR RIGHT' ROUTINE
03131   0A3D             ; --------------------------
03132   0A3D             ;   This moves the print position to the right leaving a trail in the
03133   0A3D             ;   current background colour.
03134   0A3D             ;   "However the programmer has failed to store the new print position
03135   0A3D             ;   so CHR$ 9 will only work if the next print position is at a newly
03136   0A3D             ;   defined place.
03137   0A3D             ;   e.g. PRINT PAPER 2; CHR$ 9; AT 4,0;
03138   0A3D             ;   does work but is not very helpful"
03139   0A3D             ;   - Dr. Ian Logan, Understanding Your Spectrum, 1982.
03140   0A3D             
03141   0A3D             ;; PO-RIGHT
03142   0A3D 3A 91 5C    L0A3D:   LD      A,($5C91)       ; fetch P_FLAG value
03143   0A40 F5                  PUSH    AF              ; and save it on stack.
03144   0A41             
03145   0A41 FD 36 57 01         LD      (IY+$57),$01    ; temporarily set P_FLAG 'OVER 1'.
03146   0A45 3E 20               LD      A,$20           ; prepare a space.
03147   0A47 CD 65 0B            CALL    L0B65           ; routine PO-CHAR to print it.
03148   0A4A                                             ; Note. could be PO-ABLE which would update
03149   0A4A                                             ; the column position.
03150   0A4A             
03151   0A4A F1                  POP     AF              ; restore the permanent flag.
03152   0A4B 32 91 5C            LD      ($5C91),A       ; and restore system variable P_FLAG
03153   0A4E             
03154   0A4E C9                  RET                     ; return without updating column position
03155   0A4F             
03156   0A4F             ; -----------------------
03157   0A4F             ; Perform carriage return
03158   0A4F             ; -----------------------
03159   0A4F             ; A carriage return is 'printed' to screen or printer buffer.
03160   0A4F             
03161   0A4F             ;; PO-ENTER
03162   0A4F FD CB 01 4E L0A4F:   BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03163   0A53 C2 CD 0E            JP      NZ,L0ECD        ; to COPY-BUFF if so, to flush buffer and reset
03164   0A56                                             ; the print position.
03165   0A56             
03166   0A56 0E 21               LD      C,$21           ; the leftmost column position.
03167   0A58 CD 55 0C            CALL    L0C55           ; routine PO-SCR handles any scrolling required.
03168   0A5B 05                  DEC     B               ; to next screen line.
03169   0A5C C3 D9 0D            JP      L0DD9           ; jump forward to CL-SET to store new position.
03170   0A5F             
03171   0A5F             ; -----------
03172   0A5F             ; Print comma
03173   0A5F             ; -----------
03174   0A5F             ; The comma control character. The 32 column screen has two 16 character
03175   0A5F             ; tabstops.  The routine is only reached via the control character table.
03176   0A5F             
03177   0A5F             ;; PO-COMMA
03178   0A5F CD 03 0B    L0A5F:   CALL    L0B03           ; routine PO-FETCH - seems unnecessary.
03179   0A62             
03180   0A62 79                  LD      A,C             ; the column position. $21-$01
03181   0A63 3D                  DEC     A               ; move right. $20-$00
03182   0A64 3D                  DEC     A               ; and again   $1F-$00 or $FF if trailing
03183   0A65 E6 10               AND     $10             ; will be $00 or $10.
03184   0A67 18 5A               JR      L0AC3           ; forward to PO-FILL
03185   0A69             
03186   0A69             ; -------------------
03187   0A69             ; Print question mark
03188   0A69             ; -------------------
03189   0A69             ; This routine prints a question mark which is commonly
03190   0A69             ; used to print an unassigned control character in range 0-31d.
03191   0A69             ; there are a surprising number yet to be assigned.
03192   0A69             
03193   0A69             ;; PO-QUEST
03194   0A69 3E 3F       L0A69:   LD      A,$3F           ; prepare the character '?'.
03195   0A6B 18 6C               JR      L0AD9           ; forward to PO-ABLE.
03196   0A6D             
03197   0A6D             ; --------------------------------
03198   0A6D             ; Control characters with operands
03199   0A6D             ; --------------------------------
03200   0A6D             ; Certain control characters are followed by 1 or 2 operands.
03201   0A6D             ; The entry points from control character table are PO-2-OPER and PO-1-OPER.
03202   0A6D             ; The routines alter the output address of the current channel so that
03203   0A6D             ; subsequent RST $10 instructions take the appropriate action
03204   0A6D             ; before finally resetting the output address back to PRINT-OUT.
03205   0A6D             
03206   0A6D             ;; PO-TV-2
03207   0A6D 11 87 0A    L0A6D:   LD      DE,L0A87        ; address: PO-CONT will be next output routine
03208   0A70 32 0F 5C            LD      ($5C0F),A       ; store first operand in TVDATA-hi
03209   0A73 18 0B               JR      L0A80           ; forward to PO-CHANGE >>
03210   0A75             
03211   0A75             ; ---
03212   0A75             
03213   0A75             ; -> This initial entry point deals with two operands - AT or TAB.
03214   0A75             
03215   0A75             ;; PO-2-OPER
03216   0A75 11 6D 0A    L0A75:   LD      DE,L0A6D        ; address: PO-TV-2 will be next output routine
03217   0A78 18 03               JR      L0A7D           ; forward to PO-TV-1
03218   0A7A             
03219   0A7A             ; ---
03220   0A7A             
03221   0A7A             ; -> This initial entry point deals with one operand INK to OVER.
03222   0A7A             
03223   0A7A             ;; PO-1-OPER
03224   0A7A 11 87 0A    L0A7A:   LD      DE,L0A87        ; address: PO-CONT will be next output routine
03225   0A7D             
03226   0A7D             ;; PO-TV-1
03227   0A7D 32 0E 5C    L0A7D:   LD      ($5C0E),A       ; store control code in TVDATA-lo
03228   0A80             
03229   0A80             ;; PO-CHANGE
03230   0A80 2A 51 5C    L0A80:   LD      HL,($5C51)      ; use CURCHL to find current output channel.
03231   0A83 73                  LD      (HL),E          ; make it
03232   0A84 23                  INC     HL              ; the supplied
03233   0A85 72                  LD      (HL),D          ; address from DE.
03234   0A86 C9                  RET                     ; return.
03235   0A87             
03236   0A87             ; ---
03237   0A87             
03238   0A87             ;; PO-CONT
03239   0A87 11 F4 09    L0A87:   LD      DE,L09F4        ; Address: PRINT-OUT
03240   0A8A CD 80 0A            CALL    L0A80           ; routine PO-CHANGE to restore normal channel.
03241   0A8D 2A 0E 5C            LD      HL,($5C0E)      ; TVDATA gives control code and possible
03242   0A90                                             ; subsequent character
03243   0A90 57                  LD      D,A             ; save current character
03244   0A91 7D                  LD      A,L             ; the stored control code
03245   0A92 FE 16               CP      $16             ; was it INK to OVER (1 operand) ?
03246   0A94 DA 11 22            JP      C,L2211         ; to CO-TEMP-5
03247   0A97             
03248   0A97 20 29               JR      NZ,L0AC2        ; to PO-TAB if not 22d i.e. 23d TAB.
03249   0A99             
03250   0A99                                             ; else must have been 22d AT.
03251   0A99 44                  LD      B,H             ; line to H   (0-23d)
03252   0A9A 4A                  LD      C,D             ; column to C (0-31d)
03253   0A9B 3E 1F               LD      A,$1F           ; the value 31d
03254   0A9D 91                  SUB     C               ; reverse the column number.
03255   0A9E 38 0C               JR      C,L0AAC         ; to PO-AT-ERR if C was greater than 31d.
03256   0AA0             
03257   0AA0 C6 02               ADD     A,$02           ; transform to system range $02-$21
03258   0AA2 4F                  LD      C,A             ; and place in column register.
03259   0AA3             
03260   0AA3 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03261   0AA7 20 16               JR      NZ,L0ABF        ; to PO-AT-SET as line can be ignored.
03262   0AA9             
03263   0AA9 3E 16               LD      A,$16           ; 22 decimal
03264   0AAB 90                  SUB     B               ; subtract line number to reverse
03265   0AAC                                             ; 0 - 22 becomes 22 - 0.
03266   0AAC             
03267   0AAC             ;; PO-AT-ERR
03268   0AAC DA 9F 1E    L0AAC:   JP      C,L1E9F         ; to REPORT-B if higher than 22 decimal
03269   0AAF                                             ; Integer out of range.
03270   0AAF             
03271   0AAF 3C                  INC     A               ; adjust for system range $01-$17
03272   0AB0 47                  LD      B,A             ; place in line register
03273   0AB1 04                  INC     B               ; adjust to system range  $02-$18
03274   0AB2 FD CB 02 46         BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?
03275   0AB6 C2 55 0C            JP      NZ,L0C55        ; exit to PO-SCR to test for scrolling
03276   0AB9             
03277   0AB9 FD BE 31            CP      (IY+$31)        ; Compare against DF_SZ
03278   0ABC DA 86 0C            JP      C,L0C86         ; to REPORT-5 if too low
03279   0ABF                                             ; Out of screen.
03280   0ABF             
03281   0ABF             ;; PO-AT-SET
03282   0ABF C3 D9 0D    L0ABF:   JP      L0DD9           ; print position is valid so exit via CL-SET
03283   0AC2             
03284   0AC2             ; ---
03285   0AC2             
03286   0AC2             ; Continue here when dealing with TAB.
03287   0AC2             ; Note. In BASIC, TAB is followed by a 16-bit number and was initially
03288   0AC2             ; designed to work with any output device.
03289   0AC2             
03290   0AC2             ;; PO-TAB
03291   0AC2 7C          L0AC2:   LD      A,H             ; transfer parameter to A
03292   0AC3                                             ; Losing current character -
03293   0AC3                                             ; High byte of TAB parameter.
03294   0AC3             
03295   0AC3             
03296   0AC3             ;; PO-FILL
03297   0AC3 CD 03 0B    L0AC3:   CALL    L0B03           ; routine PO-FETCH, HL-addr, BC=line/column.
03298   0AC6                                             ; column 1 (right), $21 (left)
03299   0AC6 81                  ADD     A,C             ; add operand to current column
03300   0AC7 3D                  DEC     A               ; range 0 - 31+
03301   0AC8 E6 1F               AND     $1F             ; make range 0 - 31d
03302   0ACA C8                  RET     Z               ; return if result zero
03303   0ACB             
03304   0ACB 57                  LD      D,A             ; Counter to D
03305   0ACC FD CB 01 C6         SET     0,(IY+$01)      ; update FLAGS  - signal suppress leading space.
03306   0AD0             
03307   0AD0             ;; PO-SPACE
03308   0AD0 3E 20       L0AD0:   LD      A,$20           ; space character.
03309   0AD2             
03310   0AD2 CD 3B 0C            CALL    L0C3B           ; routine PO-SAVE prints the character
03311   0AD5                                             ; using alternate set (normal output routine)
03312   0AD5             
03313   0AD5 15                  DEC     D               ; decrement counter.
03314   0AD6 20 F8               JR      NZ,L0AD0        ; to PO-SPACE until done
03315   0AD8             
03316   0AD8 C9                  RET                     ; return
03317   0AD9             
03318   0AD9             ; ----------------------
03319   0AD9             ; Printable character(s)
03320   0AD9             ; ----------------------
03321   0AD9             ; This routine prints printable characters and continues into
03322   0AD9             ; the position store routine
03323   0AD9             
03324   0AD9             ;; PO-ABLE
03325   0AD9 CD 24 0B    L0AD9:   CALL    L0B24           ; routine PO-ANY
03326   0ADC                                             ; and continue into position store routine.
03327   0ADC             
03328   0ADC             ; ----------------------------
03329   0ADC             ; THE 'POSITION STORE' ROUTINE
03330   0ADC             ; ----------------------------
03331   0ADC             ;   This routine updates the system variables associated with the main screen, 
03332   0ADC             ;   the lower screen/input buffer or the ZX printer.
03333   0ADC             
03334   0ADC             ;; PO-STORE
03335   0ADC FD CB 01 4E L0ADC:   BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
03336   0AE0 20 1A               JR      NZ,L0AFC        ; Forward, if so, to PO-ST-PR
03337   0AE2             
03338   0AE2 FD CB 02 46         BIT     0,(IY+$02)      ; Test TV_FLAG - is lower screen in use ?
03339   0AE6 20 08               JR      NZ,L0AF0        ; Forward, if so, to PO-ST-E
03340   0AE8             
03341   0AE8             ;   This section deals with the upper screen.
03342   0AE8             
03343   0AE8 ED 43 88 5C         LD      ($5C88),BC      ; Update S_POSN - line/column upper screen
03344   0AEC 22 84 5C            LD      ($5C84),HL      ; Update DF_CC - upper display file address
03345   0AEF             
03346   0AEF C9                  RET                     ; Return.
03347   0AF0             
03348   0AF0             ; ---
03349   0AF0             
03350   0AF0             ;   This section deals with the lower screen.
03351   0AF0             
03352   0AF0             ;; PO-ST-E
03353   0AF0 ED 43 8A 5C L0AF0:   LD      ($5C8A),BC      ; Update SPOSNL line/column lower screen
03354   0AF4 ED 43 82 5C         LD      ($5C82),BC      ; Update ECHO_E line/column input buffer
03355   0AF8 22 86 5C            LD      ($5C86),HL      ; Update DFCCL  lower screen memory address
03356   0AFB C9                  RET                     ; Return.
03357   0AFC             
03358   0AFC             ; ---
03359   0AFC             
03360   0AFC             ;   This section deals with the ZX Printer.
03361   0AFC             
03362   0AFC             ;; PO-ST-PR
03363   0AFC FD 71 45    L0AFC:   LD      (IY+$45),C      ; Update P_POSN column position printer
03364   0AFF 22 80 5C            LD      ($5C80),HL      ; Update PR_CC - full printer buffer memory 
03365   0B02                                             ; address
03366   0B02 C9                  RET                     ; Return.
03367   0B03             
03368   0B03             ;   Note. that any values stored in location 23681 will be overwritten with 
03369   0B03             ;   the value 91 decimal. 
03370   0B03             ;   Credit April 1983, Dilwyn Jones. "Delving Deeper into your ZX Spectrum".
03371   0B03             
03372   0B03             ; ----------------------------
03373   0B03             ; THE 'POSITION FETCH' ROUTINE
03374   0B03             ; ----------------------------
03375   0B03             ;   This routine fetches the line/column and display file address of the upper 
03376   0B03             ;   and lower screen or, if the printer is in use, the column position and 
03377   0B03             ;   absolute memory address.
03378   0B03             ;   Note. that PR-CC-hi (23681) is used by this routine and if, in accordance 
03379   0B03             ;   with the manual (that says this is unused), the location has been used for 
03380   0B03             ;   other purposes, then subsequent output to the printer buffer could corrupt 
03381   0B03             ;   a 256-byte section of memory.
03382   0B03             
03383   0B03             ;; PO-FETCH
03384   0B03 FD CB 01 4E L0B03:   BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
03385   0B07 20 14               JR      NZ,L0B1D        ; Forward, if so, to PO-F-PR
03386   0B09             
03387   0B09             ;   assume upper screen in use and thus optimize for path that requires speed.
03388   0B09             
03389   0B09 ED 4B 88 5C         LD      BC,($5C88)      ; Fetch line/column from S_POSN
03390   0B0D 2A 84 5C            LD      HL,($5C84)      ; Fetch DF_CC display file address
03391   0B10             
03392   0B10 FD CB 02 46         BIT     0,(IY+$02)      ; Test TV_FLAG - lower screen in use ?
03393   0B14 C8                  RET     Z               ; Return if upper screen in use.
03394   0B15             
03395   0B15             ;   Overwrite registers with values for lower screen.
03396   0B15             
03397   0B15 ED 4B 8A 5C         LD      BC,($5C8A)      ; Fetch line/column from SPOSNL
03398   0B19 2A 86 5C            LD      HL,($5C86)      ; Fetch display file address from DFCCL
03399   0B1C C9                  RET                     ; Return.
03400   0B1D             
03401   0B1D             ; ---
03402   0B1D             
03403   0B1D             ;   This section deals with the ZX Printer.
03404   0B1D             
03405   0B1D             ;; PO-F-PR
03406   0B1D FD 4E 45    L0B1D:   LD      C,(IY+$45)      ; Fetch column from P_POSN.
03407   0B20 2A 80 5C            LD      HL,($5C80)      ; Fetch printer buffer address from PR_CC.
03408   0B23 C9                  RET                     ; Return.
03409   0B24             
03410   0B24             ; ---------------------------------
03411   0B24             ; THE 'PRINT ANY CHARACTER' ROUTINE
03412   0B24             ; ---------------------------------
03413   0B24             ;   This routine is used to print any character in range 32d - 255d
03414   0B24             ;   It is only called from PO-ABLE which continues into PO-STORE
03415   0B24             
03416   0B24             ;; PO-ANY
03417   0B24 FE 80       L0B24:   CP      $80             ; ASCII ?
03418   0B26 38 3D               JR      C,L0B65         ; to PO-CHAR is so.
03419   0B28             
03420   0B28 FE 90               CP      $90             ; test if a block graphic character.
03421   0B2A 30 26               JR      NC,L0B52        ; to PO-T&UDG to print tokens and UDGs
03422   0B2C             
03423   0B2C             ; The 16 2*2 mosaic characters 128-143 decimal are formed from
03424   0B2C             ; bits 0-3 of the character.
03425   0B2C             
03426   0B2C 47                  LD      B,A             ; save character
03427   0B2D CD 38 0B            CALL    L0B38           ; routine PO-GR-1 to construct top half
03428   0B30                                             ; then bottom half.
03429   0B30 CD 03 0B            CALL    L0B03           ; routine PO-FETCH fetches print position.
03430   0B33 11 92 5C            LD      DE,$5C92        ; MEM-0 is location of 8 bytes of character
03431   0B36 18 47               JR      L0B7F           ; to PR-ALL to print to screen or printer
03432   0B38             
03433   0B38             ; ---
03434   0B38             
03435   0B38             ;; PO-GR-1
03436   0B38 21 92 5C    L0B38:   LD      HL,$5C92        ; address MEM-0 - a temporary buffer in
03437   0B3B                                             ; systems variables which is normally used
03438   0B3B                                             ; by the calculator.
03439   0B3B CD 3E 0B            CALL    L0B3E           ; routine PO-GR-2 to construct top half
03440   0B3E                                             ; and continue into routine to construct
03441   0B3E                                             ; bottom half.
03442   0B3E             
03443   0B3E             ;; PO-GR-2
03444   0B3E CB 18       L0B3E:   RR      B               ; rotate bit 0/2 to carry
03445   0B40 9F                  SBC     A,A             ; result $00 or $FF
03446   0B41 E6 0F               AND     $0F             ; mask off right hand side
03447   0B43 4F                  LD      C,A             ; store part in C
03448   0B44 CB 18               RR      B               ; rotate bit 1/3 of original chr to carry
03449   0B46 9F                  SBC     A,A             ; result $00 or $FF
03450   0B47 E6 F0               AND     $F0             ; mask off left hand side
03451   0B49 B1                  OR      C               ; combine with stored pattern
03452   0B4A 0E 04               LD      C,$04           ; four bytes for top/bottom half
03453   0B4C             
03454   0B4C             ;; PO-GR-3
03455   0B4C 77          L0B4C:   LD      (HL),A          ; store bit patterns in temporary buffer
03456   0B4D 23                  INC     HL              ; next address
03457   0B4E 0D                  DEC     C               ; jump back to
03458   0B4F 20 FB               JR      NZ,L0B4C        ; to PO-GR-3 until byte is stored 4 times
03459   0B51             
03460   0B51 C9                  RET                     ; return
03461   0B52             
03462   0B52             ; ---
03463   0B52             
03464   0B52             ; Tokens and User defined graphics are now separated.
03465   0B52             
03466   0B52             ;; PO-T&UDG
03467   0B52 D6 A5       L0B52:   SUB     $A5             ; the 'RND' character
03468   0B54 30 09               JR      NC,L0B5F        ; to PO-T to print tokens
03469   0B56             
03470   0B56 C6 15               ADD     A,$15           ; add 21d to restore to 0 - 20
03471   0B58 C5                  PUSH    BC              ; save current print position
03472   0B59 ED 4B 7B 5C         LD      BC,($5C7B)      ; fetch UDG to address bit patterns
03473   0B5D 18 0B               JR      L0B6A           ; to PO-CHAR-2 - common code to lay down
03474   0B5F                                             ; a bit patterned character
03475   0B5F             
03476   0B5F             ; ---
03477   0B5F             
03478   0B5F             ;; PO-T
03479   0B5F CD 10 0C    L0B5F:   CALL    L0C10           ; routine PO-TOKENS prints tokens
03480   0B62 C3 03 0B            JP      L0B03           ; exit via a JUMP to PO-FETCH as this routine 
03481   0B65                                             ; must continue into PO-STORE. 
03482   0B65                                             ; A JR instruction could be used.
03483   0B65             
03484   0B65             ; This point is used to print ASCII characters  32d - 127d.
03485   0B65             
03486   0B65             ;; PO-CHAR
03487   0B65 C5          L0B65:   PUSH    BC              ; save print position
03488   0B66 ED 4B 36 5C         LD      BC,($5C36)      ; address CHARS
03489   0B6A             
03490   0B6A             ; This common code is used to transfer the character bytes to memory.
03491   0B6A             
03492   0B6A             ;; PO-CHAR-2
03493   0B6A EB          L0B6A:   EX      DE,HL           ; transfer destination address to DE
03494   0B6B 21 3B 5C            LD      HL,$5C3B        ; point to FLAGS
03495   0B6E CB 86               RES     0,(HL)          ; allow for leading space
03496   0B70 FE 20               CP      $20             ; is it a space ?
03497   0B72 20 02               JR      NZ,L0B76        ; to PO-CHAR-3 if not
03498   0B74             
03499   0B74 CB C6               SET     0,(HL)          ; signal no leading space to FLAGS
03500   0B76             
03501   0B76             ;; PO-CHAR-3
03502   0B76 26 00       L0B76:   LD      H,$00           ; set high byte to 0
03503   0B78 6F                  LD      L,A             ; character to A
03504   0B79                                             ; 0-21 UDG or 32-127 ASCII.
03505   0B79 29                  ADD     HL,HL           ; multiply
03506   0B7A 29                  ADD     HL,HL           ; by
03507   0B7B 29                  ADD     HL,HL           ; eight
03508   0B7C 09                  ADD     HL,BC           ; HL now points to first byte of character
03509   0B7D C1                  POP     BC              ; the source address CHARS or UDG
03510   0B7E EB                  EX      DE,HL           ; character address to DE
03511   0B7F             
03512   0B7F             ; ----------------------------------
03513   0B7F             ; THE 'PRINT ALL CHARACTERS' ROUTINE
03514   0B7F             ; ----------------------------------
03515   0B7F             ;   This entry point entered from above to print ASCII and UDGs but also from 
03516   0B7F             ;   earlier to print mosaic characters.
03517   0B7F             ;   HL=destination
03518   0B7F             ;   DE=character source
03519   0B7F             ;   BC=line/column
03520   0B7F             
03521   0B7F             ;; PR-ALL
03522   0B7F 79          L0B7F:   LD      A,C             ; column to A
03523   0B80 3D                  DEC     A               ; move right
03524   0B81 3E 21               LD      A,$21           ; pre-load with leftmost position
03525   0B83 20 0E               JR      NZ,L0B93        ; but if not zero to PR-ALL-1
03526   0B85             
03527   0B85 05                  DEC     B               ; down one line
03528   0B86 4F                  LD      C,A             ; load C with $21
03529   0B87 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use
03530   0B8B 28 06               JR      Z,L0B93         ; to PR-ALL-1 if not
03531   0B8D             
03532   0B8D D5                  PUSH    DE              ; save source address
03533   0B8E CD CD 0E            CALL    L0ECD           ; routine COPY-BUFF outputs line to printer
03534   0B91 D1                  POP     DE              ; restore character source address
03535   0B92 79                  LD      A,C             ; the new column number ($21) to C
03536   0B93             
03537   0B93             ;; PR-ALL-1
03538   0B93 B9          L0B93:   CP      C               ; this test is really for screen - new line ?
03539   0B94 D5                  PUSH    DE              ; save source
03540   0B95             
03541   0B95 CC 55 0C            CALL    Z,L0C55         ; routine PO-SCR considers scrolling
03542   0B98             
03543   0B98 D1                  POP     DE              ; restore source
03544   0B99 C5                  PUSH    BC              ; save line/column
03545   0B9A E5                  PUSH    HL              ; and destination
03546   0B9B 3A 91 5C            LD      A,($5C91)       ; fetch P_FLAG to accumulator
03547   0B9E 06 FF               LD      B,$FF           ; prepare OVER mask in B.
03548   0BA0 1F                  RRA                     ; bit 0 set if OVER 1
03549   0BA1 38 01               JR      C,L0BA4         ; to PR-ALL-2
03550   0BA3             
03551   0BA3 04                  INC     B               ; set OVER mask to 0
03552   0BA4             
03553   0BA4             ;; PR-ALL-2
03554   0BA4 1F          L0BA4:   RRA                     ; skip bit 1 of P_FLAG
03555   0BA5 1F                  RRA                     ; bit 2 is INVERSE
03556   0BA6 9F                  SBC     A,A             ; will be FF for INVERSE 1 else zero
03557   0BA7 4F                  LD      C,A             ; transfer INVERSE mask to C
03558   0BA8 3E 08               LD      A,$08           ; prepare to count 8 bytes
03559   0BAA A7                  AND     A               ; clear carry to signal screen
03560   0BAB FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03561   0BAF 28 05               JR      Z,L0BB6         ; to PR-ALL-3 if screen
03562   0BB1             
03563   0BB1 FD CB 30 CE         SET     1,(IY+$30)      ; update FLAGS2  - signal printer buffer has 
03564   0BB5                                             ; been used.
03565   0BB5 37                  SCF                     ; set carry flag to signal printer.
03566   0BB6             
03567   0BB6             ;; PR-ALL-3
03568   0BB6 EB          L0BB6:   EX      DE,HL           ; now HL=source, DE=destination
03569   0BB7             
03570   0BB7             ;; PR-ALL-4
03571   0BB7 08          L0BB7:   EX      AF,AF			; save printer/screen flag
03572   0BB8 1A                  LD      A,(DE)          ; fetch existing destination byte
03573   0BB9 A0                  AND     B               ; consider OVER
03574   0BBA AE                  XOR     (HL)            ; now XOR with source
03575   0BBB A9                  XOR     C               ; now with INVERSE MASK
03576   0BBC 12                  LD      (DE),A          ; update screen/printer
03577   0BBD 08                  EX      AF,AF			; restore flag
03578   0BBE 38 13               JR      C,L0BD3         ; to PR-ALL-6 - printer address update
03579   0BC0             
03580   0BC0 14                  INC     D               ; gives next pixel line down screen
03581   0BC1             
03582   0BC1             ;; PR-ALL-5
03583   0BC1 23          L0BC1:   INC     HL              ; address next character byte
03584   0BC2 3D                  DEC     A               ; the byte count is decremented
03585   0BC3 20 F2               JR      NZ,L0BB7        ; back to PR-ALL-4 for all 8 bytes
03586   0BC5             
03587   0BC5 EB                  EX      DE,HL           ; destination to HL
03588   0BC6 25                  DEC     H               ; bring back to last updated screen position
03589   0BC7 FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03590   0BCB CC DB 0B            CALL    Z,L0BDB         ; if not, call routine PO-ATTR to update
03591   0BCE                                             ; corresponding colour attribute.
03592   0BCE E1                  POP     HL              ; restore original screen/printer position
03593   0BCF C1                  POP     BC              ; and line column
03594   0BD0 0D                  DEC     C               ; move column to right
03595   0BD1 23                  INC     HL              ; increase screen/printer position
03596   0BD2 C9                  RET                     ; return and continue into PO-STORE
03597   0BD3                                             ; within PO-ABLE
03598   0BD3             
03599   0BD3             ; ---
03600   0BD3             
03601   0BD3             ;   This branch is used to update the printer position by 32 places
03602   0BD3             ;   Note. The high byte of the address D remains constant (which it should).
03603   0BD3             
03604   0BD3             ;; PR-ALL-6
03605   0BD3 08          L0BD3:   EX      AF,AF			; save the flag
03606   0BD4 3E 20               LD      A,$20           ; load A with 32 decimal
03607   0BD6 83                  ADD     A,E             ; add this to E
03608   0BD7 5F                  LD      E,A             ; and store result in E
03609   0BD8 08                  EX      AF,AF			; fetch the flag
03610   0BD9 18 E6               JR      L0BC1           ; back to PR-ALL-5
03611   0BDB             
03612   0BDB             ; -----------------------------------
03613   0BDB             ; THE 'GET ATTRIBUTE ADDRESS' ROUTINE
03614   0BDB             ; -----------------------------------
03615   0BDB             ;   This routine is entered with the HL register holding the last screen
03616   0BDB             ;   address to be updated by PRINT or PLOT.
03617   0BDB             ;   The Spectrum screen arrangement leads to the L register holding the correct
03618   0BDB             ;   value for the attribute file and it is only necessary to manipulate H to 
03619   0BDB             ;   form the correct colour attribute address.
03620   0BDB             
03621   0BDB             ;; PO-ATTR
03622   0BDB 7C          L0BDB:   LD       A,H            ; fetch high byte $40 - $57
03623   0BDC 0F                  RRCA                    ; shift
03624   0BDD 0F                  RRCA                    ; bits 3 and 4
03625   0BDE 0F                  RRCA                    ; to right.
03626   0BDF E6 03               AND     $03             ; range is now 0 - 2
03627   0BE1 F6 58               OR      $58             ; form correct high byte for third of screen
03628   0BE3 67                  LD      H,A             ; HL is now correct
03629   0BE4 ED 5B 8F 5C         LD      DE,($5C8F)      ; make D hold ATTR_T, E hold MASK-T
03630   0BE8 7E                  LD      A,(HL)          ; fetch existing attribute
03631   0BE9 AB                  XOR     E               ; apply masks
03632   0BEA A2                  AND     D               ;
03633   0BEB AB                  XOR     E               ;
03634   0BEC FD CB 57 76         BIT     6,(IY+$57)      ; test P_FLAG  - is this PAPER 9 ??
03635   0BF0 28 08               JR      Z,L0BFA         ; skip to PO-ATTR-1 if not.
03636   0BF2             
03637   0BF2 E6 C7               AND     $C7             ; set paper
03638   0BF4 CB 57               BIT     2,A             ; to contrast with ink
03639   0BF6 20 02               JR      NZ,L0BFA        ; skip to PO-ATTR-1
03640   0BF8             
03641   0BF8 EE 38               XOR     $38             ;
03642   0BFA             
03643   0BFA             ;; PO-ATTR-1
03644   0BFA FD CB 57 66 L0BFA:   BIT     4,(IY+$57)      ; test P_FLAG  - Is this INK 9 ??
03645   0BFE 28 08               JR      Z,L0C08         ; skip to PO-ATTR-2 if not
03646   0C00             
03647   0C00 E6 F8               AND     $F8             ; make ink
03648   0C02 CB 6F               BIT     5,A             ; contrast with paper.
03649   0C04 20 02               JR      NZ,L0C08        ; to PO-ATTR-2
03650   0C06             
03651   0C06 EE 07               XOR     $07             ;
03652   0C08             
03653   0C08             ;; PO-ATTR-2
03654   0C08 77          L0C08:   LD      (HL),A          ; save the new attribute.
03655   0C09 C9                  RET                     ; return.
03656   0C0A             
03657   0C0A             ; ---------------------------------
03658   0C0A             ; THE 'MESSAGE PRINTING' SUBROUTINE
03659   0C0A             ; ---------------------------------
03660   0C0A             ;   This entry point is used to print tape, boot-up, scroll? and error messages.
03661   0C0A             ;   On entry the DE register points to an initial step-over byte or the 
03662   0C0A             ;   inverted end-marker of the previous entry in the table.
03663   0C0A             ;   Register A contains the message number, often zero to print first message.
03664   0C0A             ;   (HL has nothing important usually P_FLAG)
03665   0C0A             
03666   0C0A             ;; PO-MSG
03667   0C0A E5          L0C0A:   PUSH    HL              ; put hi-byte zero on stack to suppress
03668   0C0B 26 00               LD      H,$00           ; trailing spaces
03669   0C0D E3                  EX      (SP),HL         ; ld h,0; push hl would have done ?.
03670   0C0E 18 04               JR      L0C14           ; forward to PO-TABLE.
03671   0C10             
03672   0C10             ; ---
03673   0C10             
03674   0C10             ;   This entry point prints the BASIC keywords, '<>' etc. from alt set
03675   0C10             
03676   0C10             ;; PO-TOKENS
03677   0C10 11 95 00    L0C10:   LD      DE,L0095        ; address: TKN-TABLE
03678   0C13 F5                  PUSH    AF              ; save the token number to control
03679   0C14                                             ; trailing spaces - see later *
03680   0C14             
03681   0C14             ; ->
03682   0C14             
03683   0C14             ;; PO-TABLE
03684   0C14 CD 41 0C    L0C14:   CALL    L0C41           ; routine PO-SEARCH will set carry for
03685   0C17                                             ; all messages and function words.
03686   0C17             
03687   0C17 38 09               JR      C,L0C22         ; forward to PO-EACH if not a command, '<>' etc.
03688   0C19             
03689   0C19 3E 20               LD      A,$20           ; prepare leading space
03690   0C1B FD CB 01 46         BIT     0,(IY+$01)      ; test FLAGS  - leading space if not set
03691   0C1F             
03692   0C1F CC 3B 0C            CALL    Z,L0C3B         ; routine PO-SAVE to print a space without 
03693   0C22                                             ; disturbing registers.
03694   0C22             
03695   0C22             ;; PO-EACH
03696   0C22 1A          L0C22:   LD      A,(DE)          ; Fetch character from the table.
03697   0C23 E6 7F               AND     $7F             ; Cancel any inverted bit.
03698   0C25             
03699   0C25 CD 3B 0C            CALL    L0C3B           ; Routine PO-SAVE to print using the alternate
03700   0C28                                             ; set of registers.
03701   0C28             
03702   0C28 1A                  LD      A,(DE)          ; Re-fetch character from table.
03703   0C29 13                  INC     DE              ; Address next character in the table.
03704   0C2A             
03705   0C2A 87                  ADD     A,A             ; Was character inverted ?
03706   0C2B                                             ; (this also doubles character)
03707   0C2B 30 F5               JR      NC,L0C22        ; back to PO-EACH if not.
03708   0C2D             
03709   0C2D D1                  POP     DE              ; * re-fetch trailing space byte to D 
03710   0C2E             
03711   0C2E FE 48               CP      $48             ; was the last character '$' ?
03712   0C30 28 03               JR      Z,L0C35         ; forward to PO-TR-SP to consider trailing
03713   0C32                                             ; space if so.
03714   0C32             
03715   0C32 FE 82               CP      $82             ; was it < 'A' i.e. '#','>','=' from tokens
03716   0C34                                             ; or ' ','.' (from tape) or '?' from scroll
03717   0C34             
03718   0C34 D8                  RET     C               ; Return if so as no trailing space required.
03719   0C35             
03720   0C35             ;; PO-TR-SP
03721   0C35 7A          L0C35:   LD      A,D             ; The trailing space flag (zero if an error msg)
03722   0C36             
03723   0C36 FE 03               CP      $03             ; Test against RND, INKEY$ and PI which have no
03724   0C38                                             ; parameters and therefore no trailing space.
03725   0C38             
03726   0C38 D8                  RET     C               ; Return if no trailing space.
03727   0C39             
03728   0C39 3E 20               LD      A,$20           ; Prepare the space character and continue to
03729   0C3B                                             ; print and make an indirect return.
03730   0C3B             
03731   0C3B             ; -----------------------------------
03732   0C3B             ; THE 'RECURSIVE PRINTING' SUBROUTINE
03733   0C3B             ; -----------------------------------
03734   0C3B             ;   This routine which is part of PRINT-OUT allows RST $10 to be used 
03735   0C3B             ;   recursively to print tokens and the spaces associated with them.
03736   0C3B             ;   It is called on three occasions when the value of DE must be preserved.
03737   0C3B             
03738   0C3B             ;; PO-SAVE
03739   0C3B D5          L0C3B:   PUSH    DE              ; Save DE value.
03740   0C3C D9                  EXX                     ; Switch in main set
03741   0C3D             
03742   0C3D D7                  RST     10H             ; PRINT-A prints using this alternate set.
03743   0C3E             
03744   0C3E D9                  EXX                     ; Switch back to this alternate set.
03745   0C3F D1                  POP     DE              ; Restore the initial DE value.
03746   0C40             
03747   0C40 C9                  RET                     ; Return.
03748   0C41             
03749   0C41             ; ------------
03750   0C41             ; Table search
03751   0C41             ; ------------
03752   0C41             ; This subroutine searches a message or the token table for the
03753   0C41             ; message number held in A. DE holds the address of the table.
03754   0C41             
03755   0C41             ;; PO-SEARCH
03756   0C41 F5          L0C41:   PUSH    AF              ; save the message/token number
03757   0C42 EB                  EX      DE,HL           ; transfer DE to HL
03758   0C43 3C                  INC     A               ; adjust for initial step-over byte
03759   0C44             
03760   0C44             ;; PO-STEP
03761   0C44 CB 7E       L0C44:   BIT     7,(HL)          ; is character inverted ?
03762   0C46 23                  INC     HL              ; address next
03763   0C47 28 FB               JR      Z,L0C44         ; back to PO-STEP if not inverted.
03764   0C49             
03765   0C49 3D                  DEC     A               ; decrease counter
03766   0C4A 20 F8               JR      NZ,L0C44        ; back to PO-STEP if not zero
03767   0C4C             
03768   0C4C EB                  EX      DE,HL           ; transfer address to DE
03769   0C4D F1                  POP     AF              ; restore message/token number
03770   0C4E FE 20               CP      $20             ; return with carry set
03771   0C50 D8                  RET     C               ; for all messages and function tokens
03772   0C51             
03773   0C51 1A                  LD      A,(DE)          ; test first character of token
03774   0C52 D6 41               SUB     $41             ; and return with carry set
03775   0C54 C9                  RET                     ; if it is less that 'A'
03776   0C55                                             ; i.e. '<>', '<=', '>='
03777   0C55             
03778   0C55             ; ---------------
03779   0C55             ; Test for scroll
03780   0C55             ; ---------------
03781   0C55             ; This test routine is called when printing carriage return, when considering
03782   0C55             ; PRINT AT and from the general PRINT ALL characters routine to test if
03783   0C55             ; scrolling is required, prompting the user if necessary.
03784   0C55             ; This is therefore using the alternate set.
03785   0C55             ; The B register holds the current line.
03786   0C55             
03787   0C55             ;; PO-SCR
03788   0C55 FD CB 01 4E L0C55:   BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
03789   0C59 C0                  RET     NZ              ; return immediately if so.
03790   0C5A             
03791   0C5A 11 D9 0D            LD      DE,L0DD9        ; set DE to address: CL-SET
03792   0C5D D5                  PUSH    DE              ; and push for return address.
03793   0C5E             
03794   0C5E 78                  LD      A,B             ; transfer the line to A.
03795   0C5F FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG - lower screen in use ?
03796   0C63 C2 02 0D            JP      NZ,L0D02        ; jump forward to PO-SCR-4 if so.
03797   0C66             
03798   0C66 FD BE 31            CP      (IY+$31)        ; greater than DF_SZ display file size ?
03799   0C69 38 1B               JR      C,L0C86         ; forward to REPORT-5 if less.
03800   0C6B                                             ; 'Out of screen'
03801   0C6B             
03802   0C6B C0                  RET     NZ              ; return (via CL-SET) if greater
03803   0C6C             
03804   0C6C FD CB 02 66         BIT     4,(IY+$02)      ; test TV_FLAG  - Automatic listing ?
03805   0C70 28 16               JR      Z,L0C88         ; forward to PO-SCR-2 if not.
03806   0C72             
03807   0C72 FD 5E 2D            LD      E,(IY+$2D)      ; fetch BREG - the count of scroll lines to E.
03808   0C75 1D                  DEC     E               ; decrease and jump
03809   0C76 28 5A               JR      Z,L0CD2         ; to PO-SCR-3 if zero and scrolling required.
03810   0C78             
03811   0C78 3E 00               LD      A,$00           ; explicit - select channel zero.
03812   0C7A CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it.
03813   0C7D             
03814   0C7D ED 7B 3F 5C         LD      SP,($5C3F)      ; set stack pointer to LIST_SP
03815   0C81             
03816   0C81 FD CB 02 A6         RES     4,(IY+$02)      ; reset TV_FLAG  - signal auto listing finished.
03817   0C85 C9                  RET                     ; return ignoring pushed value, CL-SET
03818   0C86                                             ; to MAIN or EDITOR without updating
03819   0C86                                             ; print position                         >>
03820   0C86             
03821   0C86             ; ---
03822   0C86             
03823   0C86             
03824   0C86             ;; REPORT-5
03825   0C86 CF          L0C86:   RST     08H             ; ERROR-1
03826   0C87 04                  DEFB    $04             ; Error Report: Out of screen
03827   0C88             
03828   0C88             ; continue here if not an automatic listing.
03829   0C88             
03830   0C88             ;; PO-SCR-2
03831   0C88 FD 35 52    L0C88:   DEC     (IY+$52)        ; decrease SCR_CT
03832   0C8B 20 45               JR      NZ,L0CD2        ; forward to PO-SCR-3 to scroll display if
03833   0C8D                                             ; result not zero.
03834   0C8D             
03835   0C8D             ; now produce prompt.
03836   0C8D             
03837   0C8D 3E 18               LD      A,$18           ; reset
03838   0C8F 90                  SUB     B               ; the
03839   0C90 32 8C 5C            LD      ($5C8C),A       ; SCR_CT scroll count
03840   0C93 2A 8F 5C            LD      HL,($5C8F)      ; L=ATTR_T, H=MASK_T
03841   0C96 E5                  PUSH    HL              ; save on stack
03842   0C97 3A 91 5C            LD      A,($5C91)       ; P_FLAG
03843   0C9A F5                  PUSH    AF              ; save on stack to prevent lower screen
03844   0C9B                                             ; attributes (BORDCR etc.) being applied.
03845   0C9B 3E FD               LD      A,$FD           ; select system channel 'K'
03846   0C9D CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it
03847   0CA0 AF                  XOR     A               ; clear to address message directly
03848   0CA1 11 F8 0C            LD      DE,L0CF8        ; make DE address: scrl-mssg
03849   0CA4 CD 0A 0C            CALL    L0C0A           ; routine PO-MSG prints to lower screen
03850   0CA7 FD CB 02 EE         SET     5,(IY+$02)      ; set TV_FLAG  - signal lower screen requires
03851   0CAB                                             ; clearing
03852   0CAB 21 3B 5C            LD      HL,$5C3B        ; make HL address FLAGS
03853   0CAE CB DE               SET     3,(HL)          ; signal 'L' mode.
03854   0CB0 CB AE               RES     5,(HL)          ; signal 'no new key'.
03855   0CB2 D9                  EXX                     ; switch to main set.
03856   0CB3                                             ; as calling chr input from alternative set.
03857   0CB3 CD D4 15            CALL    L15D4           ; routine WAIT-KEY waits for new key
03858   0CB6                                             ; Note. this is the right routine but the
03859   0CB6                                             ; stream in use is unsatisfactory. From the
03860   0CB6                                             ; choices available, it is however the best.
03861   0CB6             
03862   0CB6 D9                  EXX                     ; switch back to alternate set.
03863   0CB7 FE 20               CP      $20             ; space is considered as BREAK
03864   0CB9 28 45               JR      Z,L0D00         ; forward to REPORT-D if so
03865   0CBB                                             ; 'BREAK - CONT repeats'
03866   0CBB             
03867   0CBB FE E2               CP      $E2             ; is character 'STOP' ?
03868   0CBD 28 41               JR      Z,L0D00         ; forward to REPORT-D if so
03869   0CBF             
03870   0CBF F6 20               OR      $20             ; convert to lower-case
03871   0CC1 FE 6E               CP      $6E             ; is character 'n' ?
03872   0CC3 28 3B               JR      Z,L0D00         ; forward to REPORT-D if so else scroll.
03873   0CC5             
03874   0CC5 3E FE               LD      A,$FE           ; select system channel 'S'
03875   0CC7 CD 01 16            CALL    L1601           ; routine CHAN-OPEN
03876   0CCA F1                  POP     AF              ; restore original P_FLAG
03877   0CCB 32 91 5C            LD      ($5C91),A       ; and save in P_FLAG.
03878   0CCE E1                  POP     HL              ; restore original ATTR_T, MASK_T
03879   0CCF 22 8F 5C            LD      ($5C8F),HL      ; and reset ATTR_T, MASK-T as 'scroll?' has
03880   0CD2                                             ; been printed.
03881   0CD2             
03882   0CD2             ;; PO-SCR-3
03883   0CD2 CD FE 0D    L0CD2:   CALL    L0DFE           ; routine CL-SC-ALL to scroll whole display
03884   0CD5 FD 46 31            LD      B,(IY+$31)      ; fetch DF_SZ to B
03885   0CD8 04                  INC     B               ; increase to address last line of display
03886   0CD9 0E 21               LD      C,$21           ; set C to $21 (was $21 from above routine)
03887   0CDB C5                  PUSH    BC              ; save the line and column in BC.
03888   0CDC             
03889   0CDC CD 9B 0E            CALL    L0E9B           ; routine CL-ADDR finds display address.
03890   0CDF             
03891   0CDF 7C                  LD      A,H             ; now find the corresponding attribute byte
03892   0CE0 0F                  RRCA                    ; (this code sequence is used twice
03893   0CE1 0F                  RRCA                    ; elsewhere and is a candidate for
03894   0CE2 0F                  RRCA                    ; a subroutine.)
03895   0CE3 E6 03               AND     $03             ;
03896   0CE5 F6 58               OR      $58             ;
03897   0CE7 67                  LD      H,A             ;
03898   0CE8             
03899   0CE8 11 E0 5A            LD      DE,$5AE0        ; start of last 'line' of attribute area
03900   0CEB 1A                  LD      A,(DE)          ; get attribute for last line
03901   0CEC 4E                  LD      C,(HL)          ; transfer to base line of upper part
03902   0CED 06 20               LD      B,$20           ; there are thirty two bytes
03903   0CEF EB                  EX      DE,HL           ; swap the pointers.
03904   0CF0             
03905   0CF0             ;; PO-SCR-3A
03906   0CF0 12          L0CF0:   LD      (DE),A          ; transfer
03907   0CF1 71                  LD      (HL),C          ; attributes.
03908   0CF2 13                  INC     DE              ; address next.
03909   0CF3 23                  INC     HL              ; address next.
03910   0CF4 10 FA               DJNZ    L0CF0           ; loop back to PO-SCR-3A for all adjacent
03911   0CF6                                             ; attribute lines.
03912   0CF6             
03913   0CF6 C1                  POP     BC              ; restore the line/column.
03914   0CF7 C9                  RET                     ; return via CL-SET (was pushed on stack).
03915   0CF8             
03916   0CF8             ; ---
03917   0CF8             
03918   0CF8             ; The message 'scroll?' appears here with last byte inverted.
03919   0CF8             
03920   0CF8             ;; scrl-mssg
03921   0CF8 80          L0CF8:   DEFB    $80             ; initial step-over byte.
03922   0CF9                     DEFM    "scroll"
03922   0CF9 7363726F6C6C
03923   0CFF BF                  DEFB    '?'+$80
03924   0D00             
03925   0D00             ;; REPORT-D
03926   0D00 CF          L0D00:   RST     08H             ; ERROR-1
03927   0D01 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
03928   0D02             
03929   0D02             ; continue here if using lower display - A holds line number.
03930   0D02             
03931   0D02             ;; PO-SCR-4
03932   0D02 FE 02       L0D02:   CP      $02             ; is line number less than 2 ?
03933   0D04 38 80               JR      C,L0C86         ; to REPORT-5 if so
03934   0D06                                             ; 'Out of Screen'.
03935   0D06             
03936   0D06 FD 86 31            ADD     A,(IY+$31)      ; add DF_SZ
03937   0D09 D6 19               SUB     $19             ;
03938   0D0B D0                  RET     NC              ; return if scrolling unnecessary
03939   0D0C             
03940   0D0C ED 44               NEG                     ; Negate to give number of scrolls required.
03941   0D0E C5                  PUSH    BC              ; save line/column
03942   0D0F 47                  LD      B,A             ; count to B
03943   0D10 2A 8F 5C            LD      HL,($5C8F)      ; fetch current ATTR_T, MASK_T to HL.
03944   0D13 E5                  PUSH    HL              ; and save
03945   0D14 2A 91 5C            LD      HL,($5C91)      ; fetch P_FLAG
03946   0D17 E5                  PUSH    HL              ; and save.
03947   0D18                                             ; to prevent corruption by input AT
03948   0D18             
03949   0D18 CD 4D 0D            CALL    L0D4D           ; routine TEMPS sets to BORDCR etc
03950   0D1B 78                  LD      A,B             ; transfer scroll number to A.
03951   0D1C             
03952   0D1C             ;; PO-SCR-4A
03953   0D1C F5          L0D1C:   PUSH    AF              ; save scroll number.
03954   0D1D 21 6B 5C            LD      HL,$5C6B        ; address DF_SZ
03955   0D20 46                  LD      B,(HL)          ; fetch old value
03956   0D21 78                  LD      A,B             ; transfer to A
03957   0D22 3C                  INC     A               ; and increment
03958   0D23 77                  LD      (HL),A          ; then put back.
03959   0D24 21 89 5C            LD      HL,$5C89        ; address S_POSN_hi - line
03960   0D27 BE                  CP      (HL)            ; compare
03961   0D28 38 03               JR      C,L0D2D         ; forward to PO-SCR-4B if scrolling required
03962   0D2A             
03963   0D2A 34                  INC     (HL)            ; else increment S_POSN_hi
03964   0D2B 06 18               LD      B,$18           ; set count to whole display ??
03965   0D2D                                             ; Note. should be $17 and the top line will be 
03966   0D2D                                             ; scrolled into the ROM which is harmless on 
03967   0D2D                                             ; the standard set up.
03968   0D2D                                             ; credit P.Giblin 1984.
03969   0D2D             
03970   0D2D             ;; PO-SCR-4B
03971   0D2D CD 00 0E    L0D2D:   CALL    L0E00           ; routine CL-SCROLL scrolls B lines
03972   0D30 F1                  POP     AF              ; restore scroll counter.
03973   0D31 3D                  DEC     A               ; decrease
03974   0D32 20 E8               JR      NZ,L0D1C        ; back to PO-SCR-4A until done
03975   0D34             
03976   0D34 E1                  POP     HL              ; restore original P_FLAG.
03977   0D35 FD 75 57            LD      (IY+$57),L      ; and overwrite system variable P_FLAG.
03978   0D38             
03979   0D38 E1                  POP     HL              ; restore original ATTR_T/MASK_T.
03980   0D39 22 8F 5C            LD      ($5C8F),HL      ; and update system variables.
03981   0D3C             
03982   0D3C ED 4B 88 5C         LD      BC,($5C88)      ; fetch S_POSN to BC.
03983   0D40 FD CB 02 86         RES     0,(IY+$02)      ; signal to TV_FLAG  - main screen in use.
03984   0D44 CD D9 0D            CALL    L0DD9           ; call routine CL-SET for upper display.
03985   0D47             
03986   0D47 FD CB 02 C6         SET     0,(IY+$02)      ; signal to TV_FLAG  - lower screen in use.
03987   0D4B C1                  POP     BC              ; restore line/column
03988   0D4C C9                  RET                     ; return via CL-SET for lower display.
03989   0D4D             
03990   0D4D             ; ----------------------
03991   0D4D             ; Temporary colour items
03992   0D4D             ; ----------------------
03993   0D4D             ; This subroutine is called 11 times to copy the permanent colour items
03994   0D4D             ; to the temporary ones.
03995   0D4D             
03996   0D4D             ;; TEMPS
03997   0D4D AF          L0D4D:   XOR     A               ; clear the accumulator
03998   0D4E 2A 8D 5C            LD      HL,($5C8D)      ; fetch L=ATTR_P and H=MASK_P
03999   0D51 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - is lower screen in use ?
04000   0D55 28 04               JR      Z,L0D5B         ; skip to TEMPS-1 if not
04001   0D57             
04002   0D57 67                  LD      H,A             ; set H, MASK P, to 00000000.
04003   0D58 FD 6E 0E            LD      L,(IY+$0E)      ; fetch BORDCR to L which is used for lower
04004   0D5B                                             ; screen.
04005   0D5B             
04006   0D5B             ;; TEMPS-1
04007   0D5B 22 8F 5C    L0D5B:   LD      ($5C8F),HL      ; transfer values to ATTR_T and MASK_T
04008   0D5E             
04009   0D5E             ; for the print flag the permanent values are odd bits, temporary even bits.
04010   0D5E             
04011   0D5E 21 91 5C            LD      HL,$5C91        ; address P_FLAG.
04012   0D61 20 02               JR      NZ,L0D65        ; skip to TEMPS-2 if lower screen using A=0.
04013   0D63             
04014   0D63 7E                  LD      A,(HL)          ; else pick up flag bits.
04015   0D64 0F                  RRCA                    ; rotate permanent bits to temporary bits.
04016   0D65             
04017   0D65             ;; TEMPS-2
04018   0D65 AE          L0D65:   XOR     (HL)            ;
04019   0D66 E6 55               AND     $55             ; BIN 01010101
04020   0D68 AE                  XOR     (HL)            ; permanent now as original
04021   0D69 77                  LD      (HL),A          ; apply permanent bits to temporary bits.
04022   0D6A C9                  RET                     ; and return.
04023   0D6B             
04024   0D6B             ; -----------------
04025   0D6B             ; THE 'CLS' COMMAND 
04026   0D6B             ; -----------------
04027   0D6B             ;    This command clears the display.
04028   0D6B             ;    The routine is also called during initialization and by the CLEAR command.
04029   0D6B             ;    If it's difficult to write it should be difficult to read.
04030   0D6B             
04031   0D6B             ;; CLS
04032   0D6B CD AF 0D    L0D6B:   CALL    L0DAF           ; Routine CL-ALL clears the entire display and
04033   0D6E                                             ; sets the attributes to the permanent ones
04034   0D6E                                             ; from ATTR-P.
04035   0D6E             
04036   0D6E             ;   Having cleared all 24 lines of the display area, continue into the 
04037   0D6E             ;   subroutine that clears the lower display area.  Note that at the moment 
04038   0D6E             ;   the attributes for the lower lines are the same as upper ones and have 
04039   0D6E             ;   to be changed to match the BORDER colour.
04040   0D6E             
04041   0D6E             ; --------------------------
04042   0D6E             ; THE 'CLS-LOWER' SUBROUTINE 
04043   0D6E             ; --------------------------
04044   0D6E             ;   This routine is called from INPUT, and from the MAIN execution loop.
04045   0D6E             ;   This is very much a housekeeping routine which clears between 2 and 23
04046   0D6E             ;   lines of the display, setting attributes and correcting situations where
04047   0D6E             ;   errors have occurred while the normal input and output routines have been
04048   0D6E             ;   temporarily diverted to deal with, say colour control codes. 
04049   0D6E             
04050   0D6E             ;; CLS-LOWER
04051   0D6E 21 3C 5C    L0D6E:   LD      HL,$5C3C        ; address System Variable TV_FLAG.
04052   0D71 CB AE               RES     5,(HL)          ; TV_FLAG - signal do not clear lower screen.
04053   0D73 CB C6               SET     0,(HL)          ; TV_FLAG - signal lower screen in use.
04054   0D75             
04055   0D75 CD 4D 0D            CALL    L0D4D           ; routine TEMPS applies permanent attributes,
04056   0D78                                             ; in this case BORDCR to ATTR_T.
04057   0D78                                             ; Note. this seems unnecessary and is repeated 
04058   0D78                                             ; within CL-LINE.
04059   0D78             
04060   0D78 FD 46 31            LD      B,(IY+$31)      ; fetch lower screen display file size DF_SZ
04061   0D7B             
04062   0D7B CD 44 0E            CALL    L0E44           ; routine CL-LINE clears lines to bottom of the
04063   0D7E                                             ; display and sets attributes from BORDCR while
04064   0D7E                                             ; preserving the B register.
04065   0D7E             
04066   0D7E 21 C0 5A            LD      HL,$5AC0        ; set initial attribute address to the leftmost 
04067   0D81                                             ; cell of second line up.
04068   0D81             
04069   0D81 3A 8D 5C            LD      A,($5C8D)       ; fetch permanent attribute from ATTR_P.
04070   0D84             
04071   0D84 05                  DEC     B               ; decrement lower screen display file size.
04072   0D85             
04073   0D85 18 07               JR      L0D8E           ; forward to enter the backfill loop at CLS-3 
04074   0D87                                             ; where B is decremented again.
04075   0D87             
04076   0D87             ; ---
04077   0D87             
04078   0D87             ;   The backfill loop is entered at midpoint and ensures, if more than 2
04079   0D87             ;   lines have been cleared, that any other lines take the permanent screen
04080   0D87             ;   attributes.
04081   0D87             
04082   0D87             ;; CLS-1
04083   0D87 0E 20       L0D87:   LD      C,$20           ; set counter to 32 character cells per line
04084   0D89             
04085   0D89             ;; CLS-2
04086   0D89 2B          L0D89:   DEC     HL              ; decrease attribute address.
04087   0D8A 77                  LD      (HL),A          ; and place attributes in next line up.
04088   0D8B 0D                  DEC     C               ; decrease the 32 counter.
04089   0D8C 20 FB               JR      NZ,L0D89        ; loop back to CLS-2 until all 32 cells done.
04090   0D8E             
04091   0D8E             ;; CLS-3
04092   0D8E 10 F7       L0D8E:   DJNZ    L0D87           ; decrease B counter and back to CLS-1
04093   0D90                                             ; if not zero.
04094   0D90             
04095   0D90 FD 36 31 02         LD      (IY+$31),$02    ; now set DF_SZ lower screen to 2
04096   0D94             
04097   0D94             ; This entry point is also called from CL-ALL below to
04098   0D94             ; reset the system channel input and output addresses to normal.
04099   0D94             
04100   0D94             ;; CL-CHAN
04101   0D94 3E FD       L0D94:   LD      A,$FD           ; select system channel 'K'
04102   0D96             
04103   0D96 CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it.
04104   0D99             
04105   0D99 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL to HL to address current channel
04106   0D9C 11 F4 09            LD      DE,L09F4        ; set address to PRINT-OUT for first pass.
04107   0D9F A7                  AND     A               ; clear carry for first pass.
04108   0DA0             
04109   0DA0             ;; CL-CHAN-A
04110   0DA0 73          L0DA0:   LD      (HL),E          ; Insert the output address on the first pass 
04111   0DA1 23                  INC     HL              ; or the input address on the second pass.
04112   0DA2 72                  LD      (HL),D          ;
04113   0DA3 23                  INC     HL              ;
04114   0DA4             
04115   0DA4 11 A8 10            LD      DE,L10A8        ; fetch address KEY-INPUT for second pass
04116   0DA7 3F                  CCF                     ; complement carry flag - will set on pass 1.
04117   0DA8             
04118   0DA8 38 F6               JR      C,L0DA0         ; back to CL-CHAN-A if first pass else done.
04119   0DAA             
04120   0DAA 01 21 17            LD      BC,$1721        ; line 23 for lower screen
04121   0DAD 18 2A               JR      L0DD9           ; exit via CL-SET to set column
04122   0DAF                                             ; for lower display
04123   0DAF             
04124   0DAF             ; ---------------------------
04125   0DAF             ; Clearing whole display area
04126   0DAF             ; ---------------------------
04127   0DAF             ; This subroutine called from CLS, AUTO-LIST and MAIN-3
04128   0DAF             ; clears 24 lines of the display and resets the relevant system variables.
04129   0DAF             ; This routine also recovers from an error situation where, for instance, an 
04130   0DAF             ; invalid colour or position control code has left the output routine addressing
04131   0DAF             ; PO-TV-2 or PO-CONT.
04132   0DAF             
04133   0DAF             ;; CL-ALL
04134   0DAF 21 00 00    L0DAF:   LD      HL,$0000        ; Initialize plot coordinates.
04135   0DB2 22 7D 5C            LD      ($5C7D),HL      ; Set system variable COORDS to 0,0.
04136   0DB5             
04137   0DB5 FD CB 30 86         RES     0,(IY+$30)      ; update FLAGS2  - signal main screen is clear.
04138   0DB9             
04139   0DB9 CD 94 0D            CALL    L0D94           ; routine CL-CHAN makes channel 'K' 'normal'.
04140   0DBC             
04141   0DBC 3E FE               LD      A,$FE           ; select system channel 'S'
04142   0DBE CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it.
04143   0DC1             
04144   0DC1 CD 4D 0D            CALL    L0D4D           ; routine TEMPS applies permanent attributes,
04145   0DC4                                             ; in this case ATTR_P, to ATTR_T. 
04146   0DC4                                             ; Note. this seems unnecessary.
04147   0DC4             
04148   0DC4 06 18               LD      B,$18           ; There are 24 lines.
04149   0DC6             
04150   0DC6 CD 44 0E            CALL    L0E44           ; routine CL-LINE clears 24 text lines and sets
04151   0DC9                                             ; attributes from ATTR-P.
04152   0DC9                                             ; This routine preserves B and sets C to $21.
04153   0DC9             
04154   0DC9 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL make HL address output routine.
04155   0DCC             
04156   0DCC 11 F4 09            LD      DE,L09F4        ; address: PRINT-OUT
04157   0DCF 73                  LD      (HL),E          ; is made
04158   0DD0 23                  INC     HL              ; the normal
04159   0DD1 72                  LD      (HL),D          ; output address.
04160   0DD2             
04161   0DD2 FD 36 52 01         LD      (IY+$52),$01    ; set SCR_CT - scroll count - to default.
04162   0DD6             
04163   0DD6             ;   Note. BC already contains $1821.
04164   0DD6             
04165   0DD6 01 21 18            LD      BC,$1821        ; reset column and line to 0,0
04166   0DD9                                             ; and continue into CL-SET, below, exiting
04167   0DD9                                             ; via PO-STORE (for the upper screen).
04168   0DD9             
04169   0DD9             ; --------------------
04170   0DD9             ; THE 'CL-SET' ROUTINE
04171   0DD9             ; --------------------
04172   0DD9             ; This important subroutine is used to calculate the character output
04173   0DD9             ; address for screens or printer based on the line/column for screens
04174   0DD9             ; or the column for printer.
04175   0DD9             
04176   0DD9             ;; CL-SET
04177   0DD9 21 00 5B    L0DD9:   LD      HL,$5B00        ; the base address of printer buffer
04178   0DDC FD CB 01 4E         BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
04179   0DE0 20 12               JR      NZ,L0DF4        ; forward to CL-SET-2 if so.
04180   0DE2             
04181   0DE2 78                  LD      A,B             ; transfer line to A.
04182   0DE3 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
04183   0DE7 28 05               JR      Z,L0DEE         ; skip to CL-SET-1 if handling upper part
04184   0DE9             
04185   0DE9 FD 86 31            ADD     A,(IY+$31)      ; add DF_SZ for lower screen
04186   0DEC D6 18               SUB     $18             ; and adjust.
04187   0DEE             
04188   0DEE             ;; CL-SET-1
04189   0DEE C5          L0DEE:   PUSH    BC              ; save the line/column.
04190   0DEF 47                  LD      B,A             ; transfer line to B
04191   0DF0                                             ; (adjusted if lower screen)
04192   0DF0             
04193   0DF0 CD 9B 0E            CALL    L0E9B           ; routine CL-ADDR calculates address at left
04194   0DF3                                             ; of screen.
04195   0DF3 C1                  POP     BC              ; restore the line/column.
04196   0DF4             
04197   0DF4             ;; CL-SET-2
04198   0DF4 3E 21       L0DF4:   LD      A,$21           ; the column $01-$21 is reversed
04199   0DF6 91                  SUB     C               ; to range $00 - $20
04200   0DF7 5F                  LD      E,A             ; now transfer to DE
04201   0DF8 16 00               LD      D,$00           ; prepare for addition
04202   0DFA 19                  ADD     HL,DE           ; and add to base address
04203   0DFB             
04204   0DFB C3 DC 0A            JP      L0ADC           ; exit via PO-STORE to update the relevant
04205   0DFE                                             ; system variables.
04206   0DFE             ; ----------------
04207   0DFE             ; Handle scrolling
04208   0DFE             ; ----------------
04209   0DFE             ; The routine CL-SC-ALL is called once from PO to scroll all the display
04210   0DFE             ; and from the routine CL-SCROLL, once, to scroll part of the display.
04211   0DFE             
04212   0DFE             ;; CL-SC-ALL
04213   0DFE 06 17       L0DFE:   LD      B,$17           ; scroll 23 lines, after 'scroll?'.
04214   0E00             
04215   0E00             ;; CL-SCROLL
04216   0E00 CD 9B 0E    L0E00:   CALL    L0E9B           ; routine CL-ADDR gets screen address in HL.
04217   0E03 0E 08               LD      C,$08           ; there are 8 pixel lines to scroll.
04218   0E05             
04219   0E05             ;; CL-SCR-1
04220   0E05 C5          L0E05:   PUSH    BC              ; save counters.
04221   0E06 E5                  PUSH    HL              ; and initial address.
04222   0E07 78                  LD      A,B             ; get line count.
04223   0E08 E6 07               AND     $07             ; will set zero if all third to be scrolled.
04224   0E0A 78                  LD      A,B             ; re-fetch the line count.
04225   0E0B 20 0C               JR      NZ,L0E19        ; forward to CL-SCR-3 if partial scroll.
04226   0E0D             
04227   0E0D             ; HL points to top line of third and must be copied to bottom of previous 3rd.
04228   0E0D             ; ( so HL = $4800 or $5000 ) ( but also sometimes $4000 )
04229   0E0D             
04230   0E0D             ;; CL-SCR-2
04231   0E0D EB          L0E0D:   EX      DE,HL           ; copy HL to DE.
04232   0E0E 21 E0 F8            LD      HL,$F8E0        ; subtract $08 from H and add $E0 to L -
04233   0E11 19                  ADD     HL,DE           ; to make destination bottom line of previous
04234   0E12                                             ; third.
04235   0E12 EB                  EX      DE,HL           ; restore the source and destination.
04236   0E13 01 20 00            LD      BC,$0020        ; thirty-two bytes are to be copied.
04237   0E16 3D                  DEC     A               ; decrement the line count.
04238   0E17 ED B0               LDIR                    ; copy a pixel line to previous third.
04239   0E19             
04240   0E19             ;; CL-SCR-3
04241   0E19 EB          L0E19:   EX      DE,HL           ; save source in DE.
04242   0E1A 21 E0 FF            LD      HL,$FFE0        ; load the value -32.
04243   0E1D 19                  ADD     HL,DE           ; add to form destination in HL.
04244   0E1E EB                  EX      DE,HL           ; switch source and destination
04245   0E1F 47                  LD      B,A             ; save the count in B.
04246   0E20 E6 07               AND     $07             ; mask to find count applicable to current
04247   0E22 0F                  RRCA                    ; third and
04248   0E23 0F                  RRCA                    ; multiply by
04249   0E24 0F                  RRCA                    ; thirty two (same as 5 RLCAs)
04250   0E25             
04251   0E25 4F                  LD      C,A             ; transfer byte count to C ($E0 at most)
04252   0E26 78                  LD      A,B             ; store line count to A
04253   0E27 06 00               LD      B,$00           ; make B zero
04254   0E29 ED B0               LDIR                    ; copy bytes (BC=0, H incremented, L=0)
04255   0E2B 06 07               LD      B,$07           ; set B to 7, C is zero.
04256   0E2D 09                  ADD     HL,BC           ; add 7 to H to address next third.
04257   0E2E E6 F8               AND     $F8             ; has last third been done ?
04258   0E30 20 DB               JR      NZ,L0E0D        ; back to CL-SCR-2 if not.
04259   0E32             
04260   0E32 E1                  POP     HL              ; restore topmost address.
04261   0E33 24                  INC     H               ; next pixel line down.
04262   0E34 C1                  POP     BC              ; restore counts.
04263   0E35 0D                  DEC     C               ; reduce pixel line count.
04264   0E36 20 CD               JR      NZ,L0E05        ; back to CL-SCR-1 if all eight not done.
04265   0E38             
04266   0E38 CD 88 0E            CALL    L0E88           ; routine CL-ATTR gets address in attributes
04267   0E3B                                             ; from current 'ninth line', count in BC.
04268   0E3B             
04269   0E3B 21 E0 FF            LD      HL,$FFE0        ; set HL to the 16-bit value -32.
04270   0E3E 19                  ADD     HL,DE           ; and add to form destination address.
04271   0E3F EB                  EX      DE,HL           ; swap source and destination addresses.
04272   0E40 ED B0               LDIR                    ; copy bytes scrolling the linear attributes.
04273   0E42 06 01               LD      B,$01           ; continue to clear the bottom line.
04274   0E44             
04275   0E44             ; ------------------------------
04276   0E44             ; THE 'CLEAR TEXT LINES' ROUTINE
04277   0E44             ; ------------------------------
04278   0E44             ; This subroutine, called from CL-ALL, CLS-LOWER and AUTO-LIST and above,
04279   0E44             ; clears text lines at bottom of display.
04280   0E44             ; The B register holds on entry the number of lines to be cleared 1-24.
04281   0E44             
04282   0E44             ;; CL-LINE
04283   0E44 C5          L0E44:   PUSH    BC              ; save line count
04284   0E45 CD 9B 0E            CALL    L0E9B           ; routine CL-ADDR gets top address
04285   0E48 0E 08               LD      C,$08           ; there are eight screen lines to a text line.
04286   0E4A             
04287   0E4A             ;; CL-LINE-1
04288   0E4A C5          L0E4A:   PUSH    BC              ; save pixel line count
04289   0E4B E5                  PUSH    HL              ; and save the address
04290   0E4C 78                  LD      A,B             ; transfer the line to A (1-24).
04291   0E4D             
04292   0E4D             ;; CL-LINE-2
04293   0E4D E6 07       L0E4D:   AND     $07             ; mask 0-7 to consider thirds at a time
04294   0E4F 0F                  RRCA                    ; multiply
04295   0E50 0F                  RRCA                    ; by 32  (same as five RLCA instructions)
04296   0E51 0F                  RRCA                    ; now 32 - 256(0)
04297   0E52 4F                  LD      C,A             ; store result in C
04298   0E53 78                  LD      A,B             ; save line in A (1-24)
04299   0E54 06 00               LD      B,$00           ; set high byte to 0, prepare for ldir.
04300   0E56 0D                  DEC     C               ; decrement count 31-255.
04301   0E57 54                  LD      D,H             ; copy HL
04302   0E58 5D                  LD      E,L             ; to DE.
04303   0E59 36 00               LD      (HL),$00        ; blank the first byte.
04304   0E5B 13                  INC     DE              ; make DE point to next byte.
04305   0E5C ED B0               LDIR                    ; ldir will clear lines.
04306   0E5E 11 01 07            LD      DE,$0701        ; now address next third adjusting
04307   0E61 19                  ADD     HL,DE           ; register E to address left hand side
04308   0E62 3D                  DEC     A               ; decrease the line count.
04309   0E63 E6 F8               AND     $F8             ; will be 16, 8 or 0  (AND $18 will do).
04310   0E65 47                  LD      B,A             ; transfer count to B.
04311   0E66 20 E5               JR      NZ,L0E4D        ; back to CL-LINE-2 if 16 or 8 to do
04312   0E68                                             ; the next third.
04313   0E68             
04314   0E68 E1                  POP     HL              ; restore start address.
04315   0E69 24                  INC     H               ; address next line down.
04316   0E6A C1                  POP     BC              ; fetch counts.
04317   0E6B 0D                  DEC     C               ; decrement pixel line count
04318   0E6C 20 DC               JR      NZ,L0E4A        ; back to CL-LINE-1 till all done.
04319   0E6E             
04320   0E6E CD 88 0E            CALL    L0E88           ; routine CL-ATTR gets attribute address
04321   0E71                                             ; in DE and B * 32 in BC.
04322   0E71             
04323   0E71 62                  LD      H,D             ; transfer the address
04324   0E72 6B                  LD      L,E             ; to HL.
04325   0E73             
04326   0E73 13                  INC     DE              ; make DE point to next location.
04327   0E74             
04328   0E74 3A 8D 5C            LD      A,($5C8D)       ; fetch ATTR_P - permanent attributes
04329   0E77 FD CB 02 46         BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
04330   0E7B 28 03               JR      Z,L0E80         ; skip to CL-LINE-3 if not.
04331   0E7D             
04332   0E7D 3A 48 5C            LD      A,($5C48)       ; else lower screen uses BORDCR as attribute.
04333   0E80             
04334   0E80             ;; CL-LINE-3
04335   0E80 77          L0E80:   LD      (HL),A          ; put attribute in first byte.
04336   0E81 0B                  DEC     BC              ; decrement the counter.
04337   0E82 ED B0               LDIR                    ; copy bytes to set all attributes.
04338   0E84 C1                  POP     BC              ; restore the line $01-$24.
04339   0E85 0E 21               LD      C,$21           ; make column $21. (No use is made of this)
04340   0E87 C9                  RET                     ; return to the calling routine.
04341   0E88             
04342   0E88             ; ------------------
04343   0E88             ; Attribute handling
04344   0E88             ; ------------------
04345   0E88             ; This subroutine is called from CL-LINE or CL-SCROLL with the HL register
04346   0E88             ; pointing to the 'ninth' line and H needs to be decremented before or after
04347   0E88             ; the division. Had it been done first then either present code or that used
04348   0E88             ; at the start of PO-ATTR could have been used.
04349   0E88             ; The Spectrum screen arrangement leads to the L register already holding 
04350   0E88             ; the correct value for the attribute file and it is only necessary
04351   0E88             ; to manipulate H to form the correct colour attribute address.
04352   0E88             
04353   0E88             ;; CL-ATTR
04354   0E88 7C          L0E88:   LD      A,H             ; fetch H to A - $48, $50, or $58.
04355   0E89 0F                  RRCA                    ; divide by
04356   0E8A 0F                  RRCA                    ; eight.
04357   0E8B 0F                  RRCA                    ; $09, $0A or $0B.
04358   0E8C 3D                  DEC     A               ; $08, $09 or $0A.
04359   0E8D F6 50               OR      $50             ; $58, $59 or $5A.
04360   0E8F 67                  LD      H,A             ; save high byte of attributes.
04361   0E90             
04362   0E90 EB                  EX      DE,HL           ; transfer attribute address to DE
04363   0E91 61                  LD      H,C             ; set H to zero - from last LDIR.
04364   0E92 68                  LD      L,B             ; load L with the line from B.
04365   0E93 29                  ADD     HL,HL           ; multiply
04366   0E94 29                  ADD     HL,HL           ; by
04367   0E95 29                  ADD     HL,HL           ; thirty two
04368   0E96 29                  ADD     HL,HL           ; to give count of attribute
04369   0E97 29                  ADD     HL,HL           ; cells to the end of display.
04370   0E98             
04371   0E98 44                  LD      B,H             ; transfer the result
04372   0E99 4D                  LD      C,L             ; to register BC.
04373   0E9A             
04374   0E9A C9                  RET                     ; return.
04375   0E9B             
04376   0E9B             ; -------------------------------
04377   0E9B             ; Handle display with line number
04378   0E9B             ; -------------------------------
04379   0E9B             ; This subroutine is called from four places to calculate the address
04380   0E9B             ; of the start of a screen character line which is supplied in B.
04381   0E9B             
04382   0E9B             ;; CL-ADDR
04383   0E9B 3E 18       L0E9B:   LD      A,$18           ; reverse the line number
04384   0E9D 90                  SUB     B               ; to range $00 - $17.
04385   0E9E 57                  LD      D,A             ; save line in D for later.
04386   0E9F 0F                  RRCA                    ; multiply
04387   0EA0 0F                  RRCA                    ; by
04388   0EA1 0F                  RRCA                    ; thirty-two.
04389   0EA2             
04390   0EA2 E6 E0               AND     $E0             ; mask off low bits to make
04391   0EA4 6F                  LD      L,A             ; L a multiple of 32.
04392   0EA5             
04393   0EA5 7A                  LD      A,D             ; bring back the line to A.
04394   0EA6             
04395   0EA6 E6 18               AND     $18             ; now $00, $08 or $10.
04396   0EA8             
04397   0EA8 F6 40               OR      $40             ; add the base address of screen.
04398   0EAA             
04399   0EAA 67                  LD      H,A             ; HL now has the correct address.
04400   0EAB C9                  RET                     ; return.
04401   0EAC             
04402   0EAC             ; -------------------
04403   0EAC             ; Handle COPY command
04404   0EAC             ; -------------------
04405   0EAC             ; This command copies the top 176 lines to the ZX Printer
04406   0EAC             ; It is popular to call this from machine code at point
04407   0EAC             ; L0EAF with B holding 192 (and interrupts disabled) for a full-screen
04408   0EAC             ; copy. This particularly applies to 16K Spectrums as time-critical
04409   0EAC             ; machine code routines cannot be written in the first 16K of RAM as
04410   0EAC             ; it is shared with the ULA which has precedence over the Z80 chip.
04411   0EAC             
04412   0EAC             ;; COPY
04413   0EAC F3          L0EAC:   DI                      ; disable interrupts as this is time-critical.
04414   0EAD             
04415   0EAD 06 B0               LD      B,$B0           ; top 176 lines.
04416   0EAF 21 00 40    L0EAF:   LD      HL,$4000        ; address start of the display file.
04417   0EB2             
04418   0EB2             ; now enter a loop to handle each pixel line.
04419   0EB2             
04420   0EB2             ;; COPY-1
04421   0EB2 E5          L0EB2:   PUSH    HL              ; save the screen address.
04422   0EB3 C5                  PUSH    BC              ; and the line counter.
04423   0EB4             
04424   0EB4 CD F4 0E            CALL    L0EF4           ; routine COPY-LINE outputs one line.
04425   0EB7             
04426   0EB7 C1                  POP     BC              ; restore the line counter.
04427   0EB8 E1                  POP     HL              ; and display address.
04428   0EB9 24                  INC     H               ; next line down screen within 'thirds'.
04429   0EBA 7C                  LD      A,H             ; high byte to A.
04430   0EBB E6 07               AND     $07             ; result will be zero if we have left third.
04431   0EBD 20 0A               JR      NZ,L0EC9        ; forward to COPY-2 if not to continue loop.
04432   0EBF             
04433   0EBF 7D                  LD      A,L             ; consider low byte first.
04434   0EC0 C6 20               ADD     A,$20           ; increase by 32 - sets carry if back to zero.
04435   0EC2 6F                  LD      L,A             ; will be next group of 8.
04436   0EC3 3F                  CCF                     ; complement - carry set if more lines in
04437   0EC4                                             ; the previous third.
04438   0EC4 9F                  SBC     A,A             ; will be FF, if more, else 00.
04439   0EC5 E6 F8               AND     $F8             ; will be F8 (-8) or 00.
04440   0EC7 84                  ADD     A,H             ; that is subtract 8, if more to do in third.
04441   0EC8 67                  LD      H,A             ; and reset address.
04442   0EC9             
04443   0EC9             ;; COPY-2
04444   0EC9 10 E7       L0EC9:   DJNZ    L0EB2           ; back to COPY-1 for all lines.
04445   0ECB             
04446   0ECB 18 0D               JR      L0EDA           ; forward to COPY-END to switch off the printer
04447   0ECD                                             ; motor and enable interrupts.
04448   0ECD                                             ; Note. Nothing else is required.
04449   0ECD             
04450   0ECD             ; ------------------------------
04451   0ECD             ; Pass printer buffer to printer
04452   0ECD             ; ------------------------------
04453   0ECD             ; This routine is used to copy 8 text lines from the printer buffer
04454   0ECD             ; to the ZX Printer. These text lines are mapped linearly so HL does
04455   0ECD             ; not need to be adjusted at the end of each line.
04456   0ECD             
04457   0ECD             ;; COPY-BUFF
04458   0ECD F3          L0ECD:   DI                      ; disable interrupts
04459   0ECE 21 00 5B            LD      HL,$5B00        ; the base address of the Printer Buffer.
04460   0ED1 06 08               LD      B,$08           ; set count to 8 lines of 32 bytes.
04461   0ED3             
04462   0ED3             ;; COPY-3
04463   0ED3 C5          L0ED3:   PUSH    BC              ; save counter.
04464   0ED4             
04465   0ED4 CD F4 0E            CALL    L0EF4           ; routine COPY-LINE outputs 32 bytes
04466   0ED7             
04467   0ED7 C1                  POP     BC              ; restore counter.
04468   0ED8 10 F9               DJNZ    L0ED3           ; loop back to COPY-3 for all 8 lines.
04469   0EDA                                             ; then stop motor and clear buffer.
04470   0EDA             
04471   0EDA             ; Note. the COPY command rejoins here, essentially to execute the next
04472   0EDA             ; three instructions.
04473   0EDA             
04474   0EDA             ;; COPY-END
04475   0EDA 3E 04       L0EDA:   LD      A,$04           ; output value 4 to port
04476   0EDC D3 FB               OUT     ($FB),A         ; to stop the slowed printer motor.
04477   0EDE FB                  EI                      ; enable interrupts.
04478   0EDF             
04479   0EDF             ; --------------------
04480   0EDF             ; Clear Printer Buffer
04481   0EDF             ; --------------------
04482   0EDF             ; This routine clears an arbitrary 256 bytes of memory.
04483   0EDF             ; Note. The routine seems designed to clear a buffer that follows the
04484   0EDF             ; system variables.
04485   0EDF             ; The routine should check a flag or HL address and simply return if COPY
04486   0EDF             ; is in use.
04487   0EDF             ; As a consequence of this omission the buffer will needlessly
04488   0EDF             ; be cleared when COPY is used and the screen/printer position may be set to
04489   0EDF             ; the start of the buffer and the line number to 0 (B)
04490   0EDF             ; giving an 'Out of Screen' error.
04491   0EDF             ; There seems to have been an unsuccessful attempt to circumvent the use
04492   0EDF             ; of PR_CC_hi.
04493   0EDF             
04494   0EDF             ;; CLEAR-PRB
04495   0EDF 21 00 5B    L0EDF:   LD      HL,$5B00        ; the location of the buffer.
04496   0EE2 FD 75 46            LD      (IY+$46),L      ; update PR_CC_lo - set to zero - superfluous.
04497   0EE5 AF                  XOR     A               ; clear the accumulator.
04498   0EE6 47                  LD      B,A             ; set count to 256 bytes.
04499   0EE7             
04500   0EE7             ;; PRB-BYTES
04501   0EE7 77          L0EE7:   LD      (HL),A          ; set addressed location to zero.
04502   0EE8 23                  INC     HL              ; address next byte - Note. not INC L.
04503   0EE9 10 FC               DJNZ    L0EE7           ; back to PRB-BYTES. repeat for 256 bytes.
04504   0EEB             
04505   0EEB FD CB 30 8E         RES     1,(IY+$30)      ; set FLAGS2 - signal printer buffer is clear.
04506   0EEF 0E 21               LD      C,$21           ; set the column position .
04507   0EF1 C3 D9 0D            JP      L0DD9           ; exit via CL-SET and then PO-STORE.
04508   0EF4             
04509   0EF4             ; -----------------
04510   0EF4             ; Copy line routine
04511   0EF4             ; -----------------
04512   0EF4             ; This routine is called from COPY and COPY-BUFF to output a line of
04513   0EF4             ; 32 bytes to the ZX Printer.
04514   0EF4             ; Output to port $FB -
04515   0EF4             ; bit 7 set - activate stylus.
04516   0EF4             ; bit 7 low - deactivate stylus.
04517   0EF4             ; bit 2 set - stops printer.
04518   0EF4             ; bit 2 reset - starts printer
04519   0EF4             ; bit 1 set - slows printer.
04520   0EF4             ; bit 1 reset - normal speed.
04521   0EF4             
04522   0EF4             ;; COPY-LINE
04523   0EF4 78          L0EF4:   LD      A,B             ; fetch the counter 1-8 or 1-176
04524   0EF5 FE 03               CP      $03             ; is it 01 or 02 ?.
04525   0EF7 9F                  SBC     A,A             ; result is $FF if so else $00.
04526   0EF8 E6 02               AND     $02             ; result is 02 now else 00.
04527   0EFA                                             ; bit 1 set slows the printer.
04528   0EFA D3 FB               OUT     ($FB),A         ; slow the printer for the
04529   0EFC                                             ; last two lines.
04530   0EFC 57                  LD      D,A             ; save the mask to control the printer later.
04531   0EFD             
04532   0EFD             ;; COPY-L-1
04533   0EFD CD 54 1F    L0EFD:   CALL    L1F54           ; call BREAK-KEY to read keyboard immediately.
04534   0F00 38 0A               JR      C,L0F0C         ; forward to COPY-L-2 if 'break' not pressed.
04535   0F02             
04536   0F02 3E 04               LD      A,$04           ; else stop the
04537   0F04 D3 FB               OUT     ($FB),A         ; printer motor.
04538   0F06 FB                  EI                      ; enable interrupts.
04539   0F07 CD DF 0E            CALL    L0EDF           ; call routine CLEAR-PRB.
04540   0F0A                                             ; Note. should not be cleared if COPY in use.
04541   0F0A             
04542   0F0A             ;; REPORT-Dc
04543   0F0A CF          L0F0A:   RST     08H             ; ERROR-1
04544   0F0B 0C                  DEFB    $0C             ; Error Report: BREAK - CONT repeats
04545   0F0C             
04546   0F0C             ;; COPY-L-2
04547   0F0C DB FB       L0F0C:   IN      A,($FB)         ; test now to see if
04548   0F0E 87                  ADD     A,A             ; a printer is attached.
04549   0F0F F8                  RET     M               ; return if not - but continue with parent
04550   0F10                                             ; command.
04551   0F10             
04552   0F10 30 EB               JR      NC,L0EFD        ; back to COPY-L-1 if stylus of printer not
04553   0F12                                             ; in position.
04554   0F12             
04555   0F12 0E 20               LD      C,$20           ; set count to 32 bytes.
04556   0F14             
04557   0F14             ;; COPY-L-3
04558   0F14 5E          L0F14:   LD      E,(HL)          ; fetch a byte from line.
04559   0F15 23                  INC     HL              ; address next location. Note. not INC L.
04560   0F16 06 08               LD      B,$08           ; count the bits.
04561   0F18             
04562   0F18             ;; COPY-L-4
04563   0F18 CB 12       L0F18:   RL      D               ; prepare mask to receive bit.
04564   0F1A CB 13               RL      E               ; rotate leftmost print bit to carry
04565   0F1C CB 1A               RR      D               ; and back to bit 7 of D restoring bit 1
04566   0F1E             
04567   0F1E             ;; COPY-L-5
04568   0F1E DB FB       L0F1E:   IN      A,($FB)         ; read the port.
04569   0F20 1F                  RRA                     ; bit 0 to carry.
04570   0F21 30 FB               JR      NC,L0F1E        ; back to COPY-L-5 if stylus not in position.
04571   0F23             
04572   0F23 7A                  LD      A,D             ; transfer command bits to A.
04573   0F24 D3 FB               OUT     ($FB),A         ; and output to port.
04574   0F26 10 F0               DJNZ    L0F18           ; loop back to COPY-L-4 for all 8 bits.
04575   0F28             
04576   0F28 0D                  DEC     C               ; decrease the byte count.
04577   0F29 20 E9               JR      NZ,L0F14        ; back to COPY-L-3 until 256 bits done.
04578   0F2B             
04579   0F2B C9                  RET                     ; return to calling routine COPY/COPY-BUFF.
04580   0F2C             
04581   0F2C             
04582   0F2C             ; ----------------------------------
04583   0F2C             ; Editor routine for BASIC and INPUT
04584   0F2C             ; ----------------------------------
04585   0F2C             ; The editor is called to prepare or edit a BASIC line.
04586   0F2C             ; It is also called from INPUT to input a numeric or string expression.
04587   0F2C             ; The behaviour and options are quite different in the various modes
04588   0F2C             ; and distinguished by bit 5 of FLAGX.
04589   0F2C             ;
04590   0F2C             ; This is a compact and highly versatile routine.
04591   0F2C             
04592   0F2C             ;; EDITOR
04593   0F2C 2A 3D 5C    L0F2C:   LD      HL,($5C3D)      ; fetch ERR_SP
04594   0F2F E5                  PUSH    HL              ; save on stack
04595   0F30             
04596   0F30             ;; ED-AGAIN
04597   0F30 21 7F 10    L0F30:   LD      HL,L107F        ; address: ED-ERROR
04598   0F33 E5                  PUSH    HL              ; save address on stack and
04599   0F34 ED 73 3D 5C         LD      ($5C3D),SP      ; make ERR_SP point to it.
04600   0F38             
04601   0F38             ; Note. While in editing/input mode should an error occur then RST 08 will
04602   0F38             ; update X_PTR to the location reached by CH_ADD and jump to ED-ERROR
04603   0F38             ; where the error will be cancelled and the loop begin again from ED-AGAIN
04604   0F38             ; above. The position of the error will be apparent when the lower screen is
04605   0F38             ; reprinted. If no error then the re-iteration is to ED-LOOP below when
04606   0F38             ; input is arriving from the keyboard.
04607   0F38             
04608   0F38             ;; ED-LOOP
04609   0F38 CD D4 15    L0F38:   CALL    L15D4           ; routine WAIT-KEY gets key possibly
04610   0F3B                                             ; changing the mode.
04611   0F3B F5                  PUSH    AF              ; save key.
04612   0F3C 16 00               LD      D,$00           ; and give a short click based
04613   0F3E FD 5E FF            LD      E,(IY-$01)      ; on PIP value for duration.
04614   0F41 21 C8 00            LD      HL,$00C8        ; and pitch.
04615   0F44 CD B5 03            CALL    L03B5           ; routine BEEPER gives click - effective
04616   0F47                                             ; with rubber keyboard.
04617   0F47 F1                  POP     AF              ; get saved key value.
04618   0F48 21 38 0F            LD      HL,L0F38        ; address: ED-LOOP is loaded to HL.
04619   0F4B E5                  PUSH    HL              ; and pushed onto stack.
04620   0F4C             
04621   0F4C             ; At this point there is a looping return address on the stack, an error
04622   0F4C             ; handler and an input stream set up to supply characters.
04623   0F4C             ; The character that has been received can now be processed.
04624   0F4C             
04625   0F4C FE 18               CP      $18             ; range 24 to 255 ?
04626   0F4E 30 31               JR      NC,L0F81        ; forward to ADD-CHAR if so.
04627   0F50             
04628   0F50 FE 07               CP      $07             ; lower than 7 ?
04629   0F52 38 2D               JR      C,L0F81         ; forward to ADD-CHAR also.
04630   0F54                                             ; Note. This is a 'bug' and chr$ 6, the comma
04631   0F54                                             ; control character, should have had an
04632   0F54                                             ; entry in the ED-KEYS table.
04633   0F54                                             ; Steven Vickers, 1984, Pitman.
04634   0F54             
04635   0F54 FE 10               CP      $10             ; less than 16 ?
04636   0F56 38 3A               JR      C,L0F92         ; forward to ED-KEYS if editing control
04637   0F58                                             ; range 7 to 15 dealt with by a table
04638   0F58             
04639   0F58 01 02 00            LD      BC,$0002        ; prepare for ink/paper etc.
04640   0F5B 57                  LD      D,A             ; save character in D
04641   0F5C FE 16               CP      $16             ; is it ink/paper/bright etc. ?
04642   0F5E 38 0C               JR      C,L0F6C         ; forward to ED-CONTR if so
04643   0F60             
04644   0F60                                             ; leaves 22d AT and 23d TAB
04645   0F60                                             ; which can't be entered via KEY-INPUT.
04646   0F60                                             ; so this code is never normally executed
04647   0F60                                             ; when the keyboard is used for input.
04648   0F60             
04649   0F60 03                  INC     BC              ; if it was AT/TAB - 3 locations required
04650   0F61 FD CB 37 7E         BIT     7,(IY+$37)      ; test FLAGX  - Is this INPUT LINE ?
04651   0F65 CA 1E 10            JP      Z,L101E         ; jump to ED-IGNORE if not, else 
04652   0F68             
04653   0F68 CD D4 15            CALL    L15D4           ; routine WAIT-KEY - input address is KEY-NEXT
04654   0F6B                                             ; but is reset to KEY-INPUT
04655   0F6B 5F                  LD      E,A             ; save first in E
04656   0F6C             
04657   0F6C             ;; ED-CONTR
04658   0F6C CD D4 15    L0F6C:   CALL    L15D4           ; routine WAIT-KEY for control.
04659   0F6F                                             ; input address will be key-next.
04660   0F6F             
04661   0F6F D5                  PUSH    DE              ; saved code/parameters
04662   0F70 2A 5B 5C            LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
04663   0F73 FD CB 07 86         RES     0,(IY+$07)      ; set MODE to 'L'
04664   0F77             
04665   0F77 CD 55 16            CALL    L1655           ; routine MAKE-ROOM makes 2/3 spaces at cursor
04666   0F7A             
04667   0F7A C1                  POP     BC              ; restore code/parameters
04668   0F7B 23                  INC     HL              ; address first location
04669   0F7C 70                  LD      (HL),B          ; place code (ink etc.)
04670   0F7D 23                  INC     HL              ; address next
04671   0F7E 71                  LD      (HL),C          ; place possible parameter. If only one
04672   0F7F                                             ; then DE points to this location also.
04673   0F7F 18 0A               JR      L0F8B           ; forward to ADD-CH-1
04674   0F81             
04675   0F81             ; ------------------------
04676   0F81             ; Add code to current line
04677   0F81             ; ------------------------
04678   0F81             ; this is the branch used to add normal non-control characters
04679   0F81             ; with ED-LOOP as the stacked return address.
04680   0F81             ; it is also the OUTPUT service routine for system channel 'R'.
04681   0F81             
04682   0F81             ;; ADD-CHAR
04683   0F81 FD CB 07 86 L0F81:   RES     0,(IY+$07)      ; set MODE to 'L'
04684   0F85             
04685   0F85 2A 5B 5C    X0F85:   LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
04686   0F88             
04687   0F88 CD 52 16            CALL    L1652           ; routine ONE-SPACE creates one space.
04688   0F8B             
04689   0F8B             ; either a continuation of above or from ED-CONTR with ED-LOOP on stack.
04690   0F8B             
04691   0F8B             ;; ADD-CH-1
04692   0F8B 12          L0F8B:   LD      (DE),A          ; load current character to last new location.
04693   0F8C 13                  INC     DE              ; address next
04694   0F8D ED 53 5B 5C         LD      ($5C5B),DE      ; and update K_CUR system variable.
04695   0F91 C9                  RET                     ; return - either a simple return
04696   0F92                                             ; from ADD-CHAR or to ED-LOOP on stack.
04697   0F92             
04698   0F92             ; ---
04699   0F92             
04700   0F92             ; a branch of the editing loop to deal with control characters
04701   0F92             ; using a look-up table.
04702   0F92             
04703   0F92             ;; ED-KEYS
04704   0F92 5F          L0F92:   LD      E,A             ; character to E.
04705   0F93 16 00               LD      D,$00           ; prepare to add.
04706   0F95 21 99 0F            LD      HL,L0FA0 - 7    ; base address of editing keys table. $0F99
04707   0F98 19                  ADD     HL,DE           ; add E
04708   0F99 5E                  LD      E,(HL)          ; fetch offset to E
04709   0F9A 19                  ADD     HL,DE           ; add offset for address of handling routine.
04710   0F9B E5                  PUSH    HL              ; push the address on machine stack.
04711   0F9C 2A 5B 5C            LD      HL,($5C5B)      ; load address of cursor from K_CUR.
04712   0F9F C9                  RET                     ; Make an indirect jump forward to routine.
04713   0FA0             
04714   0FA0             ; ------------------
04715   0FA0             ; Editing keys table
04716   0FA0             ; ------------------
04717   0FA0             ; For each code in the range $07 to $0F this table contains a
04718   0FA0             ; single offset byte to the routine that services that code.
04719   0FA0             ; Note. for what was intended there should also have been an
04720   0FA0             ; entry for chr$ 6 with offset to ed-symbol.
04721   0FA0             
04722   0FA0             ;; ed-keys-t
04723   0FA0 09          L0FA0:   DEFB    L0FA9 - $  ; 07d offset $09 to Address: ED-EDIT
04724   0FA1 66                  DEFB    L1007 - $  ; 08d offset $66 to Address: ED-LEFT
04725   0FA2 6A                  DEFB    L100C - $  ; 09d offset $6A to Address: ED-RIGHT
04726   0FA3 50                  DEFB    L0FF3 - $  ; 10d offset $50 to Address: ED-DOWN
04727   0FA4 B5                  DEFB    L1059 - $  ; 11d offset $B5 to Address: ED-UP
04728   0FA5 70                  DEFB    L1015 - $  ; 12d offset $70 to Address: ED-DELETE
04729   0FA6 7E                  DEFB    L1024 - $  ; 13d offset $7E to Address: ED-ENTER
04730   0FA7 CF                  DEFB    L1076 - $  ; 14d offset $CF to Address: ED-SYMBOL
04731   0FA8 D4                  DEFB    L107C - $  ; 15d offset $D4 to Address: ED-GRAPH
04732   0FA9             
04733   0FA9             ; ---------------
04734   0FA9             ; Handle EDIT key
04735   0FA9             ; ---------------
04736   0FA9             ; The user has pressed SHIFT 1 to bring edit line down to bottom of screen.
04737   0FA9             ; Alternatively the user wishes to clear the input buffer and start again.
04738   0FA9             ; Alternatively ...
04739   0FA9             
04740   0FA9             ;; ED-EDIT
04741   0FA9 2A 49 5C    L0FA9:   LD      HL,($5C49)      ; fetch E_PPC the last line number entered.
04742   0FAC                                             ; Note. may not exist and may follow program.
04743   0FAC FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
04744   0FB0 C2 97 10            JP      NZ,L1097        ; jump forward to CLEAR-SP if not in editor.
04745   0FB3             
04746   0FB3 CD 6E 19            CALL    L196E           ; routine LINE-ADDR to find address of line
04747   0FB6                                             ; or following line if it doesn't exist.
04748   0FB6 CD 95 16            CALL    L1695           ; routine LINE-NO will get line number from
04749   0FB9                                             ; address or previous line if at end-marker.
04750   0FB9 7A                  LD      A,D             ; if there is no program then DE will
04751   0FBA B3                  OR      E               ; contain zero so test for this.
04752   0FBB CA 97 10            JP      Z,L1097         ; jump to CLEAR-SP if so.
04753   0FBE             
04754   0FBE             ; Note. at this point we have a validated line number, not just an
04755   0FBE             ; approximation and it would be best to update E_PPC with the true
04756   0FBE             ; cursor line value which would enable the line cursor to be suppressed
04757   0FBE             ; in all situations - see shortly.
04758   0FBE             
04759   0FBE E5                  PUSH    HL              ; save address of line.
04760   0FBF 23                  INC     HL              ; address low byte of length.
04761   0FC0 4E                  LD      C,(HL)          ; transfer to C
04762   0FC1 23                  INC     HL              ; next to high byte
04763   0FC2 46                  LD      B,(HL)          ; transfer to B.
04764   0FC3 21 0A 00            LD      HL,$000A        ; an overhead of ten bytes
04765   0FC6 09                  ADD     HL,BC           ; is added to length.
04766   0FC7 44                  LD      B,H             ; transfer adjusted value
04767   0FC8 4D                  LD      C,L             ; to BC register.
04768   0FC9 CD 05 1F            CALL    L1F05           ; routine TEST-ROOM checks free memory.
04769   0FCC CD 97 10            CALL    L1097           ; routine CLEAR-SP clears editing area.
04770   0FCF 2A 51 5C            LD      HL,($5C51)      ; address CURCHL
04771   0FD2 E3                  EX      (SP),HL         ; swap with line address on stack
04772   0FD3 E5                  PUSH    HL              ; save line address underneath
04773   0FD4             
04774   0FD4 3E FF               LD      A,$FF           ; select system channel 'R'
04775   0FD6 CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it
04776   0FD9             
04777   0FD9 E1                  POP     HL              ; drop line address
04778   0FDA 2B                  DEC     HL              ; make it point to first byte of line num.
04779   0FDB FD 35 0F            DEC     (IY+$0F)        ; decrease E_PPC_lo to suppress line cursor.
04780   0FDE                                             ; Note. ineffective when E_PPC is one
04781   0FDE                                             ; greater than last line of program perhaps
04782   0FDE                                             ; as a result of a delete.
04783   0FDE                                             ; credit. Paul Harrison 1982.
04784   0FDE             
04785   0FDE CD 55 18            CALL    L1855           ; routine OUT-LINE outputs the BASIC line
04786   0FE1                                             ; to the editing area.
04787   0FE1 FD 34 0F            INC     (IY+$0F)        ; restore E_PPC_lo to the previous value.
04788   0FE4 2A 59 5C            LD      HL,($5C59)      ; address E_LINE in editing area.
04789   0FE7 23                  INC     HL              ; advance
04790   0FE8 23                  INC     HL              ; past space
04791   0FE9 23                  INC     HL              ; and digit characters
04792   0FEA 23                  INC     HL              ; of line number.
04793   0FEB             
04794   0FEB 22 5B 5C            LD      ($5C5B),HL      ; update K_CUR to address start of BASIC.
04795   0FEE E1                  POP     HL              ; restore the address of CURCHL.
04796   0FEF CD 15 16            CALL    L1615           ; routine CHAN-FLAG sets flags for it.
04797   0FF2             
04798   0FF2 C9                  RET                     ; RETURN to ED-LOOP.
04799   0FF3             
04800   0FF3             ; -------------------
04801   0FF3             ; Cursor down editing
04802   0FF3             ; -------------------
04803   0FF3             ;   The BASIC lines are displayed at the top of the screen and the user
04804   0FF3             ;   wishes to move the cursor down one line in edit mode.
04805   0FF3             ;   With INPUT LINE, this key must be used instead of entering STOP.
04806   0FF3             
04807   0FF3             ;; ED-DOWN
04808   0FF3 FD CB 37 6E L0FF3:   BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
04809   0FF7 20 08               JR      NZ,L1001        ; skip to ED-STOP if so
04810   0FF9             
04811   0FF9 21 49 5C            LD      HL,$5C49        ; address E_PPC - 'current line'
04812   0FFC CD 0F 19            CALL    L190F           ; routine LN-FETCH fetches number of next
04813   0FFF                                             ; line or same if at end of program.
04814   0FFF 18 6D               JR      L106E           ; forward to ED-LIST to produce an
04815   1001                                             ; automatic listing.
04816   1001             
04817   1001             ; ---
04818   1001             
04819   1001             ;; ED-STOP
04820   1001 FD 36 00 10 L1001:   LD      (IY+$00),$10    ; set ERR_NR to 'STOP in INPUT' code
04821   1005 18 1D               JR      L1024           ; forward to ED-ENTER to produce error.
04822   1007             
04823   1007             ; -------------------
04824   1007             ; Cursor left editing
04825   1007             ; -------------------
04826   1007             ; This acts on the cursor in the lower section of the screen in both
04827   1007             ; editing and input mode.
04828   1007             
04829   1007             ;; ED-LEFT
04830   1007 CD 31 10    L1007:   CALL    L1031           ; routine ED-EDGE moves left if possible
04831   100A 18 05               JR      L1011           ; forward to ED-CUR to update K-CUR
04832   100C                                             ; and return to ED-LOOP.
04833   100C             
04834   100C             ; --------------------
04835   100C             ; Cursor right editing
04836   100C             ; --------------------
04837   100C             ; This acts on the cursor in the lower screen in both editing and input
04838   100C             ; mode and moves it to the right.
04839   100C             
04840   100C             ;; ED-RIGHT
04841   100C 7E          L100C:   LD      A,(HL)          ; fetch addressed character.
04842   100D FE 0D               CP      $0D             ; is it carriage return ?
04843   100F C8                  RET     Z               ; return if so to ED-LOOP
04844   1010             
04845   1010 23                  INC     HL              ; address next character
04846   1011             
04847   1011             ;; ED-CUR
04848   1011 22 5B 5C    L1011:   LD      ($5C5B),HL      ; update K_CUR system variable
04849   1014 C9                  RET                     ; return to ED-LOOP
04850   1015             
04851   1015             ; --------------
04852   1015             ; DELETE editing
04853   1015             ; --------------
04854   1015             ; This acts on the lower screen and deletes the character to left of
04855   1015             ; cursor. If control characters are present these are deleted first
04856   1015             ; leaving the naked parameter (0-7) which appears as a '?' except in the
04857   1015             ; case of chr$ 6 which is the comma control character. It is not mandatory
04858   1015             ; to delete these second characters.
04859   1015             
04860   1015             ;; ED-DELETE
04861   1015 CD 31 10    L1015:   CALL    L1031           ; routine ED-EDGE moves cursor to left.
04862   1018 01 01 00            LD      BC,$0001        ; of character to be deleted.
04863   101B C3 E8 19            JP      L19E8           ; to RECLAIM-2 reclaim the character.
04864   101E             
04865   101E             ; ------------------------------------------
04866   101E             ; Ignore next 2 codes from key-input routine
04867   101E             ; ------------------------------------------
04868   101E             ; Since AT and TAB cannot be entered this point is never reached
04869   101E             ; from the keyboard. If inputting from a tape device or network then
04870   101E             ; the control and two following characters are ignored and processing
04871   101E             ; continues as if a carriage return had been received.
04872   101E             ; Here, perhaps, another Spectrum has said print #15; AT 0,0; "This is yellow"
04873   101E             ; and this one is interpreting input #15; a$.
04874   101E             
04875   101E             ;; ED-IGNORE
04876   101E CD D4 15    L101E:   CALL    L15D4           ; routine WAIT-KEY to ignore keystroke.
04877   1021 CD D4 15            CALL    L15D4           ; routine WAIT-KEY to ignore next key.
04878   1024             
04879   1024             ; -------------
04880   1024             ; Enter/newline
04881   1024             ; -------------
04882   1024             ; The enter key has been pressed to have BASIC line or input accepted.
04883   1024             
04884   1024             ;; ED-ENTER
04885   1024 E1          L1024:   POP     HL              ; discard address ED-LOOP
04886   1025 E1                  POP     HL              ; drop address ED-ERROR
04887   1026             
04888   1026             ;; ED-END
04889   1026 E1          L1026:   POP     HL              ; the previous value of ERR_SP
04890   1027 22 3D 5C            LD      ($5C3D),HL      ; is restored to ERR_SP system variable
04891   102A FD CB 00 7E         BIT     7,(IY+$00)      ; is ERR_NR $FF (= 'OK') ?
04892   102E C0                  RET     NZ              ; return if so
04893   102F             
04894   102F F9                  LD      SP,HL           ; else put error routine on stack
04895   1030 C9                  RET                     ; and make an indirect jump to it.
04896   1031             
04897   1031             ; -----------------------------
04898   1031             ; Move cursor left when editing
04899   1031             ; -----------------------------
04900   1031             ; This routine moves the cursor left. The complication is that it must
04901   1031             ; not position the cursor between control codes and their parameters.
04902   1031             ; It is further complicated in that it deals with TAB and AT characters
04903   1031             ; which are never present from the keyboard.
04904   1031             ; The method is to advance from the beginning of the line each time,
04905   1031             ; jumping one, two, or three characters as necessary saving the original
04906   1031             ; position at each jump in DE. Once it arrives at the cursor then the next
04907   1031             ; legitimate leftmost position is in DE.
04908   1031             
04909   1031             ;; ED-EDGE
04910   1031 37          L1031:   SCF                     ; carry flag must be set to call the nested
04911   1032 CD 95 11            CALL    L1195           ; subroutine SET-DE.
04912   1035                                             ; if input   then DE=WORKSP
04913   1035                                             ; if editing then DE=E_LINE
04914   1035 ED 52               SBC     HL,DE           ; subtract address from start of line
04915   1037 19                  ADD     HL,DE           ; and add back.
04916   1038 23                  INC     HL              ; adjust for carry.
04917   1039 C1                  POP     BC              ; drop return address
04918   103A D8                  RET     C               ; return to ED-LOOP if already at left
04919   103B                                             ; of line.
04920   103B             
04921   103B C5                  PUSH    BC              ; resave return address - ED-LOOP.
04922   103C 44                  LD      B,H             ; transfer HL - cursor address
04923   103D 4D                  LD      C,L             ; to BC register pair.
04924   103E                                             ; at this point DE addresses start of line.
04925   103E             
04926   103E             ;; ED-EDGE-1
04927   103E 62          L103E:   LD      H,D             ; transfer DE - leftmost pointer
04928   103F 6B                  LD      L,E             ; to HL
04929   1040 23                  INC     HL              ; address next leftmost character to
04930   1041                                             ; advance position each time.
04931   1041 1A                  LD      A,(DE)          ; pick up previous in A
04932   1042 E6 F0               AND     $F0             ; lose the low bits
04933   1044 FE 10               CP      $10             ; is it INK to TAB $10-$1F ?
04934   1046                                             ; that is, is it followed by a parameter ?
04935   1046 20 09               JR      NZ,L1051        ; to ED-EDGE-2 if not
04936   1048                                             ; HL has been incremented once
04937   1048             
04938   1048 23                  INC     HL              ; address next as at least one parameter.
04939   1049             
04940   1049             ; in fact since 'tab' and 'at' cannot be entered the next section seems
04941   1049             ; superfluous.
04942   1049             ; The test will always fail and the jump to ED-EDGE-2 will be taken.
04943   1049             
04944   1049 1A                  LD      A,(DE)          ; reload leftmost character
04945   104A D6 17               SUB     $17             ; decimal 23 ('tab')
04946   104C CE 00               ADC     A,$00           ; will be 0 for 'tab' and 'at'.
04947   104E 20 01               JR      NZ,L1051        ; forward to ED-EDGE-2 if not
04948   1050                                             ; HL has been incremented twice
04949   1050             
04950   1050 23                  INC     HL              ; increment a third time for 'at'/'tab'
04951   1051             
04952   1051             ;; ED-EDGE-2
04953   1051 A7          L1051:   AND     A               ; prepare for true subtraction
04954   1052 ED 42               SBC     HL,BC           ; subtract cursor address from pointer
04955   1054 09                  ADD     HL,BC           ; and add back
04956   1055                                             ; Note when HL matches the cursor position BC,
04957   1055                                             ; there is no carry and the previous
04958   1055                                             ; position is in DE.
04959   1055 EB                  EX      DE,HL           ; transfer result to DE if looping again.
04960   1056                                             ; transfer DE to HL to be used as K-CUR
04961   1056                                             ; if exiting loop.
04962   1056 38 E6               JR      C,L103E         ; back to ED-EDGE-1 if cursor not matched.
04963   1058             
04964   1058 C9                  RET                     ; return.
04965   1059             
04966   1059             ; -----------------
04967   1059             ; Cursor up editing
04968   1059             ; -----------------
04969   1059             ; The main screen displays part of the BASIC program and the user wishes
04970   1059             ; to move up one line scrolling if necessary.
04971   1059             ; This has no alternative use in input mode.
04972   1059             
04973   1059             ;; ED-UP
04974   1059 FD CB 37 6E L1059:   BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
04975   105D C0                  RET     NZ              ; return if not in editor - to ED-LOOP.
04976   105E             
04977   105E 2A 49 5C            LD      HL,($5C49)      ; get current line from E_PPC
04978   1061 CD 6E 19            CALL    L196E           ; routine LINE-ADDR gets address
04979   1064 EB                  EX      DE,HL           ; and previous in DE
04980   1065 CD 95 16            CALL    L1695           ; routine LINE-NO gets prev line number
04981   1068 21 4A 5C            LD      HL,$5C4A        ; set HL to E_PPC_hi as next routine stores
04982   106B                                             ; top first.
04983   106B CD 1C 19            CALL    L191C           ; routine LN-STORE loads DE value to HL
04984   106E                                             ; high byte first - E_PPC_lo takes E
04985   106E             
04986   106E             ; this branch is also taken from ed-down.
04987   106E             
04988   106E             ;; ED-LIST
04989   106E CD 95 17    L106E:   CALL    L1795           ; routine AUTO-LIST lists to upper screen
04990   1071                                             ; including adjusted current line.
04991   1071 3E 00               LD      A,$00           ; select lower screen again
04992   1073 C3 01 16            JP      L1601           ; exit via CHAN-OPEN to ED-LOOP
04993   1076             
04994   1076             ; --------------------------------
04995   1076             ; Use of symbol and graphics codes
04996   1076             ; --------------------------------
04997   1076             ; These will not be encountered with the keyboard but would be handled
04998   1076             ; otherwise as follows.
04999   1076             ; As noted earlier, Vickers says there should have been an entry in
05000   1076             ; the KEYS table for chr$ 6 which also pointed here.
05001   1076             ; If, for simplicity, two Spectrums were both using #15 as a bi-directional
05002   1076             ; channel connected to each other:-
05003   1076             ; then when the other Spectrum has said PRINT #15; x, y
05004   1076             ; input #15; i ; j  would treat the comma control as a newline and the
05005   1076             ; control would skip to input j.
05006   1076             ; You can get round the missing chr$ 6 handler by sending multiple print
05007   1076             ; items separated by a newline '.
05008   1076             
05009   1076             ; chr$14 would have the same functionality.
05010   1076             
05011   1076             ; This is chr$ 14.
05012   1076             ;; ED-SYMBOL
05013   1076 FD CB 37 7E L1076:   BIT     7,(IY+$37)      ; test FLAGX - is this INPUT LINE ?
05014   107A 28 A8               JR      Z,L1024         ; back to ED-ENTER if not to treat as if
05015   107C                                             ; enter had been pressed.
05016   107C                                             ; else continue and add code to buffer.
05017   107C             
05018   107C             ; Next is chr$ 15
05019   107C             ; Note that ADD-CHAR precedes the table so we can't offset to it directly.
05020   107C             
05021   107C             ;; ED-GRAPH
05022   107C C3 81 0F    L107C:   JP      L0F81           ; jump back to ADD-CHAR
05023   107F             
05024   107F             ; --------------------
05025   107F             ; Editor error routine
05026   107F             ; --------------------
05027   107F             ; If an error occurs while editing, or inputting, then ERR_SP
05028   107F             ; points to the stack location holding address ED_ERROR.
05029   107F             
05030   107F             ;; ED-ERROR
05031   107F FD CB 30 66 L107F:   BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
05032   1083 28 A1               JR      Z,L1026         ; back to ED-END if not.
05033   1085             
05034   1085             ; but as long as we're editing lines or inputting from the keyboard, then
05035   1085             ; we've run out of memory so give a short rasp.
05036   1085             
05037   1085 FD 36 00 FF         LD      (IY+$00),$FF    ; reset ERR_NR to 'OK'.
05038   1089 16 00               LD      D,$00           ; prepare for beeper.
05039   108B FD 5E FE            LD      E,(IY-$02)      ; use RASP value.
05040   108E 21 90 1A            LD      HL,$1A90        ; set the pitch - or tone period.
05041   1091 CD B5 03            CALL    L03B5           ; routine BEEPER emits a warning rasp.
05042   1094 C3 30 0F            JP      L0F30           ; to ED-AGAIN to re-stack address of
05043   1097                                             ; this routine and make ERR_SP point to it.
05044   1097             
05045   1097             ; ---------------------
05046   1097             ; Clear edit/work space
05047   1097             ; ---------------------
05048   1097             ; The editing area or workspace is cleared depending on context.
05049   1097             ; This is called from ED-EDIT to clear workspace if edit key is
05050   1097             ; used during input, to clear editing area if no program exists
05051   1097             ; and to clear editing area prior to copying the edit line to it.
05052   1097             ; It is also used by the error routine to clear the respective
05053   1097             ; area depending on FLAGX.
05054   1097             
05055   1097             ;; CLEAR-SP
05056   1097 E5          L1097:   PUSH    HL              ; preserve HL
05057   1098 CD 90 11            CALL    L1190           ; routine SET-HL
05058   109B                                             ; if in edit   HL = WORKSP-1, DE = E_LINE
05059   109B                                             ; if in input  HL = STKBOT,   DE = WORKSP
05060   109B 2B                  DEC     HL              ; adjust
05061   109C CD E5 19            CALL    L19E5           ; routine RECLAIM-1 reclaims space
05062   109F 22 5B 5C            LD      ($5C5B),HL      ; set K_CUR to start of empty area
05063   10A2 FD 36 07 00         LD      (IY+$07),$00    ; set MODE to 'KLC'
05064   10A6 E1                  POP     HL              ; restore HL.
05065   10A7 C9                  RET                     ; return.
05066   10A8             
05067   10A8             ; ----------------------------
05068   10A8             ; THE 'KEYBOARD INPUT' ROUTINE
05069   10A8             ; ----------------------------
05070   10A8             ; This is the service routine for the input stream of the keyboard channel 'K'.
05071   10A8             
05072   10A8             ;; KEY-INPUT
05073   10A8 FD CB 02 5E L10A8:   BIT     3,(IY+$02)      ; test TV_FLAG  - has a key been pressed in
05074   10AC                                             ; editor ?
05075   10AC             
05076   10AC C4 1D 11            CALL    NZ,L111D        ; routine ED-COPY, if so, to reprint the lower
05077   10AF                                             ; screen at every keystroke/mode change.
05078   10AF             
05079   10AF A7                  AND     A               ; clear carry flag - required exit condition.
05080   10B0             
05081   10B0 FD CB 01 6E         BIT     5,(IY+$01)      ; test FLAGS  - has a new key been pressed ?
05082   10B4 C8                  RET     Z               ; return if not.                        >>
05083   10B5             
05084   10B5 3A 08 5C            LD      A,($5C08)       ; system variable LASTK will hold last key -
05085   10B8                                             ; from the interrupt routine.
05086   10B8             
05087   10B8 FD CB 01 AE         RES     5,(IY+$01)      ; update FLAGS  - reset the new key flag.
05088   10BC F5                  PUSH    AF              ; save the input character.
05089   10BD             
05090   10BD FD CB 02 6E         BIT     5,(IY+$02)      ; test TV_FLAG  - clear lower screen ?
05091   10C1             
05092   10C1 C4 6E 0D            CALL    NZ,L0D6E        ; routine CLS-LOWER if so.
05093   10C4             
05094   10C4 F1                  POP     AF              ; restore the character code.
05095   10C5             
05096   10C5 FE 20               CP      $20             ; if space or higher then
05097   10C7 30 52               JR      NC,L111B        ; forward to KEY-DONE2 and return with carry
05098   10C9                                             ; set to signal key-found.
05099   10C9             
05100   10C9 FE 10               CP      $10             ; with 16d INK and higher skip
05101   10CB 30 2D               JR      NC,L10FA        ; forward to KEY-CONTR.
05102   10CD             
05103   10CD FE 06               CP      $06             ; for 6 - 15d
05104   10CF 30 0A               JR      NC,L10DB        ; skip forward to KEY-M-CL to handle Modes
05105   10D1                                             ; and CapsLock.
05106   10D1             
05107   10D1             ; that only leaves 0-5, the flash bright inverse switches.
05108   10D1             
05109   10D1 47                  LD      B,A             ; save character in B
05110   10D2 E6 01               AND     $01             ; isolate the embedded parameter (0/1).
05111   10D4 4F                  LD      C,A             ; and store in C
05112   10D5 78                  LD      A,B             ; re-fetch copy (0-5)
05113   10D6 1F                  RRA                     ; halve it 0, 1 or 2.
05114   10D7 C6 12               ADD     A,$12           ; add 18d gives 'flash', 'bright'
05115   10D9                                             ; and 'inverse'.
05116   10D9 18 2A               JR      L1105           ; forward to KEY-DATA with the 
05117   10DB                                             ; parameter (0/1) in C.
05118   10DB             
05119   10DB             ; ---
05120   10DB             
05121   10DB             ; Now separate capslock 06 from modes 7-15.
05122   10DB             
05123   10DB             ;; KEY-M-CL
05124   10DB 20 09       L10DB:   JR      NZ,L10E6        ; forward to KEY-MODE if not 06 (capslock)
05125   10DD             
05126   10DD 21 6A 5C            LD      HL,$5C6A        ; point to FLAGS2
05127   10E0 3E 08               LD      A,$08           ; value 00001000
05128   10E2 AE                  XOR     (HL)            ; toggle BIT 3 of FLAGS2 the capslock bit
05129   10E3 77                  LD      (HL),A          ; and store result in FLAGS2 again.
05130   10E4 18 0E               JR      L10F4           ; forward to KEY-FLAG to signal no-key.
05131   10E6             
05132   10E6             ; ---
05133   10E6             
05134   10E6             ;; KEY-MODE
05135   10E6 FE 0E       L10E6:   CP      $0E             ; compare with chr 14d
05136   10E8 D8                  RET     C               ; return with carry set "key found" for
05137   10E9                                             ; codes 7 - 13d leaving 14d and 15d
05138   10E9                                             ; which are converted to mode codes.
05139   10E9             
05140   10E9 D6 0D               SUB     $0D             ; subtract 13d leaving 1 and 2
05141   10EB                                             ; 1 is 'E' mode, 2 is 'G' mode.
05142   10EB 21 41 5C            LD      HL,$5C41        ; address the MODE system variable.
05143   10EE BE                  CP      (HL)            ; compare with existing value before
05144   10EF 77                  LD      (HL),A          ; inserting the new value.
05145   10F0 20 02               JR      NZ,L10F4        ; forward to KEY-FLAG if it has changed.
05146   10F2             
05147   10F2 36 00               LD      (HL),$00        ; else make MODE zero - KLC mode
05148   10F4                                             ; Note. while in Extended/Graphics mode,
05149   10F4                                             ; the Extended Mode/Graphics key is pressed
05150   10F4                                             ; again to get out.
05151   10F4             
05152   10F4             ;; KEY-FLAG
05153   10F4 FD CB 02 DE L10F4:   SET     3,(IY+$02)      ; update TV_FLAG  - show key state has changed
05154   10F8 BF                  CP      A               ; clear carry and reset zero flags -
05155   10F9                                             ; no actual key returned.
05156   10F9 C9                  RET                     ; make the return.
05157   10FA             
05158   10FA             ; ---
05159   10FA             
05160   10FA             ; now deal with colour controls - 16-23 ink, 24-31 paper
05161   10FA             
05162   10FA             ;; KEY-CONTR
05163   10FA 47          L10FA:   LD      B,A             ; make a copy of character.
05164   10FB E6 07               AND     $07             ; mask to leave bits 0-7
05165   10FD 4F                  LD      C,A             ; and store in C.
05166   10FE 3E 10               LD      A,$10           ; initialize to 16d - INK.
05167   1100 CB 58               BIT     3,B             ; was it paper ?
05168   1102 20 01               JR      NZ,L1105        ; forward to KEY-DATA with INK 16d and
05169   1104                                             ; colour in C.
05170   1104             
05171   1104 3C                  INC     A               ; else change from INK to PAPER (17d) if so.
05172   1105             
05173   1105             ;; KEY-DATA
05174   1105 FD 71 D3    L1105:   LD      (IY-$2D),C      ; put the colour (0-7)/state(0/1) in KDATA
05175   1108 11 0D 11            LD      DE,L110D        ; address: KEY-NEXT will be next input stream
05176   110B 18 06               JR      L1113           ; forward to KEY-CHAN to change it ...
05177   110D             
05178   110D             ; ---
05179   110D             
05180   110D             ; ... so that INPUT_AD directs control to here at next call to WAIT-KEY
05181   110D             
05182   110D             ;; KEY-NEXT
05183   110D 3A 0D 5C    L110D:   LD      A,($5C0D)       ; pick up the parameter stored in KDATA.
05184   1110 11 A8 10            LD      DE,L10A8        ; address: KEY-INPUT will be next input stream
05185   1113                                             ; continue to restore default channel and
05186   1113                                             ; make a return with the control code.
05187   1113             
05188   1113             ;; KEY-CHAN
05189   1113 2A 4F 5C    L1113:   LD      HL,($5C4F)      ; address start of CHANNELS area using CHANS
05190   1116                                             ; system variable.
05191   1116                                             ; Note. One might have expected CURCHL to
05192   1116                                             ; have been used.
05193   1116 23                  INC     HL              ; step over the
05194   1117 23                  INC     HL              ; output address
05195   1118 73                  LD      (HL),E          ; and update the input
05196   1119 23                  INC     HL              ; routine address for
05197   111A 72                  LD      (HL),D          ; the next call to WAIT-KEY.
05198   111B             
05199   111B             ;; KEY-DONE2
05200   111B 37          L111B:   SCF                     ; set carry flag to show a key has been found
05201   111C C9                  RET                     ; and return.
05202   111D             
05203   111D             ; --------------------
05204   111D             ; Lower screen copying
05205   111D             ; --------------------
05206   111D             ; This subroutine is called whenever the line in the editing area or
05207   111D             ; input workspace is required to be printed to the lower screen.
05208   111D             ; It is by calling this routine after any change that the cursor, for
05209   111D             ; instance, appears to move to the left.
05210   111D             ; Remember the edit line will contain characters and tokens
05211   111D             ; e.g. "1000 LET a=1" is 8 characters.
05212   111D             
05213   111D             ;; ED-COPY
05214   111D CD 4D 0D    L111D:   CALL    L0D4D           ; routine TEMPS sets temporary attributes.
05215   1120 FD CB 02 9E         RES     3,(IY+$02)      ; update TV_FLAG  - signal no change in mode
05216   1124 FD CB 02 AE         RES     5,(IY+$02)      ; update TV_FLAG  - signal don't clear lower
05217   1128                                             ; screen.
05218   1128 2A 8A 5C            LD      HL,($5C8A)      ; fetch SPOSNL
05219   112B E5                  PUSH    HL              ; and save on stack.
05220   112C             
05221   112C 2A 3D 5C            LD      HL,($5C3D)      ; fetch ERR_SP
05222   112F E5                  PUSH    HL              ; and save also
05223   1130 21 67 11            LD      HL,L1167        ; address: ED-FULL
05224   1133 E5                  PUSH    HL              ; is pushed as the error routine
05225   1134 ED 73 3D 5C         LD      ($5C3D),SP      ; and ERR_SP made to point to it.
05226   1138             
05227   1138 2A 82 5C            LD      HL,($5C82)      ; fetch ECHO_E
05228   113B E5                  PUSH    HL              ; and push also
05229   113C             
05230   113C 37                  SCF                     ; set carry flag to control SET-DE
05231   113D CD 95 11            CALL    L1195           ; call routine SET-DE
05232   1140                                             ; if in input DE = WORKSP
05233   1140                                             ; if in edit  DE = E_LINE
05234   1140 EB                  EX      DE,HL           ; start address to HL
05235   1141             
05236   1141 CD 7D 18            CALL    L187D           ; routine OUT-LINE2 outputs entire line up to
05237   1144                                             ; carriage return including initial
05238   1144                                             ; characterized line number when present.
05239   1144 EB                  EX      DE,HL           ; transfer new address to DE
05240   1145 CD E1 18            CALL    L18E1           ; routine OUT-CURS considers a
05241   1148                                             ; terminating cursor.
05242   1148             
05243   1148 2A 8A 5C            LD      HL,($5C8A)      ; fetch updated SPOSNL
05244   114B E3                  EX      (SP),HL         ; exchange with ECHO_E on stack
05245   114C EB                  EX      DE,HL           ; transfer ECHO_E to DE
05246   114D CD 4D 0D            CALL    L0D4D           ; routine TEMPS to re-set attributes
05247   1150                                             ; if altered.
05248   1150             
05249   1150             ; the lower screen was not cleared, at the outset, so if deleting then old
05250   1150             ; text from a previous print may follow this line and requires blanking.
05251   1150             
05252   1150             ;; ED-BLANK
05253   1150 3A 8B 5C    L1150:   LD      A,($5C8B)       ; fetch SPOSNL_hi is current line
05254   1153 92                  SUB     D               ; compare with old
05255   1154 38 26               JR      C,L117C         ; forward to ED-C-DONE if no blanking
05256   1156             
05257   1156 20 06               JR      NZ,L115E        ; forward to ED-SPACES if line has changed
05258   1158             
05259   1158 7B                  LD      A,E             ; old column to A
05260   1159 FD 96 50            SUB     (IY+$50)        ; subtract new in SPOSNL_lo
05261   115C 30 1E               JR      NC,L117C        ; forward to ED-C-DONE if no backfilling.
05262   115E             
05263   115E             ;; ED-SPACES
05264   115E 3E 20       L115E:   LD      A,$20           ; prepare a space.
05265   1160 D5                  PUSH    DE              ; save old line/column.
05266   1161 CD F4 09            CALL    L09F4           ; routine PRINT-OUT prints a space over
05267   1164                                             ; any text from previous print.
05268   1164                                             ; Note. Since the blanking only occurs when
05269   1164                                             ; using $09F4 to print to the lower screen,
05270   1164                                             ; there is no need to vector via a RST 10
05271   1164                                             ; and we can use this alternate set.
05272   1164 D1                  POP     DE              ; restore the old line column.
05273   1165 18 E9               JR      L1150           ; back to ED-BLANK until all old text blanked.
05274   1167             
05275   1167             ; -------------------------------
05276   1167             ; THE 'EDITOR-FULL' ERROR ROUTINE
05277   1167             ; -------------------------------
05278   1167             ;   This is the error routine addressed by ERR_SP.  This is not for the out of
05279   1167             ;   memory situation as we're just printing.  The pitch and duration are exactly
05280   1167             ;   the same as used by ED-ERROR from which this has been augmented.  The
05281   1167             ;   situation is that the lower screen is full and a rasp is given to suggest
05282   1167             ;   that this is perhaps not the best idea you've had that day.
05283   1167             
05284   1167             ;; ED-FULL
05285   1167 16 00       L1167:   LD      D,$00           ; prepare to moan.
05286   1169 FD 5E FE            LD      E,(IY-$02)      ; fetch RASP value.
05287   116C 21 90 1A            LD      HL,$1A90        ; set pitch or tone period.
05288   116F             
05289   116F CD B5 03            CALL    L03B5           ; routine BEEPER.
05290   1172             
05291   1172 FD 36 00 FF         LD      (IY+$00),$FF    ; clear ERR_NR.
05292   1176 ED 5B 8A 5C         LD      DE,($5C8A)      ; fetch SPOSNL.
05293   117A 18 02               JR      L117E           ; forward to ED-C-END
05294   117C             
05295   117C             ; -------
05296   117C             
05297   117C             ; the exit point from line printing continues here.
05298   117C             
05299   117C             ;; ED-C-DONE
05300   117C D1          L117C:   POP     DE              ; fetch new line/column.
05301   117D E1                  POP     HL              ; fetch the error address.
05302   117E             
05303   117E             ; the error path rejoins here.
05304   117E             
05305   117E             ;; ED-C-END
05306   117E E1          L117E:   POP     HL              ; restore the old value of ERR_SP.
05307   117F 22 3D 5C            LD      ($5C3D),HL      ; update the system variable ERR_SP
05308   1182             
05309   1182 C1                  POP     BC              ; old value of SPOSN_L
05310   1183 D5                  PUSH    DE              ; save new value
05311   1184             
05312   1184 CD D9 0D            CALL    L0DD9           ; routine CL-SET and PO-STORE
05313   1187                                             ; update ECHO_E and SPOSN_L from BC
05314   1187             
05315   1187 E1                  POP     HL              ; restore new value
05316   1188 22 82 5C            LD      ($5C82),HL      ; and overwrite ECHO_E
05317   118B             
05318   118B FD 36 26 00         LD      (IY+$26),$00    ; make error pointer X_PTR_hi out of bounds
05319   118F             
05320   118F C9                  RET                     ; return
05321   1190             
05322   1190             ; -----------------------------------------------
05323   1190             ; Point to first and last locations of work space
05324   1190             ; -----------------------------------------------
05325   1190             ;   These two nested routines ensure that the appropriate pointers are
05326   1190             ;   selected for the editing area or workspace. The routines that call
05327   1190             ;   these routines are designed to work on either area.
05328   1190             
05329   1190             ; this routine is called once
05330   1190             
05331   1190             ;; SET-HL
05332   1190 2A 61 5C    L1190:   LD      HL,($5C61)      ; fetch WORKSP to HL.
05333   1193 2B                  DEC     HL              ; point to last location of editing area.
05334   1194 A7                  AND     A               ; clear carry to limit exit points to first
05335   1195                                             ; or last.
05336   1195             
05337   1195             ; this routine is called with carry set and exits at a conditional return.
05338   1195             
05339   1195             ;; SET-DE
05340   1195 ED 5B 59 5C L1195:   LD      DE,($5C59)      ; fetch E_LINE to DE
05341   1199 FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
05342   119D C8                  RET     Z               ; return now if in editing mode
05343   119E             
05344   119E ED 5B 61 5C         LD      DE,($5C61)      ; fetch WORKSP to DE
05345   11A2 D8                  RET     C               ; return if carry set ( entry = set-de)
05346   11A3             
05347   11A3 2A 63 5C            LD      HL,($5C63)      ; fetch STKBOT to HL as well
05348   11A6 C9                  RET                     ; and return  (entry = set-hl (in input))
05349   11A7             
05350   11A7             ; -----------------------------------
05351   11A7             ; THE 'REMOVE FLOATING POINT' ROUTINE
05352   11A7             ; -----------------------------------
05353   11A7             ;   When a BASIC LINE or the INPUT BUFFER is parsed any numbers will have
05354   11A7             ;   an invisible chr 14d inserted after them and the 5-byte integer or
05355   11A7             ;   floating point form inserted after that.  Similar invisible value holders
05356   11A7             ;   are also created after the numeric and string variables in a DEF FN list.
05357   11A7             ;   This routine removes these 'compiled' numbers from the edit line or
05358   11A7             ;   input workspace.
05359   11A7             
05360   11A7             ;; REMOVE-FP
05361   11A7 7E          L11A7:   LD      A,(HL)          ; fetch character
05362   11A8 FE 0E               CP      $0E             ; is it the CHR$ 14 number marker ?
05363   11AA 01 06 00            LD      BC,$0006        ; prepare to strip six bytes
05364   11AD             
05365   11AD CC E8 19            CALL    Z,L19E8         ; routine RECLAIM-2 reclaims bytes if CHR$ 14.
05366   11B0             
05367   11B0 7E                  LD      A,(HL)          ; reload next (or same) character
05368   11B1 23                  INC     HL              ; and advance address
05369   11B2 FE 0D               CP      $0D             ; end of line or input buffer ?
05370   11B4 20 F1               JR      NZ,L11A7        ; back to REMOVE-FP until entire line done.
05371   11B6             
05372   11B6 C9                  RET                     ; return.
05373   11B7             
05374   11B7             
05375   11B7             ; *********************************
05376   11B7             ; ** Part 6. EXECUTIVE ROUTINES  **
05377   11B7             ; *********************************
05378   11B7             
05379   11B7             
05380   11B7             ; The memory.
05381   11B7             ;
05382   11B7             ; +---------+-----------+------------+--------------+-------------+--
05383   11B7             ; | BASIC   |  Display  | Attributes | ZX Printer   |    System   | 
05384   11B7             ; |  ROM    |   File    |    File    |   Buffer     |  Variables  | 
05385   11B7             ; +---------+-----------+------------+--------------+-------------+--
05386   11B7             ; ^         ^           ^            ^              ^             ^
05387   11B7             ; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS 
05388   11B7             ;
05389   11B7             ;
05390   11B7             ;  --+----------+---+---------+-----------+---+------------+--+---+--
05391   11B7             ;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|
05392   11B7             ;    |   Info   |   | Program |   Area    |   | or Command |  |   |
05393   11B7             ;  --+----------+---+---------+-----------+---+------------+--+---+--
05394   11B7             ;    ^              ^         ^               ^                   ^
05395   11B7             ;  CHANS           PROG      VARS           E_LINE              WORKSP
05396   11B7             ;
05397   11B7             ;
05398   11B7             ;                             ---5-->         <---2---  <--3---
05399   11B7             ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
05400   11B7             ;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |
05401   11B7             ;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |
05402   11B7             ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
05403   11B7             ;    ^                       ^       ^       ^                   ^   ^      ^
05404   11B7             ;  WORKSP                  STKBOT  STKEND   sp               RAMTOP UDG  P_RAMT
05405   11B7             ;                                                                         
05406   11B7             
05407   11B7             ; -----------------
05408   11B7             ; THE 'NEW' COMMAND
05409   11B7             ; -----------------
05410   11B7             ;   The NEW command is about to set all RAM below RAMTOP to zero and then
05411   11B7             ;   re-initialize the system.  All RAM above RAMTOP should, and will be,
05412   11B7             ;   preserved.
05413   11B7             ;   There is nowhere to store values in RAM or on the stack which becomes
05414   11B7             ;   inoperable. Similarly PUSH and CALL instructions cannot be used to store
05415   11B7             ;   values or section common code. The alternate register set is the only place
05416   11B7             ;   available to store 3 persistent 16-bit system variables.
05417   11B7             	IFDEF autocarga
05418   11B7 F3          L11B7:   DI                      ; Disable Interrupts - machine stack will be
05419   11B8                                             ; cleared.
05420   11B8 2A B2 5C            LD      HL,($5CB2)      ; Fetch RAMTOP as top value.
05421   11BB D9                  EXX                     ; Switch in alternate set.
05422   11BC ED 4B B4 5C         LD      BC,($5CB4)      ; Fetch P-RAMT differs on 16K/48K machines.
05423   11C0 ED 5B 38 5C         LD      DE,($5C38)      ; Fetch RASP/PIP.
05424   11C4 2A 7B 5C            LD      HL,($5C7B)      ; Fetch UDG    differs on 16K/48K machines.
05425   11C7 D9                  EXX                     ; Switch back to main set and continue into...
05426   11C8             
05427   11C8             ; ----------------------
05428   11C8             ; THE 'START-NEW' BRANCH     
05429   11C8             ; ----------------------
05430   11C8             ;   This branch is taken from above and from RST 00h.
05431   11C8             ;   The common code tests RAM and sets it to zero re-initializing all the 
05432   11C8             ;   non-zero system variables and channel information.  The A register flags 
05433   11C8             ;   if coming from START or NEW.
05434   11C8             
05435   11C8             ;; START-NEW
05436   11C8             L11C8: 
05437   11C8             
05438   11C8             			IFDEF nocheckram		;nocheckram
05439   11C8             		;IM 		1	
05440   11C8 77          		LD		(HL),A			;A=0 
05441   11C9 D3 FE               OUT     ($FE),A         ; and set it now by writing to a port. (A=0 so border 0)
05442   11CB             		
05443   11CB 08          		EX      AF,AF			; Save the flag to control later branching. '
05444   11CC                     ;LD      A,$38           ; Select a black border
05445   11CC                     ;OUT     ($FE),A         ; and set it now by writing to a port.
05446   11CC             
05447   11CC                     ;LD      A,$3F           ; I interrupt (only for IM2)
05448   11CC                     ;LD      I,A             ; Set the I register - this remains constant
05449   11CC                                             ; and can't be in the range $40 - $7F as 'snow'
05450   11CC                                             ; appears on the screen.
05451   11CC             		;LD		HL,#FFFF		;clear Screen zone (and a bit more to adjust clear zone: HL=#5B5C, DE=#5B5B, BC=#1B5B)
05452   11CC             		;LD 	DE,#5B5B
05453   11CC 54          		LD		D,H
05454   11CD 5C          		LD		E,H
05455   11CE             		;LD 		BC,#1AFF
05456   11CE 01 FF BE    		LD		BC,BCfrom
05457   11D1 ED B8       		LDDR
05458   11D3 7A          		LD      A,D
05459   11D4 ED 47       		LD      I,A
05460   11D6 63          		LD		H,E
05461   11D7 6B          		LD		L,E
05462   11D8 11 05 1F    		LD		DE,#1F05		;Necessary, if DE is not #1F05 then some corrupted text appears when loading
05463   11DB             		DEFS $11DB-$,0
05464   11DB             								
05465   11DB             			ELSE					;nocheckram
05466   11DB~            			
05467   11DB~            		EX      AF,AF			; Save the flag to control later branching. '
05468   11DB~            		
05469   11DB~                    LD      A,$3F           ; Select a white border
05470   11DB~                    OUT     ($FE),A         ; and set it now by writing to a port.
05471   11DB~            05472   11DB~                    LD      I,A             ; Set the I register - this remains constant
05473   11DB~                                            ; and can't be in the range $40 - $7F as 'snow'
05474   11DB~                                            ; appears on the screen.
05475   11DB~            05476   11DB~            ; -----------------------
05477   11DB~            ; THE 'RAM CHECK' SECTION
05478   11DB~            ; -----------------------
05479   11DB~            ;   Typically, a Spectrum will have 16K or 48K of RAM and this code will test
05480   11DB~            ;   it all till it finds an unpopulated location or, less likely, a faulty 
05481   11DB~            ;   location.  Usually it stops when it reaches the top $FFFF, or in the case 
05482   11DB~            ;   of NEW the supplied top value.  The entire screen turns black with 
05483   11DB~            ;   sometimes red stripes on black paper just visible.
05484   11DB~            05485   11DB~            ;; ram-check
05486   11DB~            ;; RAM-FILL
05487   11DB~            L11CF:   LD      (HL),$01        ; Load memory with $01 - blue ink on black paper.
05488   11DB~                    DEC     HL              ; Decrement memory address.
05489   11DB~                    CP      H               ; Have we reached ROM - $3F ?
05490   11DB~                    JR      NZ,L11CF        ; Back to RAM-FILL if not.
05491   11DB~            05492   11DB~            ;; RAM-READ
05493   11DB~            L11D5:   INC     HL              ; increment for next iteration.
05494   11DB~            05495   11DB~                    DEC     (HL)            ; decrement to zero.
05496   11DB~                    JR      Z,L11D5         ; back to RAM-READ if zero flag was set.
05497   11DB~            05498   11DB~            ;; RAM-DONE
05499   11DB~                    DEC     HL              ; step back to last valid location.
05500   11DB~                    LD      B,(HL)          ; B=0
05501   11DB~            		
05502   11DB             			ENDIF					;nocheckram
05503   11DB             			
05504   11DB             L11DB: 
05505   11DB D9                  EXX                     ; regardless of state, set up possibly
05506   11DC                                             ; stored system variables in case from NEW.
05507   11DC             		
05508   11DC ED 43 B4 5C         LD      ($5CB4),BC      ; insert P-RAMT.
05509   11E0 ED 53 38 5C         LD      ($5C38),DE      ; insert RASP/PIP.
05510   11E4 22 7B 5C            LD      ($5C7B),HL      ; insert UDG.
05511   11E7 D9                  EXX                     ; switch in main set.
05512   11E8 08                  EX      AF,AF			; now test if we arrived here from NEW. '
05513   11E9 11 AF 3E            LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.
05514   11EC 20 13               JR      NZ,L1201        ; forward to RAM-SET if we did.
05515   11EE             
05516   11EE             ;   This section applies to START only.
05517   11EE             
05518   11EE 22 B4 5C            LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM
05519   11F1                                             ; address.
05520   11F1 0E A7               LD      C,$A7           ; there are 21 user defined graphics.
05521   11F3 EB                  EX      DE,HL           ; switch pointers and make the UDGs a
05522   11F4 ED B8               LDDR                    ; copy of the standard characters A - U.
05523   11F6 EB                  EX      DE,HL           ; switch the pointer to HL.
05524   11F7             
05525   11F7 22 7B 5C            LD      ($5C7B),HL      ; make UDG system variable address the first
05526   11FA                                             ; bitmap.
05527   11FA 2B                  DEC     HL              ; point at RAMTOP again.
05528   11FB             
05529   11FB 0E 40               LD      C,$40           ; set the values of
05530   11FD ED 43 38 5C         LD      ($5C38),BC      ; the PIP and RASP system variables.
05531   1201             
05532   1201             ;   The NEW command path rejoins here.
05533   1201             
05534   1201             ;; RAM-SET
05535   1201 22 B2 5C    L1201:   LD      ($5CB2),HL      ; set system variable RAMTOP to HL.
05536   1204             
05537   1204             ;   
05538   1204             ;   Note. this entry point is a disabled Warm Restart that was almost certainly
05539   1204             ;   once pointed to by the System Variable NMIADD.  It would be essential that
05540   1204             ;   any NMI Handler would perform the tasks from here to the EI instruction 
05541   1204             ;   below.
05542   1204             
05543   1204             ;; NMI_VECT
05544   1204 72                  LD      (HL),D          ; top of user ram holds GOSUB end marker
05545   1205                                             ; an impossible line number - see RETURN.
05546   1205                                             ; no significance in the number $3E. It has
05547   1205                                             ; been traditional since the ZX80.
05548   1205             
05549   1205 2B                  DEC     HL              ; followed by empty byte (not important).
05550   1206 F9                  LD      SP,HL           ; set up the machine stack pointer.
05551   1207 2B                  DEC     HL              ;
05552   1208 2B                  DEC     HL              ;
05553   1209 22 3D 5C            LD      ($5C3D),HL      ; ERR_SP is where the error pointer is
05554   120C                                             ; at moment empty - will take address MAIN-4
05555   120C                                             ; at the call preceding that address,
05556   120C                                             ; although interrupts and calls will make use
05557   120C                                             ; of this location in meantime.
05558   120C             
05559   120C ED 56               IM      1               ; select interrupt mode 1.
05560   120E             
05561   120E FD 21 3A 5C         LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard
05562   1212                                             ; system variables but shadow ROM system
05563   1212                                             ; variables will be mostly out of range.
05564   1212             
05565   1212 FB                  EI                      ; enable interrupts now that we have a stack.
05566   1213             
05567   1213             ;   If, as suggested above, the NMI service routine pointed to this section of
05568   1213             ;   code then a decision would have to be made at this point to jump forward, 
05569   1213             ;   in a Warm Restart scenario, to produce a report code, leaving any program 
05570   1213             ;   intact.
05571   1213             
05572   1213                   ;  LD      (IY-3),$3C      ; character set, CHARS - as no printing yet.
05573   1213 21 00 3C            LD      HL,$3C00        ; a strange place to set the pointer to the ;Mad3001 Replaced previos IY-3 to be sure low and ...
05574   1216 22 36 5C            LD      ($5C36),HL      ; character set, CHARS - as no printing yet.;Mad3001 ... high byte of Charset initialization
05575   1219             		
05576   1219 21 B6 5C            LD      HL,$5CB6        ; The address of the channels - initially
05577   121C                                             ; following system variables.
05578   121C 22 4F 5C            LD      ($5C4F),HL      ; Set the CHANS system variable.
05579   121F             
05580   121F 11 AF 15            LD      DE,L15AF        ; Address: init-chan in ROM.
05581   1222 4A                  LD      C,D             ; There are 21 bytes of initial data in ROM.
05582   1223 EB                  EX      DE,HL           ; swap the pointers.
05583   1224 ED B0               LDIR                    ; Copy the bytes to RAM.
05584   1226             
05585   1226 1E 0E               LD      E,$0E           ; set destination to system variable STRMS-FD
05586   1228 0E 10               LD      C,$10           ; copy the 14 bytes of initial 7 streams data
05587   122A ED B0               LDIR                    ; from ROM to RAM.
05588   122C             
05589   122C 21 23 05            LD      HL,$0523        ; The keyboard repeat and delay values are 
05590   122F 4C                  LD      C,H
05591   1230 FD 71 31            LD      (IY+$31),C      ; set DF_SZ the lower screen display size to
05592   1233                                             ; five lines
05593   1233 22 09 5C            LD      ($5C09),HL      ; loaded to REPDEL and REPPER.
05594   1236             
05595   1236 21 CA 5C            LD      HL,$5CCA
05596   1239 22 57 5C            LD      ($5C57),HL      ; Set DATADD to location before program area.
05597   123C 2C                  INC     L               ; Increment again.
05598   123D 22 53 5C            LD      ($5C53),HL      ; Set PROG the location where BASIC starts.
05599   1240 22 4B 5C            LD      ($5C4B),HL      ; Set VARS to same location with a
05600   1243 36 80               LD      (HL),$80        ; put $80 marker at (HL)
05601   1245 2C                  INC     L               ; Increment again.
05602   1246 22 59 5C            LD      ($5C59),HL      ; Set E_LINE, where the edit line
05603   1249                                             ; will be created.
05604   1249                                             ; Note. it is not strictly necessary to
05605   1249                                             ; execute the next fifteen bytes of code
05606   1249                                             ; as this will be done by the call to SET-MIN.
05607   1249                                             ; --
05608   1249             
05609   1249 11 9D 12            LD      DE,L129D
05610   124C EB                  EX      DE,HL
05611   124D ED B0               LDIR
05612   124F EB                  EX      DE,HL
05613   1250             
05614   1250 22 61 5C            LD      ($5C61),HL      ; set WORKSP - empty workspace.
05615   1253 22 63 5C            LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.
05616   1256 22 65 5C            LD      ($5C65),HL      ; set STKEND to the end of the empty stack.
05617   1259                                             ; --
05618   1259 3E 3F               LD      A,OVERALL_COLOURS	;$38           ; the colour system is set to white paper,
05619   125B                                             ; black ink, no flash or bright.
05620   125B 32 8D 5C            LD      ($5C8D),A       ; set ATTR_P permanent colour attributes.
05621   125E             ;        LD      ($5C8F),A       ; set ATTR_T temporary colour attributes.
05622   125E 32 48 5C            LD      ($5C48),A       ; set BORDCR the border colour/lower screen
05623   1261                                             ; attributes.
05624   1261             
05625   1261 FD 35 C6            DEC     (IY-$3A)        ; set KSTATE-0 to $FF - keyboard map available.
05626   1264 FD 35 CA            DEC     (IY-$36)        ; set KSTATE-4 to $FF - keyboard map available.
05627   1267                     
05628   1267 CD 4D 16            CALL    L164D           ; update FLAGS  - signal printer in use.
05629   126A CD DF 0E            CALL    L0EDF           ; call routine CLEAR-PRB to initialize system
05630   126D                                             ; variables associated with printer.
05631   126D                                             ; The buffer is clear.
05632   126D FD 36 01 8C         LD      (IY+$01),$8C    ; update FLAGS again
05633   1271             
05634   1271 CD 6B 0D            CALL    L0D6B           ; call routine CLS to set up system
05635   1274                                             ; variables associated with screen and clear
05636   1274                                             ; the screen and set attributes.
05637   1274 11 38 15            LD      DE,L1539 - 1    ; the message table directly.
05638   1277 CD 0A 0C            CALL    L0C0A           ; routine PO-MSG puts
05639   127A                                             ; 'Press PLAY or SPACE to break'
05640   127A                                             ; at bottom of display.
05641   127A CD 0B 03            CALL    L0308+3         ; update TV_FLAG  - signal lower screen will
05642   127D                                             ; require clearing.
05643   127D             
05644   127D 18 79               JR      L1303-11        ; jump to one instruction before MAIN-4
05645   127F             
05646   127F                     ;DEFM    'Reset&Play, Antonio Villena 2012'; 32 bytes
05647   127F             		DEFM    'ResetPlay,Antonio Villena 2012'; 30 bytes
05647   127F 5265736574506C61792C416E746F6E696F2056696C6C656E612032303132
05648   129D             
05649   129D EF22220D80  L129D:   DEFB    $EF, $22, $22, $0D, $80; LOAD "" + Enter + $80
05650   12A2             
05651   12A2             	ELSE
05652   12A2~            ;; NEW
05653   12A2~            L11B7:   DI                      ; Disable Interrupts - machine stack will be
05654   12A2~                                            ; cleared.
05655   12A2~                    LD      A,$FF           ; Flag coming from NEW.
05656   12A2~                    LD      DE,($5CB2)      ; Fetch RAMTOP as top value.
05657   12A2~                    EXX                     ; Switch in alternate set.
05658   12A2~                    LD      BC,($5CB4)      ; Fetch P-RAMT differs on 16K/48K machines.
05659   12A2~                    LD      DE,($5C38)      ; Fetch RASP/PIP.
05660   12A2~                    LD      HL,($5C7B)      ; Fetch UDG    differs on 16K/48K machines.
05661   12A2~                    EXX                     ; Switch back to main set and continue into...
05662   12A2~            05663   12A2~            ; ----------------------
05664   12A2~            ; THE 'START-NEW' BRANCH     
05665   12A2~            ; ----------------------
05666   12A2~            ;   This branch is taken from above and from RST 00h.
05667   12A2~            ;   The common code tests RAM and sets it to zero re-initializing all the 
05668   12A2~            ;   non-zero system variables and channel information.  The A register flags 
05669   12A2~            ;   if coming from START or NEW.
05670   12A2~            05671   12A2~            ;; START-NEW
05672   12A2~            L11CB:   LD      B,A             ; Save the flag to control later branching.
05673   12A2~            05674   12A2~                    LD      A,$07           ; Select a white border
05675   12A2~                    OUT     ($FE),A         ; and set it now by writing to a port.
05676   12A2~            05677   12A2~                    LD      A,$3F           ; Load the accumulator with last page in ROM.
05678   12A2~                    LD      I,A             ; Set the I register - this remains constant
05679   12A2~                                            ; and can't be in the range $40 - $7F as 'snow'
05680   12A2~                                            ; appears on the screen.
05681   12A2~            05682   12A2~                    NOP                     ; These seem unnecessary.
05683   12A2~                    NOP                     ;
05684   12A2~                    NOP                     ;
05685   12A2~                    NOP                     ;
05686   12A2~                    NOP                     ;
05687   12A2~                    NOP                     ;
05688   12A2~            05689   12A2~            ; -----------------------
05690   12A2~            ; THE 'RAM CHECK' SECTION
05691   12A2~            ; -----------------------
05692   12A2~            ;   Typically, a Spectrum will have 16K or 48K of RAM and this code will test
05693   12A2~            ;   it all till it finds an unpopulated location or, less likely, a faulty 
05694   12A2~            ;   location.  Usually it stops when it reaches the top $FFFF, or in the case 
05695   12A2~            ;   of NEW the supplied top value.  The entire screen turns black with 
05696   12A2~            ;   sometimes red stripes on black paper just visible.
05697   12A2~            05698   12A2~            ;; ram-check
05699   12A2~            L11DA:   LD      H,D             ; Transfer the top value to the HL register
05700   12A2~                    LD      L,E             ; pair.
05701   12A2~            05702   12A2~            ;; RAM-FILL
05703   12A2~            L11DC:   LD      (HL),$02        ; Load memory with $02 - red ink on black paper.
05704   12A2~                    DEC     HL              ; Decrement memory address.
05705   12A2~                    CP      H               ; Have we reached ROM - $3F ?
05706   12A2~                    JR      NZ,L11DC        ; Back to RAM-FILL if not.
05707   12A2~            05708   12A2~            ;; RAM-READ
05709   12A2~            L11E2:   AND     A               ; Clear carry - prepare to subtract.
05710   12A2~                    SBC     HL,DE           ; subtract and add back setting
05711   12A2~                    ADD     HL,DE           ; carry when back at start.
05712   12A2~                    INC     HL              ; and increment for next iteration.
05713   12A2~                    JR      NC,L11EF        ; forward to RAM-DONE if we've got back to
05714   12A2~                                            ; starting point with no errors.
05715   12A2~            05716   12A2~                    DEC     (HL)            ; decrement to 1.
05717   12A2~                    JR      Z,L11EF         ; forward to RAM-DONE if faulty.
05718   12A2~            05719   12A2~                    DEC     (HL)            ; decrement to zero.
05720   12A2~                    JR      Z,L11E2         ; back to RAM-READ if zero flag was set.
05721   12A2~            05722   12A2~            ;; RAM-DONE
05723   12A2~            L11EF:   DEC     HL              ; step back to last valid location.
05724   12A2~                    EXX                     ; regardless of state, set up possibly
05725   12A2~                                            ; stored system variables in case from NEW.
05726   12A2~                    LD      ($5CB4),BC      ; insert P-RAMT.
05727   12A2~                    LD      ($5C38),DE      ; insert RASP/PIP.
05728   12A2~                    LD      ($5C7B),HL      ; insert UDG.
05729   12A2~                    EXX                     ; switch in main set.
05730   12A2~                    INC     B               ; now test if we arrived here from NEW.
05731   12A2~                    JR      Z,L1219         ; forward to RAM-SET if we did.
05732   12A2~            05733   12A2~            ;   This section applies to START only.
05734   12A2~            05735   12A2~                    LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM
05736   12A2~                                            ; address.
05737   12A2~                    LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.
05738   12A2~                    LD      BC,$00A8        ; there are 21 user defined graphics.
05739   12A2~                    EX      DE,HL           ; switch pointers and make the UDGs a
05740   12A2~                    LDDR                    ; copy of the standard characters A - U.
05741   12A2~                    EX      DE,HL           ; switch the pointer to HL.
05742   12A2~                    INC     HL              ; update to start of 'A' in RAM.
05743   12A2~                    LD      ($5C7B),HL      ; make UDG system variable address the first
05744   12A2~                                            ; bitmap.
05745   12A2~                    DEC     HL              ; point at RAMTOP again.
05746   12A2~            05747   12A2~                    LD      BC,$0040        ; set the values of
05748   12A2~                    LD      ($5C38),BC      ; the PIP and RASP system variables.
05749   12A2~            05750   12A2~            ;   The NEW command path rejoins here.
05751   12A2~            05752   12A2~            ;; RAM-SET
05753   12A2~            L1219:   LD      ($5CB2),HL      ; set system variable RAMTOP to HL.
05754   12A2~            05755   12A2~            ;   
05756   12A2~            ;   Note. this entry point is a disabled Warm Restart that was almost certainly
05757   12A2~            ;   once pointed to by the System Variable NMIADD.  It would be essential that
05758   12A2~            ;   any NMI Handler would perform the tasks from here to the EI instruction 
05759   12A2~            ;   below.
05760   12A2~            05761   12A2~            ;; NMI_VECT
05762   12A2~            L121C: 
05763   12A2~                    LD      HL,$3C00        ; a strange place to set the pointer to the 
05764   12A2~                    LD      ($5C36),HL      ; character set, CHARS - as no printing yet.
05765   12A2~            05766   12A2~                    LD      HL,($5CB2)      ; fetch RAMTOP to HL again as we've lost it.
05767   12A2~            05768   12A2~                    LD      (HL),$3E        ; top of user ram holds GOSUB end marker
05769   12A2~                                            ; an impossible line number - see RETURN.
05770   12A2~                                            ; no significance in the number $3E. It has
05771   12A2~                                            ; been traditional since the ZX80.
05772   12A2~            05773   12A2~                    DEC     HL              ; followed by empty byte (not important).
05774   12A2~                    LD      SP,HL           ; set up the machine stack pointer.
05775   12A2~                    DEC     HL              ;
05776   12A2~                    DEC     HL              ;
05777   12A2~                    LD      ($5C3D),HL      ; ERR_SP is where the error pointer is
05778   12A2~                                            ; at moment empty - will take address MAIN-4
05779   12A2~                                            ; at the call preceding that address,
05780   12A2~                                            ; although interrupts and calls will make use
05781   12A2~                                            ; of this location in meantime.
05782   12A2~            05783   12A2~                    IM      1               ; select interrupt mode 1.
05784   12A2~            05785   12A2~                    LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard
05786   12A2~                                            ; system variables but shadow ROM system
05787   12A2~                                            ; variables will be mostly out of range.
05788   12A2~            05789   12A2~                    EI                      ; enable interrupts now that we have a stack.
05790   12A2~            05791   12A2~            ;   If, as suggested above, the NMI service routine pointed to this section of
05792   12A2~            ;   code then a decision would have to be made at this point to jump forward, 
05793   12A2~            ;   in a Warm Restart scenario, to produce a report code, leaving any program 
05794   12A2~            ;   intact.
05795   12A2~            05796   12A2~                    LD      HL,$5CB6        ; The address of the channels - initially
05797   12A2~                                            ; following system variables.
05798   12A2~                    LD      ($5C4F),HL      ; Set the CHANS system variable.
05799   12A2~            05800   12A2~                    LD      DE,L15AF        ; Address: init-chan in ROM.
05801   12A2~                    LD      BC,$0015        ; There are 21 bytes of initial data in ROM.
05802   12A2~                    EX      DE,HL           ; swap the pointers.
05803   12A2~                    LDIR                    ; Copy the bytes to RAM.
05804   12A2~            05805   12A2~                    EX      DE,HL           ; Swap pointers. HL points to program area.
05806   12A2~                    DEC     HL              ; Decrement address.
05807   12A2~                    LD      ($5C57),HL      ; Set DATADD to location before program area.
05808   12A2~                    INC     HL              ; Increment again.
05809   12A2~            05810   12A2~                    LD      ($5C53),HL      ; Set PROG the location where BASIC starts.
05811   12A2~                    LD      ($5C4B),HL      ; Set VARS to same location with a
05812   12A2~                    LD      (HL),$80        ; variables end-marker.
05813   12A2~                    INC     HL              ; Advance address.
05814   12A2~                    LD      ($5C59),HL      ; Set E_LINE, where the edit line
05815   12A2~                                            ; will be created.
05816   12A2~                                            ; Note. it is not strictly necessary to
05817   12A2~                                            ; execute the next fifteen bytes of code
05818   12A2~                                            ; as this will be done by the call to SET-MIN.
05819   12A2~                                            ; --
05820   12A2~                    LD      (HL),$0D        ; initially just has a carriage return
05821   12A2~                    INC     HL              ; followed by
05822   12A2~                    LD      (HL),$80        ; an end-marker.
05823   12A2~                    INC     HL              ; address the next location.
05824   12A2~                    LD      ($5C61),HL      ; set WORKSP - empty workspace.
05825   12A2~                    LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.
05826   12A2~                    LD      ($5C65),HL      ; set STKEND to the end of the empty stack.
05827   12A2~                                            ; --
05828   12A2~                    LD      A,$38           ; the colour system is set to white paper,
05829   12A2~                                            ; black ink, no flash or bright.
05830   12A2~                    LD      ($5C8D),A       ; set ATTR_P permanent colour attributes.
05831   12A2~                    LD      ($5C8F),A       ; set ATTR_T temporary colour attributes.
05832   12A2~                    LD      ($5C48),A       ; set BORDCR the border colour/lower screen
05833   12A2~                                            ; attributes.
05834   12A2~            05835   12A2~                    LD      HL,$0523        ; The keyboard repeat and delay values are 
05836   12A2~                    LD      ($5C09),HL      ; loaded to REPDEL and REPPER.
05837   12A2~            05838   12A2~                    DEC     (IY-$3A)        ; set KSTATE-0 to $FF - keyboard map available.
05839   12A2~                    DEC     (IY-$36)        ; set KSTATE-4 to $FF - keyboard map available.
05840   12A2~            05841   12A2~                    LD      HL,L15C6        ; set source to ROM Address: init-strm
05842   12A2~                    LD      DE,$5C10        ; set destination to system variable STRMS-FD
05843   12A2~                    LD      BC,$000E        ; copy the 14 bytes of initial 7 streams data
05844   12A2~                    LDIR                    ; from ROM to RAM.
05845   12A2~            05846   12A2~                    SET     1,(IY+$01)      ; update FLAGS  - signal printer in use.
05847   12A2~                    CALL    L0EDF           ; call routine CLEAR-PRB to initialize system
05848   12A2~                                            ; variables associated with printer.
05849   12A2~                                            ; The buffer is clear.
05850   12A2~            05851   12A2~                    LD      (IY+$31),$02    ; set DF_SZ the lower screen display size to
05852   12A2~                                            ; two lines
05853   12A2~                    CALL    L0D6B           ; call routine CLS to set up system
05854   12A2~                                            ; variables associated with screen and clear
05855   12A2~                                            ; the screen and set attributes.
05856   12A2~                    XOR     A               ; clear accumulator so that we can address
05857   12A2~                    LD      DE,L1539 - 1    ; the message table directly.
05858   12A2~                    CALL    L0C0A           ; routine PO-MSG puts
05859   12A2~                                            ; ' ©  1982 Sinclair Research Ltd'
05860   12A2~                                            ; at bottom of display.
05861   12A2~                    SET     5,(IY+$02)      ; update TV_FLAG  - signal lower screen will
05862   12A2~                                            ; require clearing.
05863   12A2~            05864   12A2~                    JR      L12A9           ; forward to MAIN-1
05865   12A2             	ENDIF	;autocarga
05866   12A2             ; -------------------------
05867   12A2             ; THE 'MAIN EXECUTION LOOP'
05868   12A2             ; -------------------------
05869   12A2             ;
05870   12A2             ;
05871   12A2             
05872   12A2             ;; MAIN-EXEC
05873   12A2 FD 36 31 02 L12A2:   LD      (IY+$31),$02    ; set DF_SZ lower screen display file size to 
05874   12A6                                             ; two lines.
05875   12A6 CD 95 17            CALL    L1795           ; routine AUTO-LIST
05876   12A9             
05877   12A9             ;; MAIN-1
05878   12A9 CD B0 16    L12A9:   CALL    L16B0           ; routine SET-MIN clears work areas.
05879   12AC             
05880   12AC             ;; MAIN-2
05881   12AC 3E 00       L12AC:   LD      A,$00           ; select channel 'K' the keyboard
05882   12AE             
05883   12AE CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it
05884   12B1             
05885   12B1 CD 2C 0F            CALL    L0F2C           ; routine EDITOR is called.
05886   12B4                                             ; Note the above routine is where the Spectrum
05887   12B4                                             ; waits for user-interaction. Perhaps the
05888   12B4                                             ; most common input at this stage
05889   12B4                                             ; is LOAD "".
05890   12B4             
05891   12B4 CD 17 1B            CALL    L1B17           ; routine LINE-SCAN scans the input.
05892   12B7             
05893   12B7 FD CB 00 7E         BIT     7,(IY+$00)      ; test ERR_NR - will be $FF if syntax is OK.
05894   12BB 20 12               JR      NZ,L12CF        ; forward, if correct, to MAIN-3.
05895   12BD             
05896   12BD             ; 
05897   12BD             
05898   12BD FD CB 30 66         BIT     4,(IY+$30)      ; test FLAGS2 - K channel in use ?
05899   12C1 28 40               JR      Z,L1303         ; forward to MAIN-4 if not.
05900   12C3             
05901   12C3             ;
05902   12C3             
05903   12C3 2A 59 5C            LD      HL,($5C59)      ; an editing error so address E_LINE.
05904   12C6 CD A7 11            CALL    L11A7           ; routine REMOVE-FP removes the hidden
05905   12C9                                             ; floating-point forms.
05906   12C9 FD 36 00 FF         LD      (IY+$00),$FF    ; system variable ERR_NR is reset to 'OK'.
05907   12CD 18 DD               JR      L12AC           ; back to MAIN-2 to allow user to correct.
05908   12CF             
05909   12CF             ; ---
05910   12CF             
05911   12CF             ; the branch was here if syntax has passed test.
05912   12CF             
05913   12CF             ;; MAIN-3
05914   12CF 2A 59 5C    L12CF:   LD      HL,($5C59)      ; fetch the edit line address from E_LINE.
05915   12D2             
05916   12D2 22 5D 5C            LD      ($5C5D),HL      ; system variable CH_ADD is set to first
05917   12D5                                             ; character of edit line.
05918   12D5                                             ; Note. the above two instructions are a little
05919   12D5                                             ; inadequate. 
05920   12D5                                             ; They are repeated with a subtle difference 
05921   12D5                                             ; at the start of the next subroutine and are 
05922   12D5                                             ; therefore not required above.
05923   12D5             
05924   12D5 CD FB 19            CALL    L19FB           ; routine E-LINE-NO will fetch any line
05925   12D8                                             ; number to BC if this is a program line.
05926   12D8             
05927   12D8 78                  LD      A,B             ; test if the number of
05928   12D9 B1                  OR      C               ; the line is non-zero.
05929   12DA C2 5D 15            JP      NZ,L155D        ; jump forward to MAIN-ADD if so to add the 
05930   12DD                                             ; line to the BASIC program.
05931   12DD             
05932   12DD             ; Has the user just pressed the ENTER key ?
05933   12DD             
05934   12DD DF                  RST     18H             ; GET-CHAR gets character addressed by CH_ADD.
05935   12DE FE 0D               CP      $0D             ; is it a carriage return ?
05936   12E0 28 C0               JR      Z,L12A2         ; back to MAIN-EXEC if so for an automatic
05937   12E2                                             ; listing.
05938   12E2             
05939   12E2             ; this must be a direct command.
05940   12E2             
05941   12E2 FD CB 30 46         BIT     0,(IY+$30)      ; test FLAGS2 - clear the main screen ?
05942   12E6             
05943   12E6 C4 AF 0D            CALL    NZ,L0DAF        ; routine CL-ALL, if so, e.g. after listing.
05944   12E9             
05945   12E9 CD 6E 0D            CALL    L0D6E           ; routine CLS-LOWER anyway.
05946   12EC             
05947   12EC 3E 19               LD      A,$19           ; compute scroll count as 25 minus
05948   12EE FD 96 4F            SUB     (IY+$4F)        ; value of S_POSN_hi.
05949   12F1 32 8C 5C            LD      ($5C8C),A       ; update SCR_CT system variable.
05950   12F4 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS - signal running program.
05951   12F8 FD 36 00 FF         LD      (IY+$00),$FF    ; set ERR_NR to 'OK'.
05952   12FC FD 36 0A 01         LD      (IY+$0A),$01    ; set NSPPC to one for first statement.
05953   1300 CD 8A 1B            CALL    L1B8A           ; call routine LINE-RUN to run the line.
05954   1303                                             ; sysvar ERR_SP therefore addresses MAIN-4
05955   1303             
05956   1303             ; Examples of direct commands are RUN, CLS, LOAD "", PRINT USR 40000,
05957   1303             ; LPRINT "A"; etc..
05958   1303             ; If a user written machine-code program disables interrupts then it
05959   1303             ; must enable them to pass the next step. We also jumped to here if the
05960   1303             ; keyboard was not being used.
05961   1303             
05962   1303             ;; MAIN-4
05963   1303 76          L1303:   HALT                    ; wait for interrupt the only routine that can
05964   1304                                             ; set bit 5 of FLAGS.
05965   1304             
05966   1304 FD CB 01 AE         RES     5,(IY+$01)      ; update bit 5 of FLAGS - signal no new key.
05967   1308             
05968   1308 FD CB 30 4E         BIT     1,(IY+$30)      ; test FLAGS2 - is printer buffer clear ?
05969   130C C4 CD 0E            CALL    NZ,L0ECD        ; call routine COPY-BUFF if not.
05970   130F                                             ; Note. the programmer has neglected
05971   130F                                             ; to set bit 1 of FLAGS first.
05972   130F             
05973   130F 3A 3A 5C            LD      A,($5C3A)       ; fetch ERR_NR
05974   1312 3C                  INC     A               ; increment to give true code.
05975   1313             
05976   1313             ; Now deal with a runtime error as opposed to an editing error.
05977   1313             ; However if the error code is now zero then the OK message will be printed.
05978   1313             
05979   1313             ;; MAIN-G
05980   1313 F5          L1313:   PUSH    AF              ; save the error number.
05981   1314             
05982   1314 21 00 00            LD      HL,$0000        ; prepare to clear some system variables.
05983   1317 FD 74 37            LD      (IY+$37),H      ; clear all the bits of FLAGX.
05984   131A FD 74 26            LD      (IY+$26),H      ; blank X_PTR_hi to suppress error marker.
05985   131D 22 0B 5C            LD      ($5C0B),HL      ; blank DEFADD to signal that no defined
05986   1320                                             ; function is currently being evaluated.
05987   1320             
05988   1320 21 01 00            LD      HL,$0001        ; explicit - inc hl would do.
05989   1323 22 16 5C            LD      ($5C16),HL      ; ensure STRMS-00 is keyboard.
05990   1326             
05991   1326 CD B0 16            CALL    L16B0           ; routine SET-MIN clears workspace etc.
05992   1329 FD CB 37 AE         RES     5,(IY+$37)      ; update FLAGX - signal in EDIT not INPUT mode.
05993   132D                                             ; Note. all the bits were reset earlier.
05994   132D             
05995   132D CD 6E 0D            CALL    L0D6E           ; call routine CLS-LOWER.
05996   1330             
05997   1330 FD CB 02 EE         SET     5,(IY+$02)      ; update TV_FLAG - signal lower screen
05998   1334                                             ; requires clearing.
05999   1334             
06000   1334 F1                  POP     AF              ; bring back the true error number
06001   1335 47                  LD      B,A             ; and make a copy in B.
06002   1336 FE 0A               CP      $0A             ; is it a print-ready digit ?
06003   1338 38 02               JR      C,L133C         ; forward to MAIN-5 if so.
06004   133A             
06005   133A C6 07               ADD     A,$07           ; add ASCII offset to letters.
06006   133C             
06007   133C             ;; MAIN-5
06008   133C CD EF 15    L133C:   CALL    L15EF           ; call routine OUT-CODE to print the code.
06009   133F             
06010   133F 3E 20               LD      A,$20           ; followed by a space.
06011   1341 D7                  RST     10H             ; PRINT-A
06012   1342             
06013   1342 78                  LD      A,B             ; fetch stored report code.
06014   1343 11 91 13            LD      DE,L1391        ; address: rpt-mesgs.
06015   1346             
06016   1346 CD 0A 0C            CALL    L0C0A           ; call routine PO-MSG to print the message.
06017   1349             
06018   1349 AF          X1349:   XOR     A               ; clear accumulator to directly
06019   134A 11 36 15            LD      DE,L1537 - 1    ; address the comma and space message.  
06020   134D             
06021   134D CD 0A 0C            CALL    L0C0A           ; routine PO-MSG prints ', ' although it would
06022   1350                                             ; be more succinct to use RST $10.
06023   1350             
06024   1350 ED 4B 45 5C         LD      BC,($5C45)      ; fetch PPC the current line number.
06025   1354 CD 1B 1A            CALL    L1A1B           ; routine OUT-NUM-1 will print that
06026   1357             
06027   1357 3E 3A               LD      A,$3A           ; then a ':' character.
06028   1359 D7                  RST     10H             ; PRINT-A
06029   135A             
06030   135A FD 4E 0D            LD      C,(IY+$0D)      ; then SUBPPC for statement
06031   135D 06 00               LD      B,$00           ; limited to 127
06032   135F CD 1B 1A            CALL    L1A1B           ; routine OUT-NUM-1 prints BC.
06033   1362             
06034   1362 CD 97 10            CALL    L1097           ; routine CLEAR-SP clears editing area which 
06035   1365                                             ; probably contained 'RUN'.
06036   1365             
06037   1365 3A 3A 5C            LD      A,($5C3A)       ; fetch ERR_NR again
06038   1368 3C                  INC     A               ; test for no error originally $FF.
06039   1369 28 1B               JR      Z,L1386         ; forward to MAIN-9 if no error.
06040   136B             
06041   136B FE 09               CP      $09             ; is code Report 9 STOP ?
06042   136D 28 04               JR      Z,L1373         ; forward to MAIN-6 if so
06043   136F             
06044   136F FE 15               CP      $15             ; is code Report L Break ?
06045   1371 20 03               JR      NZ,L1376        ; forward to MAIN-7 if not
06046   1373             
06047   1373             ; Stop or Break was encountered so consider CONTINUE.
06048   1373             
06049   1373             ;; MAIN-6
06050   1373 FD 34 0D    L1373:   INC     (IY+$0D)        ; increment SUBPPC to next statement.
06051   1376             
06052   1376             ;; MAIN-7
06053   1376 01 03 00    L1376:   LD      BC,$0003        ; prepare to copy 3 system variables to
06054   1379 11 70 5C            LD      DE,$5C70        ; address OSPPC - statement for CONTINUE.
06055   137C                                             ; also updating OLDPPC line number below.
06056   137C             
06057   137C 21 44 5C            LD      HL,$5C44        ; set source top to NSPPC next statement.
06058   137F CB 7E               BIT     7,(HL)          ; did BREAK occur before the jump ?
06059   1381                                             ; e.g. between GO TO and next statement.
06060   1381 28 01               JR      Z,L1384         ; skip forward to MAIN-8, if not, as set-up
06061   1383                                             ; is correct.
06062   1383             
06063   1383 09                  ADD     HL,BC           ; set source to SUBPPC number of current
06064   1384                                             ; statement/line which will be repeated.
06065   1384             
06066   1384             ;; MAIN-8
06067   1384 ED B8       L1384:   LDDR                    ; copy PPC to OLDPPC and SUBPPC to OSPCC
06068   1386                                             ; or NSPPC to OLDPPC and NEWPPC to OSPCC
06069   1386             
06070   1386             ;; MAIN-9
06071   1386 FD 36 0A FF L1386:   LD      (IY+$0A),$FF    ; update NSPPC - signal 'no jump'.
06072   138A FD CB 01 9E         RES     3,(IY+$01)      ; update FLAGS - signal use 'K' mode for
06073   138E                                             ; the first character in the editor and
06074   138E             
06075   138E C3 AC 12            JP      L12AC           ; jump back to MAIN-2.
06076   1391             
06077   1391             
06078   1391             ; ----------------------
06079   1391             ; Canned report messages
06080   1391             ; ----------------------
06081   1391             ; The Error reports with the last byte inverted. The first entry
06082   1391             ; is a dummy entry. The last, which begins with $7F, the Spectrum
06083   1391             ; character for copyright symbol, is placed here for convenience
06084   1391             ; as is the preceding comma and space.
06085   1391             ; The report line must accommodate a 4-digit line number and a 3-digit
06086   1391             ; statement number which limits the length of the message text to twenty 
06087   1391             ; characters.
06088   1391             ; e.g.  "B Integer out of range, 1000:127"
06089   1391             
06090   1391             ;; rpt-mesgs
06091   1391 80          L1391:   DEFB    $80
06092   1392 4F CB               DEFB    'O','K'+$80                             ; 0
06093   1394                     DEFM    "NEXT without FO"
06093   1394 4E45585420776974686F757420464F
06094   13A3 D2                  DEFB    'R'+$80                                 ; 1
06095   13A4                     DEFM    "Variable not foun"
06095   13A4 5661726961626C65206E6F7420666F756E
06096   13B5 E4                  DEFB    'd'+$80                                 ; 2
06097   13B6                     DEFM    "Subscript wron"
06097   13B6 5375627363726970742077726F6E
06098   13C4 E7                  DEFB    'g'+$80                                 ; 3
06099   13C5                     DEFM    "Out of memor"
06099   13C5 4F7574206F66206D656D6F72
06100   13D1 F9                  DEFB    'y'+$80                                 ; 4
06101   13D2                     DEFM    "Out of scree"
06101   13D2 4F7574206F66207363726565
06102   13DE EE                  DEFB    'n'+$80                                 ; 5
06103   13DF                     DEFM    "Number too bi"
06103   13DF 4E756D62657220746F6F206269
06104   13EC E7                  DEFB    'g'+$80                                 ; 6
06105   13ED                     DEFM    "RETURN without GOSU"
06105   13ED 52455455524E20776974686F757420474F5355
06106   1400 C2                  DEFB    'B'+$80                                 ; 7
06107   1401                     DEFM    "End of fil"
06107   1401 456E64206F662066696C
06108   140B E5                  DEFB    'e'+$80                                 ; 8
06109   140C                     DEFM    "STOP statemen"
06109   140C 53544F502073746174656D656E
06110   1419 F4                  DEFB    't'+$80                                 ; 9
06111   141A                     DEFM    "Invalid argumen"
06111   141A 496E76616C696420617267756D656E
06112   1429 F4                  DEFB    't'+$80                                 ; A
06113   142A                     DEFM    "Integer out of rang"
06113   142A 496E7465676572206F7574206F662072616E67
06114   143D E5                  DEFB    'e'+$80                                 ; B
06115   143E                     DEFM    "Nonsense in BASI"
06115   143E 4E6F6E73656E736520696E2042415349
06116   144E C3                  DEFB    'C'+$80                                 ; C
06117   144F                     DEFM    "BREAK - CONT repeat"
06117   144F 425245414B202D20434F4E5420726570656174
06118   1462 F3                  DEFB    's'+$80                                 ; D
06119   1463                     DEFM    "Out of DAT"
06119   1463 4F7574206F6620444154
06120   146D C1                  DEFB    'A'+$80                                 ; E
06121   146E                     DEFM    "Invalid file nam"
06121   146E 496E76616C69642066696C65206E616D
06122   147E E5                  DEFB    'e'+$80                                 ; F
06123   147F                     DEFM    "No room for lin"
06123   147F 4E6F20726F6F6D20666F72206C696E
06124   148E E5                  DEFB    'e'+$80                                 ; G
06125   148F                     DEFM    "STOP in INPU"
06125   148F 53544F5020696E20494E5055
06126   149B D4                  DEFB    'T'+$80                                 ; H
06127   149C                     DEFM    "FOR without NEX"
06127   149C 464F5220776974686F7574204E4558
06128   14AB D4                  DEFB    'T'+$80                                 ; I
06129   14AC                     DEFM    "Invalid I/O devic"
06129   14AC 496E76616C696420492F4F206465766963
06130   14BD E5                  DEFB    'e'+$80                                 ; J
06131   14BE                     DEFM    "Invalid colou"
06131   14BE 496E76616C696420636F6C6F75
06132   14CB F2                  DEFB    'r'+$80                                 ; K
06133   14CC                     DEFM    "BREAK into progra"
06133   14CC 425245414B20696E746F2070726F677261
06134   14DD ED                  DEFB    'm'+$80                                 ; L
06135   14DE                     DEFM    "RAMTOP no goo"
06135   14DE 52414D544F50206E6F20676F6F
06136   14EB E4                  DEFB    'd'+$80                                 ; M
06137   14EC                     DEFM    "Statement los"
06137   14EC 53746174656D656E74206C6F73
06138   14F9 F4                  DEFB    't'+$80                                 ; N
06139   14FA                     DEFM    "Invalid strea"
06139   14FA 496E76616C6964207374726561
06140   1507 ED                  DEFB    'm'+$80                                 ; O
06141   1508                     DEFM    "FN without DE"
06141   1508 464E20776974686F7574204445
06142   1515 C6                  DEFB    'F'+$80                                 ; P
06143   1516                     DEFM    "Parameter erro"
06143   1516 506172616D65746572206572726F
06144   1524 F2                  DEFB    'r'+$80                                 ; Q
06145   1525                     DEFM    "Tape loading erro"
06145   1525 54617065206C6F6164696E67206572726F
06146   1536 F2                  DEFB    'r'+$80                                 ; R
06147   1537             ;; comma-sp   
06148   1537 2C A0       L1537:   DEFB    ',',' '+$80                             ; used in report line.
06149   1539             ;; copyright
06150   1539 7F          L1539:   DEFB    $7F                                     ; copyright
06151   153A             	IFDEF autocarga
06152   153A                     DEFM    " 1982 Sinclair - Multiply."
06152   153A 20313938322053696E636C616972202D204D756C7469706C792E
06153   1554 AE                  DEFB    '.'+$80
06154   1555             	ELSE
06155   1555~            		DEFM    " 1982 Sinclair Research Lt"
06156   1555~            		DEFB    'd'+$80
06157   1555             	ENDIF
06158   1555             
06159   1555             ; -------------
06160   1555             ; REPORT-G
06161   1555             ; -------------
06162   1555             ; Note ERR_SP points here during line entry which allows the
06163   1555             ; normal 'Out of Memory' report to be augmented to the more
06164   1555             ; precise 'No Room for line' report.
06165   1555             
06166   1555             ;; REPORT-G
06167   1555             ; No Room for line
06168   1555 3E 10       L1555:   LD      A,$10           ; i.e. 'G' -$30 -$07
06169   1557 01 00 00            LD      BC,$0000        ; this seems unnecessary.
06170   155A C3 13 13            JP      L1313           ; jump back to MAIN-G
06171   155D             
06172   155D             ; -----------------------------
06173   155D             ; Handle addition of BASIC line
06174   155D             ; -----------------------------
06175   155D             ; Note this is not a subroutine but a branch of the main execution loop.
06176   155D             ; System variable ERR_SP still points to editing error handler.
06177   155D             ; A new line is added to the BASIC program at the appropriate place.
06178   155D             ; An existing line with same number is deleted first.
06179   155D             ; Entering an existing line number deletes that line.
06180   155D             ; Entering a non-existent line allows the subsequent line to be edited next.
06181   155D             
06182   155D             ;; MAIN-ADD
06183   155D ED 43 49 5C L155D:   LD      ($5C49),BC      ; set E_PPC to extracted line number.
06184   1561 2A 5D 5C            LD      HL,($5C5D)      ; fetch CH_ADD - points to location after the
06185   1564                                             ; initial digits (set in E_LINE_NO).
06186   1564 EB                  EX      DE,HL           ; save start of BASIC in DE.
06187   1565             
06188   1565 21 55 15            LD      HL,L1555        ; Address: REPORT-G
06189   1568 E5                  PUSH    HL              ; is pushed on stack and addressed by ERR_SP.
06190   1569                                             ; the only error that can occur is
06191   1569                                             ; 'Out of memory'.
06192   1569             
06193   1569 2A 61 5C            LD      HL,($5C61)      ; fetch WORKSP - end of line.
06194   156C 37                  SCF                     ; prepare for true subtraction.
06195   156D ED 52               SBC     HL,DE           ; find length of BASIC and
06196   156F E5                  PUSH    HL              ; save it on stack.
06197   1570 60                  LD      H,B             ; transfer line number
06198   1571 69                  LD      L,C             ; to HL register.
06199   1572 CD 6E 19            CALL    L196E           ; routine LINE-ADDR will see if
06200   1575                                             ; a line with the same number exists.
06201   1575 20 06               JR      NZ,L157D        ; forward if no existing line to MAIN-ADD1.
06202   1577             
06203   1577 CD B8 19            CALL    L19B8           ; routine NEXT-ONE finds the existing line.
06204   157A CD E8 19            CALL    L19E8           ; routine RECLAIM-2 reclaims it.
06205   157D             
06206   157D             ;; MAIN-ADD1
06207   157D C1          L157D:   POP     BC              ; retrieve the length of the new line.
06208   157E 79                  LD      A,C             ; and test if carriage return only
06209   157F 3D                  DEC     A               ; i.e. one byte long.
06210   1580 B0                  OR      B               ; result would be zero.
06211   1581 28 28               JR      Z,L15AB         ; forward to MAIN-ADD2 is so.
06212   1583             
06213   1583 C5                  PUSH    BC              ; save the length again.
06214   1584 03                  INC     BC              ; adjust for inclusion
06215   1585 03                  INC     BC              ; of line number (two bytes)
06216   1586 03                  INC     BC              ; and line length
06217   1587 03                  INC     BC              ; (two bytes).
06218   1588 2B                  DEC     HL              ; HL points to location before the destination
06219   1589             
06220   1589 ED 5B 53 5C         LD      DE,($5C53)      ; fetch the address of PROG
06221   158D D5                  PUSH    DE              ; and save it on the stack
06222   158E CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates BC spaces in
06223   1591                                             ; program area and updates pointers.
06224   1591 E1                  POP     HL              ; restore old program pointer.
06225   1592 22 53 5C            LD      ($5C53),HL      ; and put back in PROG as it may have been
06226   1595                                             ; altered by the POINTERS routine.
06227   1595             
06228   1595 C1                  POP     BC              ; retrieve BASIC length
06229   1596 C5                  PUSH    BC              ; and save again.
06230   1597             
06231   1597 13                  INC     DE              ; points to end of new area.
06232   1598 2A 61 5C            LD      HL,($5C61)      ; set HL to WORKSP - location after edit line.
06233   159B 2B                  DEC     HL              ; decrement to address end marker.
06234   159C 2B                  DEC     HL              ; decrement to address carriage return.
06235   159D ED B8               LDDR                    ; copy the BASIC line back to initial command.
06236   159F             
06237   159F 2A 49 5C            LD      HL,($5C49)      ; fetch E_PPC - line number.
06238   15A2 EB                  EX      DE,HL           ; swap it to DE, HL points to last of
06239   15A3                                             ; four locations.
06240   15A3 C1                  POP     BC              ; retrieve length of line.
06241   15A4 70                  LD      (HL),B          ; high byte last.
06242   15A5 2B                  DEC     HL              ;
06243   15A6 71                  LD      (HL),C          ; then low byte of length.
06244   15A7 2B                  DEC     HL              ;
06245   15A8 73                  LD      (HL),E          ; then low byte of line number.
06246   15A9 2B                  DEC     HL              ;
06247   15AA 72                  LD      (HL),D          ; then high byte range $0 - $27 (1-9999).
06248   15AB             
06249   15AB             ;; MAIN-ADD2
06250   15AB F1          L15AB:   POP     AF              ; drop the address of Report G
06251   15AC C3 A2 12            JP      L12A2           ; and back to MAIN-EXEC producing a listing
06252   15AF                                             ; and to reset ERR_SP in EDITOR.
06253   15AF             
06254   15AF             
06255   15AF             ; ---------------------------------
06256   15AF             ; THE 'INITIAL CHANNEL' INFORMATION
06257   15AF             ; ---------------------------------
06258   15AF             ;   This initial channel information is copied from ROM to RAM, during 
06259   15AF             ;   initialization.  It's new location is after the system variables and is 
06260   15AF             ;   addressed by the system variable CHANS which means that it can slide up and
06261   15AF             ;   down in memory.  The table is never searched, by this ROM, and the last 
06262   15AF             ;   character, which could be anything other than a comma, provides a 
06263   15AF             ;   convenient resting place for DATADD.
06264   15AF             
06265   15AF             ;; init-chan
06266   15AF F4 09       L15AF:   DEFW    L09F4           ; PRINT-OUT
06267   15B1 A8 10               DEFW    L10A8           ; KEY-INPUT
06268   15B3 4B                  DEFB    $4B             ; 'K'
06269   15B4 F4 09               DEFW    L09F4           ; PRINT-OUT
06270   15B6 C4 15               DEFW    L15C4           ; REPORT-J
06271   15B8 53                  DEFB    $53             ; 'S'
06272   15B9 81 0F               DEFW    L0F81           ; ADD-CHAR
06273   15BB C4 15               DEFW    L15C4           ; REPORT-J
06274   15BD 52                  DEFB    $52             ; 'R'
06275   15BE F4 09               DEFW    L09F4           ; PRINT-OUT
06276   15C0 C4 15               DEFW    L15C4           ; REPORT-J
06277   15C2 50                  DEFB    $50             ; 'P'
06278   15C3             
06279   15C3 80                  DEFB    $80             ; End Marker
06280   15C4             
06281   15C4             ;; REPORT-J
06282   15C4 CF          L15C4:   RST     08H             ; ERROR-1
06283   15C5 12                  DEFB    $12             ; Error Report: Invalid I/O device
06284   15C6             
06285   15C6             
06286   15C6             ; -------------------------
06287   15C6             ; THE 'INITIAL STREAM' DATA
06288   15C6             ; -------------------------
06289   15C6             ;   This is the initial stream data for the seven streams $FD - $03 that is
06290   15C6             ;   copied from ROM to the STRMS system variables area during initialization.
06291   15C6             ;   There are reserved locations there for another 12 streams.  Each location 
06292   15C6             ;   contains an offset to the second byte of a channel.  The first byte of a 
06293   15C6             ;   channel can't be used as that would result in an offset of zero for some 
06294   15C6             ;   and zero is used to denote that a stream is closed.
06295   15C6             
06296   15C6             ;; init-strm
06297   15C6 01 00       L15C6:   DEFB    $01, $00        ; stream $FD offset to channel 'K'
06298   15C8 06 00               DEFB    $06, $00        ; stream $FE offset to channel 'S'
06299   15CA 0B 00               DEFB    $0B, $00        ; stream $FF offset to channel 'R'
06300   15CC             
06301   15CC 01 00               DEFB    $01, $00        ; stream $00 offset to channel 'K'
06302   15CE 01 00               DEFB    $01, $00        ; stream $01 offset to channel 'K'
06303   15D0 06 00               DEFB    $06, $00        ; stream $02 offset to channel 'S'
06304   15D2 10 00               DEFB    $10, $00        ; stream $03 offset to channel 'P'
06305   15D4             
06306   15D4             ; ------------------------------
06307   15D4             ; THE 'INPUT CONTROL' SUBROUTINE
06308   15D4             ; ------------------------------
06309   15D4             ;
06310   15D4             
06311   15D4             ;; WAIT-KEY
06312   15D4 FD CB 02 6E L15D4:   BIT     5,(IY+$02)      ; test TV_FLAG - clear lower screen ?
06313   15D8 20 04               JR      NZ,L15DE        ; forward to WAIT-KEY1 if so.
06314   15DA             
06315   15DA FD CB 02 DE         SET     3,(IY+$02)      ; update TV_FLAG - signal reprint the edit
06316   15DE                                             ; line to the lower screen.
06317   15DE             
06318   15DE             ;; WAIT-KEY1
06319   15DE CD E6 15    L15DE:   CALL    L15E6           ; routine INPUT-AD is called.
06320   15E1             
06321   15E1 D8                  RET     C               ; return with acceptable keys.
06322   15E2             
06323   15E2 28 FA               JR      Z,L15DE         ; back to WAIT-KEY1 if no key is pressed
06324   15E4                                             ; or it has been handled within INPUT-AD.
06325   15E4             
06326   15E4             ;   Note. When inputting from the keyboard all characters are returned with
06327   15E4             ;   above conditions so this path is never taken.
06328   15E4             
06329   15E4             ;; REPORT-8
06330   15E4 CF          L15E4:   RST     08H             ; ERROR-1
06331   15E5 07                  DEFB    $07             ; Error Report: End of file
06332   15E6             
06333   15E6             ; ---------------------------
06334   15E6             ; THE 'INPUT ADDRESS' ROUTINE
06335   15E6             ; ---------------------------
06336   15E6             ;   This routine fetches the address of the input stream from the current 
06337   15E6             ;   channel area using the system variable CURCHL.
06338   15E6             
06339   15E6             ;; INPUT-AD
06340   15E6 D9          L15E6:   EXX                     ; switch in alternate set.
06341   15E7 E5                  PUSH    HL              ; save HL register
06342   15E8 2A 51 5C            LD      HL,($5C51)      ; fetch address of CURCHL - current channel.
06343   15EB 23                  INC     HL              ; step over output routine
06344   15EC 23                  INC     HL              ; to point to low byte of input routine.
06345   15ED 18 08               JR      L15F7           ; forward to CALL-SUB.
06346   15EF             
06347   15EF             ; -------------------------
06348   15EF             ; THE 'CODE OUTPUT' ROUTINE
06349   15EF             ; -------------------------
06350   15EF             ;   This routine is called on five occasions to print the ASCII equivalent of 
06351   15EF             ;   a value 0-9.
06352   15EF             
06353   15EF             ;; OUT-CODE
06354   15EF 1E 30       L15EF:   LD      E,$30           ; add 48 decimal to give the ASCII character 
06355   15F1 83                  ADD     A,E             ; '0' to '9' and continue into the main output
06356   15F2                                             ; routine.
06357   15F2             
06358   15F2             ; -------------------------
06359   15F2             ; THE 'MAIN OUTPUT' ROUTINE
06360   15F2             ; -------------------------
06361   15F2             ;   PRINT-A-2 is a continuation of the RST 10 restart that prints any character.
06362   15F2             ;   The routine prints to the current channel and the printing of control codes
06363   15F2             ;   may alter that channel to divert subsequent RST 10 instructions to temporary
06364   15F2             ;   routines. The normal channel is $09F4.
06365   15F2             
06366   15F2             ;; PRINT-A-2
06367   15F2 D9          L15F2:   EXX                     ; switch in alternate set
06368   15F3 E5                  PUSH    HL              ; save HL register
06369   15F4 2A 51 5C            LD      HL,($5C51)      ; fetch CURCHL the current channel.
06370   15F7             
06371   15F7             ; input-ad rejoins here also.
06372   15F7             
06373   15F7             ;; CALL-SUB
06374   15F7 5E          L15F7:   LD      E,(HL)          ; put the low byte in E.
06375   15F8 23                  INC     HL              ; advance address.
06376   15F9 56                  LD      D,(HL)          ; put the high byte to D.
06377   15FA EB                  EX      DE,HL           ; transfer the stream to HL.
06378   15FB CD 2C 16            CALL    L162C           ; use routine CALL-JUMP.
06379   15FE                                             ; in effect CALL (HL).
06380   15FE             
06381   15FE E1                  POP     HL              ; restore saved HL register.
06382   15FF D9                  EXX                     ; switch back to the main set and
06383   1600 C9                  RET                     ; return.
06384   1601             
06385   1601             ; --------------------------
06386   1601             ; THE 'OPEN CHANNEL' ROUTINE
06387   1601             ; --------------------------
06388   1601             ;   This subroutine is used by the ROM to open a channel 'K', 'S', 'R' or 'P'.
06389   1601             ;   This is either for its own use or in response to a user's request, for
06390   1601             ;   example, when '#' is encountered with output - PRINT, LIST etc.
06391   1601             ;   or with input - INPUT, INKEY$ etc.
06392   1601             ;   It is entered with a system stream $FD - $FF, or a user stream $00 - $0F
06393   1601             ;   in the accumulator.
06394   1601             
06395   1601             ;; CHAN-OPEN
06396   1601 87          L1601:   ADD     A,A             ; double the stream ($FF will become $FE etc.)
06397   1602 C6 16               ADD     A,$16           ; add the offset to stream 0 from $5C00
06398   1604 6F                  LD      L,A             ; result to L
06399   1605 26 5C               LD      H,$5C           ; now form the address in STRMS area.
06400   1607 5E                  LD      E,(HL)          ; fetch low byte of CHANS offset
06401   1608 23                  INC     HL              ; address next
06402   1609 56                  LD      D,(HL)          ; fetch high byte of offset
06403   160A 7A                  LD      A,D             ; test that the stream is open.
06404   160B B3                  OR      E               ; zero if closed.
06405   160C 20 02               JR      NZ,L1610        ; forward to CHAN-OP-1 if open.
06406   160E             
06407   160E             ;; REPORT-Oa
06408   160E CF          L160E:   RST     08H             ; ERROR-1
06409   160F 17                  DEFB    $17             ; Error Report: Invalid stream
06410   1610             
06411   1610             ; continue here if stream was open. Note that the offset is from CHANS
06412   1610             ; to the second byte of the channel.
06413   1610             
06414   1610             ;; CHAN-OP-1
06415   1610 1B          L1610:   DEC     DE              ; reduce offset so it points to the channel.
06416   1611 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS the location of the base of
06417   1614                                             ; the channel information area
06418   1614 19                  ADD     HL,DE           ; and add the offset to address the channel.
06419   1615                                             ; and continue to set flags.
06420   1615             
06421   1615             ; -----------------
06422   1615             ; Set channel flags
06423   1615             ; -----------------
06424   1615             ; This subroutine is used from ED-EDIT, str$ and read-in to reset the
06425   1615             ; current channel when it has been temporarily altered.
06426   1615             
06427   1615             ;; CHAN-FLAG
06428   1615 22 51 5C    L1615:   LD      ($5C51),HL      ; set CURCHL system variable to the
06429   1618                                             ; address in HL
06430   1618 FD CB 30 A6         RES     4,(IY+$30)      ; update FLAGS2  - signal K channel not in use.
06431   161C                                             ; Note. provide a default for channel 'R'.
06432   161C 23                  INC     HL              ; advance past
06433   161D 23                  INC     HL              ; output routine.
06434   161E 23                  INC     HL              ; advance past
06435   161F 23                  INC     HL              ; input routine.
06436   1620 4E                  LD      C,(HL)          ; pick up the letter.
06437   1621 21 2D 16            LD      HL,L162D        ; address: chn-cd-lu
06438   1624 CD DC 16            CALL    L16DC           ; routine INDEXER finds offset to a
06439   1627                                             ; flag-setting routine.
06440   1627             
06441   1627 D0                  RET     NC              ; but if the letter wasn't found in the
06442   1628                                             ; table just return now. - channel 'R'.
06443   1628             
06444   1628 16 00               LD      D,$00           ; prepare to add
06445   162A 5E                  LD      E,(HL)          ; offset to E
06446   162B 19                  ADD     HL,DE           ; add offset to location of offset to form
06447   162C                                             ; address of routine
06448   162C             
06449   162C             ;; CALL-JUMP
06450   162C E9          L162C:   JP      (HL)            ; jump to the routine
06451   162D             
06452   162D             ; Footnote. calling any location that holds JP (HL) is the equivalent to
06453   162D             ; a pseudo Z80 instruction CALL (HL). The ROM uses the instruction above.
06454   162D             
06455   162D             ; --------------------------
06456   162D             ; Channel code look-up table
06457   162D             ; --------------------------
06458   162D             ; This table is used by the routine above to find one of the three
06459   162D             ; flag setting routines below it.
06460   162D             ; A zero end-marker is required as channel 'R' is not present.
06461   162D             
06462   162D             ;; chn-cd-lu
06463   162D 4B 06       L162D:   DEFB    'K', L1634-$-1  ; offset $06 to CHAN-K
06464   162F 53 12               DEFB    'S', L1642-$-1  ; offset $12 to CHAN-S
06465   1631 50 1B               DEFB    'P', L164D-$-1  ; offset $1B to CHAN-P
06466   1633             
06467   1633 00                  DEFB    $00             ; end marker.
06468   1634             
06469   1634             ; --------------
06470   1634             ; Channel K flag
06471   1634             ; --------------
06472   1634             ; routine to set flags for lower screen/keyboard channel.
06473   1634             
06474   1634             ;; CHAN-K
06475   1634 FD CB 02 C6 L1634:   SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
06476   1638 FD CB 01 AE         RES     5,(IY+$01)      ; update FLAGS    - signal no new key
06477   163C FD CB 30 E6         SET     4,(IY+$30)      ; update FLAGS2   - signal K channel in use
06478   1640 18 04               JR      L1646           ; forward to CHAN-S-1 for indirect exit
06479   1642             
06480   1642             ; --------------
06481   1642             ; Channel S flag
06482   1642             ; --------------
06483   1642             ; routine to set flags for upper screen channel.
06484   1642             
06485   1642             ;; CHAN-S
06486   1642 FD CB 02 86 L1642:   RES     0,(IY+$02)      ; TV_FLAG  - signal main screen in use
06487   1646             
06488   1646             ;; CHAN-S-1
06489   1646 FD CB 01 8E L1646:   RES     1,(IY+$01)      ; update FLAGS  - signal printer not in use
06490   164A C3 4D 0D            JP      L0D4D           ; jump back to TEMPS and exit via that
06491   164D                                             ; routine after setting temporary attributes.
06492   164D             ; --------------
06493   164D             ; Channel P flag
06494   164D             ; --------------
06495   164D             ; This routine sets a flag so that subsequent print related commands
06496   164D             ; print to printer or update the relevant system variables.
06497   164D             ; This status remains in force until reset by the routine above.
06498   164D             
06499   164D             ;; CHAN-P
06500   164D FD CB 01 CE L164D:   SET     1,(IY+$01)      ; update FLAGS  - signal printer in use
06501   1651 C9                  RET                     ; return
06502   1652             
06503   1652             ; --------------------------
06504   1652             ; THE 'ONE SPACE' SUBROUTINE
06505   1652             ; --------------------------
06506   1652             ; This routine is called once only to create a single space
06507   1652             ; in workspace by ADD-CHAR. 
06508   1652             
06509   1652             ;; ONE-SPACE
06510   1652 01 01 00    L1652:   LD      BC,$0001        ; create space for a single character.
06511   1655             
06512   1655             ; ---------
06513   1655             ; Make Room
06514   1655             ; ---------
06515   1655             ; This entry point is used to create BC spaces in various areas such as
06516   1655             ; program area, variables area, workspace etc..
06517   1655             ; The entire free RAM is available to each BASIC statement.
06518   1655             ; On entry, HL addresses where the first location is to be created.
06519   1655             ; Afterwards, HL will point to the location before this.
06520   1655             
06521   1655             ;; MAKE-ROOM
06522   1655 E5          L1655:   PUSH    HL              ; save the address pointer.
06523   1656 CD 05 1F            CALL    L1F05           ; routine TEST-ROOM checks if room
06524   1659                                             ; exists and generates an error if not.
06525   1659 E1                  POP     HL              ; restore the address pointer.
06526   165A CD 64 16            CALL    L1664           ; routine POINTERS updates the
06527   165D                                             ; dynamic memory location pointers.
06528   165D                                             ; DE now holds the old value of STKEND.
06529   165D 2A 65 5C            LD      HL,($5C65)      ; fetch new STKEND the top destination.
06530   1660             
06531   1660 EB                  EX      DE,HL           ; HL now addresses the top of the area to
06532   1661                                             ; be moved up - old STKEND.
06533   1661 ED B8               LDDR                    ; the program, variables, etc are moved up.
06534   1663 C9                  RET                     ; return with new area ready to be populated.
06535   1664                                             ; HL points to location before new area,
06536   1664                                             ; and DE to last of new locations.
06537   1664             
06538   1664             ; -----------------------------------------------
06539   1664             ; Adjust pointers before making or reclaiming room
06540   1664             ; -----------------------------------------------
06541   1664             ; This routine is called by MAKE-ROOM to adjust upwards and by RECLAIM to
06542   1664             ; adjust downwards the pointers within dynamic memory.
06543   1664             ; The fourteen pointers to dynamic memory, starting with VARS and ending 
06544   1664             ; with STKEND, are updated adding BC if they are higher than the position
06545   1664             ; in HL.  
06546   1664             ; The system variables are in no particular order except that STKEND, the first
06547   1664             ; free location after dynamic memory must be the last encountered.
06548   1664             
06549   1664             ;; POINTERS
06550   1664 F5          L1664:   PUSH    AF              ; preserve accumulator.
06551   1665 E5                  PUSH    HL              ; put pos pointer on stack.
06552   1666 21 4B 5C            LD      HL,$5C4B        ; address VARS the first of the
06553   1669 3E 0E               LD      A,$0E           ; fourteen variables to consider.
06554   166B             
06555   166B             ;; PTR-NEXT
06556   166B 5E          L166B:   LD      E,(HL)          ; fetch the low byte of the system variable.
06557   166C 23                  INC     HL              ; advance address.
06558   166D 56                  LD      D,(HL)          ; fetch high byte of the system variable.
06559   166E E3                  EX      (SP),HL         ; swap pointer on stack with the variable
06560   166F                                             ; pointer.
06561   166F A7                  AND     A               ; prepare to subtract.
06562   1670 ED 52               SBC     HL,DE           ; subtract variable address
06563   1672 19                  ADD     HL,DE           ; and add back
06564   1673 E3                  EX      (SP),HL         ; swap pos with system variable pointer
06565   1674 30 09               JR      NC,L167F        ; forward to PTR-DONE if var before pos
06566   1676             
06567   1676 D5                  PUSH    DE              ; save system variable address.
06568   1677 EB                  EX      DE,HL           ; transfer to HL
06569   1678 09                  ADD     HL,BC           ; add the offset
06570   1679 EB                  EX      DE,HL           ; back to DE
06571   167A 72                  LD      (HL),D          ; load high byte
06572   167B 2B                  DEC     HL              ; move back
06573   167C 73                  LD      (HL),E          ; load low byte
06574   167D 23                  INC     HL              ; advance to high byte
06575   167E D1                  POP     DE              ; restore old system variable address.
06576   167F             
06577   167F             ;; PTR-DONE
06578   167F 23          L167F:   INC     HL              ; address next system variable.
06579   1680 3D                  DEC     A               ; decrease counter.
06580   1681 20 E8               JR      NZ,L166B        ; back to PTR-NEXT if more.
06581   1683 EB                  EX      DE,HL           ; transfer old value of STKEND to HL.
06582   1684                                             ; Note. this has always been updated.
06583   1684 D1                  POP     DE              ; pop the address of the position.
06584   1685             
06585   1685 F1                  POP     AF              ; pop preserved accumulator.
06586   1686 A7                  AND     A               ; clear carry flag preparing to subtract.
06587   1687             
06588   1687 ED 52               SBC     HL,DE           ; subtract position from old stkend 
06589   1689 44                  LD      B,H             ; to give number of data bytes
06590   168A 4D                  LD      C,L             ; to be moved.
06591   168B 03                  INC     BC              ; increment as we also copy byte at old STKEND.
06592   168C 19                  ADD     HL,DE           ; recompute old stkend.
06593   168D EB                  EX      DE,HL           ; transfer to DE.
06594   168E C9                  RET                     ; return.
06595   168F             
06596   168F             
06597   168F             
06598   168F             ; -------------------
06599   168F             ; Collect line number
06600   168F             ; -------------------
06601   168F             ; This routine extracts a line number, at an address that has previously
06602   168F             ; been found using LINE-ADDR, and it is entered at LINE-NO. If it encounters
06603   168F             ; the program 'end-marker' then the previous line is used and if that
06604   168F             ; should also be unacceptable then zero is used as it must be a direct
06605   168F             ; command. The program end-marker is the variables end-marker $80, or
06606   168F             ; if variables exist, then the first character of any variable name.
06607   168F             
06608   168F             ;; LINE-ZERO
06609   168F 00 00       L168F:   DEFB    $00, $00        ; dummy line number used for direct commands
06610   1691             
06611   1691             
06612   1691             ;; LINE-NO-A
06613   1691 EB          L1691:   EX      DE,HL           ; fetch the previous line to HL and set
06614   1692 11 8F 16            LD      DE,L168F        ; DE to LINE-ZERO should HL also fail.
06615   1695             
06616   1695             ; -> The Entry Point.
06617   1695             
06618   1695             ;; LINE-NO
06619   1695 7E          L1695:   LD      A,(HL)          ; fetch the high byte - max $2F
06620   1696 E6 C0               AND     $C0             ; mask off the invalid bits.
06621   1698 20 F7               JR      NZ,L1691        ; to LINE-NO-A if an end-marker.
06622   169A             
06623   169A 56                  LD      D,(HL)          ; reload the high byte.
06624   169B 23                  INC     HL              ; advance address.
06625   169C 5E                  LD      E,(HL)          ; pick up the low byte.
06626   169D C9                  RET                     ; return from here.
06627   169E             
06628   169E             ; -------------------
06629   169E             ; Handle reserve room
06630   169E             ; -------------------
06631   169E             ; This is a continuation of the restart BC-SPACES
06632   169E             
06633   169E             ;; RESERVE
06634   169E 2A 63 5C    L169E:   LD      HL,($5C63)      ; STKBOT first location of calculator stack
06635   16A1 2B                  DEC     HL              ; make one less than new location
06636   16A2 CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates the room.
06637   16A5 23                  INC     HL              ; address the first new location
06638   16A6 23                  INC     HL              ; advance to second
06639   16A7 C1                  POP     BC              ; restore old WORKSP
06640   16A8 ED 43 61 5C         LD      ($5C61),BC      ; system variable WORKSP was perhaps
06641   16AC                                             ; changed by POINTERS routine.
06642   16AC C1                  POP     BC              ; restore count for return value.
06643   16AD EB                  EX      DE,HL           ; switch. DE = location after first new space
06644   16AE 23                  INC     HL              ; HL now location after new space
06645   16AF C9                  RET                     ; return.
06646   16B0             
06647   16B0             ; ---------------------------
06648   16B0             ; Clear various editing areas
06649   16B0             ; ---------------------------
06650   16B0             ; This routine sets the editing area, workspace and calculator stack
06651   16B0             ; to their minimum configurations as at initialization and indeed this
06652   16B0             ; routine could have been relied on to perform that task.
06653   16B0             ; This routine uses HL only and returns with that register holding
06654   16B0             ; WORKSP/STKBOT/STKEND though no use is made of this. The routines also
06655   16B0             ; reset MEM to its usual place in the systems variable area should it
06656   16B0             ; have been relocated to a FOR-NEXT variable. The main entry point
06657   16B0             ; SET-MIN is called at the start of the MAIN-EXEC loop and prior to
06658   16B0             ; displaying an error.
06659   16B0             
06660   16B0             ;; SET-MIN
06661   16B0 2A 59 5C    L16B0:   LD      HL,($5C59)      ; fetch E_LINE
06662   16B3 36 0D               LD      (HL),$0D        ; insert carriage return
06663   16B5 22 5B 5C            LD      ($5C5B),HL      ; make K_CUR keyboard cursor point there.
06664   16B8 23                  INC     HL              ; next location
06665   16B9 36 80               LD      (HL),$80        ; holds end-marker $80
06666   16BB 23                  INC     HL              ; next location becomes
06667   16BC 22 61 5C            LD      ($5C61),HL      ; start of WORKSP
06668   16BF             
06669   16BF             ; This entry point is used prior to input and prior to the execution,
06670   16BF             ; or parsing, of each statement.
06671   16BF             
06672   16BF             ;; SET-WORK
06673   16BF 2A 61 5C    L16BF:   LD      HL,($5C61)      ; fetch WORKSP value
06674   16C2 22 63 5C            LD      ($5C63),HL      ; and place in STKBOT
06675   16C5             
06676   16C5             ; This entry point is used to move the stack back to its normal place
06677   16C5             ; after temporary relocation during line entry and also from ERROR-3
06678   16C5             
06679   16C5             ;; SET-STK
06680   16C5 2A 63 5C    L16C5:   LD      HL,($5C63)      ; fetch STKBOT value 
06681   16C8 22 65 5C            LD      ($5C65),HL      ; and place in STKEND.
06682   16CB             
06683   16CB E5                  PUSH    HL              ; perhaps an obsolete entry point.
06684   16CC 21 92 5C            LD      HL,$5C92        ; normal location of MEM-0
06685   16CF 22 68 5C            LD      ($5C68),HL      ; is restored to system variable MEM.
06686   16D2 E1                  POP     HL              ; saved value not required.
06687   16D3 C9                  RET                     ; return.
06688   16D4             
06689   16D4             ; ------------------
06690   16D4             ; Reclaim edit-line?
06691   16D4             ; ------------------
06692   16D4             ; This seems to be legacy code from the ZX80/ZX81 as it is 
06693   16D4             ; not used in this ROM.
06694   16D4             ; That task, in fact, is performed here by the dual-area routine CLEAR-SP.
06695   16D4             ; This routine is designed to deal with something that is known to be in the
06696   16D4             ; edit buffer and not workspace.
06697   16D4             ; On entry, HL must point to the end of the something to be deleted.
06698   16D4             
06699   16D4             ;; REC-EDIT
06700   16D4 ED 5B 59 5C L16D4:   LD      DE,($5C59)      ; fetch start of edit line from E_LINE.
06701   16D8 C3 E5 19            JP      L19E5           ; jump forward to RECLAIM-1.
06702   16DB             
06703   16DB             ; --------------------------
06704   16DB             ; The Table INDEXING routine
06705   16DB             ; --------------------------
06706   16DB             ; This routine is used to search two-byte hash tables for a character
06707   16DB             ; held in C, returning the address of the following offset byte.
06708   16DB             ; if it is known that the character is in the table e.g. for priorities,
06709   16DB             ; then the table requires no zero end-marker. If this is not known at the
06710   16DB             ; outset then a zero end-marker is required and carry is set to signal
06711   16DB             ; success.
06712   16DB             
06713   16DB             ;; INDEXER-1
06714   16DB 23          L16DB:   INC     HL              ; address the next pair of values.
06715   16DC             
06716   16DC             ; -> The Entry Point.
06717   16DC             
06718   16DC             ;; INDEXER
06719   16DC 7E          L16DC:   LD      A,(HL)          ; fetch the first byte of pair
06720   16DD A7                  AND     A               ; is it the end-marker ?
06721   16DE C8                  RET     Z               ; return with carry reset if so.
06722   16DF             
06723   16DF B9                  CP      C               ; is it the required character ?
06724   16E0 23                  INC     HL              ; address next location.
06725   16E1 20 F8               JR      NZ,L16DB        ; back to INDEXER-1 if no match.
06726   16E3             
06727   16E3 37                  SCF                     ; else set the carry flag.
06728   16E4 C9                  RET                     ; return with carry set
06729   16E5             
06730   16E5             ; --------------------------------
06731   16E5             ; The Channel and Streams Routines
06732   16E5             ; --------------------------------
06733   16E5             ; A channel is an input/output route to a hardware device
06734   16E5             ; and is identified to the system by a single letter e.g. 'K' for
06735   16E5             ; the keyboard. A channel can have an input and output route
06736   16E5             ; associated with it in which case it is bi-directional like
06737   16E5             ; the keyboard. Others like the upper screen 'S' are output
06738   16E5             ; only and the input routine usually points to a report message.
06739   16E5             ; Channels 'K' and 'S' are system channels and it would be inappropriate
06740   16E5             ; to close the associated streams so a mechanism is provided to
06741   16E5             ; re-attach them. When the re-attachment is no longer required, then
06742   16E5             ; closing these streams resets them as at initialization.
06743   16E5             ; Early adverts said that the network and RS232 were in this ROM. 
06744   16E5             ; Channels 'N' and 'B' are user channels and have been removed successfully 
06745   16E5             ; if, as seems possible, they existed.
06746   16E5             ; Ironically the tape streamer is not accessed through streams and
06747   16E5             ; channels.
06748   16E5             ; Early demonstrations of the Spectrum showed a single microdrive being
06749   16E5             ; controlled by the main ROM.
06750   16E5             
06751   16E5             ; ---------------------
06752   16E5             ; THE 'CLOSE #' COMMAND
06753   16E5             ; ---------------------
06754   16E5             ;   This command allows streams to be closed after use.
06755   16E5             ;   Any temporary memory areas used by the stream would be reclaimed and
06756   16E5             ;   finally flags set or reset if necessary.
06757   16E5             
06758   16E5             ;; CLOSE
06759   16E5 CD 1E 17    L16E5:   CALL    L171E           ; routine STR-DATA fetches parameter
06760   16E8                                             ; from calculator stack and gets the
06761   16E8                                             ; existing STRMS data pointer address in HL
06762   16E8                                             ; and stream offset from CHANS in BC.
06763   16E8             
06764   16E8                                             ; Note. this offset could be zero if the
06765   16E8                                             ; stream is already closed. A check for this
06766   16E8                                             ; should occur now and an error should be
06767   16E8                                             ; generated, for example,
06768   16E8                                             ; Report S 'Stream status closed'.
06769   16E8             
06770   16E8 CD 01 17            CALL    L1701           ; routine CLOSE-2 would perform any actions
06771   16EB                                             ; peculiar to that stream without disturbing
06772   16EB                                             ; data pointer to STRMS entry in HL.
06773   16EB             
06774   16EB 01 00 00            LD      BC,$0000        ; the stream is to be blanked.
06775   16EE 11 E2 A3            LD      DE,$A3E2        ; the number of bytes from stream 4, $5C1E,
06776   16F1                                             ; to $10000
06777   16F1 EB                  EX      DE,HL           ; transfer offset to HL, STRMS data pointer
06778   16F2                                             ; to DE.
06779   16F2 19                  ADD     HL,DE           ; add the offset to the data pointer.  
06780   16F3 38 07               JR      C,L16FC         ; forward to CLOSE-1 if a non-system stream.
06781   16F5                                             ; i.e. higher than 3. 
06782   16F5             
06783   16F5             ; proceed with a negative result.
06784   16F5             
06785   16F5 01 D4 15            LD      BC,L15C6 + 14   ; prepare the address of the byte after
06786   16F8                                             ; the initial stream data in ROM. ($15D4)
06787   16F8 09                  ADD     HL,BC           ; index into the data table with negative value.
06788   16F9 4E                  LD      C,(HL)          ; low byte to C
06789   16FA 23                  INC     HL              ; address next.
06790   16FB 46                  LD      B,(HL)          ; high byte to B.
06791   16FC             
06792   16FC             ;   and for streams 0 - 3 just enter the initial data back into the STRMS entry
06793   16FC             ;   streams 0 - 2 can't be closed as they are shared by the operating system.
06794   16FC             ;   -> for streams 4 - 15 then blank the entry.
06795   16FC             
06796   16FC             ;; CLOSE-1
06797   16FC EB          L16FC:   EX      DE,HL           ; address of stream to HL.
06798   16FD 71                  LD      (HL),C          ; place zero (or low byte).
06799   16FE 23                  INC     HL              ; next address.
06800   16FF 70                  LD      (HL),B          ; place zero (or high byte).
06801   1700 C9                  RET                     ; return.
06802   1701             
06803   1701             ; ------------------------
06804   1701             ; THE 'CLOSE-2' SUBROUTINE
06805   1701             ; ------------------------
06806   1701             ;   There is not much point in coming here.
06807   1701             ;   The purpose was once to find the offset to a special closing routine,
06808   1701             ;   in this ROM and within 256 bytes of the close stream look up table that
06809   1701             ;   would reclaim any buffers associated with a stream. At least one has been
06810   1701             ;   removed.
06811   1701             ;   Any attempt to CLOSE streams $00 to $04, without first opening the stream,
06812   1701             ;   will lead to either a system restart or the production of a strange report.
06813   1701             ;   credit: Martin Wren-Hilton 1982.
06814   1701             
06815   1701             ;; CLOSE-2
06816   1701 E5          L1701:   PUSH    HL              ; * save address of stream data pointer
06817   1702                                             ; in STRMS on the machine stack.
06818   1702 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS address to HL
06819   1705 09                  ADD     HL,BC           ; add the offset to address the second
06820   1706                                             ; byte of the output routine hopefully.
06821   1706 23                  INC     HL              ; step past
06822   1707 23                  INC     HL              ; the input routine.
06823   1708             
06824   1708             ;    Note. When the Sinclair Interface1 is fitted then an instruction fetch 
06825   1708             ;    on the next address pages this ROM out and the shadow ROM in.
06826   1708             
06827   1708             ;; ROM_TRAP
06828   1708 23          L1708:   INC     HL              ; to address channel's letter
06829   1709 4E                  LD      C,(HL)          ; pick it up in C.
06830   170A                                             ; Note. but if stream is already closed we
06831   170A                                             ; get the value $10 (the byte preceding 'K').
06832   170A             
06833   170A EB                  EX      DE,HL           ; save the pointer to the letter in DE.
06834   170B             
06835   170B             ;   Note. The string pointer is saved but not used!!
06836   170B             
06837   170B 21 16 17            LD      HL,L1716        ; address: cl-str-lu in ROM.
06838   170E CD DC 16            CALL    L16DC           ; routine INDEXER uses the code to get 
06839   1711                                             ; the 8-bit offset from the current point to
06840   1711                                             ; the address of the closing routine in ROM.
06841   1711                                             ; Note. it won't find $10 there!
06842   1711             
06843   1711 4E                  LD      C,(HL)          ; transfer the offset to C.
06844   1712 06 00               LD      B,$00           ; prepare to add.
06845   1714 09                  ADD     HL,BC           ; add offset to point to the address of the
06846   1715                                             ; routine that closes the stream.
06847   1715                                             ; (and presumably removes any buffers that
06848   1715                                             ; are associated with it.)
06849   1715 E9                  JP      (HL)            ; jump to that routine.
06850   1716             
06851   1716             ; --------------------------------
06852   1716             ; THE 'CLOSE STREAM LOOK-UP' TABLE
06853   1716             ; --------------------------------
06854   1716             ;   This table contains an entry for a letter found in the CHANS area.
06855   1716             ;   followed by an 8-bit displacement, from that byte's address in the
06856   1716             ;   table to the routine that performs any ancillary actions associated
06857   1716             ;   with closing the stream of that channel.
06858   1716             ;   The table doesn't require a zero end-marker as the letter has been
06859   1716             ;   picked up from a channel that has an open stream.
06860   1716             
06861   1716             ;; cl-str-lu
06862   1716 4B 05       L1716:   DEFB    'K', L171C-$-1  ; offset 5 to CLOSE-STR
06863   1718 53 03               DEFB    'S', L171C-$-1  ; offset 3 to CLOSE-STR
06864   171A 50 01               DEFB    'P', L171C-$-1  ; offset 1 to CLOSE-STR
06865   171C             
06866   171C             
06867   171C             ; ------------------------------
06868   171C             ; THE 'CLOSE STREAM' SUBROUTINES
06869   171C             ; ------------------------------
06870   171C             ; The close stream routines in fact have no ancillary actions to perform
06871   171C             ; which is not surprising with regard to 'K' and 'S'.
06872   171C             
06873   171C             ;; CLOSE-STR                    
06874   171C E1          L171C:   POP     HL              ; * now just restore the stream data pointer
06875   171D C9                  RET                     ; in STRMS and return.
06876   171E             
06877   171E             ; -----------
06878   171E             ; Stream data
06879   171E             ; -----------
06880   171E             ; This routine finds the data entry in the STRMS area for the specified
06881   171E             ; stream which is passed on the calculator stack. It returns with HL
06882   171E             ; pointing to this system variable and BC holding a displacement from
06883   171E             ; the CHANS area to the second byte of the stream's channel. If BC holds
06884   171E             ; zero, then that signifies that the stream is closed.
06885   171E             
06886   171E             ;; STR-DATA
06887   171E CD 94 1E    L171E:   CALL    L1E94           ; routine FIND-INT1 fetches parameter to A
06888   1721 FE 10               CP      $10             ; is it less than 16d ?
06889   1723 38 02               JR      C,L1727         ; skip forward to STR-DATA1 if so.
06890   1725             
06891   1725             ;; REPORT-Ob
06892   1725 CF          L1725:   RST     08H             ; ERROR-1
06893   1726 17                  DEFB    $17             ; Error Report: Invalid stream
06894   1727             
06895   1727             ;; STR-DATA1
06896   1727 C6 03       L1727:   ADD     A,$03           ; add the offset for 3 system streams.
06897   1729                                             ; range 00 - 15d becomes 3 - 18d.
06898   1729 07                  RLCA                    ; double as there are two bytes per 
06899   172A                                             ; stream - now 06 - 36d
06900   172A 21 10 5C            LD      HL,$5C10        ; address STRMS - the start of the streams
06901   172D                                             ; data area in system variables.
06902   172D 4F                  LD      C,A             ; transfer the low byte to A.
06903   172E 06 00               LD      B,$00           ; prepare to add offset.
06904   1730 09                  ADD     HL,BC           ; add to address the data entry in STRMS.
06905   1731             
06906   1731             ; the data entry itself contains an offset from CHANS to the address of the
06907   1731             ; stream
06908   1731             
06909   1731 4E                  LD      C,(HL)          ; low byte of displacement to C.
06910   1732 23                  INC     HL              ; address next.
06911   1733 46                  LD      B,(HL)          ; high byte of displacement to B.
06912   1734 2B                  DEC     HL              ; step back to leave HL pointing to STRMS
06913   1735                                             ; data entry.
06914   1735 C9                  RET                     ; return with CHANS displacement in BC
06915   1736                                             ; and address of stream data entry in HL.
06916   1736             
06917   1736             ; --------------------
06918   1736             ; Handle OPEN# command
06919   1736             ; --------------------
06920   1736             ; Command syntax example: OPEN #5,"s"
06921   1736             ; On entry the channel code entry is on the calculator stack with the next
06922   1736             ; value containing the stream identifier. They have to swapped.
06923   1736             
06924   1736             ;; OPEN
06925   1736 EF          L1736:   RST     28H             ;; FP-CALC    ;s,c.
06926   1737 01                  DEFB    $01             ;;exchange    ;c,s.
06927   1738 38                  DEFB    $38             ;;end-calc
06928   1739             
06929   1739 CD 1E 17            CALL    L171E           ; routine STR-DATA fetches the stream off
06930   173C                                             ; the stack and returns with the CHANS
06931   173C                                             ; displacement in BC and HL addressing 
06932   173C                                             ; the STRMS data entry.
06933   173C 78                  LD      A,B             ; test for zero which
06934   173D B1                  OR      C               ; indicates the stream is closed.
06935   173E 28 16               JR      Z,L1756         ; skip forward to OPEN-1 if so.
06936   1740             
06937   1740             ; if it is a system channel then it can re-attached.
06938   1740             
06939   1740 EB                  EX      DE,HL           ; save STRMS address in DE.
06940   1741 2A 4F 5C            LD      HL,($5C4F)      ; fetch CHANS.
06941   1744 09                  ADD     HL,BC           ; add the offset to address the second 
06942   1745                                             ; byte of the channel.
06943   1745 23                  INC     HL              ; skip over the
06944   1746 23                  INC     HL              ; input routine.
06945   1747 23                  INC     HL              ; and address the letter.
06946   1748 7E                  LD      A,(HL)          ; pick up the letter.
06947   1749 EB                  EX      DE,HL           ; save letter pointer and bring back
06948   174A                                             ; the STRMS pointer.
06949   174A             
06950   174A FE 4B               CP      $4B             ; is it 'K' ?
06951   174C 28 08               JR      Z,L1756         ; forward to OPEN-1 if so
06952   174E             
06953   174E FE 53               CP      $53             ; is it 'S' ?
06954   1750 28 04               JR      Z,L1756         ; forward to OPEN-1 if so
06955   1752             
06956   1752 FE 50               CP      $50             ; is it 'P' ?
06957   1754 20 CF               JR      NZ,L1725        ; back to REPORT-Ob if not.
06958   1756                                             ; to report 'Invalid stream'.
06959   1756             
06960   1756             ; continue if one of the upper-case letters was found.
06961   1756             ; and rejoin here from above if stream was closed.
06962   1756             
06963   1756             ;; OPEN-1
06964   1756 CD 5D 17    L1756:   CALL    L175D           ; routine OPEN-2 opens the stream.
06965   1759             
06966   1759             ; it now remains to update the STRMS variable.
06967   1759             
06968   1759 73                  LD      (HL),E          ; insert or overwrite the low byte.
06969   175A 23                  INC     HL              ; address high byte in STRMS.
06970   175B 72                  LD      (HL),D          ; insert or overwrite the high byte.
06971   175C C9                  RET                     ; return.
06972   175D             
06973   175D             ; -----------------
06974   175D             ; OPEN-2 Subroutine
06975   175D             ; -----------------
06976   175D             ; There is some point in coming here as, as well as once creating buffers,
06977   175D             ; this routine also sets flags.
06978   175D             
06979   175D             ;; OPEN-2
06980   175D E5          L175D:   PUSH    HL              ; * save the STRMS data entry pointer.
06981   175E CD F1 2B            CALL    L2BF1           ; routine STK-FETCH now fetches the
06982   1761                                             ; parameters of the channel string.
06983   1761                                             ; start in DE, length in BC.
06984   1761             
06985   1761 78                  LD      A,B             ; test that it is not
06986   1762 B1                  OR      C               ; the null string.
06987   1763 20 02               JR      NZ,L1767        ; skip forward to OPEN-3 with 1 character
06988   1765                                             ; or more!
06989   1765             
06990   1765             ;; REPORT-Fb
06991   1765 CF          L1765:   RST     08H             ; ERROR-1
06992   1766 0E                  DEFB    $0E             ; Error Report: Invalid file name
06993   1767             
06994   1767             ;; OPEN-3
06995   1767 C5          L1767:   PUSH    BC              ; save the length of the string.
06996   1768 1A                  LD      A,(DE)          ; pick up the first character.
06997   1769                                             ; Note. There can be more than one character.
06998   1769 E6 DF               AND     $DF             ; make it upper-case.
06999   176B 4F                  LD      C,A             ; place it in C.
07000   176C 21 7A 17            LD      HL,L177A        ; address: op-str-lu is loaded.
07001   176F CD DC 16            CALL    L16DC           ; routine INDEXER will search for letter.
07002   1772 30 F1               JR      NC,L1765        ; back to REPORT-F if not found
07003   1774                                             ; 'Invalid filename'
07004   1774             
07005   1774 4E                  LD      C,(HL)          ; fetch the displacement to opening routine.
07006   1775 06 00               LD      B,$00           ; prepare to add.
07007   1777 09                  ADD     HL,BC           ; now form address of opening routine.
07008   1778 C1                  POP     BC              ; restore the length of string.
07009   1779 E9                  JP      (HL)            ; now jump forward to the relevant routine.
07010   177A             
07011   177A             ; -------------------------
07012   177A             ; OPEN stream look-up table
07013   177A             ; -------------------------
07014   177A             ; The open stream look-up table consists of matched pairs.
07015   177A             ; The channel letter is followed by an 8-bit displacement to the
07016   177A             ; associated stream-opening routine in this ROM.
07017   177A             ; The table requires a zero end-marker as the letter has been
07018   177A             ; provided by the user and not the operating system.
07019   177A             
07020   177A             ;; op-str-lu
07021   177A 4B 06       L177A:   DEFB    'K', L1781-$-1  ; $06 offset to OPEN-K
07022   177C 53 08               DEFB    'S', L1785-$-1  ; $08 offset to OPEN-S
07023   177E 50 0A               DEFB    'P', L1789-$-1  ; $0A offset to OPEN-P
07024   1780             
07025   1780 00                  DEFB    $00             ; end-marker.
07026   1781             
07027   1781             ; ----------------------------
07028   1781             ; The Stream Opening Routines.
07029   1781             ; ----------------------------
07030   1781             ; These routines would have opened any buffers associated with the stream
07031   1781             ; before jumping forward to OPEN-END with the displacement value in E
07032   1781             ; and perhaps a modified value in BC. The strange pathing does seem to
07033   1781             ; provide for flexibility in this respect.
07034   1781             ;
07035   1781             ; There is no need to open the printer buffer as it is there already
07036   1781             ; even if you are still saving up for a ZX Printer or have moved onto
07037   1781             ; something bigger. In any case it would have to be created after
07038   1781             ; the system variables but apart from that it is a simple task
07039   1781             ; and all but one of the ROM routines can handle a buffer in that position.
07040   1781             ; (PR-ALL-6 would require an extra 3 bytes of code).
07041   1781             ; However it wouldn't be wise to have two streams attached to the ZX Printer
07042   1781             ; as you can now, so one assumes that if PR_CC_hi was non-zero then
07043   1781             ; the OPEN-P routine would have refused to attach a stream if another
07044   1781             ; stream was attached.
07045   1781             
07046   1781             ; Something of significance is being passed to these ghost routines in the
07047   1781             ; second character. Strings 'RB', 'RT' perhaps or a drive/station number.
07048   1781             ; The routine would have to deal with that and exit to OPEN_END with BC
07049   1781             ; containing $0001 or more likely there would be an exit within the routine.
07050   1781             ; Anyway doesn't matter, these routines are long gone.
07051   1781             
07052   1781             ; -----------------
07053   1781             ; OPEN-K Subroutine
07054   1781             ; -----------------
07055   1781             ; Open Keyboard stream.
07056   1781             
07057   1781             ;; OPEN-K
07058   1781 1E 01       L1781:   LD      E,$01           ; 01 is offset to second byte of channel 'K'.
07059   1783 18 06               JR      L178B           ; forward to OPEN-END
07060   1785             
07061   1785             ; -----------------
07062   1785             ; OPEN-S Subroutine
07063   1785             ; -----------------
07064   1785             ; Open Screen stream.
07065   1785             
07066   1785             ;; OPEN-S
07067   1785 1E 06       L1785:   LD      E,$06           ; 06 is offset to 2nd byte of channel 'S'
07068   1787 18 02               JR      L178B           ; to OPEN-END
07069   1789             
07070   1789             ; -----------------
07071   1789             ; OPEN-P Subroutine
07072   1789             ; -----------------
07073   1789             ; Open Printer stream.
07074   1789             
07075   1789             ;; OPEN-P
07076   1789 1E 10       L1789:   LD      E,$10           ; 16d is offset to 2nd byte of channel 'P'
07077   178B             
07078   178B             ;; OPEN-END
07079   178B 0B          L178B:   DEC     BC              ; the stored length of 'K','S','P' or
07080   178C                                             ; whatever is now tested. ??
07081   178C 78                  LD      A,B             ; test now if initial or residual length
07082   178D B1                  OR      C               ; is one character.
07083   178E 20 D5               JR      NZ,L1765        ; to REPORT-Fb 'Invalid file name' if not.
07084   1790             
07085   1790 57                  LD      D,A             ; load D with zero to form the displacement
07086   1791                                             ; in the DE register.
07087   1791 E1                  POP     HL              ; * restore the saved STRMS pointer.
07088   1792 C9                  RET                     ; return to update STRMS entry thereby 
07089   1793                                             ; signaling stream is open.
07090   1793             
07091   1793             ; ----------------------------------------
07092   1793             ; Handle CAT, ERASE, FORMAT, MOVE commands
07093   1793             ; ----------------------------------------
07094   1793             ; These just generate an error report as the ROM is 'incomplete'.
07095   1793             ;
07096   1793             ; Luckily this provides a mechanism for extending these in a shadow ROM
07097   1793             ; but without the powerful mechanisms set up in this ROM.
07098   1793             ; An instruction fetch on $0008 may page in a peripheral ROM,
07099   1793             ; e.g. the Sinclair Interface 1 ROM, to handle these commands.
07100   1793             ; However that wasn't the plan.
07101   1793             ; Development of this ROM continued for another three months until the cost
07102   1793             ; of replacing it and the manual became unfeasible.
07103   1793             ; The ultimate power of channels and streams died at birth.
07104   1793             
07105   1793             ;; CAT-ETC
07106   1793 18 90       L1793:   JR      L1725           ; to REPORT-Ob
07107   1795             
07108   1795             ; -----------------
07109   1795             ; Perform AUTO-LIST
07110   1795             ; -----------------
07111   1795             ; This produces an automatic listing in the upper screen.
07112   1795             
07113   1795             ;; AUTO-LIST
07114   1795 ED 73 3F 5C L1795:   LD      ($5C3F),SP      ; save stack pointer in LIST_SP
07115   1799 FD 36 02 10         LD      (IY+$02),$10    ; update TV_FLAG set bit 3
07116   179D CD AF 0D            CALL    L0DAF           ; routine CL-ALL.
07117   17A0 FD CB 02 C6         SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
07118   17A4             
07119   17A4 FD 46 31            LD      B,(IY+$31)      ; fetch DF_SZ to B.
07120   17A7 CD 44 0E            CALL    L0E44           ; routine CL-LINE clears lower display
07121   17AA                                             ; preserving B.
07122   17AA FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG  - signal main screen in use
07123   17AE FD CB 30 C6         SET     0,(IY+$30)      ; update FLAGS2 - signal will be necessary to
07124   17B2                                             ; clear main screen.
07125   17B2 2A 49 5C            LD      HL,($5C49)      ; fetch E_PPC current edit line to HL.
07126   17B5 ED 5B 6C 5C         LD      DE,($5C6C)      ; fetch S_TOP to DE, the current top line
07127   17B9                                             ; (initially zero)
07128   17B9 A7                  AND     A               ; prepare for true subtraction.
07129   17BA ED 52               SBC     HL,DE           ; subtract and
07130   17BC 19                  ADD     HL,DE           ; add back.
07131   17BD 38 22               JR      C,L17E1         ; to AUTO-L-2 if S_TOP higher than E_PPC
07132   17BF                                             ; to set S_TOP to E_PPC
07133   17BF             
07134   17BF D5                  PUSH    DE              ; save the top line number.
07135   17C0 CD 6E 19            CALL    L196E           ; routine LINE-ADDR gets address of E_PPC.
07136   17C3 11 C0 02            LD      DE,$02C0        ; prepare known number of characters in
07137   17C6                                             ; the default upper screen.
07138   17C6 EB                  EX      DE,HL           ; offset to HL, program address to DE.
07139   17C7 ED 52               SBC     HL,DE           ; subtract high value from low to obtain
07140   17C9                                             ; negated result used in addition.
07141   17C9 E3                  EX      (SP),HL         ; swap result with top line number on stack.
07142   17CA CD 6E 19            CALL    L196E           ; routine LINE-ADDR  gets address of that
07143   17CD                                             ; top line in HL and next line in DE.
07144   17CD C1                  POP     BC              ; restore the result to balance stack.
07145   17CE             
07146   17CE             ;; AUTO-L-1
07147   17CE C5          L17CE:   PUSH    BC              ; save the result.
07148   17CF CD B8 19            CALL    L19B8           ; routine NEXT-ONE gets address in HL of
07149   17D2                                             ; line after auto-line (in DE).
07150   17D2 C1                  POP     BC              ; restore result.
07151   17D3 09                  ADD     HL,BC           ; compute back.
07152   17D4 38 0E               JR      C,L17E4         ; to AUTO-L-3 if line 'should' appear
07153   17D6             
07154   17D6 EB                  EX      DE,HL           ; address of next line to HL.
07155   17D7 56                  LD      D,(HL)          ; get line
07156   17D8 23                  INC     HL              ; number
07157   17D9 5E                  LD      E,(HL)          ; in DE.
07158   17DA 2B                  DEC     HL              ; adjust back to start.
07159   17DB ED 53 6C 5C         LD      ($5C6C),DE      ; update S_TOP.
07160   17DF 18 ED               JR      L17CE           ; to AUTO-L-1 until estimate reached.
07161   17E1             
07162   17E1             ; ---
07163   17E1             
07164   17E1             ; the jump was to here if S_TOP was greater than E_PPC
07165   17E1             
07166   17E1             ;; AUTO-L-2
07167   17E1 22 6C 5C    L17E1:   LD      ($5C6C),HL      ; make S_TOP the same as E_PPC.
07168   17E4             
07169   17E4             ; continue here with valid starting point from above or good estimate
07170   17E4             ; from computation
07171   17E4             
07172   17E4             ;; AUTO-L-3
07173   17E4 2A 6C 5C    L17E4:   LD      HL,($5C6C)      ; fetch S_TOP line number to HL.
07174   17E7 CD 6E 19            CALL    L196E           ; routine LINE-ADDR gets address in HL.
07175   17EA                                             ; address of next in DE.
07176   17EA 28 01               JR      Z,L17ED         ; to AUTO-L-4 if line exists.
07177   17EC             
07178   17EC EB                  EX      DE,HL           ; else use address of next line.
07179   17ED             
07180   17ED             ;; AUTO-L-4
07181   17ED CD 33 18    L17ED:   CALL    L1833           ; routine LIST-ALL                >>>
07182   17F0             
07183   17F0             ; The return will be to here if no scrolling occurred
07184   17F0             
07185   17F0 FD CB 02 A6         RES     4,(IY+$02)      ; update TV_FLAG  - signal no auto listing.
07186   17F4 C9                  RET                     ; return.
07187   17F5             
07188   17F5             ; ------------
07189   17F5             ; Handle LLIST
07190   17F5             ; ------------
07191   17F5             ; A short form of LIST #3. The listing goes to stream 3 - default printer.
07192   17F5             
07193   17F5             ;; LLIST
07194   17F5 3E 03       L17F5:   LD      A,$03           ; the usual stream for ZX Printer
07195   17F7 18 02               JR      L17FB           ; forward to LIST-1
07196   17F9             
07197   17F9             ; -----------
07198   17F9             ; Handle LIST
07199   17F9             ; -----------
07200   17F9             ; List to any stream.
07201   17F9             ; Note. While a starting line can be specified it is
07202   17F9             ; not possible to specify an end line.
07203   17F9             ; Just listing a line makes it the current edit line.
07204   17F9             
07205   17F9             ;; LIST
07206   17F9 3E 02       L17F9:   LD      A,$02           ; default is stream 2 - the upper screen.
07207   17FB             
07208   17FB             ;; LIST-1
07209   17FB FD 36 02 00 L17FB:   LD      (IY+$02),$00    ; the TV_FLAG is initialized with bit 0 reset
07210   17FF                                             ; indicating upper screen in use.
07211   17FF CD 30 25            CALL    L2530           ; routine SYNTAX-Z - checking syntax ?
07212   1802 C4 01 16            CALL    NZ,L1601        ; routine CHAN-OPEN if in run-time.
07213   1805             
07214   1805 DF                  RST     18H             ; GET-CHAR
07215   1806 CD 70 20            CALL    L2070           ; routine STR-ALTER will alter if '#'.
07216   1809 38 14               JR      C,L181F         ; forward to LIST-4 not a '#' .
07217   180B             
07218   180B             
07219   180B DF                  RST     18H             ; GET-CHAR
07220   180C FE 3B               CP      $3B             ; is it ';' ?
07221   180E 28 04               JR      Z,L1814         ; skip to LIST-2 if so.
07222   1810             
07223   1810 FE 2C               CP      $2C             ; is it ',' ?
07224   1812 20 06               JR      NZ,L181A        ; forward to LIST-3 if neither separator.
07225   1814             
07226   1814             ; we have, say,  LIST #15, and a number must follow the separator.
07227   1814             
07228   1814             ;; LIST-2
07229   1814 E7          L1814:   RST     20H             ; NEXT-CHAR
07230   1815 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM
07231   1818 18 08               JR      L1822           ; forward to LIST-5
07232   181A             
07233   181A             ; ---
07234   181A             
07235   181A             ; the branch was here with just LIST #3 etc.
07236   181A             
07237   181A             ;; LIST-3
07238   181A CD E6 1C    L181A:   CALL    L1CE6           ; routine USE-ZERO
07239   181D 18 03               JR      L1822           ; forward to LIST-5
07240   181F             
07241   181F             ; ---
07242   181F             
07243   181F             ; the branch was here with LIST
07244   181F             
07245   181F             ;; LIST-4
07246   181F CD DE 1C    L181F:   CALL    L1CDE           ; routine FETCH-NUM checks if a number 
07247   1822                                             ; follows else uses zero.
07248   1822             
07249   1822             ;; LIST-5
07250   1822 CD EE 1B    L1822:   CALL    L1BEE           ; routine CHECK-END quits if syntax OK >>>
07251   1825             
07252   1825 CD 99 1E            CALL    L1E99           ; routine FIND-INT2 fetches the number
07253   1828                                             ; from the calculator stack in run-time.
07254   1828 78                  LD      A,B             ; fetch high byte of line number and
07255   1829 E6 3F               AND     $3F             ; make less than $40 so that NEXT-ONE
07256   182B                                             ; (from LINE-ADDR) doesn't lose context.
07257   182B                                             ; Note. this is not satisfactory and the typo
07258   182B                                             ; LIST 20000 will list an entirely different
07259   182B                                             ; section than LIST 2000. Such typos are not
07260   182B                                             ; available for checking if they are direct
07261   182B                                             ; commands.
07262   182B             
07263   182B 67                  LD      H,A             ; transfer the modified
07264   182C 69                  LD      L,C             ; line number to HL.
07265   182D 22 49 5C            LD      ($5C49),HL      ; update E_PPC to new line number.
07266   1830 CD 6E 19            CALL    L196E           ; routine LINE-ADDR gets the address of the
07267   1833                                             ; line.
07268   1833             
07269   1833             ; This routine is called from AUTO-LIST
07270   1833             
07271   1833             ;; LIST-ALL
07272   1833 1E 01       L1833:   LD      E,$01           ; signal current line not yet printed
07273   1835             
07274   1835             ;; LIST-ALL-2
07275   1835 CD 55 18    L1835:   CALL    L1855           ; routine OUT-LINE outputs a BASIC line
07276   1838                                             ; using PRINT-OUT and makes an early return
07277   1838                                             ; when no more lines to print. >>>
07278   1838             
07279   1838 D7                  RST     10H             ; PRINT-A prints the carriage return (in A)
07280   1839             
07281   1839 FD CB 02 66         BIT     4,(IY+$02)      ; test TV_FLAG  - automatic listing ?
07282   183D 28 F6               JR      Z,L1835         ; back to LIST-ALL-2 if not
07283   183F                                             ; (loop exit is via OUT-LINE)
07284   183F             
07285   183F             ; continue here if an automatic listing required.
07286   183F             
07287   183F 3A 6B 5C            LD      A,($5C6B)       ; fetch DF_SZ lower display file size.
07288   1842 FD 96 4F            SUB     (IY+$4F)        ; subtract S_POSN_hi ithe current line number.
07289   1845 20 EE               JR      NZ,L1835        ; back to LIST-ALL-2 if upper screen not full.
07290   1847             
07291   1847 AB                  XOR     E               ; A contains zero, E contains one if the
07292   1848                                             ; current edit line has not been printed
07293   1848                                             ; or zero if it has (from OUT-LINE).
07294   1848 C8                  RET     Z               ; return if the screen is full and the line
07295   1849                                             ; has been printed.
07296   1849             
07297   1849             ; continue with automatic listings if the screen is full and the current
07298   1849             ; edit line is missing. OUT-LINE will scroll automatically.
07299   1849             
07300   1849 E5                  PUSH    HL              ; save the pointer address.
07301   184A D5                  PUSH    DE              ; save the E flag.
07302   184B 21 6C 5C            LD      HL,$5C6C        ; fetch S_TOP the rough estimate.
07303   184E CD 0F 19            CALL    L190F           ; routine LN-FETCH updates S_TOP with
07304   1851                                             ; the number of the next line.
07305   1851 D1                  POP     DE              ; restore the E flag.
07306   1852 E1                  POP     HL              ; restore the address of the next line.
07307   1853 18 E0               JR      L1835           ; back to LIST-ALL-2.
07308   1855             
07309   1855             ; ------------------------
07310   1855             ; Print a whole BASIC line
07311   1855             ; ------------------------
07312   1855             ; This routine prints a whole BASIC line and it is called
07313   1855             ; from LIST-ALL to output the line to current channel
07314   1855             ; and from ED-EDIT to 'sprint' the line to the edit buffer.
07315   1855             
07316   1855             ;; OUT-LINE
07317   1855 ED 4B 49 5C L1855:   LD      BC,($5C49)      ; fetch E_PPC the current line which may be
07318   1859                                             ; unchecked and not exist.
07319   1859 CD 80 19            CALL    L1980           ; routine CP-LINES finds match or line after.
07320   185C 16 3E               LD      D,$3E           ; prepare cursor '>' in D.
07321   185E 28 05               JR      Z,L1865         ; to OUT-LINE1 if matched or line after.
07322   1860             
07323   1860 11 00 00            LD      DE,$0000        ; put zero in D, to suppress line cursor.
07324   1863 CB 13               RL      E               ; pick up carry in E if line before current
07325   1865                                             ; leave E zero if same or after.
07326   1865             
07327   1865             ;; OUT-LINE1
07328   1865 FD 73 2D    L1865:   LD      (IY+$2D),E      ; save flag in BREG which is spare.
07329   1868 7E                  LD      A,(HL)          ; get high byte of line number.
07330   1869 FE 40               CP      $40             ; is it too high ($2F is maximum possible) ?
07331   186B C1                  POP     BC              ; drop the return address and
07332   186C D0                  RET     NC              ; make an early return if so >>>
07333   186D             
07334   186D C5                  PUSH    BC              ; save return address
07335   186E CD 28 1A            CALL    L1A28           ; routine OUT-NUM-2 to print addressed number
07336   1871                                             ; with leading space.
07337   1871 23                  INC     HL              ; skip low number byte.
07338   1872 23                  INC     HL              ; and the two
07339   1873 23                  INC     HL              ; length bytes.
07340   1874 FD CB 01 86         RES     0,(IY+$01)      ; update FLAGS - signal leading space required.
07341   1878 7A                  LD      A,D             ; fetch the cursor.
07342   1879 A7                  AND     A               ; test for zero.
07343   187A 28 05               JR      Z,L1881         ; to OUT-LINE3 if zero.
07344   187C             
07345   187C             
07346   187C D7                  RST     10H             ; PRINT-A prints '>' the current line cursor.
07347   187D             
07348   187D             ; this entry point is called from ED-COPY
07349   187D             
07350   187D             ;; OUT-LINE2
07351   187D FD CB 01 C6 L187D:   SET     0,(IY+$01)      ; update FLAGS - suppress leading space.
07352   1881             
07353   1881             ;; OUT-LINE3
07354   1881 D5          L1881:   PUSH    DE              ; save flag E for a return value.
07355   1882 EB                  EX      DE,HL           ; save HL address in DE.
07356   1883 FD CB 30 96         RES     2,(IY+$30)      ; update FLAGS2 - signal NOT in QUOTES.
07357   1887             
07358   1887 21 3B 5C            LD      HL,$5C3B        ; point to FLAGS.
07359   188A CB 96               RES     2,(HL)          ; signal 'K' mode. (starts before keyword)
07360   188C FD CB 37 6E         BIT     5,(IY+$37)      ; test FLAGX - input mode ?
07361   1890 28 02               JR      Z,L1894         ; forward to OUT-LINE4 if not.
07362   1892             
07363   1892 CB D6               SET     2,(HL)          ; signal 'L' mode. (used for input)
07364   1894             
07365   1894             ;; OUT-LINE4
07366   1894 2A 5F 5C    L1894:   LD      HL,($5C5F)      ; fetch X_PTR - possibly the error pointer
07367   1897                                             ; address.
07368   1897 A7                  AND     A               ; clear the carry flag.
07369   1898 ED 52               SBC     HL,DE           ; test if an error address has been reached.
07370   189A 20 05               JR      NZ,L18A1        ; forward to OUT-LINE5 if not.
07371   189C             
07372   189C 3E 3F               LD      A,$3F           ; load A with '?' the error marker.
07373   189E CD C1 18            CALL    L18C1           ; routine OUT-FLASH to print flashing marker.
07374   18A1             
07375   18A1             ;; OUT-LINE5
07376   18A1 CD E1 18    L18A1:   CALL    L18E1           ; routine OUT-CURS will print the cursor if
07377   18A4                                             ; this is the right position.
07378   18A4 EB                  EX      DE,HL           ; restore address pointer to HL.
07379   18A5 7E                  LD      A,(HL)          ; fetch the addressed character.
07380   18A6 CD B6 18            CALL    L18B6           ; routine NUMBER skips a hidden floating 
07381   18A9                                             ; point number if present.
07382   18A9 23                  INC     HL              ; now increment the pointer.
07383   18AA FE 0D               CP      $0D             ; is character end-of-line ?
07384   18AC 28 06               JR      Z,L18B4         ; to OUT-LINE6, if so, as line is finished.
07385   18AE             
07386   18AE EB                  EX      DE,HL           ; save the pointer in DE.
07387   18AF CD 37 19            CALL    L1937           ; routine OUT-CHAR to output character/token.
07388   18B2             
07389   18B2 18 E0               JR      L1894           ; back to OUT-LINE4 until entire line is done.
07390   18B4             
07391   18B4             ; ---
07392   18B4             
07393   18B4             ;; OUT-LINE6
07394   18B4 D1          L18B4:   POP     DE              ; bring back the flag E, zero if current
07395   18B5                                             ; line printed else 1 if still to print.
07396   18B5 C9                  RET                     ; return with A holding $0D
07397   18B6             
07398   18B6             ; -------------------------
07399   18B6             ; Check for a number marker
07400   18B6             ; -------------------------
07401   18B6             ; this subroutine is called from two processes. while outputting BASIC lines
07402   18B6             ; and while searching statements within a BASIC line.
07403   18B6             ; during both, this routine will pass over an invisible number indicator
07404   18B6             ; and the five bytes floating-point number that follows it.
07405   18B6             ; Note that this causes floating point numbers to be stripped from
07406   18B6             ; the BASIC line when it is fetched to the edit buffer by OUT_LINE.
07407   18B6             ; the number marker also appears after the arguments of a DEF FN statement
07408   18B6             ; and may mask old 5-byte string parameters.
07409   18B6             
07410   18B6             ;; NUMBER
07411   18B6 FE 0E       L18B6:   CP      $0E             ; character fourteen ?
07412   18B8 C0                  RET     NZ              ; return if not.
07413   18B9             
07414   18B9 23                  INC     HL              ; skip the character
07415   18BA 23                  INC     HL              ; and five bytes
07416   18BB 23                  INC     HL              ; following.
07417   18BC 23                  INC     HL              ;
07418   18BD 23                  INC     HL              ;
07419   18BE 23                  INC     HL              ;
07420   18BF 7E                  LD      A,(HL)          ; fetch the following character
07421   18C0 C9                  RET                     ; for return value.
07422   18C1             
07423   18C1             ; --------------------------
07424   18C1             ; Print a flashing character
07425   18C1             ; --------------------------
07426   18C1             ; This subroutine is called from OUT-LINE to print a flashing error
07427   18C1             ; marker '?' or from the next routine to print a flashing cursor e.g. 'L'.
07428   18C1             ; However, this only gets called from OUT-LINE when printing the edit line
07429   18C1             ; or the input buffer to the lower screen so a direct call to $09F4 can
07430   18C1             ; be used, even though out-line outputs to other streams.
07431   18C1             ; In fact the alternate set is used for the whole routine.
07432   18C1             
07433   18C1             ;; OUT-FLASH
07434   18C1 D9          L18C1:   EXX                     ; switch in alternate set
07435   18C2             
07436   18C2 2A 8F 5C            LD      HL,($5C8F)      ; fetch L = ATTR_T, H = MASK-T
07437   18C5 E5                  PUSH    HL              ; save masks.
07438   18C6 CB BC               RES     7,H             ; reset flash mask bit so active. 
07439   18C8 CB FD               SET     7,L             ; make attribute FLASH.
07440   18CA 22 8F 5C            LD      ($5C8F),HL      ; resave ATTR_T and MASK-T
07441   18CD             
07442   18CD 21 91 5C            LD      HL,$5C91        ; address P_FLAG
07443   18D0 56                  LD      D,(HL)          ; fetch to D
07444   18D1 D5                  PUSH    DE              ; and save.
07445   18D2 36 00               LD      (HL),$00        ; clear inverse, over, ink/paper 9
07446   18D4             
07447   18D4 CD F4 09            CALL    L09F4           ; routine PRINT-OUT outputs character
07448   18D7                                             ; without the need to vector via RST 10.
07449   18D7             
07450   18D7 E1                  POP     HL              ; pop P_FLAG to H.
07451   18D8 FD 74 57            LD      (IY+$57),H      ; and restore system variable P_FLAG.
07452   18DB E1                  POP     HL              ; restore temporary masks
07453   18DC 22 8F 5C            LD      ($5C8F),HL      ; and restore system variables ATTR_T/MASK_T
07454   18DF             
07455   18DF D9                  EXX                     ; switch back to main set
07456   18E0 C9                  RET                     ; return
07457   18E1             
07458   18E1             ; ----------------
07459   18E1             ; Print the cursor
07460   18E1             ; ----------------
07461   18E1             ; This routine is called before any character is output while outputting
07462   18E1             ; a BASIC line or the input buffer. This includes listing to a printer
07463   18E1             ; or screen, copying a BASIC line to the edit buffer and printing the
07464   18E1             ; input buffer or edit buffer to the lower screen. It is only in the
07465   18E1             ; latter two cases that it has any relevance and in the last case it
07466   18E1             ; performs another very important function also.
07467   18E1             
07468   18E1             ;; OUT-CURS
07469   18E1 2A 5B 5C    L18E1:   LD      HL,($5C5B)      ; fetch K_CUR the current cursor address
07470   18E4 A7                  AND     A               ; prepare for true subtraction.
07471   18E5 ED 52               SBC     HL,DE           ; test against pointer address in DE and
07472   18E7 C0                  RET     NZ              ; return if not at exact position.
07473   18E8             
07474   18E8             ; the value of MODE, maintained by KEY-INPUT, is tested and if non-zero
07475   18E8             ; then this value 'E' or 'G' will take precedence.
07476   18E8             
07477   18E8 3A 41 5C            LD      A,($5C41)       ; fetch MODE  0='KLC', 1='E', 2='G'.
07478   18EB CB 07               RLC     A               ; double the value and set flags.
07479   18ED 28 04               JR      Z,L18F3         ; to OUT-C-1 if still zero ('KLC').
07480   18EF             
07481   18EF C6 43               ADD     A,$43           ; add 'C' - will become 'E' if originally 1
07482   18F1                                             ; or 'G' if originally 2.
07483   18F1 18 16               JR      L1909           ; forward to OUT-C-2 to print.
07484   18F3             
07485   18F3             ; ---
07486   18F3             
07487   18F3             ; If mode was zero then, while printing a BASIC line, bit 2 of flags has been
07488   18F3             ; set if 'THEN' or ':' was encountered as a main character and reset otherwise.
07489   18F3             ; This is now used to determine if the 'K' cursor is to be printed but this
07490   18F3             ; transient state is also now transferred permanently to bit 3 of FLAGS
07491   18F3             ; to let the interrupt routine know how to decode the next key.
07492   18F3             
07493   18F3             ;; OUT-C-1
07494   18F3 21 3B 5C    L18F3:   LD      HL,$5C3B        ; Address FLAGS
07495   18F6 CB 9E               RES     3,(HL)          ; signal 'K' mode initially.
07496   18F8 3E 4B               LD      A,$4B           ; prepare letter 'K'.
07497   18FA CB 56               BIT     2,(HL)          ; test FLAGS - was the
07498   18FC                                             ; previous main character ':' or 'THEN' ?
07499   18FC 28 0B               JR      Z,L1909         ; forward to OUT-C-2 if so to print.
07500   18FE             
07501   18FE CB DE               SET     3,(HL)          ; signal 'L' mode to interrupt routine.
07502   1900                                             ; Note. transient bit has been made permanent.
07503   1900 3C                  INC     A               ; augment from 'K' to 'L'.
07504   1901             
07505   1901 FD CB 30 5E         BIT     3,(IY+$30)      ; test FLAGS2 - consider caps lock ?
07506   1905                                             ; which is maintained by KEY-INPUT.
07507   1905 28 02               JR      Z,L1909         ; forward to OUT-C-2 if not set to print.
07508   1907             
07509   1907 3E 43               LD      A,$43           ; alter 'L' to 'C'.
07510   1909             
07511   1909             ;; OUT-C-2
07512   1909 D5          L1909:   PUSH    DE              ; save address pointer but OK as OUT-FLASH
07513   190A                                             ; uses alternate set without RST 10.
07514   190A             
07515   190A CD C1 18            CALL    L18C1           ; routine OUT-FLASH to print.
07516   190D             
07517   190D D1                  POP     DE              ; restore and
07518   190E C9                  RET                     ; return.
07519   190F             
07520   190F             ; ----------------------------
07521   190F             ; Get line number of next line
07522   190F             ; ----------------------------
07523   190F             ; These two subroutines are called while editing.
07524   190F             ; This entry point is from ED-DOWN with HL addressing E_PPC
07525   190F             ; to fetch the next line number.
07526   190F             ; Also from AUTO-LIST with HL addressing S_TOP just to update S_TOP
07527   190F             ; with the value of the next line number. It gets fetched but is discarded.
07528   190F             ; These routines never get called while the editor is being used for input.
07529   190F             
07530   190F             ;; LN-FETCH
07531   190F 5E          L190F:   LD      E,(HL)          ; fetch low byte
07532   1910 23                  INC     HL              ; address next
07533   1911 56                  LD      D,(HL)          ; fetch high byte.
07534   1912 E5                  PUSH    HL              ; save system variable hi pointer.
07535   1913 EB                  EX      DE,HL           ; line number to HL,
07536   1914 23                  INC     HL              ; increment as a starting point.
07537   1915 CD 6E 19            CALL    L196E           ; routine LINE-ADDR gets address in HL.
07538   1918 CD 95 16            CALL    L1695           ; routine LINE-NO gets line number in DE.
07539   191B E1                  POP     HL              ; restore system variable hi pointer.
07540   191C             
07541   191C             ; This entry point is from the ED-UP with HL addressing E_PPC_hi
07542   191C             
07543   191C             ;; LN-STORE
07544   191C FD CB 37 6E L191C:   BIT     5,(IY+$37)      ; test FLAGX - input mode ?
07545   1920 C0                  RET     NZ              ; return if so.
07546   1921                                             ; Note. above already checked by ED-UP/ED-DOWN.
07547   1921             
07548   1921 72                  LD      (HL),D          ; save high byte of line number.
07549   1922 2B                  DEC     HL              ; address lower
07550   1923 73                  LD      (HL),E          ; save low byte of line number.
07551   1924 C9                  RET                     ; return.
07552   1925             
07553   1925             ; -----------------------------------------
07554   1925             ; Outputting numbers at start of BASIC line
07555   1925             ; -----------------------------------------
07556   1925             ; This routine entered at OUT-SP-NO is used to compute then output the first
07557   1925             ; three digits of a 4-digit BASIC line printing a space if necessary.
07558   1925             ; The line number, or residual part, is held in HL and the BC register
07559   1925             ; holds a subtraction value -1000, -100 or -10.
07560   1925             ; Note. for example line number 200 -
07561   1925             ; space(out_char), 2(out_code), 0(out_char) final number always out-code.
07562   1925             
07563   1925             ;; OUT-SP-2
07564   1925 7B          L1925:   LD      A,E             ; will be space if OUT-CODE not yet called.
07565   1926                                             ; or $FF if spaces are suppressed.
07566   1926                                             ; else $30 ('0').
07567   1926                                             ; (from the first instruction at OUT-CODE)
07568   1926                                             ; this guy is just too clever.
07569   1926 A7                  AND     A               ; test bit 7 of A.
07570   1927 F8                  RET     M               ; return if $FF, as leading spaces not
07571   1928                                             ; required. This is set when printing line
07572   1928                                             ; number and statement in MAIN-5.
07573   1928             
07574   1928 18 0D               JR      L1937           ; forward to exit via OUT-CHAR.
07575   192A             
07576   192A             ; ---
07577   192A             
07578   192A             ; -> the single entry point.
07579   192A             
07580   192A             ;; OUT-SP-NO
07581   192A AF          L192A:   XOR     A               ; initialize digit to 0
07582   192B             
07583   192B             ;; OUT-SP-1
07584   192B 09          L192B:   ADD     HL,BC           ; add negative number to HL.
07585   192C 3C                  INC     A               ; increment digit
07586   192D 38 FC               JR      C,L192B         ; back to OUT-SP-1 until no carry from
07587   192F                                             ; the addition.
07588   192F             
07589   192F ED 42               SBC     HL,BC           ; cancel the last addition
07590   1931 3D                  DEC     A               ; and decrement the digit.
07591   1932 28 F1               JR      Z,L1925         ; back to OUT-SP-2 if it is zero.
07592   1934             
07593   1934 C3 EF 15            JP      L15EF           ; jump back to exit via OUT-CODE.    ->
07594   1937             
07595   1937             
07596   1937             ; -------------------------------------
07597   1937             ; Outputting characters in a BASIC line
07598   1937             ; -------------------------------------
07599   1937             ; This subroutine ...
07600   1937             
07601   1937             ;; OUT-CHAR
07602   1937 CD 1B 2D    L1937:   CALL    L2D1B           ; routine NUMERIC tests if it is a digit ?
07603   193A 30 30               JR      NC,L196C        ; to OUT-CH-3 to print digit without
07604   193C                                             ; changing mode. Will be 'K' mode if digits
07605   193C                                             ; are at beginning of edit line.
07606   193C             
07607   193C FE 21               CP      $21             ; less than quote character ?
07608   193E 38 2C               JR      C,L196C         ; to OUT-CH-3 to output controls and space.
07609   1940             
07610   1940 FD CB 01 96         RES     2,(IY+$01)      ; initialize FLAGS to 'K' mode and leave
07611   1944                                             ; unchanged if this character would precede
07612   1944                                             ; a keyword.
07613   1944             
07614   1944 FE CB               CP      $CB             ; is character 'THEN' token ?
07615   1946 28 24               JR      Z,L196C         ; to OUT-CH-3 to output if so.
07616   1948             
07617   1948 FE 3A               CP      $3A             ; is it ':' ?
07618   194A 20 0E               JR      NZ,L195A        ; to OUT-CH-1 if not statement separator
07619   194C                                             ; to change mode back to 'L'.
07620   194C             
07621   194C FD CB 37 6E         BIT     5,(IY+$37)      ; FLAGX  - Input Mode ??
07622   1950 20 16               JR      NZ,L1968        ; to OUT-CH-2 if in input as no statements.
07623   1952                                             ; Note. this check should seemingly be at
07624   1952                                             ; the start. Commands seem inappropriate in
07625   1952                                             ; INPUT mode and are rejected by the syntax
07626   1952                                             ; checker anyway.
07627   1952                                             ; unless INPUT LINE is being used.
07628   1952             
07629   1952 FD CB 30 56         BIT     2,(IY+$30)      ; test FLAGS2 - is the ':' within quotes ?
07630   1956 28 14               JR      Z,L196C         ; to OUT-CH-3 if ':' is outside quoted text.
07631   1958             
07632   1958 18 0E               JR      L1968           ; to OUT-CH-2 as ':' is within quotes
07633   195A             
07634   195A             ; ---
07635   195A             
07636   195A             ;; OUT-CH-1
07637   195A FE 22       L195A:   CP      $22             ; is it quote character '"'  ?
07638   195C 20 0A               JR      NZ,L1968        ; to OUT-CH-2 with others to set 'L' mode.
07639   195E             
07640   195E F5                  PUSH    AF              ; save character.
07641   195F 3A 6A 5C            LD      A,($5C6A)       ; fetch FLAGS2.
07642   1962 EE 04               XOR     $04             ; toggle the quotes flag.
07643   1964 32 6A 5C            LD      ($5C6A),A       ; update FLAGS2
07644   1967 F1                  POP     AF              ; and restore character.
07645   1968             
07646   1968             ;; OUT-CH-2
07647   1968 FD CB 01 D6 L1968:   SET     2,(IY+$01)      ; update FLAGS - signal L mode if the cursor
07648   196C                                             ; is next.
07649   196C             
07650   196C             ;; OUT-CH-3
07651   196C D7          L196C:   RST     10H             ; PRINT-A vectors the character to
07652   196D                                             ; channel 'S', 'K', 'R' or 'P'.
07653   196D C9                  RET                     ; return.
07654   196E             
07655   196E             ; -------------------------------------------
07656   196E             ; Get starting address of line, or line after
07657   196E             ; -------------------------------------------
07658   196E             ; This routine is used often to get the address, in HL, of a BASIC line
07659   196E             ; number supplied in HL, or failing that the address of the following line
07660   196E             ; and the address of the previous line in DE.
07661   196E             
07662   196E             ;; LINE-ADDR
07663   196E E5          L196E:   PUSH    HL              ; save line number in HL register
07664   196F 2A 53 5C            LD      HL,($5C53)      ; fetch start of program from PROG
07665   1972 54                  LD      D,H             ; transfer address to
07666   1973 5D                  LD      E,L             ; the DE register pair.
07667   1974             
07668   1974             ;; LINE-AD-1
07669   1974 C1          L1974:   POP     BC              ; restore the line number to BC
07670   1975 CD 80 19            CALL    L1980           ; routine CP-LINES compares with that
07671   1978                                             ; addressed by HL
07672   1978 D0                  RET     NC              ; return if line has been passed or matched.
07673   1979                                             ; if NZ, address of previous is in DE
07674   1979             
07675   1979 C5                  PUSH    BC              ; save the current line number
07676   197A CD B8 19            CALL    L19B8           ; routine NEXT-ONE finds address of next
07677   197D                                             ; line number in DE, previous in HL.
07678   197D EB                  EX      DE,HL           ; switch so next in HL
07679   197E 18 F4               JR      L1974           ; back to LINE-AD-1 for another comparison
07680   1980             
07681   1980             ; --------------------
07682   1980             ; Compare line numbers
07683   1980             ; --------------------
07684   1980             ; This routine compares a line number supplied in BC with an addressed
07685   1980             ; line number pointed to by HL.
07686   1980             
07687   1980             ;; CP-LINES
07688   1980 7E          L1980:   LD      A,(HL)          ; Load the high byte of line number and
07689   1981 B8                  CP      B               ; compare with that of supplied line number.
07690   1982 C0                  RET     NZ              ; return if yet to match (carry will be set).
07691   1983             
07692   1983 23                  INC     HL              ; address low byte of
07693   1984 7E                  LD      A,(HL)          ; number and pick up in A.
07694   1985 2B                  DEC     HL              ; step back to first position.
07695   1986 B9                  CP      C               ; now compare.
07696   1987 C9                  RET                     ; zero set if exact match.
07697   1988                                             ; carry set if yet to match.
07698   1988                                             ; no carry indicates a match or
07699   1988                                             ; next available BASIC line or
07700   1988                                             ; program end marker.
07701   1988             
07702   1988             ; -------------------
07703   1988             ; Find each statement
07704   1988             ; -------------------
07705   1988             ; The single entry point EACH-STMT is used to
07706   1988             ; 1) To find the D'th statement in a line.
07707   1988             ; 2) To find a token in held E.
07708   1988             
07709   1988             ;; not-used
07710   1988 23          L1988:   INC     HL              ;
07711   1989 23                  INC     HL              ;
07712   198A 23                  INC     HL              ;
07713   198B             
07714   198B             ; -> entry point.
07715   198B             
07716   198B             ;; EACH-STMT
07717   198B 22 5D 5C    L198B:   LD      ($5C5D),HL      ; save HL in CH_ADD
07718   198E 0E 00               LD      C,$00           ; initialize quotes flag
07719   1990             
07720   1990             ;; EACH-S-1
07721   1990 15          L1990:   DEC     D               ; decrease statement count
07722   1991 C8                  RET     Z               ; return if zero
07723   1992             
07724   1992             
07725   1992 E7                  RST     20H             ; NEXT-CHAR
07726   1993 BB                  CP      E               ; is it the search token ?
07727   1994 20 04               JR      NZ,L199A        ; forward to EACH-S-3 if not
07728   1996             
07729   1996 A7                  AND     A               ; clear carry
07730   1997 C9                  RET                     ; return signalling success.
07731   1998             
07732   1998             ; ---
07733   1998             
07734   1998             ;; EACH-S-2
07735   1998 23          L1998:   INC     HL              ; next address
07736   1999 7E                  LD      A,(HL)          ; next character
07737   199A             
07738   199A             ;; EACH-S-3
07739   199A CD B6 18    L199A:   CALL    L18B6           ; routine NUMBER skips if number marker
07740   199D 22 5D 5C            LD      ($5C5D),HL      ; save in CH_ADD
07741   19A0 FE 22               CP      $22             ; is it quotes '"' ?
07742   19A2 20 01               JR      NZ,L19A5        ; to EACH-S-4 if not
07743   19A4             
07744   19A4 0D                  DEC     C               ; toggle bit 0 of C
07745   19A5             
07746   19A5             ;; EACH-S-4
07747   19A5 FE 3A       L19A5:   CP      $3A             ; is it ':'
07748   19A7 28 04               JR      Z,L19AD         ; to EACH-S-5
07749   19A9             
07750   19A9 FE CB               CP      $CB             ; 'THEN'
07751   19AB 20 04               JR      NZ,L19B1        ; to EACH-S-6
07752   19AD             
07753   19AD             ;; EACH-S-5
07754   19AD CB 41       L19AD:   BIT     0,C             ; is it in quotes
07755   19AF 28 DF               JR      Z,L1990         ; to EACH-S-1 if not
07756   19B1             
07757   19B1             ;; EACH-S-6
07758   19B1 FE 0D       L19B1:   CP      $0D             ; end of line ?
07759   19B3 20 E3               JR      NZ,L1998        ; to EACH-S-2
07760   19B5             
07761   19B5 15                  DEC     D               ; decrease the statement counter
07762   19B6                                             ; which should be zero else
07763   19B6                                             ; 'Statement Lost'.
07764   19B6 37                  SCF                     ; set carry flag - not found
07765   19B7 C9                  RET                     ; return
07766   19B8             
07767   19B8             ; -----------------------------------------------------------------------
07768   19B8             ; Storage of variables. For full details - see chapter 24.
07769   19B8             ; ZX Spectrum BASIC Programming by Steven Vickers 1982.
07770   19B8             ; It is bits 7-5 of the first character of a variable that allow
07771   19B8             ; the six types to be distinguished. Bits 4-0 are the reduced letter.
07772   19B8             ; So any variable name is higher that $3F and can be distinguished
07773   19B8             ; also from the variables area end-marker $80.
07774   19B8             ;
07775   19B8             ; 76543210 meaning                               brief outline of format.
07776   19B8             ; -------- ------------------------              -----------------------
07777   19B8             ; 010      string variable.                      2 byte length + contents.
07778   19B8             ; 110      string array.                         2 byte length + contents.
07779   19B8             ; 100      array of numbers.                     2 byte length + contents.
07780   19B8             ; 011      simple numeric variable.              5 bytes.
07781   19B8             ; 101      variable length named numeric.        5 bytes.
07782   19B8             ; 111      for-next loop variable.               18 bytes.
07783   19B8             ; 10000000 the variables area end-marker.
07784   19B8             ;
07785   19B8             ; Note. any of the above seven will serve as a program end-marker.
07786   19B8             ;
07787   19B8             ; -----------------------------------------------------------------------
07788   19B8             
07789   19B8             ; ------------
07790   19B8             ; Get next one
07791   19B8             ; ------------
07792   19B8             ; This versatile routine is used to find the address of the next line
07793   19B8             ; in the program area or the next variable in the variables area.
07794   19B8             ; The reason one routine is made to handle two apparently unrelated tasks
07795   19B8             ; is that it can be called indiscriminately when merging a line or a
07796   19B8             ; variable.
07797   19B8             
07798   19B8             ;; NEXT-ONE
07799   19B8 E5          L19B8:   PUSH    HL              ; save the pointer address.
07800   19B9 7E                  LD      A,(HL)          ; get first byte.
07801   19BA FE 40               CP      $40             ; compare with upper limit for line numbers.
07802   19BC 38 17               JR      C,L19D5         ; forward to NEXT-O-3 if within BASIC area.
07803   19BE             
07804   19BE             ; the continuation here is for the next variable unless the supplied
07805   19BE             ; line number was erroneously over 16383. see RESTORE command.
07806   19BE             
07807   19BE CB 6F               BIT     5,A             ; is it a string or an array variable ?
07808   19C0 28 14               JR      Z,L19D6         ; forward to NEXT-O-4 to compute length.
07809   19C2             
07810   19C2 87                  ADD     A,A             ; test bit 6 for single-character variables.
07811   19C3 FA C7 19            JP      M,L19C7         ; forward to NEXT-O-1 if so
07812   19C6             
07813   19C6 3F                  CCF                     ; clear the carry for long-named variables.
07814   19C7                                             ; it remains set for for-next loop variables.
07815   19C7             
07816   19C7             ;; NEXT-O-1
07817   19C7 01 05 00    L19C7:   LD      BC,$0005        ; set BC to 5 for floating point number
07818   19CA 30 02               JR      NC,L19CE        ; forward to NEXT-O-2 if not a for/next
07819   19CC                                             ; variable.
07820   19CC             
07821   19CC 0E 12               LD      C,$12           ; set BC to eighteen locations.
07822   19CE                                             ; value, limit, step, line and statement.
07823   19CE             
07824   19CE             ; now deal with long-named variables
07825   19CE             
07826   19CE             ;; NEXT-O-2
07827   19CE 17          L19CE:   RLA                     ; test if character inverted. carry will also
07828   19CF                                             ; be set for single character variables
07829   19CF 23                  INC     HL              ; address next location.
07830   19D0 7E                  LD      A,(HL)          ; and load character.
07831   19D1 30 FB               JR      NC,L19CE        ; back to NEXT-O-2 if not inverted bit.
07832   19D3                                             ; forward immediately with single character
07833   19D3                                             ; variable names.
07834   19D3             
07835   19D3 18 06               JR      L19DB           ; forward to NEXT-O-5 to add length of
07836   19D5                                             ; floating point number(s etc.).
07837   19D5             
07838   19D5             ; ---
07839   19D5             
07840   19D5             ; this branch is for line numbers.
07841   19D5             
07842   19D5             ;; NEXT-O-3
07843   19D5 23          L19D5:   INC     HL              ; increment pointer to low byte of line no.
07844   19D6             
07845   19D6             ; strings and arrays rejoin here
07846   19D6             
07847   19D6             ;; NEXT-O-4
07848   19D6 23          L19D6:   INC     HL              ; increment to address the length low byte.
07849   19D7 4E                  LD      C,(HL)          ; transfer to C and
07850   19D8 23                  INC     HL              ; point to high byte of length.
07851   19D9 46                  LD      B,(HL)          ; transfer that to B
07852   19DA 23                  INC     HL              ; point to start of BASIC/variable contents.
07853   19DB             
07854   19DB             ; the three types of numeric variables rejoin here
07855   19DB             
07856   19DB             ;; NEXT-O-5
07857   19DB 09          L19DB:   ADD     HL,BC           ; add the length to give address of next
07858   19DC                                             ; line/variable in HL.
07859   19DC D1                  POP     DE              ; restore previous address to DE.
07860   19DD             
07861   19DD             ; ------------------
07862   19DD             ; Difference routine
07863   19DD             ; ------------------
07864   19DD             ; This routine terminates the above routine and is also called from the
07865   19DD             ; start of the next routine to calculate the length to reclaim.
07866   19DD             
07867   19DD             ;; DIFFER
07868   19DD A7          L19DD:   AND     A               ; prepare for true subtraction.
07869   19DE ED 52               SBC     HL,DE           ; subtract the two pointers.
07870   19E0 44                  LD      B,H             ; transfer result
07871   19E1 4D                  LD      C,L             ; to BC register pair.
07872   19E2 19                  ADD     HL,DE           ; add back
07873   19E3 EB                  EX      DE,HL           ; and switch pointers
07874   19E4 C9                  RET                     ; return values are the length of area in BC,
07875   19E5                                             ; low pointer (previous) in HL,
07876   19E5                                             ; high pointer (next) in DE.
07877   19E5             
07878   19E5             ; -----------------------
07879   19E5             ; Handle reclaiming space
07880   19E5             ; -----------------------
07881   19E5             ;
07882   19E5             
07883   19E5             ;; RECLAIM-1
07884   19E5 CD DD 19    L19E5:   CALL    L19DD           ; routine DIFFER immediately above
07885   19E8             
07886   19E8             ;; RECLAIM-2
07887   19E8 C5          L19E8:   PUSH    BC              ;
07888   19E9             
07889   19E9 78                  LD      A,B             ;
07890   19EA 2F                  CPL                     ;
07891   19EB 47                  LD      B,A             ;
07892   19EC 79                  LD      A,C             ;
07893   19ED 2F                  CPL                     ;
07894   19EE 4F                  LD      C,A             ;
07895   19EF 03                  INC     BC              ;
07896   19F0             
07897   19F0 CD 64 16            CALL    L1664           ; routine POINTERS
07898   19F3 EB                  EX      DE,HL           ;
07899   19F4 E1                  POP     HL              ;
07900   19F5             
07901   19F5 19                  ADD     HL,DE           ;
07902   19F6 D5                  PUSH    DE              ;
07903   19F7 ED B0               LDIR                    ; copy bytes
07904   19F9             
07905   19F9 E1                  POP     HL              ;
07906   19FA C9                  RET                     ;
07907   19FB             
07908   19FB             ; ----------------------------------------
07909   19FB             ; Read line number of line in editing area
07910   19FB             ; ----------------------------------------
07911   19FB             ; This routine reads a line number in the editing area returning the number
07912   19FB             ; in the BC register or zero if no digits exist before commands.
07913   19FB             ; It is called from LINE-SCAN to check the syntax of the digits.
07914   19FB             ; It is called from MAIN-3 to extract the line number in preparation for
07915   19FB             ; inclusion of the line in the BASIC program area.
07916   19FB             ;
07917   19FB             ; Interestingly the calculator stack is moved from its normal place at the
07918   19FB             ; end of dynamic memory to an adequate area within the system variables area.
07919   19FB             ; This ensures that in a low memory situation, that valid line numbers can
07920   19FB             ; be extracted without raising an error and that memory can be reclaimed
07921   19FB             ; by deleting lines. If the stack was in its normal place then a situation
07922   19FB             ; arises whereby the Spectrum becomes locked with no means of reclaiming space.
07923   19FB             
07924   19FB             ;; E-LINE-NO
07925   19FB 2A 59 5C    L19FB:   LD      HL,($5C59)      ; load HL from system variable E_LINE.
07926   19FE             
07927   19FE 2B                  DEC     HL              ; decrease so that NEXT_CHAR can be used
07928   19FF                                             ; without skipping the first digit.
07929   19FF             
07930   19FF 22 5D 5C            LD      ($5C5D),HL      ; store in the system variable CH_ADD.
07931   1A02             
07932   1A02 E7                  RST     20H             ; NEXT-CHAR skips any noise and white-space
07933   1A03                                             ; to point exactly at the first digit.
07934   1A03             
07935   1A03 21 92 5C            LD      HL,$5C92        ; use MEM-0 as a temporary calculator stack
07936   1A06                                             ; an overhead of three locations are needed.
07937   1A06 22 65 5C            LD      ($5C65),HL      ; set new STKEND.
07938   1A09             
07939   1A09 CD 3B 2D            CALL    L2D3B           ; routine INT-TO-FP will read digits till
07940   1A0C                                             ; a non-digit found.
07941   1A0C CD A2 2D            CALL    L2DA2           ; routine FP-TO-BC will retrieve number
07942   1A0F                                             ; from stack at membot.
07943   1A0F 38 04               JR      C,L1A15         ; forward to E-L-1 if overflow i.e. > 65535.
07944   1A11                                             ; 'Nonsense in BASIC'
07945   1A11             
07946   1A11 21 F0 D8            LD      HL,$D8F0        ; load HL with value -9999
07947   1A14 09                  ADD     HL,BC           ; add to line number in BC
07948   1A15             
07949   1A15             ;; E-L-1
07950   1A15 DA 8A 1C    L1A15:   JP      C,L1C8A         ; to REPORT-C 'Nonsense in BASIC' if over.
07951   1A18                                             ; Note. As ERR_SP points to ED_ERROR
07952   1A18                                             ; the report is never produced although
07953   1A18                                             ; the RST $08 will update X_PTR leading to
07954   1A18                                             ; the error marker being displayed when
07955   1A18                                             ; the ED_LOOP is reiterated.
07956   1A18                                             ; in fact, since it is immediately
07957   1A18                                             ; cancelled, any report will do.
07958   1A18             
07959   1A18             ; a line in the range 0 - 9999 has been entered.
07960   1A18             
07961   1A18 C3 C5 16            JP      L16C5           ; jump back to SET-STK to set the calculator 
07962   1A1B                                             ; stack back to its normal place and exit 
07963   1A1B                                             ; from there.
07964   1A1B             
07965   1A1B             ; ---------------------------------
07966   1A1B             ; Report and line number outputting
07967   1A1B             ; ---------------------------------
07968   1A1B             ; Entry point OUT-NUM-1 is used by the Error Reporting code to print
07969   1A1B             ; the line number and later the statement number held in BC.
07970   1A1B             ; If the statement was part of a direct command then -2 is used as a
07971   1A1B             ; dummy line number so that zero will be printed in the report.
07972   1A1B             ; This routine is also used to print the exponent of E-format numbers.
07973   1A1B             ;
07974   1A1B             ; Entry point OUT-NUM-2 is used from OUT-LINE to output the line number
07975   1A1B             ; addressed by HL with leading spaces if necessary.
07976   1A1B             
07977   1A1B             ;; OUT-NUM-1
07978   1A1B D5          L1A1B:   PUSH    DE              ; save the
07979   1A1C E5                  PUSH    HL              ; registers.
07980   1A1D AF                  XOR     A               ; set A to zero.
07981   1A1E CB 78               BIT     7,B             ; is the line number minus two ?
07982   1A20 20 20               JR      NZ,L1A42        ; forward to OUT-NUM-4 if so to print zero 
07983   1A22                                             ; for a direct command.
07984   1A22             
07985   1A22 60                  LD      H,B             ; transfer the
07986   1A23 69                  LD      L,C             ; number to HL.
07987   1A24 1E FF               LD      E,$FF           ; signal 'no leading zeros'.
07988   1A26 18 08               JR      L1A30           ; forward to continue at OUT-NUM-3
07989   1A28             
07990   1A28             ; ---
07991   1A28             
07992   1A28             ; from OUT-LINE - HL addresses line number.
07993   1A28             
07994   1A28             ;; OUT-NUM-2
07995   1A28 D5          L1A28:   PUSH    DE              ; save flags
07996   1A29 56                  LD      D,(HL)          ; high byte to D
07997   1A2A 23                  INC     HL              ; address next
07998   1A2B 5E                  LD      E,(HL)          ; low byte to E
07999   1A2C E5                  PUSH    HL              ; save pointer
08000   1A2D EB                  EX      DE,HL           ; transfer number to HL
08001   1A2E 1E 20               LD      E,$20           ; signal 'output leading spaces'
08002   1A30             
08003   1A30             ;; OUT-NUM-3
08004   1A30 01 18 FC    L1A30:   LD      BC,$FC18        ; value -1000
08005   1A33 CD 2A 19            CALL    L192A           ; routine OUT-SP-NO outputs space or number
08006   1A36 01 9C FF            LD      BC,$FF9C        ; value -100
08007   1A39 CD 2A 19            CALL    L192A           ; routine OUT-SP-NO
08008   1A3C 0E F6               LD      C,$F6           ; value -10 ( B is still $FF )
08009   1A3E CD 2A 19            CALL    L192A           ; routine OUT-SP-NO
08010   1A41 7D                  LD      A,L             ; remainder to A.
08011   1A42             
08012   1A42             ;; OUT-NUM-4
08013   1A42 CD EF 15    L1A42:   CALL    L15EF           ; routine OUT-CODE for final digit.
08014   1A45                                             ; else report code zero wouldn't get
08015   1A45                                             ; printed.
08016   1A45 E1                  POP     HL              ; restore the
08017   1A46 D1                  POP     DE              ; registers and
08018   1A47 C9                  RET                     ; return.
08019   1A48             
08020   1A48             
08021   1A48             ;***************************************************
08022   1A48             ;** Part 7. BASIC LINE AND COMMAND INTERPRETATION **
08023   1A48             ;***************************************************
08024   1A48             
08025   1A48             ; ----------------
08026   1A48             ; The offset table
08027   1A48             ; ----------------
08028   1A48             ; The BASIC interpreter has found a command code $CE - $FF
08029   1A48             ; which is then reduced to range $00 - $31 and added to the base address
08030   1A48             ; of this table to give the address of an offset which, when added to
08031   1A48             ; the offset therein, gives the location in the following parameter table
08032   1A48             ; where a list of class codes, separators and addresses relevant to the
08033   1A48             ; command exists.
08034   1A48             
08035   1A48             ;; offst-tbl
08036   1A48 B1          L1A48:   DEFB    L1AF9 - $       ; B1 offset to Address: P-DEF-FN
08037   1A49 CB                  DEFB    L1B14 - $       ; CB offset to Address: P-CAT
08038   1A4A BC                  DEFB    L1B06 - $       ; BC offset to Address: P-FORMAT
08039   1A4B BF                  DEFB    L1B0A - $       ; BF offset to Address: P-MOVE
08040   1A4C C4                  DEFB    L1B10 - $       ; C4 offset to Address: P-ERASE
08041   1A4D AF                  DEFB    L1AFC - $       ; AF offset to Address: P-OPEN
08042   1A4E B4                  DEFB    L1B02 - $       ; B4 offset to Address: P-CLOSE
08043   1A4F 93                  DEFB    L1AE2 - $       ; 93 offset to Address: P-MERGE
08044   1A50 91                  DEFB    L1AE1 - $       ; 91 offset to Address: P-VERIFY
08045   1A51 92                  DEFB    L1AE3 - $       ; 92 offset to Address: P-BEEP
08046   1A52 95                  DEFB    L1AE7 - $       ; 95 offset to Address: P-CIRCLE
08047   1A53 98                  DEFB    L1AEB - $       ; 98 offset to Address: P-INK
08048   1A54 98                  DEFB    L1AEC - $       ; 98 offset to Address: P-PAPER
08049   1A55 98                  DEFB    L1AED - $       ; 98 offset to Address: P-FLASH
08050   1A56 98                  DEFB    L1AEE - $       ; 98 offset to Address: P-BRIGHT
08051   1A57 98                  DEFB    L1AEF - $       ; 98 offset to Address: P-INVERSE
08052   1A58 98                  DEFB    L1AF0 - $       ; 98 offset to Address: P-OVER
08053   1A59 98                  DEFB    L1AF1 - $       ; 98 offset to Address: P-OUT
08054   1A5A 7F                  DEFB    L1AD9 - $       ; 7F offset to Address: P-LPRINT
08055   1A5B 81                  DEFB    L1ADC - $       ; 81 offset to Address: P-LLIST
08056   1A5C 2E                  DEFB    L1A8A - $       ; 2E offset to Address: P-STOP
08057   1A5D 6C                  DEFB    L1AC9 - $       ; 6C offset to Address: P-READ
08058   1A5E 6E                  DEFB    L1ACC - $       ; 6E offset to Address: P-DATA
08059   1A5F 70                  DEFB    L1ACF - $       ; 70 offset to Address: P-RESTORE
08060   1A60 48                  DEFB    L1AA8 - $       ; 48 offset to Address: P-NEW
08061   1A61 94                  DEFB    L1AF5 - $       ; 94 offset to Address: P-BORDER
08062   1A62 56                  DEFB    L1AB8 - $       ; 56 offset to Address: P-CONT
08063   1A63 3F                  DEFB    L1AA2 - $       ; 3F offset to Address: P-DIM
08064   1A64 41                  DEFB    L1AA5 - $       ; 41 offset to Address: P-REM
08065   1A65 2B                  DEFB    L1A90 - $       ; 2B offset to Address: P-FOR
08066   1A66 17                  DEFB    L1A7D - $       ; 17 offset to Address: P-GO-TO
08067   1A67 1F                  DEFB    L1A86 - $       ; 1F offset to Address: P-GO-SUB
08068   1A68 37                  DEFB    L1A9F - $       ; 37 offset to Address: P-INPUT
08069   1A69 77                  DEFB    L1AE0 - $       ; 77 offset to Address: P-LOAD
08070   1A6A 44                  DEFB    L1AAE - $       ; 44 offset to Address: P-LIST
08071   1A6B 0F                  DEFB    L1A7A - $       ; 0F offset to Address: P-LET
08072   1A6C 59                  DEFB    L1AC5 - $       ; 59 offset to Address: P-PAUSE
08073   1A6D 2B                  DEFB    L1A98 - $       ; 2B offset to Address: P-NEXT
08074   1A6E 43                  DEFB    L1AB1 - $       ; 43 offset to Address: P-POKE
08075   1A6F 2D                  DEFB    L1A9C - $       ; 2D offset to Address: P-PRINT
08076   1A70 51                  DEFB    L1AC1 - $       ; 51 offset to Address: P-PLOT
08077   1A71 3A                  DEFB    L1AAB - $       ; 3A offset to Address: P-RUN
08078   1A72 6D                  DEFB    L1ADF - $       ; 6D offset to Address: P-SAVE
08079   1A73 42                  DEFB    L1AB5 - $       ; 42 offset to Address: P-RANDOM
08080   1A74 0D                  DEFB    L1A81 - $       ; 0D offset to Address: P-IF
08081   1A75 49                  DEFB    L1ABE - $       ; 49 offset to Address: P-CLS
08082   1A76 5C                  DEFB    L1AD2 - $       ; 5C offset to Address: P-DRAW
08083   1A77 44                  DEFB    L1ABB - $       ; 44 offset to Address: P-CLEAR
08084   1A78 15                  DEFB    L1A8D - $       ; 15 offset to Address: P-RETURN
08085   1A79 5D                  DEFB    L1AD6 - $       ; 5D offset to Address: P-COPY
08086   1A7A             
08087   1A7A             
08088   1A7A             ; -------------------------------
08089   1A7A             ; The parameter or "Syntax" table
08090   1A7A             ; -------------------------------
08091   1A7A             ; For each command there exists a variable list of parameters.
08092   1A7A             ; If the character is greater than a space it is a required separator.
08093   1A7A             ; If less, then it is a command class in the range 00 - 0B.
08094   1A7A             ; Note that classes 00, 03 and 05 will fetch the addresses from this table.
08095   1A7A             ; Some classes e.g. 07 and 0B have the same address in all invocations
08096   1A7A             ; and the command is re-computed from the low-byte of the parameter address.
08097   1A7A             ; Some e.g. 02 are only called once so a call to the command is made from
08098   1A7A             ; within the class routine rather than holding the address within the table.
08099   1A7A             ; Some class routines check syntax entirely and some leave this task for the
08100   1A7A             ; command itself.
08101   1A7A             ; Others for example CIRCLE (x,y,z) check the first part (x,y) using the
08102   1A7A             ; class routine and the final part (,z) within the command.
08103   1A7A             ; The last few commands appear to have been added in a rush but their syntax
08104   1A7A             ; is rather simple e.g. MOVE "M1","M2"
08105   1A7A             
08106   1A7A             ;; P-LET
08107   1A7A 01          L1A7A:   DEFB    $01             ; Class-01 - A variable is required.
08108   1A7B 3D                  DEFB    $3D             ; Separator:  '='
08109   1A7C 02                  DEFB    $02             ; Class-02 - An expression, numeric or string,
08110   1A7D                                             ; must follow.
08111   1A7D             
08112   1A7D             ;; P-GO-TO
08113   1A7D 06          L1A7D:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08114   1A7E 00                  DEFB    $00             ; Class-00 - No further operands.
08115   1A7F 67 1E               DEFW    L1E67           ; Address: $1E67; Address: GO-TO
08116   1A81             
08117   1A81             ;; P-IF
08118   1A81 06          L1A81:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08119   1A82 CB                  DEFB    $CB             ; Separator:  'THEN'
08120   1A83 05                  DEFB    $05             ; Class-05 - Variable syntax checked
08121   1A84                                             ; by routine.
08122   1A84 F0 1C               DEFW    L1CF0           ; Address: $1CF0; Address: IF
08123   1A86             
08124   1A86             ;; P-GO-SUB
08125   1A86 06          L1A86:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08126   1A87 00                  DEFB    $00             ; Class-00 - No further operands.
08127   1A88 ED 1E               DEFW    L1EED           ; Address: $1EED; Address: GO-SUB
08128   1A8A             
08129   1A8A             ;; P-STOP
08130   1A8A 00          L1A8A:   DEFB    $00             ; Class-00 - No further operands.
08131   1A8B EE 1C               DEFW    L1CEE           ; Address: $1CEE; Address: STOP
08132   1A8D             
08133   1A8D             ;; P-RETURN
08134   1A8D 00          L1A8D:   DEFB    $00             ; Class-00 - No further operands.
08135   1A8E 23 1F               DEFW    L1F23           ; Address: $1F23; Address: RETURN
08136   1A90             
08137   1A90             ;; P-FOR
08138   1A90 04          L1A90:   DEFB    $04             ; Class-04 - A single character variable must
08139   1A91                                             ; follow.
08140   1A91 3D                  DEFB    $3D             ; Separator:  '='
08141   1A92 06                  DEFB    $06             ; Class-06 - A numeric expression must follow.
08142   1A93 CC                  DEFB    $CC             ; Separator:  'TO'
08143   1A94 06                  DEFB    $06             ; Class-06 - A numeric expression must follow.
08144   1A95 05                  DEFB    $05             ; Class-05 - Variable syntax checked
08145   1A96                                             ; by routine.
08146   1A96 03 1D               DEFW    L1D03           ; Address: $1D03; Address: FOR
08147   1A98             
08148   1A98             ;; P-NEXT
08149   1A98 04          L1A98:   DEFB    $04             ; Class-04 - A single character variable must
08150   1A99                                             ; follow.
08151   1A99 00                  DEFB    $00             ; Class-00 - No further operands.
08152   1A9A AB 1D               DEFW    L1DAB           ; Address: $1DAB; Address: NEXT
08153   1A9C             
08154   1A9C             ;; P-PRINT
08155   1A9C 05          L1A9C:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08156   1A9D                                             ; by routine.
08157   1A9D CD 1F               DEFW    L1FCD           ; Address: $1FCD; Address: PRINT
08158   1A9F             
08159   1A9F             ;; P-INPUT
08160   1A9F 05          L1A9F:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08161   1AA0                                             ; by routine.
08162   1AA0 89 20               DEFW    L2089           ; Address: $2089; Address: INPUT
08163   1AA2             
08164   1AA2             ;; P-DIM
08165   1AA2 05          L1AA2:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08166   1AA3                                             ; by routine.
08167   1AA3 02 2C               DEFW    L2C02           ; Address: $2C02; Address: DIM
08168   1AA5             
08169   1AA5             ;; P-REM
08170   1AA5 05          L1AA5:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08171   1AA6                                             ; by routine.
08172   1AA6 B2 1B               DEFW    L1BB2           ; Address: $1BB2; Address: REM
08173   1AA8             
08174   1AA8             ;; P-NEW
08175   1AA8 00          L1AA8:   DEFB    $00             ; Class-00 - No further operands.
08176   1AA9 B7 11               DEFW    L11B7           ; Address: $11B7; Address: NEW
08177   1AAB             
08178   1AAB             ;; P-RUN
08179   1AAB 03          L1AAB:   DEFB    $03             ; Class-03 - A numeric expression may follow
08180   1AAC                                             ; else default to zero.
08181   1AAC A1 1E               DEFW    L1EA1           ; Address: $1EA1; Address: RUN
08182   1AAE             
08183   1AAE             ;; P-LIST
08184   1AAE 05          L1AAE:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08185   1AAF                                             ; by routine.
08186   1AAF F9 17               DEFW    L17F9           ; Address: $17F9; Address: LIST
08187   1AB1             
08188   1AB1             ;; P-POKE
08189   1AB1 08          L1AB1:   DEFB    $08             ; Class-08 - Two comma-separated numeric
08190   1AB2                                             ; expressions required.
08191   1AB2 00                  DEFB    $00             ; Class-00 - No further operands.
08192   1AB3 80 1E               DEFW    L1E80           ; Address: $1E80; Address: POKE
08193   1AB5             
08194   1AB5             ;; P-RANDOM
08195   1AB5 03          L1AB5:   DEFB    $03             ; Class-03 - A numeric expression may follow
08196   1AB6                                             ; else default to zero.
08197   1AB6 4F 1E               DEFW    L1E4F           ; Address: $1E4F; Address: RANDOMIZE
08198   1AB8             
08199   1AB8             ;; P-CONT
08200   1AB8 00          L1AB8:   DEFB    $00             ; Class-00 - No further operands.
08201   1AB9 5F 1E               DEFW    L1E5F           ; Address: $1E5F; Address: CONTINUE
08202   1ABB             
08203   1ABB             ;; P-CLEAR
08204   1ABB 03          L1ABB:   DEFB    $03             ; Class-03 - A numeric expression may follow
08205   1ABC                                             ; else default to zero.
08206   1ABC AC 1E               DEFW    L1EAC           ; Address: $1EAC; Address: CLEAR
08207   1ABE             
08208   1ABE             ;; P-CLS
08209   1ABE 00          L1ABE:   DEFB    $00             ; Class-00 - No further operands.
08210   1ABF 6B 0D               DEFW    L0D6B           ; Address: $0D6B; Address: CLS
08211   1AC1             
08212   1AC1             ;; P-PLOT
08213   1AC1 09          L1AC1:   DEFB    $09             ; Class-09 - Two comma-separated numeric
08214   1AC2                                             ; expressions required with optional colour
08215   1AC2                                             ; items.
08216   1AC2 00                  DEFB    $00             ; Class-00 - No further operands.
08217   1AC3 DC 22               DEFW    L22DC           ; Address: $22DC; Address: PLOT
08218   1AC5             
08219   1AC5             ;; P-PAUSE
08220   1AC5 06          L1AC5:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08221   1AC6 00                  DEFB    $00             ; Class-00 - No further operands.
08222   1AC7 3A 1F               DEFW    L1F3A           ; Address: $1F3A; Address: PAUSE
08223   1AC9             
08224   1AC9             ;; P-READ
08225   1AC9 05          L1AC9:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08226   1ACA                                             ; by routine.
08227   1ACA ED 1D               DEFW    L1DED           ; Address: $1DED; Address: READ
08228   1ACC             
08229   1ACC             ;; P-DATA
08230   1ACC 05          L1ACC:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08231   1ACD                                             ; by routine.
08232   1ACD 27 1E               DEFW    L1E27           ; Address: $1E27; Address: DATA
08233   1ACF             
08234   1ACF             ;; P-RESTORE
08235   1ACF 03          L1ACF:   DEFB    $03             ; Class-03 - A numeric expression may follow
08236   1AD0                                             ; else default to zero.
08237   1AD0 42 1E               DEFW    L1E42           ; Address: $1E42; Address: RESTORE
08238   1AD2             
08239   1AD2             ;; P-DRAW
08240   1AD2 09          L1AD2:   DEFB    $09             ; Class-09 - Two comma-separated numeric
08241   1AD3                                             ; expressions required with optional colour
08242   1AD3                                             ; items.
08243   1AD3 05                  DEFB    $05             ; Class-05 - Variable syntax checked
08244   1AD4                                             ; by routine.
08245   1AD4 82 23               DEFW    L2382           ; Address: $2382; Address: DRAW
08246   1AD6             
08247   1AD6             ;; P-COPY
08248   1AD6 00          L1AD6:   DEFB    $00             ; Class-00 - No further operands.
08249   1AD7 AC 0E               DEFW    L0EAC           ; Address: $0EAC; Address: COPY
08250   1AD9             
08251   1AD9             ;; P-LPRINT
08252   1AD9 05          L1AD9:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08253   1ADA                                             ; by routine.
08254   1ADA C9 1F               DEFW    L1FC9           ; Address: $1FC9; Address: LPRINT
08255   1ADC             
08256   1ADC             ;; P-LLIST
08257   1ADC 05          L1ADC:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08258   1ADD                                             ; by routine.
08259   1ADD F5 17               DEFW    L17F5           ; Address: $17F5; Address: LLIST
08260   1ADF             
08261   1ADF             ;; P-SAVE
08262   1ADF 0B          L1ADF:   DEFB    $0B             ; Class-0B - Offset address converted to tape
08263   1AE0                                             ; command.
08264   1AE0             
08265   1AE0             ;; P-LOAD
08266   1AE0 0B          L1AE0:   DEFB    $0B             ; Class-0B - Offset address converted to tape
08267   1AE1                                             ; command.
08268   1AE1             
08269   1AE1             ;; P-VERIFY
08270   1AE1 0B          L1AE1:   DEFB    $0B             ; Class-0B - Offset address converted to tape
08271   1AE2                                             ; command.
08272   1AE2             
08273   1AE2             ;; P-MERGE
08274   1AE2 0B          L1AE2:   DEFB    $0B             ; Class-0B - Offset address converted to tape
08275   1AE3                                             ; command.
08276   1AE3             
08277   1AE3             ;; P-BEEP
08278   1AE3 08          L1AE3:   DEFB    $08             ; Class-08 - Two comma-separated numeric
08279   1AE4                                             ; expressions required.
08280   1AE4 00                  DEFB    $00             ; Class-00 - No further operands.
08281   1AE5 F8 03               DEFW    L03F8           ; Address: $03F8; Address: BEEP
08282   1AE7             
08283   1AE7             ;; P-CIRCLE
08284   1AE7 09          L1AE7:   DEFB    $09             ; Class-09 - Two comma-separated numeric
08285   1AE8                                             ; expressions required with optional colour
08286   1AE8                                             ; items.
08287   1AE8 05                  DEFB    $05             ; Class-05 - Variable syntax checked
08288   1AE9                                             ; by routine.
08289   1AE9 20 23               DEFW    L2320           ; Address: $2320; Address: CIRCLE
08290   1AEB             
08291   1AEB             ;; P-INK
08292   1AEB 07          L1AEB:   DEFB    $07             ; Class-07 - Offset address is converted to
08293   1AEC                                             ; colour code.
08294   1AEC             
08295   1AEC             ;; P-PAPER
08296   1AEC 07          L1AEC:   DEFB    $07             ; Class-07 - Offset address is converted to
08297   1AED                                             ; colour code.
08298   1AED             
08299   1AED             ;; P-FLASH
08300   1AED 07          L1AED:   DEFB    $07             ; Class-07 - Offset address is converted to
08301   1AEE                                             ; colour code.
08302   1AEE             
08303   1AEE             ;; P-BRIGHT
08304   1AEE 07          L1AEE:   DEFB    $07             ; Class-07 - Offset address is converted to
08305   1AEF                                             ; colour code.
08306   1AEF             
08307   1AEF             ;; P-INVERSE
08308   1AEF 07          L1AEF:   DEFB    $07             ; Class-07 - Offset address is converted to
08309   1AF0                                             ; colour code.
08310   1AF0             
08311   1AF0             ;; P-OVER
08312   1AF0 07          L1AF0:   DEFB    $07             ; Class-07 - Offset address is converted to
08313   1AF1                                             ; colour code.
08314   1AF1             
08315   1AF1             ;; P-OUT
08316   1AF1 08          L1AF1:   DEFB    $08             ; Class-08 - Two comma-separated numeric
08317   1AF2                                             ; expressions required.
08318   1AF2 00                  DEFB    $00             ; Class-00 - No further operands.
08319   1AF3 7A 1E               DEFW    L1E7A           ; Address: $1E7A; Address: OUT
08320   1AF5             
08321   1AF5             ;; P-BORDER
08322   1AF5 06          L1AF5:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08323   1AF6 00                  DEFB    $00             ; Class-00 - No further operands.
08324   1AF7 94 22               DEFW    L2294           ; Address: $2294; Address: BORDER
08325   1AF9             
08326   1AF9             ;; P-DEF-FN
08327   1AF9 05          L1AF9:   DEFB    $05             ; Class-05 - Variable syntax checked entirely
08328   1AFA                                             ; by routine.
08329   1AFA 60 1F               DEFW    L1F60           ; Address: $1F60; Address: DEF-FN
08330   1AFC             
08331   1AFC             ;; P-OPEN
08332   1AFC 06          L1AFC:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08333   1AFD 2C                  DEFB    $2C             ; Separator:  ','          see Footnote *
08334   1AFE 0A                  DEFB    $0A             ; Class-0A - A string expression must follow.
08335   1AFF 00                  DEFB    $00             ; Class-00 - No further operands.
08336   1B00 36 17               DEFW    L1736           ; Address: $1736; Address: OPEN
08337   1B02             
08338   1B02             ;; P-CLOSE
08339   1B02 06          L1B02:   DEFB    $06             ; Class-06 - A numeric expression must follow.
08340   1B03 00                  DEFB    $00             ; Class-00 - No further operands.
08341   1B04 E5 16               DEFW    L16E5           ; Address: $16E5; Address: CLOSE
08342   1B06             
08343   1B06             ;; P-FORMAT
08344   1B06 0A          L1B06:   DEFB    $0A             ; Class-0A - A string expression must follow.
08345   1B07 00                  DEFB    $00             ; Class-00 - No further operands.
08346   1B08 93 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
08347   1B0A             
08348   1B0A             ;; P-MOVE
08349   1B0A 0A          L1B0A:   DEFB    $0A             ; Class-0A - A string expression must follow.
08350   1B0B 2C                  DEFB    $2C             ; Separator:  ','
08351   1B0C 0A                  DEFB    $0A             ; Class-0A - A string expression must follow.
08352   1B0D 00                  DEFB    $00             ; Class-00 - No further operands.
08353   1B0E 93 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
08354   1B10             
08355   1B10             ;; P-ERASE
08356   1B10 0A          L1B10:   DEFB    $0A             ; Class-0A - A string expression must follow.
08357   1B11 00                  DEFB    $00             ; Class-00 - No further operands.
08358   1B12 93 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
08359   1B14             
08360   1B14             ;; P-CAT
08361   1B14 00          L1B14:   DEFB    $00             ; Class-00 - No further operands.
08362   1B15 93 17               DEFW    L1793           ; Address: $1793; Address: CAT-ETC
08363   1B17             
08364   1B17             ; * Note that a comma is required as a separator with the OPEN command
08365   1B17             ; but the Interface 1 programmers relaxed this allowing ';' as an
08366   1B17             ; alternative for their channels creating a confusing mixture of
08367   1B17             ; allowable syntax as it is this ROM which opens or re-opens the
08368   1B17             ; normal channels.
08369   1B17             
08370   1B17             ; -------------------------------
08371   1B17             ; Main parser (BASIC interpreter)
08372   1B17             ; -------------------------------
08373   1B17             ; This routine is called once from MAIN-2 when the BASIC line is to
08374   1B17             ; be entered or re-entered into the Program area and the syntax
08375   1B17             ; requires checking.
08376   1B17             
08377   1B17             ;; LINE-SCAN
08378   1B17 FD CB 01 BE L1B17:   RES     7,(IY+$01)      ; update FLAGS - signal checking syntax
08379   1B1B CD FB 19            CALL    L19FB           ; routine E-LINE-NO              >>
08380   1B1E                                             ; fetches the line number if in range.
08381   1B1E             
08382   1B1E AF                  XOR     A               ; clear the accumulator.
08383   1B1F 32 47 5C            LD      ($5C47),A       ; set statement number SUBPPC to zero.
08384   1B22 3D                  DEC     A               ; set accumulator to $FF.
08385   1B23 32 3A 5C            LD      ($5C3A),A       ; set ERR_NR to 'OK' - 1.
08386   1B26 18 01               JR      L1B29           ; forward to continue at STMT-L-1.
08387   1B28             
08388   1B28             ; --------------
08389   1B28             ; Statement loop
08390   1B28             ; --------------
08391   1B28             ;
08392   1B28             ;
08393   1B28             
08394   1B28             ;; STMT-LOOP
08395   1B28 E7          L1B28:   RST     20H             ; NEXT-CHAR
08396   1B29             
08397   1B29             ; -> the entry point from above or LINE-RUN
08398   1B29             ;; STMT-L-1
08399   1B29 CD BF 16    L1B29:   CALL    L16BF           ; routine SET-WORK clears workspace etc.
08400   1B2C             
08401   1B2C FD 34 0D            INC     (IY+$0D)        ; increment statement number SUBPPC
08402   1B2F FA 8A 1C            JP      M,L1C8A         ; to REPORT-C to raise
08403   1B32                                             ; 'Nonsense in BASIC' if over 127.
08404   1B32             
08405   1B32 DF                  RST     18H             ; GET-CHAR
08406   1B33             
08407   1B33 06 00               LD      B,$00           ; set B to zero for later indexing.
08408   1B35                                             ; early so any other reason ???
08409   1B35             
08410   1B35 FE 0D               CP      $0D             ; is character carriage return ?
08411   1B37                                             ; i.e. an empty statement.
08412   1B37 28 7A               JR      Z,L1BB3         ; forward to LINE-END if so.
08413   1B39             
08414   1B39 FE 3A               CP      $3A             ; is it statement end marker ':' ?
08415   1B3B                                             ; i.e. another type of empty statement.
08416   1B3B 28 EB               JR      Z,L1B28         ; back to STMT-LOOP if so.
08417   1B3D             
08418   1B3D 21 76 1B            LD      HL,L1B76        ; address: STMT-RET
08419   1B40 E5                  PUSH    HL              ; is now pushed as a return address
08420   1B41 4F                  LD      C,A             ; transfer the current character to C.
08421   1B42             
08422   1B42             ; advance CH_ADD to a position after command and test if it is a command.
08423   1B42             
08424   1B42 E7                  RST     20H             ; NEXT-CHAR to advance pointer
08425   1B43 79                  LD      A,C             ; restore current character
08426   1B44 D6 CE               SUB     $CE             ; subtract 'DEF FN' - first command
08427   1B46 DA 8A 1C            JP      C,L1C8A         ; jump to REPORT-C if less than a command
08428   1B49                                             ; raising 
08429   1B49                                             ; 'Nonsense in BASIC'
08430   1B49             
08431   1B49 4F                  LD      C,A             ; put the valid command code back in C.
08432   1B4A                                             ; register B is zero.
08433   1B4A 21 48 1A            LD      HL,L1A48        ; address: offst-tbl
08434   1B4D 09                  ADD     HL,BC           ; index into table with one of 50 commands.
08435   1B4E 4E                  LD      C,(HL)          ; pick up displacement to syntax table entry.
08436   1B4F 09                  ADD     HL,BC           ; add to address the relevant entry.
08437   1B50 18 03               JR      L1B55           ; forward to continue at GET-PARAM
08438   1B52             
08439   1B52             ; ----------------------
08440   1B52             ; The main scanning loop
08441   1B52             ; ----------------------
08442   1B52             ; not documented properly
08443   1B52             ;
08444   1B52             
08445   1B52             ;; SCAN-LOOP
08446   1B52 2A 74 5C    L1B52:   LD      HL,($5C74)      ; fetch temporary address from T_ADDR
08447   1B55                                             ; during subsequent loops.
08448   1B55             
08449   1B55             ; -> the initial entry point with HL addressing start of syntax table entry.
08450   1B55             
08451   1B55             ;; GET-PARAM
08452   1B55 7E          L1B55:   LD      A,(HL)          ; pick up the parameter.
08453   1B56 23                  INC     HL              ; address next one.
08454   1B57 22 74 5C            LD      ($5C74),HL      ; save pointer in system variable T_ADDR
08455   1B5A             
08456   1B5A 01 52 1B            LD      BC,L1B52        ; address: SCAN-LOOP
08457   1B5D C5                  PUSH    BC              ; is now pushed on stack as looping address.
08458   1B5E 4F                  LD      C,A             ; store parameter in C.
08459   1B5F FE 20               CP      $20             ; is it greater than ' '  ?
08460   1B61 30 0C               JR      NC,L1B6F        ; forward to SEPARATOR to check that correct
08461   1B63                                             ; separator appears in statement if so.
08462   1B63             
08463   1B63 21 01 1C            LD      HL,L1C01        ; address: class-tbl.
08464   1B66 06 00               LD      B,$00           ; prepare to index into the class table.
08465   1B68 09                  ADD     HL,BC           ; index to find displacement to routine.
08466   1B69 4E                  LD      C,(HL)          ; displacement to BC
08467   1B6A 09                  ADD     HL,BC           ; add to address the CLASS routine.
08468   1B6B E5                  PUSH    HL              ; push the address on the stack.
08469   1B6C             
08470   1B6C DF                  RST     18H             ; GET-CHAR - HL points to place in statement.
08471   1B6D             
08472   1B6D 05                  DEC     B               ; reset the zero flag - the initial state
08473   1B6E                                             ; for all class routines.
08474   1B6E             
08475   1B6E C9                  RET                     ; and make an indirect jump to routine
08476   1B6F                                             ; and then SCAN-LOOP (also on stack).
08477   1B6F             
08478   1B6F             ; Note. one of the class routines will eventually drop the return address
08479   1B6F             ; off the stack breaking out of the above seemingly endless loop.
08480   1B6F             
08481   1B6F             ; -----------------------
08482   1B6F             ; THE 'SEPARATOR' ROUTINE
08483   1B6F             ; -----------------------
08484   1B6F             ;   This routine is called once to verify that the mandatory separator
08485   1B6F             ;   present in the parameter table is also present in the correct
08486   1B6F             ;   location following the command.  For example, the 'THEN' token after
08487   1B6F             ;   the 'IF' token and expression.
08488   1B6F             
08489   1B6F             ;; SEPARATOR
08490   1B6F DF          L1B6F:   RST     18H             ; GET-CHAR
08491   1B70 B9                  CP      C               ; does it match the character in C ?
08492   1B71 C2 8A 1C            JP      NZ,L1C8A        ; jump forward to REPORT-C if not
08493   1B74                                             ; 'Nonsense in BASIC'.
08494   1B74             
08495   1B74 E7                  RST     20H             ; NEXT-CHAR advance to next character
08496   1B75 C9                  RET                     ; return.
08497   1B76             
08498   1B76             ; ------------------------------
08499   1B76             ; Come here after interpretation
08500   1B76             ; ------------------------------
08501   1B76             ;
08502   1B76             ;
08503   1B76             
08504   1B76             ;; STMT-RET
08505   1B76 CD 54 1F    L1B76:   CALL    L1F54           ; routine BREAK-KEY is tested after every
08506   1B79                                             ; statement.
08507   1B79 38 02               JR      C,L1B7D         ; step forward to STMT-R-1 if not pressed.
08508   1B7B             
08509   1B7B             ;; REPORT-L
08510   1B7B CF          L1B7B:   RST     08H             ; ERROR-1
08511   1B7C 14                  DEFB    $14             ; Error Report: BREAK into program
08512   1B7D             
08513   1B7D             ;; STMT-R-1
08514   1B7D FD CB 0A 7E L1B7D:   BIT     7,(IY+$0A)      ; test NSPPC - will be set if $FF -
08515   1B81                                             ; no jump to be made.
08516   1B81 20 71               JR      NZ,L1BF4        ; forward to STMT-NEXT if a program line.
08517   1B83             
08518   1B83 2A 42 5C            LD      HL,($5C42)      ; fetch line number from NEWPPC
08519   1B86 CB 7C               BIT     7,H             ; will be set if minus two - direct command(s)
08520   1B88 28 14               JR      Z,L1B9E         ; forward to LINE-NEW if a jump is to be
08521   1B8A                                             ; made to a new program line/statement.
08522   1B8A             
08523   1B8A             ; --------------------
08524   1B8A             ; Run a direct command
08525   1B8A             ; --------------------
08526   1B8A             ; A direct command is to be run or, if continuing from above,
08527   1B8A             ; the next statement of a direct command is to be considered.
08528   1B8A             
08529   1B8A             ;; LINE-RUN
08530   1B8A 21 FE FF    L1B8A:   LD      HL,$FFFE        ; The dummy value minus two
08531   1B8D 22 45 5C            LD      ($5C45),HL      ; is set/reset as line number in PPC.
08532   1B90 2A 61 5C            LD      HL,($5C61)      ; point to end of line + 1 - WORKSP.
08533   1B93 2B                  DEC     HL              ; now point to $80 end-marker.
08534   1B94 ED 5B 59 5C         LD      DE,($5C59)      ; address the start of line E_LINE.
08535   1B98 1B                  DEC     DE              ; now location before - for GET-CHAR.
08536   1B99 3A 44 5C            LD      A,($5C44)       ; load statement to A from NSPPC.
08537   1B9C 18 33               JR      L1BD1           ; forward to NEXT-LINE.
08538   1B9E             
08539   1B9E             ; ------------------------------
08540   1B9E             ; Find start address of new line
08541   1B9E             ; ------------------------------
08542   1B9E             ; The branch was to here if a jump is to made to a new line number
08543   1B9E             ; and statement.
08544   1B9E             ; That is the previous statement was a GO TO, GO SUB, RUN, RETURN, NEXT etc..
08545   1B9E             
08546   1B9E             ;; LINE-NEW
08547   1B9E CD 6E 19    L1B9E:   CALL    L196E           ; routine LINE-ADDR gets address of line
08548   1BA1                                             ; returning zero flag set if line found.
08549   1BA1 3A 44 5C            LD      A,($5C44)       ; fetch new statement from NSPPC
08550   1BA4 28 19               JR      Z,L1BBF         ; forward to LINE-USE if line matched.
08551   1BA6             
08552   1BA6             ; continue as must be a direct command.
08553   1BA6             
08554   1BA6 A7                  AND     A               ; test statement which should be zero
08555   1BA7 20 43               JR      NZ,L1BEC        ; forward to REPORT-N if not.
08556   1BA9                                             ; 'Statement lost'
08557   1BA9             
08558   1BA9             ; 
08559   1BA9             
08560   1BA9 47                  LD      B,A             ; save statement in B.??
08561   1BAA 7E                  LD      A,(HL)          ; fetch high byte of line number.
08562   1BAB E6 C0               AND     $C0             ; test if using direct command
08563   1BAD                                             ; a program line is less than $3F
08564   1BAD 78                  LD      A,B             ; retrieve statement.
08565   1BAE                                             ; (we can assume it is zero).
08566   1BAE 28 0F               JR      Z,L1BBF         ; forward to LINE-USE if was a program line
08567   1BB0             
08568   1BB0             ; Alternatively a direct statement has finished correctly.
08569   1BB0             
08570   1BB0             ;; REPORT-0
08571   1BB0 CF          L1BB0:   RST     08H             ; ERROR-1
08572   1BB1 FF                  DEFB    $FF             ; Error Report: OK
08573   1BB2             
08574   1BB2             ; -----------------
08575   1BB2             ; THE 'REM' COMMAND
08576   1BB2             ; -----------------
08577   1BB2             ; The REM command routine.
08578   1BB2             ; The return address STMT-RET is dropped and the rest of line ignored.
08579   1BB2             
08580   1BB2             ;; REM
08581   1BB2 C1          L1BB2:   POP     BC              ; drop return address STMT-RET and
08582   1BB3                                             ; continue ignoring rest of line.
08583   1BB3             
08584   1BB3             ; ------------
08585   1BB3             ; End of line?
08586   1BB3             ; ------------
08587   1BB3             ;
08588   1BB3             ;
08589   1BB3             
08590   1BB3             ;; LINE-END
08591   1BB3 CD 30 25    L1BB3:   CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
08592   1BB6 C8                  RET     Z               ; return if checking syntax.
08593   1BB7             
08594   1BB7 2A 55 5C            LD      HL,($5C55)      ; fetch NXTLIN to HL.
08595   1BBA 3E C0               LD      A,$C0           ; test against the
08596   1BBC A6                  AND     (HL)            ; system limit $3F.
08597   1BBD C0                  RET     NZ              ; return if more as must be
08598   1BBE                                             ; end of program.
08599   1BBE                                             ; (or direct command)
08600   1BBE             
08601   1BBE AF                  XOR     A               ; set statement to zero.
08602   1BBF             
08603   1BBF             ; and continue to set up the next following line and then consider this new one.
08604   1BBF             
08605   1BBF             ; ---------------------
08606   1BBF             ; General line checking
08607   1BBF             ; ---------------------
08608   1BBF             ; The branch was here from LINE-NEW if BASIC is branching.
08609   1BBF             ; or a continuation from above if dealing with a new sequential line.
08610   1BBF             ; First make statement zero number one leaving others unaffected.
08611   1BBF             
08612   1BBF             ;; LINE-USE
08613   1BBF FE 01       L1BBF:   CP      $01             ; will set carry if zero.
08614   1BC1 CE 00               ADC     A,$00           ; add in any carry.
08615   1BC3             
08616   1BC3 56                  LD      D,(HL)          ; high byte of line number to D.
08617   1BC4 23                  INC     HL              ; advance pointer.
08618   1BC5 5E                  LD      E,(HL)          ; low byte of line number to E.
08619   1BC6 ED 53 45 5C         LD      ($5C45),DE      ; set system variable PPC.
08620   1BCA             
08621   1BCA 23                  INC     HL              ; advance pointer.
08622   1BCB 5E                  LD      E,(HL)          ; low byte of line length to E.
08623   1BCC 23                  INC     HL              ; advance pointer.
08624   1BCD 56                  LD      D,(HL)          ; high byte of line length to D.
08625   1BCE             
08626   1BCE EB                  EX      DE,HL           ; swap pointer to DE before
08627   1BCF 19                  ADD     HL,DE           ; adding to address the end of line.
08628   1BD0 23                  INC     HL              ; advance to start of next line.
08629   1BD1             
08630   1BD1             ; -----------------------------
08631   1BD1             ; Update NEXT LINE but consider
08632   1BD1             ; previous line or edit line.
08633   1BD1             ; -----------------------------
08634   1BD1             ; The pointer will be the next line if continuing from above or to
08635   1BD1             ; edit line end-marker ($80) if from LINE-RUN.
08636   1BD1             
08637   1BD1             ;; NEXT-LINE
08638   1BD1 22 55 5C    L1BD1:   LD      ($5C55),HL      ; store pointer in system variable NXTLIN
08639   1BD4             
08640   1BD4 EB                  EX      DE,HL           ; bring back pointer to previous or edit line
08641   1BD5 22 5D 5C            LD      ($5C5D),HL      ; and update CH_ADD with character address.
08642   1BD8             
08643   1BD8 57                  LD      D,A             ; store statement in D.
08644   1BD9 1E 00               LD      E,$00           ; set E to zero to suppress token searching
08645   1BDB                                             ; if EACH-STMT is to be called.
08646   1BDB FD 36 0A FF         LD      (IY+$0A),$FF    ; set statement NSPPC to $FF signalling
08647   1BDF                                             ; no jump to be made.
08648   1BDF 15                  DEC     D               ; decrement and test statement
08649   1BE0 FD 72 0D            LD      (IY+$0D),D      ; set SUBPPC to decremented statement number.
08650   1BE3 CA 28 1B            JP      Z,L1B28         ; to STMT-LOOP if result zero as statement is
08651   1BE6                                             ; at start of line and address is known.
08652   1BE6             
08653   1BE6 14                  INC     D               ; else restore statement.
08654   1BE7 CD 8B 19            CALL    L198B           ; routine EACH-STMT finds the D'th statement
08655   1BEA                                             ; address as E does not contain a token.
08656   1BEA 28 08               JR      Z,L1BF4         ; forward to STMT-NEXT if address found.
08657   1BEC             
08658   1BEC             ;; REPORT-N
08659   1BEC CF          L1BEC:   RST     08H             ; ERROR-1
08660   1BED 16                  DEFB    $16             ; Error Report: Statement lost
08661   1BEE             
08662   1BEE             ; -----------------
08663   1BEE             ; End of statement?
08664   1BEE             ; -----------------
08665   1BEE             ; This combination of routines is called from 20 places when
08666   1BEE             ; the end of a statement should have been reached and all preceding
08667   1BEE             ; syntax is in order.
08668   1BEE             
08669   1BEE             ;; CHECK-END
08670   1BEE CD 30 25    L1BEE:   CALL    L2530           ; routine SYNTAX-Z
08671   1BF1 C0                  RET     NZ              ; return immediately in runtime
08672   1BF2             
08673   1BF2 C1                  POP     BC              ; drop address of calling routine.
08674   1BF3 C1                  POP     BC              ; drop address STMT-RET.
08675   1BF4                                             ; and continue to find next statement.
08676   1BF4             
08677   1BF4             ; --------------------
08678   1BF4             ; Go to next statement
08679   1BF4             ; --------------------
08680   1BF4             ; Acceptable characters at this point are carriage return and ':'.
08681   1BF4             ; If so go to next statement which in the first case will be on next line.
08682   1BF4             
08683   1BF4             ;; STMT-NEXT
08684   1BF4 DF          L1BF4:   RST     18H             ; GET-CHAR - ignoring white space etc.
08685   1BF5             
08686   1BF5 FE 0D               CP      $0D             ; is it carriage return ?
08687   1BF7 28 BA               JR      Z,L1BB3         ; back to LINE-END if so.
08688   1BF9             
08689   1BF9 FE 3A               CP      $3A             ; is it ':' ?
08690   1BFB CA 28 1B            JP      Z,L1B28         ; jump back to STMT-LOOP to consider
08691   1BFE                                             ; further statements
08692   1BFE             
08693   1BFE C3 8A 1C            JP      L1C8A           ; jump to REPORT-C with any other character
08694   1C01                                             ; 'Nonsense in BASIC'.
08695   1C01             
08696   1C01             ; Note. the two-byte sequence 'rst 08; defb $0b' could replace the above jp.
08697   1C01             
08698   1C01             ; -------------------
08699   1C01             ; Command class table
08700   1C01             ; -------------------
08701   1C01             ;
08702   1C01             
08703   1C01             ;; class-tbl
08704   1C01 0F          L1C01:   DEFB    L1C10 - $       ; 0F offset to Address: CLASS-00
08705   1C02 1D                  DEFB    L1C1F - $       ; 1D offset to Address: CLASS-01
08706   1C03 4B                  DEFB    L1C4E - $       ; 4B offset to Address: CLASS-02
08707   1C04 09                  DEFB    L1C0D - $       ; 09 offset to Address: CLASS-03
08708   1C05 67                  DEFB    L1C6C - $       ; 67 offset to Address: CLASS-04
08709   1C06 0B                  DEFB    L1C11 - $       ; 0B offset to Address: CLASS-05
08710   1C07 7B                  DEFB    L1C82 - $       ; 7B offset to Address: CLASS-06
08711   1C08 8E                  DEFB    L1C96 - $       ; 8E offset to Address: CLASS-07
08712   1C09 71                  DEFB    L1C7A - $       ; 71 offset to Address: CLASS-08
08713   1C0A B4                  DEFB    L1CBE - $       ; B4 offset to Address: CLASS-09
08714   1C0B 81                  DEFB    L1C8C - $       ; 81 offset to Address: CLASS-0A
08715   1C0C CF                  DEFB    L1CDB - $       ; CF offset to Address: CLASS-0B
08716   1C0D             
08717   1C0D             
08718   1C0D             ; --------------------------------
08719   1C0D             ; Command classes---00, 03, and 05
08720   1C0D             ; --------------------------------
08721   1C0D             ; class-03 e.g. RUN or RUN 200   ;  optional operand
08722   1C0D             ; class-00 e.g. CONTINUE         ;  no operand
08723   1C0D             ; class-05 e.g. PRINT            ;  variable syntax checked by routine
08724   1C0D             
08725   1C0D             ;; CLASS-03
08726   1C0D CD DE 1C    L1C0D:   CALL    L1CDE           ; routine FETCH-NUM
08727   1C10             
08728   1C10             ;; CLASS-00
08729   1C10             
08730   1C10 BF          L1C10:   CP      A               ; reset zero flag.
08731   1C11             
08732   1C11             ; if entering here then all class routines are entered with zero reset.
08733   1C11             
08734   1C11             ;; CLASS-05
08735   1C11 C1          L1C11:   POP     BC              ; drop address SCAN-LOOP.
08736   1C12 CC EE 1B            CALL    Z,L1BEE         ; if zero set then call routine CHECK-END >>>
08737   1C15                                             ; as should be no further characters.
08738   1C15             
08739   1C15 EB                  EX      DE,HL           ; save HL to DE.
08740   1C16 2A 74 5C            LD      HL,($5C74)      ; fetch T_ADDR
08741   1C19 4E                  LD      C,(HL)          ; fetch low byte of routine
08742   1C1A 23                  INC     HL              ; address next.
08743   1C1B 46                  LD      B,(HL)          ; fetch high byte of routine.
08744   1C1C EB                  EX      DE,HL           ; restore HL from DE
08745   1C1D C5                  PUSH    BC              ; push the address
08746   1C1E C9                  RET                     ; and make an indirect jump to the command.
08747   1C1F             
08748   1C1F             ; --------------------------------
08749   1C1F             ; Command classes---01, 02, and 04
08750   1C1F             ; --------------------------------
08751   1C1F             ; class-01  e.g. LET A = 2*3     ; a variable is reqd
08752   1C1F             
08753   1C1F             ; This class routine is also called from INPUT and READ to find the
08754   1C1F             ; destination variable for an assignment.
08755   1C1F             
08756   1C1F             ;; CLASS-01
08757   1C1F CD B2 28    L1C1F:   CALL    L28B2           ; routine LOOK-VARS returns carry set if not
08758   1C22                                             ; found in runtime.
08759   1C22             
08760   1C22             ; ----------------------
08761   1C22             ; Variable in assignment
08762   1C22             ; ----------------------
08763   1C22             ;
08764   1C22             ;
08765   1C22             
08766   1C22             ;; VAR-A-1
08767   1C22 FD 36 37 00 L1C22:   LD      (IY+$37),$00    ; set FLAGX to zero
08768   1C26 30 08               JR      NC,L1C30        ; forward to VAR-A-2 if found or checking
08769   1C28                                             ; syntax.
08770   1C28             
08771   1C28 FD CB 37 CE         SET     1,(IY+$37)      ; FLAGX  - Signal a new variable
08772   1C2C 20 18               JR      NZ,L1C46        ; to VAR-A-3 if not assigning to an array
08773   1C2E                                             ; e.g. LET a$(3,3) = "X"
08774   1C2E             
08775   1C2E             ;; REPORT-2
08776   1C2E CF          L1C2E:   RST     08H             ; ERROR-1
08777   1C2F 01                  DEFB    $01             ; Error Report: Variable not found
08778   1C30             
08779   1C30             ;; VAR-A-2
08780   1C30 CC 96 29    L1C30:   CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
08781   1C33 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
08782   1C37 20 0D               JR      NZ,L1C46        ; to VAR-A-3 if numeric
08783   1C39             
08784   1C39 AF                  XOR     A               ; default to array/slice - to be retained.
08785   1C3A CD 30 25            CALL    L2530           ; routine SYNTAX-Z
08786   1C3D C4 F1 2B            CALL    NZ,L2BF1        ; routine STK-FETCH is called in runtime
08787   1C40                                             ; may overwrite A with 1.
08788   1C40 21 71 5C            LD      HL,$5C71        ; address system variable FLAGX
08789   1C43 B6                  OR      (HL)            ; set bit 0 if simple variable to be reclaimed
08790   1C44 77                  LD      (HL),A          ; update FLAGX
08791   1C45 EB                  EX      DE,HL           ; start of string/subscript to DE
08792   1C46             
08793   1C46             ;; VAR-A-3
08794   1C46 ED 43 72 5C L1C46:   LD      ($5C72),BC      ; update STRLEN
08795   1C4A 22 4D 5C            LD      ($5C4D),HL      ; and DEST of assigned string.
08796   1C4D C9                  RET                     ; return.
08797   1C4E             
08798   1C4E             ; -------------------------------------------------
08799   1C4E             ; class-02 e.g. LET a = 1 + 1   ; an expression must follow
08800   1C4E             
08801   1C4E             ;; CLASS-02
08802   1C4E C1          L1C4E:   POP     BC              ; drop return address SCAN-LOOP
08803   1C4F CD 56 1C            CALL    L1C56           ; routine VAL-FET-1 is called to check
08804   1C52                                             ; expression and assign result in runtime
08805   1C52 CD EE 1B            CALL    L1BEE           ; routine CHECK-END checks nothing else
08806   1C55                                             ; is present in statement.
08807   1C55 C9                  RET                     ; Return
08808   1C56             
08809   1C56             ; -------------
08810   1C56             ; Fetch a value
08811   1C56             ; -------------
08812   1C56             ;
08813   1C56             ;
08814   1C56             
08815   1C56             ;; VAL-FET-1
08816   1C56 3A 3B 5C    L1C56:   LD      A,($5C3B)       ; initial FLAGS to A
08817   1C59             
08818   1C59             ;; VAL-FET-2
08819   1C59 F5          L1C59:   PUSH    AF              ; save A briefly
08820   1C5A CD FB 24            CALL    L24FB           ; routine SCANNING evaluates expression.
08821   1C5D F1                  POP     AF              ; restore A
08822   1C5E FD 56 01            LD      D,(IY+$01)      ; post-SCANNING FLAGS to D
08823   1C61 AA                  XOR     D               ; xor the two sets of flags
08824   1C62 E6 40               AND     $40             ; pick up bit 6 of xored FLAGS should be zero
08825   1C64 20 24               JR      NZ,L1C8A        ; forward to REPORT-C if not zero
08826   1C66                                             ; 'Nonsense in BASIC' - results don't agree.
08827   1C66             
08828   1C66 CB 7A               BIT     7,D             ; test FLAGS - is syntax being checked ?
08829   1C68 C2 FF 2A            JP      NZ,L2AFF        ; jump forward to LET to make the assignment
08830   1C6B                                             ; in runtime.
08831   1C6B             
08832   1C6B C9                  RET                     ; but return from here if checking syntax.
08833   1C6C             
08834   1C6C             ; ------------------
08835   1C6C             ; Command class---04
08836   1C6C             ; ------------------
08837   1C6C             ; class-04 e.g. FOR i            ; a single character variable must follow
08838   1C6C             
08839   1C6C             ;; CLASS-04
08840   1C6C CD B2 28    L1C6C:   CALL    L28B2           ; routine LOOK-VARS
08841   1C6F F5                  PUSH    AF              ; preserve flags.
08842   1C70 79                  LD      A,C             ; fetch type - should be 011xxxxx
08843   1C71 F6 9F               OR      $9F             ; combine with 10011111.
08844   1C73 3C                  INC     A               ; test if now $FF by incrementing.
08845   1C74 20 14               JR      NZ,L1C8A        ; forward to REPORT-C if result not zero.
08846   1C76             
08847   1C76 F1                  POP     AF              ; else restore flags.
08848   1C77 18 A9               JR      L1C22           ; back to VAR-A-1
08849   1C79             
08850   1C79             
08851   1C79             ; --------------------------------
08852   1C79             ; Expect numeric/string expression
08853   1C79             ; --------------------------------
08854   1C79             ; This routine is used to get the two coordinates of STRING$, ATTR and POINT.
08855   1C79             ; It is also called from PRINT-ITEM to get the two numeric expressions that
08856   1C79             ; follow the AT ( in PRINT AT, INPUT AT).
08857   1C79             
08858   1C79             ;; NEXT-2NUM
08859   1C79 E7          L1C79:   RST     20H             ; NEXT-CHAR advance past 'AT' or '('.
08860   1C7A             
08861   1C7A             ; --------
08862   1C7A             ; class-08 e.g. POKE 65535,2     ; two numeric expressions separated by comma
08863   1C7A             ;; CLASS-08
08864   1C7A             ;; EXPT-2NUM
08865   1C7A CD 82 1C    L1C7A:   CALL    L1C82           ; routine EXPT-1NUM is called for first
08866   1C7D                                             ; numeric expression
08867   1C7D FE 2C               CP      $2C             ; is character ',' ?
08868   1C7F 20 09               JR      NZ,L1C8A        ; to REPORT-C if not required separator.
08869   1C81                                             ; 'Nonsense in BASIC'.
08870   1C81             
08871   1C81 E7                  RST     20H             ; NEXT-CHAR
08872   1C82             
08873   1C82             ; ->
08874   1C82             ;  class-06  e.g. GOTO a*1000   ; a numeric expression must follow
08875   1C82             ;; CLASS-06
08876   1C82             ;; EXPT-1NUM
08877   1C82 CD FB 24    L1C82:   CALL    L24FB           ; routine SCANNING
08878   1C85 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
08879   1C89 C0                  RET     NZ              ; return if result is numeric.
08880   1C8A             
08881   1C8A             ;; REPORT-C
08882   1C8A CF          L1C8A:   RST     08H             ; ERROR-1
08883   1C8B 0B                  DEFB    $0B             ; Error Report: Nonsense in BASIC
08884   1C8C             
08885   1C8C             ; ---------------------------------------------------------------
08886   1C8C             ; class-0A e.g. ERASE "????"    ; a string expression must follow.
08887   1C8C             ;                               ; these only occur in unimplemented commands
08888   1C8C             ;                               ; although the routine expt-exp is called
08889   1C8C             ;                               ; from SAVE-ETC
08890   1C8C             
08891   1C8C             ;; CLASS-0A
08892   1C8C             ;; EXPT-EXP
08893   1C8C CD FB 24    L1C8C:   CALL    L24FB           ; routine SCANNING
08894   1C8F FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
08895   1C93 C8                  RET     Z               ; return if string result.
08896   1C94             
08897   1C94 18 F4               JR      L1C8A           ; back to REPORT-C if numeric.
08898   1C96             
08899   1C96             ; ---------------------
08900   1C96             ; Set permanent colours
08901   1C96             ; class 07
08902   1C96             ; ---------------------
08903   1C96             ; class-07 e.g. PAPER 6          ; a single class for a collection of
08904   1C96             ;                               ; similar commands. Clever.
08905   1C96             ;
08906   1C96             ; Note. these commands should ensure that current channel is 'S'
08907   1C96             
08908   1C96             ;; CLASS-07
08909   1C96 FD CB 01 7E L1C96:   BIT     7,(IY+$01)      ; test FLAGS - checking syntax only ?
08910   1C9A                                             ; Note. there is a subroutine to do this.
08911   1C9A FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
08912   1C9E C4 4D 0D            CALL    NZ,L0D4D        ; routine TEMPS is called in runtime.
08913   1CA1 F1                  POP     AF              ; drop return address SCAN-LOOP
08914   1CA2 3A 74 5C            LD      A,($5C74)       ; T_ADDR_lo to accumulator.
08915   1CA5                                             ; points to '$07' entry + 1
08916   1CA5                                             ; e.g. for INK points to $EC now
08917   1CA5             
08918   1CA5             ; Note if you move alter the syntax table next line may have to be altered.
08919   1CA5             
08920   1CA5             ; Note. For ZASM assembler replace following expression with SUB $13.
08921   1CA5             
08922   1CA5 D6 13       L1CA5:   SUB     LOW (L1AEB-$D8) ; convert $EB to $D8 ('INK') etc.
08923   1CA7                                             ; ( is SUB $13 in standard ROM )
08924   1CA7             
08925   1CA7 CD FC 21            CALL    L21FC           ; routine CO-TEMP-4
08926   1CAA CD EE 1B            CALL    L1BEE           ; routine CHECK-END check that nothing else
08927   1CAD                                             ; in statement.
08928   1CAD             
08929   1CAD             ; return here in runtime.
08930   1CAD             
08931   1CAD 2A 8F 5C            LD      HL,($5C8F)      ; pick up ATTR_T and MASK_T
08932   1CB0 22 8D 5C            LD      ($5C8D),HL      ; and store in ATTR_P and MASK_P
08933   1CB3 21 91 5C            LD      HL,$5C91        ; point to P_FLAG.
08934   1CB6 7E                  LD      A,(HL)          ; pick up in A
08935   1CB7 07                  RLCA                    ; rotate to left
08936   1CB8 AE                  XOR     (HL)            ; combine with HL
08937   1CB9 E6 AA               AND     $AA             ; 10101010
08938   1CBB AE                  XOR     (HL)            ; only permanent bits affected
08939   1CBC 77                  LD      (HL),A          ; reload into P_FLAG.
08940   1CBD C9                  RET                     ; return.
08941   1CBE             
08942   1CBE             ; ------------------
08943   1CBE             ; Command class---09
08944   1CBE             ; ------------------
08945   1CBE             ; e.g. PLOT PAPER 0; 128,88     ; two coordinates preceded by optional
08946   1CBE             ;                               ; embedded colour items.
08947   1CBE             ;
08948   1CBE             ; Note. this command should ensure that current channel is actually 'S'.
08949   1CBE             
08950   1CBE             ;; CLASS-09
08951   1CBE CD 30 25    L1CBE:   CALL    L2530           ; routine SYNTAX-Z
08952   1CC1 28 13               JR      Z,L1CD6         ; forward to CL-09-1 if checking syntax.
08953   1CC3             
08954   1CC3 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
08955   1CC7 CD 4D 0D            CALL    L0D4D           ; routine TEMPS is called.
08956   1CCA 21 90 5C            LD      HL,$5C90        ; point to MASK_T
08957   1CCD 7E                  LD      A,(HL)          ; fetch mask to accumulator.
08958   1CCE F6 F8               OR      $F8             ; or with 11111000 paper/bright/flash 8
08959   1CD0 77                  LD      (HL),A          ; mask back to MASK_T system variable.
08960   1CD1 FD CB 57 B6         RES     6,(IY+$57)      ; reset P_FLAG  - signal NOT PAPER 9 ?
08961   1CD5             
08962   1CD5 DF                  RST     18H             ; GET-CHAR
08963   1CD6             
08964   1CD6             ;; CL-09-1
08965   1CD6 CD E2 21    L1CD6:   CALL    L21E2           ; routine CO-TEMP-2 deals with any embedded
08966   1CD9                                             ; colour items.
08967   1CD9 18 9F               JR      L1C7A           ; exit via EXPT-2NUM to check for x,y.
08968   1CDB             
08969   1CDB             ; Note. if either of the numeric expressions contain STR$ then the flag setting 
08970   1CDB             ; above will be undone when the channel flags are reset during STR$.
08971   1CDB             ; e.g. 
08972   1CDB             ; 10 BORDER 3 : PLOT VAL STR$ 128, VAL STR$ 100
08973   1CDB             ; credit John Elliott.
08974   1CDB             
08975   1CDB             ; ------------------
08976   1CDB             ; Command class---0B
08977   1CDB             ; ------------------
08978   1CDB             ; Again a single class for four commands.
08979   1CDB             ; This command just jumps back to SAVE-ETC to handle the four tape commands.
08980   1CDB             ; The routine itself works out which command has called it by examining the
08981   1CDB             ; address in T_ADDR_lo. Note therefore that the syntax table has to be
08982   1CDB             ; located where these and other sequential command addresses are not split
08983   1CDB             ; over a page boundary.
08984   1CDB             
08985   1CDB             ;; CLASS-0B
08986   1CDB C3 05 06    L1CDB:   JP      L0605           ; jump way back to SAVE-ETC
08987   1CDE             
08988   1CDE             ; --------------
08989   1CDE             ; Fetch a number
08990   1CDE             ; --------------
08991   1CDE             ; This routine is called from CLASS-03 when a command may be followed by
08992   1CDE             ; an optional numeric expression e.g. RUN. If the end of statement has
08993   1CDE             ; been reached then zero is used as the default.
08994   1CDE             ; Also called from LIST-4.
08995   1CDE             
08996   1CDE             ;; FETCH-NUM
08997   1CDE FE 0D       L1CDE:   CP      $0D             ; is character a carriage return ?
08998   1CE0 28 04               JR      Z,L1CE6         ; forward to USE-ZERO if so
08999   1CE2             
09000   1CE2 FE 3A               CP      $3A             ; is it ':' ?
09001   1CE4 20 9C               JR      NZ,L1C82        ; forward to EXPT-1NUM if not.
09002   1CE6                                             ; else continue and use zero.
09003   1CE6             
09004   1CE6             ; ----------------
09005   1CE6             ; Use zero routine
09006   1CE6             ; ----------------
09007   1CE6             ; This routine is called four times to place the value zero on the
09008   1CE6             ; calculator stack as a default value in runtime.
09009   1CE6             
09010   1CE6             ;; USE-ZERO
09011   1CE6 CD 30 25    L1CE6:   CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
09012   1CE9 C8                  RET     Z               ;
09013   1CEA             
09014   1CEA EF                  RST     28H             ;; FP-CALC
09015   1CEB A0                  DEFB    $A0             ;;stk-zero       ;0.
09016   1CEC 38                  DEFB    $38             ;;end-calc
09017   1CED             
09018   1CED C9                  RET                     ; return.
09019   1CEE             
09020   1CEE             ; -------------------
09021   1CEE             ; Handle STOP command
09022   1CEE             ; -------------------
09023   1CEE             ; Command Syntax: STOP
09024   1CEE             ; One of the shortest and least used commands. As with 'OK' not an error.
09025   1CEE             
09026   1CEE             ;; REPORT-9
09027   1CEE             ;; STOP
09028   1CEE CF          L1CEE:   RST     08H             ; ERROR-1
09029   1CEF 08                  DEFB    $08             ; Error Report: STOP statement
09030   1CF0             
09031   1CF0             ; -----------------
09032   1CF0             ; Handle IF command
09033   1CF0             ; -----------------
09034   1CF0             ; e.g. IF score>100 THEN PRINT "You Win"
09035   1CF0             ; The parser has already checked the expression the result of which is on
09036   1CF0             ; the calculator stack. The presence of the 'THEN' separator has also been
09037   1CF0             ; checked and CH-ADD points to the command after THEN.
09038   1CF0             ;
09039   1CF0             
09040   1CF0             ;; IF
09041   1CF0 C1          L1CF0:   POP     BC              ; drop return address - STMT-RET
09042   1CF1 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
09043   1CF4 28 0A               JR      Z,L1D00         ; forward to IF-1 if checking syntax
09044   1CF6                                             ; to check syntax of PRINT "You Win"
09045   1CF6             
09046   1CF6             
09047   1CF6 EF                  RST     28H             ;; FP-CALC    score>100 (1=TRUE 0=FALSE)
09048   1CF7 02                  DEFB    $02             ;;delete      .
09049   1CF8 38                  DEFB    $38             ;;end-calc
09050   1CF9             
09051   1CF9 EB                  EX      DE,HL           ; make HL point to deleted value
09052   1CFA CD E9 34            CALL    L34E9           ; routine TEST-ZERO
09053   1CFD DA B3 1B            JP      C,L1BB3         ; jump to LINE-END if FALSE (0)
09054   1D00             
09055   1D00             ;; IF-1
09056   1D00 C3 29 1B    L1D00:   JP      L1B29           ; to STMT-L-1, if true (1) to execute command
09057   1D03                                             ; after 'THEN' token.
09058   1D03             
09059   1D03             ; ------------------
09060   1D03             ; Handle FOR command
09061   1D03             ; ------------------
09062   1D03             ; e.g. FOR i = 0 TO 1 STEP 0.1
09063   1D03             ; Using the syntax tables, the parser has already checked for a start and
09064   1D03             ; limit value and also for the intervening separator.
09065   1D03             ; the two values v,l are on the calculator stack.
09066   1D03             ; CLASS-04 has also checked the variable and the name is in STRLEN_lo.
09067   1D03             ; The routine begins by checking for an optional STEP.
09068   1D03             
09069   1D03             ;; FOR
09070   1D03 FE CD       L1D03:   CP      $CD             ; is there a 'STEP' ?
09071   1D05 20 09               JR      NZ,L1D10        ; to F-USE-1 if not to use 1 as default.
09072   1D07             
09073   1D07 E7                  RST     20H             ; NEXT-CHAR
09074   1D08 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM
09075   1D0B CD EE 1B            CALL    L1BEE           ; routine CHECK-END
09076   1D0E 18 06               JR      L1D16           ; to F-REORDER
09077   1D10             
09078   1D10             ; ---
09079   1D10             
09080   1D10             ;; F-USE-1
09081   1D10 CD EE 1B    L1D10:   CALL    L1BEE           ; routine CHECK-END
09082   1D13             
09083   1D13 EF                  RST     28H             ;; FP-CALC      v,l.
09084   1D14 A1                  DEFB    $A1             ;;stk-one       v,l,1=s.
09085   1D15 38                  DEFB    $38             ;;end-calc
09086   1D16             
09087   1D16             
09088   1D16             ;; F-REORDER
09089   1D16 EF          L1D16:   RST     28H             ;; FP-CALC       v,l,s.
09090   1D17 C0                  DEFB    $C0             ;;st-mem-0       v,l,s.
09091   1D18 02                  DEFB    $02             ;;delete         v,l.
09092   1D19 01                  DEFB    $01             ;;exchange       l,v.
09093   1D1A E0                  DEFB    $E0             ;;get-mem-0      l,v,s.
09094   1D1B 01                  DEFB    $01             ;;exchange       l,s,v.
09095   1D1C 38                  DEFB    $38             ;;end-calc
09096   1D1D             
09097   1D1D CD FF 2A            CALL    L2AFF           ; routine LET assigns the initial value v to
09098   1D20                                             ; the variable altering type if necessary.
09099   1D20 22 68 5C            LD      ($5C68),HL      ; The system variable MEM is made to point to
09100   1D23                                             ; the variable instead of its normal
09101   1D23                                             ; location MEMBOT
09102   1D23 2B                  DEC     HL              ; point to single-character name
09103   1D24 7E                  LD      A,(HL)          ; fetch name
09104   1D25 CB FE               SET     7,(HL)          ; set bit 7 at location
09105   1D27 01 06 00            LD      BC,$0006        ; add six to HL
09106   1D2A 09                  ADD     HL,BC           ; to address where limit should be.
09107   1D2B 07                  RLCA                    ; test bit 7 of original name.
09108   1D2C 38 06               JR      C,L1D34         ; forward to F-L-S if already a FOR/NEXT
09109   1D2E                                             ; variable
09110   1D2E             
09111   1D2E 0E 0D               LD      C,$0D           ; otherwise an additional 13 bytes are needed.
09112   1D30                                             ; 5 for each value, two for line number and
09113   1D30                                             ; 1 byte for looping statement.
09114   1D30 CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates them.
09115   1D33 23                  INC     HL              ; make HL address limit.
09116   1D34             
09117   1D34             ;; F-L-S
09118   1D34 E5          L1D34:   PUSH    HL              ; save position.
09119   1D35             
09120   1D35 EF                  RST     28H             ;; FP-CALC         l,s.
09121   1D36 02                  DEFB    $02             ;;delete           l.
09122   1D37 02                  DEFB    $02             ;;delete           .
09123   1D38 38                  DEFB    $38             ;;end-calc
09124   1D39                                             ; DE points to STKEND, l.
09125   1D39             
09126   1D39 E1                  POP     HL              ; restore variable position
09127   1D3A EB                  EX      DE,HL           ; swap pointers
09128   1D3B 0E 0A               LD      C,$0A           ; ten bytes to move
09129   1D3D ED B0               LDIR                    ; Copy 'deleted' values to variable.
09130   1D3F 2A 45 5C            LD      HL,($5C45)      ; Load with current line number from PPC
09131   1D42 EB                  EX      DE,HL           ; exchange pointers.
09132   1D43 73                  LD      (HL),E          ; save the looping line
09133   1D44 23                  INC     HL              ; in the next
09134   1D45 72                  LD      (HL),D          ; two locations.
09135   1D46 FD 56 0D            LD      D,(IY+$0D)      ; fetch statement from SUBPPC system variable.
09136   1D49 14                  INC     D               ; increment statement.
09137   1D4A 23                  INC     HL              ; and pointer
09138   1D4B 72                  LD      (HL),D          ; and store the looping statement.
09139   1D4C                                             ;
09140   1D4C CD DA 1D            CALL    L1DDA           ; routine NEXT-LOOP considers an initial
09141   1D4F D0                  RET     NC              ; iteration. Return to STMT-RET if a loop is
09142   1D50                                             ; possible to execute next statement.
09143   1D50             
09144   1D50             ; no loop is possible so execution continues after the matching 'NEXT'
09145   1D50             
09146   1D50 FD 46 38            LD      B,(IY+$38)      ; get single-character name from STRLEN_lo
09147   1D53 2A 45 5C            LD      HL,($5C45)      ; get the current line from PPC
09148   1D56 22 42 5C            LD      ($5C42),HL      ; and store it in NEWPPC
09149   1D59 3A 47 5C            LD      A,($5C47)       ; fetch current statement from SUBPPC
09150   1D5C ED 44               NEG                     ; Negate as counter decrements from zero
09151   1D5E                                             ; initially and we are in the middle of a
09152   1D5E                                             ; line.
09153   1D5E 57                  LD      D,A             ; Store result in D.
09154   1D5F 2A 5D 5C            LD      HL,($5C5D)      ; get current address from CH_ADD
09155   1D62 1E F3               LD      E,$F3           ; search will be for token 'NEXT'
09156   1D64             
09157   1D64             ;; F-LOOP
09158   1D64 C5          L1D64:   PUSH    BC              ; save variable name.
09159   1D65 ED 4B 55 5C         LD      BC,($5C55)      ; fetch NXTLIN
09160   1D69 CD 86 1D            CALL    L1D86           ; routine LOOK-PROG searches for 'NEXT' token.
09161   1D6C ED 43 55 5C         LD      ($5C55),BC      ; update NXTLIN
09162   1D70 C1                  POP     BC              ; and fetch the letter
09163   1D71 38 11               JR      C,L1D84         ; forward to REPORT-I if the end of program
09164   1D73                                             ; was reached by LOOK-PROG.
09165   1D73                                             ; 'FOR without NEXT'
09166   1D73             
09167   1D73 E7                  RST     20H             ; NEXT-CHAR fetches character after NEXT
09168   1D74 F6 20               OR      $20             ; ensure it is upper-case.
09169   1D76 B8                  CP      B               ; compare with FOR variable name
09170   1D77 28 03               JR      Z,L1D7C         ; forward to F-FOUND if it matches.
09171   1D79             
09172   1D79             ; but if no match i.e. nested FOR/NEXT loops then continue search.
09173   1D79             
09174   1D79 E7                  RST     20H             ; NEXT-CHAR
09175   1D7A 18 E8               JR      L1D64           ; back to F-LOOP
09176   1D7C             
09177   1D7C             ; ---
09178   1D7C             
09179   1D7C             
09180   1D7C             ;; F-FOUND
09181   1D7C E7          L1D7C:   RST     20H             ; NEXT-CHAR
09182   1D7D 3E 01               LD      A,$01           ; subtract the negated counter from 1
09183   1D7F 92                  SUB     D               ; to give the statement after the NEXT
09184   1D80 32 44 5C            LD      ($5C44),A       ; set system variable NSPPC
09185   1D83 C9                  RET                     ; return to STMT-RET to branch to new
09186   1D84                                             ; line and statement. ->
09187   1D84             ; ---
09188   1D84             
09189   1D84             ;; REPORT-I
09190   1D84 CF          L1D84:   RST     08H             ; ERROR-1
09191   1D85 11                  DEFB    $11             ; Error Report: FOR without NEXT
09192   1D86             
09193   1D86             ; ---------
09194   1D86             ; LOOK-PROG
09195   1D86             ; ---------
09196   1D86             ; Find DATA, DEF FN or NEXT.
09197   1D86             ; This routine searches the program area for one of the above three keywords.
09198   1D86             ; On entry, HL points to start of search area.
09199   1D86             ; The token is in E, and D holds a statement count, decremented from zero.
09200   1D86             
09201   1D86             ;; LOOK-PROG
09202   1D86 7E          L1D86:   LD      A,(HL)          ; fetch current character
09203   1D87 FE 3A               CP      $3A             ; is it ':' a statement separator ?
09204   1D89 28 18               JR      Z,L1DA3         ; forward to LOOK-P-2 if so.
09205   1D8B             
09206   1D8B             ; The starting point was PROG - 1 or the end of a line.
09207   1D8B             
09208   1D8B             ;; LOOK-P-1
09209   1D8B 23          L1D8B:   INC     HL              ; increment pointer to address
09210   1D8C 7E                  LD      A,(HL)          ; the high byte of line number
09211   1D8D E6 C0               AND     $C0             ; test for program end marker $80 or a
09212   1D8F                                             ; variable
09213   1D8F 37                  SCF                     ; Set Carry Flag
09214   1D90 C0                  RET     NZ              ; return with carry set if at end
09215   1D91                                             ; of program.           ->
09216   1D91             
09217   1D91 46                  LD      B,(HL)          ; high byte of line number to B
09218   1D92 23                  INC     HL              ;
09219   1D93 4E                  LD      C,(HL)          ; low byte to C.
09220   1D94 ED 43 42 5C         LD      ($5C42),BC      ; set system variable NEWPPC.
09221   1D98 23                  INC     HL              ;
09222   1D99 4E                  LD      C,(HL)          ; low byte of line length to C.
09223   1D9A 23                  INC     HL              ;
09224   1D9B 46                  LD      B,(HL)          ; high byte to B.
09225   1D9C E5                  PUSH    HL              ; save address
09226   1D9D 09                  ADD     HL,BC           ; add length to position.
09227   1D9E 44                  LD      B,H             ; and save result
09228   1D9F 4D                  LD      C,L             ; in BC.
09229   1DA0 E1                  POP     HL              ; restore address.
09230   1DA1 16 00               LD      D,$00           ; initialize statement counter to zero.
09231   1DA3             
09232   1DA3             ;; LOOK-P-2
09233   1DA3 C5          L1DA3:   PUSH    BC              ; save address of next line
09234   1DA4 CD 8B 19            CALL    L198B           ; routine EACH-STMT searches current line.
09235   1DA7 C1                  POP     BC              ; restore address.
09236   1DA8 D0                  RET     NC              ; return if match was found. ->
09237   1DA9             
09238   1DA9 18 E0               JR      L1D8B           ; back to LOOK-P-1 for next line.
09239   1DAB             
09240   1DAB             ; -------------------
09241   1DAB             ; Handle NEXT command
09242   1DAB             ; -------------------
09243   1DAB             ; e.g. NEXT i
09244   1DAB             ; The parameter tables have already evaluated the presence of a variable
09245   1DAB             
09246   1DAB             ;; NEXT
09247   1DAB FD CB 37 4E L1DAB:   BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
09248   1DAF C2 2E 1C            JP      NZ,L1C2E        ; jump back to REPORT-2 if so
09249   1DB2                                             ; 'Variable not found'
09250   1DB2             
09251   1DB2             ; now test if found variable is a simple variable uninitialized by a FOR.
09252   1DB2             
09253   1DB2 2A 4D 5C            LD      HL,($5C4D)      ; load address of variable from DEST
09254   1DB5 CB 7E               BIT     7,(HL)          ; is it correct type ?
09255   1DB7 28 1F               JR      Z,L1DD8         ; forward to REPORT-1 if not
09256   1DB9                                             ; 'NEXT without FOR'
09257   1DB9             
09258   1DB9 23                  INC     HL              ; step past variable name
09259   1DBA 22 68 5C            LD      ($5C68),HL      ; and set MEM to point to three 5-byte values
09260   1DBD                                             ; value, limit, step.
09261   1DBD             
09262   1DBD EF                  RST     28H             ;; FP-CALC     add step and re-store
09263   1DBE E0                  DEFB    $E0             ;;get-mem-0    v.
09264   1DBF E2                  DEFB    $E2             ;;get-mem-2    v,s.
09265   1DC0 0F                  DEFB    $0F             ;;addition     v+s.
09266   1DC1 C0                  DEFB    $C0             ;;st-mem-0     v+s.
09267   1DC2 02                  DEFB    $02             ;;delete       .
09268   1DC3 38                  DEFB    $38             ;;end-calc
09269   1DC4             
09270   1DC4 CD DA 1D            CALL    L1DDA           ; routine NEXT-LOOP tests against limit.
09271   1DC7 D8                  RET     C               ; return if no more iterations possible.
09272   1DC8             
09273   1DC8 2A 68 5C            LD      HL,($5C68)      ; find start of variable contents from MEM.
09274   1DCB 11 0F 00            LD      DE,$000F        ; add 3*5 to
09275   1DCE 19                  ADD     HL,DE           ; address the looping line number
09276   1DCF 5E                  LD      E,(HL)          ; low byte to E
09277   1DD0 23                  INC     HL              ;
09278   1DD1 56                  LD      D,(HL)          ; high byte to D
09279   1DD2 23                  INC     HL              ; address looping statement
09280   1DD3 66                  LD      H,(HL)          ; and store in H
09281   1DD4 EB                  EX      DE,HL           ; swap registers
09282   1DD5 C3 73 1E            JP      L1E73           ; exit via GO-TO-2 to execute another loop.
09283   1DD8             
09284   1DD8             ; ---
09285   1DD8             
09286   1DD8             ;; REPORT-1
09287   1DD8 CF          L1DD8:   RST     08H             ; ERROR-1
09288   1DD9 00                  DEFB    $00             ; Error Report: NEXT without FOR
09289   1DDA             
09290   1DDA             
09291   1DDA             ; -----------------
09292   1DDA             ; Perform NEXT loop
09293   1DDA             ; -----------------
09294   1DDA             ; This routine is called from the FOR command to test for an initial
09295   1DDA             ; iteration and from the NEXT command to test for all subsequent iterations.
09296   1DDA             ; the system variable MEM addresses the variable's contents which, in the
09297   1DDA             ; latter case, have had the step, possibly negative, added to the value.
09298   1DDA             
09299   1DDA             ;; NEXT-LOOP
09300   1DDA EF          L1DDA:   RST     28H             ;; FP-CALC
09301   1DDB E1                  DEFB    $E1             ;;get-mem-1        l.
09302   1DDC E0                  DEFB    $E0             ;;get-mem-0        l,v.
09303   1DDD E2                  DEFB    $E2             ;;get-mem-2        l,v,s.
09304   1DDE 36                  DEFB    $36             ;;less-0           l,v,(1/0) negative step ?
09305   1DDF 00                  DEFB    $00             ;;jump-true        l,v.(1/0)
09306   1DE0             
09307   1DE0 02                  DEFB    $02             ;;to L1DE2, NEXT-1 if step negative
09308   1DE1             
09309   1DE1 01                  DEFB    $01             ;;exchange         v,l.
09310   1DE2             
09311   1DE2             ;; NEXT-1
09312   1DE2 03          L1DE2:   DEFB    $03             ;;subtract         l-v OR v-l.
09313   1DE3 37                  DEFB    $37             ;;greater-0        (1/0)
09314   1DE4 00                  DEFB    $00             ;;jump-true        .
09315   1DE5             
09316   1DE5 04                  DEFB    $04             ;;to L1DE9, NEXT-2 if no more iterations.
09317   1DE6             
09318   1DE6 38                  DEFB    $38             ;;end-calc         .
09319   1DE7             
09320   1DE7 A7                  AND     A               ; clear carry flag signalling another loop.
09321   1DE8 C9                  RET                     ; return
09322   1DE9             
09323   1DE9             ; ---
09324   1DE9             
09325   1DE9             ;; NEXT-2
09326   1DE9 38          L1DE9:   DEFB    $38             ;;end-calc         .
09327   1DEA             
09328   1DEA 37                  SCF                     ; set carry flag signalling looping exhausted.
09329   1DEB C9                  RET                     ; return
09330   1DEC             
09331   1DEC             
09332   1DEC             ; -------------------
09333   1DEC             ; Handle READ command
09334   1DEC             ; -------------------
09335   1DEC             ; e.g. READ a, b$, c$(1000 TO 3000)
09336   1DEC             ; A list of comma-separated variables is assigned from a list of
09337   1DEC             ; comma-separated expressions.
09338   1DEC             ; As it moves along the first list, the character address CH_ADD is stored
09339   1DEC             ; in X_PTR while CH_ADD is used to read the second list.
09340   1DEC             
09341   1DEC             ;; READ-3
09342   1DEC E7          L1DEC:   RST     20H             ; NEXT-CHAR
09343   1DED             
09344   1DED             ; -> Entry point.
09345   1DED             ;; READ
09346   1DED CD 1F 1C    L1DED:   CALL    L1C1F           ; routine CLASS-01 checks variable.
09347   1DF0 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
09348   1DF3 28 29               JR      Z,L1E1E         ; forward to READ-2 if checking syntax
09349   1DF5             
09350   1DF5             
09351   1DF5 DF                  RST     18H             ; GET-CHAR
09352   1DF6 22 5F 5C            LD      ($5C5F),HL      ; save character position in X_PTR.
09353   1DF9 2A 57 5C            LD      HL,($5C57)      ; load HL with Data Address DATADD, which is
09354   1DFC                                             ; the start of the program or the address
09355   1DFC                                             ; after the last expression that was read or
09356   1DFC                                             ; the address of the line number of the 
09357   1DFC                                             ; last RESTORE command.
09358   1DFC 7E                  LD      A,(HL)          ; fetch character
09359   1DFD FE 2C               CP      $2C             ; is it a comma ?
09360   1DFF 28 09               JR      Z,L1E0A         ; forward to READ-1 if so.
09361   1E01             
09362   1E01             ; else all data in this statement has been read so look for next DATA token
09363   1E01             
09364   1E01 1E E4               LD      E,$E4           ; token 'DATA'
09365   1E03 CD 86 1D            CALL    L1D86           ; routine LOOK-PROG
09366   1E06 30 02               JR      NC,L1E0A        ; forward to READ-1 if DATA found
09367   1E08             
09368   1E08             ; else report the error.
09369   1E08             
09370   1E08             ;; REPORT-E
09371   1E08 CF          L1E08:   RST     08H             ; ERROR-1
09372   1E09 0D                  DEFB    $0D             ; Error Report: Out of DATA
09373   1E0A             
09374   1E0A             ;; READ-1
09375   1E0A CD 77 00    L1E0A:   CALL    L0077           ; routine TEMP-PTR1 advances updating CH_ADD
09376   1E0D                                             ; with new DATADD position.
09377   1E0D CD 56 1C            CALL    L1C56           ; routine VAL-FET-1 assigns value to variable
09378   1E10                                             ; checking type match and adjusting CH_ADD.
09379   1E10             
09380   1E10 DF                  RST     18H             ; GET-CHAR fetches adjusted character position
09381   1E11 22 57 5C            LD      ($5C57),HL      ; store back in DATADD
09382   1E14 2A 5F 5C            LD      HL,($5C5F)      ; fetch X_PTR  the original READ CH_ADD
09383   1E17 FD 36 26 00         LD      (IY+$26),$00    ; now nullify X_PTR_hi
09384   1E1B CD 78 00            CALL    L0078           ; routine TEMP-PTR2 restores READ CH_ADD
09385   1E1E             
09386   1E1E             ;; READ-2
09387   1E1E DF          L1E1E:   RST     18H             ; GET-CHAR
09388   1E1F FE 2C               CP      $2C             ; is it ',' indicating more variables to read ?
09389   1E21 28 C9               JR      Z,L1DEC         ; back to READ-3 if so
09390   1E23             
09391   1E23 CD EE 1B            CALL    L1BEE           ; routine CHECK-END
09392   1E26 C9                  RET                     ; return from here in runtime to STMT-RET.
09393   1E27             
09394   1E27             ; -------------------
09395   1E27             ; Handle DATA command
09396   1E27             ; -------------------
09397   1E27             ; In runtime this 'command' is passed by but the syntax is checked when such
09398   1E27             ; a statement is found while parsing a line.
09399   1E27             ; e.g. DATA 1, 2, "text", score-1, a$(location, room, object), FN r(49),
09400   1E27             ;         wages - tax, TRUE, The meaning of life
09401   1E27             
09402   1E27             ;; DATA
09403   1E27 CD 30 25    L1E27:   CALL    L2530           ; routine SYNTAX-Z to check status
09404   1E2A 20 0B               JR      NZ,L1E37        ; forward to DATA-2 if in runtime
09405   1E2C             
09406   1E2C             ;; DATA-1
09407   1E2C CD FB 24    L1E2C:   CALL    L24FB           ; routine SCANNING to check syntax of
09408   1E2F                                             ; expression
09409   1E2F FE 2C               CP      $2C             ; is it a comma ?
09410   1E31 C4 EE 1B            CALL    NZ,L1BEE        ; routine CHECK-END checks that statement
09411   1E34                                             ; is complete. Will make an early exit if
09412   1E34                                             ; so. >>>
09413   1E34 E7                  RST     20H             ; NEXT-CHAR
09414   1E35 18 F5               JR      L1E2C           ; back to DATA-1
09415   1E37             
09416   1E37             ; ---
09417   1E37             
09418   1E37             ;; DATA-2
09419   1E37 3E E4       L1E37:   LD      A,$E4           ; set token to 'DATA' and continue into
09420   1E39                                             ; the PASS-BY routine.
09421   1E39             
09422   1E39             
09423   1E39             ; ----------------------------------
09424   1E39             ; Check statement for DATA or DEF FN
09425   1E39             ; ----------------------------------
09426   1E39             ; This routine is used to backtrack to a command token and then
09427   1E39             ; forward to the next statement in runtime.
09428   1E39             
09429   1E39             ;; PASS-BY
09430   1E39 47          L1E39:   LD      B,A             ; Give BC enough space to find token.
09431   1E3A ED B9               CPDR                    ; Compare decrement and repeat. (Only use).
09432   1E3C                                             ; Work backwards till keyword is found which
09433   1E3C                                             ; is start of statement before any quotes.
09434   1E3C                                             ; HL points to location before keyword.
09435   1E3C 11 00 02            LD      DE,$0200        ; count 1+1 statements, dummy value in E to
09436   1E3F                                             ; inhibit searching for a token.
09437   1E3F C3 8B 19            JP      L198B           ; to EACH-STMT to find next statement
09438   1E42             
09439   1E42             ; -----------------------------------------------------------------------
09440   1E42             ; A General Note on Invalid Line Numbers.
09441   1E42             ; =======================================
09442   1E42             ; One of the revolutionary concepts of Sinclair BASIC was that it supported
09443   1E42             ; virtual line numbers. That is the destination of a GO TO, RESTORE etc. need
09444   1E42             ; not exist. It could be a point before or after an actual line number.
09445   1E42             ; Zero suffices for a before but the after should logically be infinity.
09446   1E42             ; Since the maximum actual line limit is 9999 then the system limit, 16383
09447   1E42             ; when variables kick in, would serve fine as a virtual end point.
09448   1E42             ; However, ironically, only the LOAD command gets it right. It will not
09449   1E42             ; autostart a program that has been saved with a line higher than 16383.
09450   1E42             ; All the other commands deal with the limit unsatisfactorily.
09451   1E42             ; LIST, RUN, GO TO, GO SUB and RESTORE have problems and the latter may
09452   1E42             ; crash the machine when supplied with an inappropriate virtual line number.
09453   1E42             ; This is puzzling as very careful consideration must have been given to
09454   1E42             ; this point when the new variable types were allocated their masks and also
09455   1E42             ; when the routine NEXT-ONE was successfully re-written to reflect this.
09456   1E42             ; An enigma.
09457   1E42             ; -------------------------------------------------------------------------
09458   1E42             
09459   1E42             ; ----------------------
09460   1E42             ; Handle RESTORE command
09461   1E42             ; ----------------------
09462   1E42             ; The restore command sets the system variable for the data address to
09463   1E42             ; point to the location before the supplied line number or first line
09464   1E42             ; thereafter.
09465   1E42             ; This alters the position where subsequent READ commands look for data.
09466   1E42             ; Note. If supplied with inappropriate high numbers the system may crash
09467   1E42             ; in the LINE-ADDR routine as it will pass the program/variables end-marker
09468   1E42             ; and then lose control of what it is looking for - variable or line number.
09469   1E42             ; - observation, Steven Vickers, 1984, Pitman.
09470   1E42             
09471   1E42             ;; RESTORE
09472   1E42 CD 99 1E    L1E42:   CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
09473   1E45                                             ; Note. B should be checked against limit $3F
09474   1E45                                             ; and an error generated if higher.
09475   1E45             
09476   1E45             ; this entry point is used from RUN command with BC holding zero
09477   1E45             
09478   1E45             ;; REST-RUN
09479   1E45 60          L1E45:   LD      H,B             ; transfer the line
09480   1E46 69                  LD      L,C             ; number to the HL register.
09481   1E47 CD 6E 19            CALL    L196E           ; routine LINE-ADDR to fetch the address.
09482   1E4A 2B                  DEC     HL              ; point to the location before the line.
09483   1E4B 22 57 5C            LD      ($5C57),HL      ; update system variable DATADD.
09484   1E4E C9                  RET                     ; return to STMT-RET (or RUN)
09485   1E4F             
09486   1E4F             ; ------------------------
09487   1E4F             ; Handle RANDOMIZE command
09488   1E4F             ; ------------------------
09489   1E4F             ; This command sets the SEED for the RND function to a fixed value.
09490   1E4F             ; With the parameter zero, a random start point is used depending on
09491   1E4F             ; how long the computer has been switched on.
09492   1E4F             
09493   1E4F             ;; RANDOMIZE
09494   1E4F CD 99 1E    L1E4F:   CALL    L1E99           ; routine FIND-INT2 puts parameter in BC.
09495   1E52 78                  LD      A,B             ; test this
09496   1E53 B1                  OR      C               ; for zero.
09497   1E54 20 04               JR      NZ,L1E5A        ; forward to RAND-1 if not zero.
09498   1E56             
09499   1E56 ED 4B 78 5C         LD      BC,($5C78)      ; use the lower two bytes at FRAMES1.
09500   1E5A             
09501   1E5A             ;; RAND-1
09502   1E5A ED 43 76 5C L1E5A:   LD      ($5C76),BC      ; place in SEED system variable.
09503   1E5E C9                  RET                     ; return to STMT-RET
09504   1E5F             
09505   1E5F             ; -----------------------
09506   1E5F             ; Handle CONTINUE command
09507   1E5F             ; -----------------------
09508   1E5F             ; The CONTINUE command transfers the OLD (but incremented) values of
09509   1E5F             ; line number and statement to the equivalent "NEW VALUE" system variables
09510   1E5F             ; by using the last part of GO TO and exits indirectly to STMT-RET.
09511   1E5F             
09512   1E5F             ;; CONTINUE
09513   1E5F 2A 6E 5C    L1E5F:   LD      HL,($5C6E)      ; fetch OLDPPC line number.
09514   1E62 FD 56 36            LD      D,(IY+$36)      ; fetch OSPPC statement.
09515   1E65 18 0C               JR      L1E73           ; forward to GO-TO-2
09516   1E67             
09517   1E67             ; --------------------
09518   1E67             ; Handle GO TO command
09519   1E67             ; --------------------
09520   1E67             ; The GO TO command routine is also called by GO SUB and RUN routines
09521   1E67             ; to evaluate the parameters of both commands.
09522   1E67             ; It updates the system variables used to fetch the next line/statement.
09523   1E67             ; It is at STMT-RET that the actual change in control takes place.
09524   1E67             ; Unlike some BASICs the line number need not exist.
09525   1E67             ; Note. the high byte of the line number is incorrectly compared with $F0
09526   1E67             ; instead of $3F. This leads to commands with operands greater than 32767
09527   1E67             ; being considered as having been run from the editing area and the
09528   1E67             ; error report 'Statement Lost' is given instead of 'OK'.
09529   1E67             ; - Steven Vickers, 1984.
09530   1E67             
09531   1E67             ;; GO-TO
09532   1E67 CD 99 1E    L1E67:   CALL    L1E99           ; routine FIND-INT2 puts operand in BC
09533   1E6A 60                  LD      H,B             ; transfer line
09534   1E6B 69                  LD      L,C             ; number to HL.
09535   1E6C 16 00               LD      D,$00           ; set statement to 0 - first.
09536   1E6E 7C                  LD      A,H             ; compare high byte only
09537   1E6F FE F0               CP      $F0             ; to $F0 i.e. 61439 in full.
09538   1E71 30 2C               JR      NC,L1E9F        ; forward to REPORT-B if above.
09539   1E73             
09540   1E73             ; This call entry point is used to update the system variables e.g. by RETURN.
09541   1E73             
09542   1E73             ;; GO-TO-2
09543   1E73 22 42 5C    L1E73:   LD      ($5C42),HL      ; save line number in NEWPPC
09544   1E76 FD 72 0A            LD      (IY+$0A),D      ; and statement in NSPPC
09545   1E79 C9                  RET                     ; to STMT-RET (or GO-SUB command)
09546   1E7A             
09547   1E7A             ; ------------------
09548   1E7A             ; Handle OUT command
09549   1E7A             ; ------------------
09550   1E7A             ; Syntax has been checked and the two comma-separated values are on the
09551   1E7A             ; calculator stack.
09552   1E7A             
09553   1E7A             ;; OUT
09554   1E7A CD 85 1E    L1E7A:   CALL    L1E85           ; routine TWO-PARAM fetches values
09555   1E7D                                             ; to BC and A.
09556   1E7D ED 79               OUT     (C),A           ; perform the operation.
09557   1E7F C9                  RET                     ; return to STMT-RET.
09558   1E80             
09559   1E80             ; -------------------
09560   1E80             ; Handle POKE command
09561   1E80             ; -------------------
09562   1E80             ; This routine alters a single byte in the 64K address space.
09563   1E80             ; Happily no check is made as to whether ROM or RAM is addressed.
09564   1E80             ; Sinclair BASIC requires no poking of system variables.
09565   1E80             
09566   1E80             ;; POKE
09567   1E80 CD 85 1E    L1E80:   CALL    L1E85           ; routine TWO-PARAM fetches values
09568   1E83                                             ; to BC and A.
09569   1E83 02                  LD      (BC),A          ; load memory location with A.
09570   1E84 C9                  RET                     ; return to STMT-RET.
09571   1E85             
09572   1E85             ; ------------------------------------
09573   1E85             ; Fetch two  parameters from calculator stack
09574   1E85             ; ------------------------------------
09575   1E85             ; This routine fetches a byte and word from the calculator stack
09576   1E85             ; producing an error if either is out of range.
09577   1E85             
09578   1E85             ;; TWO-PARAM
09579   1E85 CD D5 2D    L1E85:   CALL    L2DD5           ; routine FP-TO-A
09580   1E88 38 15               JR      C,L1E9F         ; forward to REPORT-B if overflow occurred
09581   1E8A             
09582   1E8A 28 02               JR      Z,L1E8E         ; forward to TWO-P-1 if positive
09583   1E8C             
09584   1E8C ED 44               NEG                     ; negative numbers are made positive
09585   1E8E             
09586   1E8E             ;; TWO-P-1
09587   1E8E F5          L1E8E:   PUSH    AF              ; save the value
09588   1E8F CD 99 1E            CALL    L1E99           ; routine FIND-INT2 gets integer to BC
09589   1E92 F1                  POP     AF              ; restore the value
09590   1E93 C9                  RET                     ; return
09591   1E94             
09592   1E94             ; -------------
09593   1E94             ; Find integers
09594   1E94             ; -------------
09595   1E94             ; The first of these routines fetches a 8-bit integer (range 0-255) from the
09596   1E94             ; calculator stack to the accumulator and is used for colours, streams,
09597   1E94             ; durations and coordinates.
09598   1E94             ; The second routine fetches 16-bit integers to the BC register pair 
09599   1E94             ; and is used to fetch command and function arguments involving line numbers
09600   1E94             ; or memory addresses and also array subscripts and tab arguments.
09601   1E94             ; ->
09602   1E94             
09603   1E94             ;; FIND-INT1
09604   1E94 CD D5 2D    L1E94:   CALL    L2DD5           ; routine FP-TO-A
09605   1E97 18 03               JR      L1E9C           ; forward to FIND-I-1 for common exit routine.
09606   1E99             
09607   1E99             ; ---
09608   1E99             
09609   1E99             ; ->
09610   1E99             
09611   1E99             ;; FIND-INT2
09612   1E99 CD A2 2D    L1E99:   CALL    L2DA2           ; routine FP-TO-BC
09613   1E9C             
09614   1E9C             ;; FIND-I-1
09615   1E9C 38 01       L1E9C:   JR      C,L1E9F         ; to REPORT-Bb with overflow.
09616   1E9E             
09617   1E9E C8                  RET     Z               ; return if positive.
09618   1E9F             
09619   1E9F             
09620   1E9F             ;; REPORT-Bb
09621   1E9F CF          L1E9F:   RST     08H             ; ERROR-1
09622   1EA0 0A                  DEFB    $0A             ; Error Report: Integer out of range
09623   1EA1             
09624   1EA1             ; ------------------
09625   1EA1             ; Handle RUN command
09626   1EA1             ; ------------------
09627   1EA1             ; This command runs a program starting at an optional line.
09628   1EA1             ; It performs a 'RESTORE 0' then CLEAR
09629   1EA1             
09630   1EA1             ;; RUN
09631   1EA1 CD 67 1E    L1EA1:   CALL    L1E67           ; routine GO-TO puts line number in
09632   1EA4                                             ; system variables.
09633   1EA4 01 00 00            LD      BC,$0000        ; prepare to set DATADD to first line.
09634   1EA7 CD 45 1E            CALL    L1E45           ; routine REST-RUN does the 'restore'.
09635   1EAA                                             ; Note BC still holds zero.
09636   1EAA 18 03               JR      L1EAF           ; forward to CLEAR-RUN to clear variables
09637   1EAC                                             ; without disturbing RAMTOP and
09638   1EAC                                             ; exit indirectly to STMT-RET
09639   1EAC             
09640   1EAC             ; --------------------
09641   1EAC             ; Handle CLEAR command
09642   1EAC             ; --------------------
09643   1EAC             ; This command reclaims the space used by the variables.
09644   1EAC             ; It also clears the screen and the GO SUB stack.
09645   1EAC             ; With an integer expression, it sets the uppermost memory
09646   1EAC             ; address within the BASIC system.
09647   1EAC             ; "Contrary to the manual, CLEAR doesn't execute a RESTORE" -
09648   1EAC             ; Steven Vickers, Pitman Pocket Guide to the Spectrum, 1984.
09649   1EAC             
09650   1EAC             ;; CLEAR
09651   1EAC CD 99 1E    L1EAC:   CALL    L1E99           ; routine FIND-INT2 fetches to BC.
09652   1EAF             
09653   1EAF             ;; CLEAR-RUN
09654   1EAF 78          L1EAF:   LD      A,B             ; test for
09655   1EB0 B1                  OR      C               ; zero.
09656   1EB1 20 04               JR      NZ,L1EB7        ; skip to CLEAR-1 if not zero.
09657   1EB3             
09658   1EB3 ED 4B B2 5C         LD      BC,($5CB2)      ; use the existing value of RAMTOP if zero.
09659   1EB7             
09660   1EB7             ;; CLEAR-1
09661   1EB7 C5          L1EB7:   PUSH    BC              ; save ramtop value.
09662   1EB8             
09663   1EB8 ED 5B 4B 5C         LD      DE,($5C4B)      ; fetch VARS
09664   1EBC 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE
09665   1EBF 2B                  DEC     HL              ; adjust to point at variables end-marker.
09666   1EC0 CD E5 19            CALL    L19E5           ; routine RECLAIM-1 reclaims the space used by
09667   1EC3                                             ; the variables.
09668   1EC3             
09669   1EC3 CD 6B 0D            CALL    L0D6B           ; routine CLS to clear screen.
09670   1EC6             
09671   1EC6 2A 65 5C            LD      HL,($5C65)      ; fetch STKEND the start of free memory.
09672   1EC9 11 32 00            LD      DE,$0032        ; allow for another 50 bytes.
09673   1ECC 19                  ADD     HL,DE           ; add the overhead to HL.
09674   1ECD             
09675   1ECD D1                  POP     DE              ; restore the ramtop value.
09676   1ECE ED 52               SBC     HL,DE           ; if HL is greater than the value then jump
09677   1ED0 30 08               JR      NC,L1EDA        ; forward to REPORT-M
09678   1ED2                                             ; 'RAMTOP no good'
09679   1ED2             
09680   1ED2 2A B4 5C            LD      HL,($5CB4)      ; now P-RAMT ($7FFF on 16K RAM machine)
09681   1ED5 A7                  AND     A               ; exact this time.
09682   1ED6 ED 52               SBC     HL,DE           ; new ramtop must be lower or the same.
09683   1ED8 30 02               JR      NC,L1EDC        ; skip to CLEAR-2 if in actual RAM.
09684   1EDA             
09685   1EDA             ;; REPORT-M
09686   1EDA CF          L1EDA:   RST     08H             ; ERROR-1
09687   1EDB 15                  DEFB    $15             ; Error Report: RAMTOP no good
09688   1EDC             
09689   1EDC             ;; CLEAR-2
09690   1EDC EB          L1EDC:   EX      DE,HL           ; transfer ramtop value to HL.
09691   1EDD 22 B2 5C            LD      ($5CB2),HL      ; update system variable RAMTOP.
09692   1EE0 D1                  POP     DE              ; pop the return address STMT-RET.
09693   1EE1 C1                  POP     BC              ; pop the Error Address.
09694   1EE2 36 3E               LD      (HL),$3E        ; now put the GO SUB end-marker at RAMTOP.
09695   1EE4 2B                  DEC     HL              ; leave a location beneath it.
09696   1EE5 F9                  LD      SP,HL           ; initialize the machine stack pointer.
09697   1EE6 C5                  PUSH    BC              ; push the error address.
09698   1EE7 ED 73 3D 5C         LD      ($5C3D),SP      ; make ERR_SP point to location.
09699   1EEB EB                  EX      DE,HL           ; put STMT-RET in HL.
09700   1EEC E9                  JP      (HL)            ; and go there directly.
09701   1EED             
09702   1EED             ; ---------------------
09703   1EED             ; Handle GO SUB command
09704   1EED             ; ---------------------
09705   1EED             ; The GO SUB command diverts BASIC control to a new line number
09706   1EED             ; in a very similar manner to GO TO but
09707   1EED             ; the current line number and current statement + 1
09708   1EED             ; are placed on the GO SUB stack as a RETURN point.
09709   1EED             
09710   1EED             ;; GO-SUB
09711   1EED D1          L1EED:   POP     DE              ; drop the address STMT-RET
09712   1EEE FD 66 0D            LD      H,(IY+$0D)      ; fetch statement from SUBPPC and
09713   1EF1 24                  INC     H               ; increment it
09714   1EF2 E3                  EX      (SP),HL         ; swap - error address to HL,
09715   1EF3                                             ; H (statement) at top of stack,
09716   1EF3                                             ; L (unimportant) beneath.
09717   1EF3 33                  INC     SP              ; adjust to overwrite unimportant byte
09718   1EF4 ED 4B 45 5C         LD      BC,($5C45)      ; fetch the current line number from PPC
09719   1EF8 C5                  PUSH    BC              ; and PUSH onto GO SUB stack.
09720   1EF9                                             ; the empty machine-stack can be rebuilt
09721   1EF9 E5                  PUSH    HL              ; push the error address.
09722   1EFA ED 73 3D 5C         LD      ($5C3D),SP      ; make system variable ERR_SP point to it.
09723   1EFE D5                  PUSH    DE              ; push the address STMT-RET.
09724   1EFF CD 67 1E            CALL    L1E67           ; call routine GO-TO to update the system
09725   1F02                                             ; variables NEWPPC and NSPPC.
09726   1F02                                             ; then make an indirect exit to STMT-RET via
09727   1F02 01 14 00            LD      BC,$0014        ; a 20-byte overhead memory check.
09728   1F05             
09729   1F05             ; ----------------------
09730   1F05             ; Check available memory
09731   1F05             ; ----------------------
09732   1F05             ; This routine is used on many occasions when extending a dynamic area
09733   1F05             ; upwards or the GO SUB stack downwards.
09734   1F05             
09735   1F05             ;; TEST-ROOM
09736   1F05 2A 65 5C    L1F05:   LD      HL,($5C65)      ; fetch STKEND
09737   1F08 09                  ADD     HL,BC           ; add the supplied test value
09738   1F09 38 0A               JR      C,L1F15         ; forward to REPORT-4 if over $FFFF
09739   1F0B             
09740   1F0B EB                  EX      DE,HL           ; was less so transfer to DE
09741   1F0C 21 50 00            LD      HL,$0050        ; test against another 80 bytes
09742   1F0F 19                  ADD     HL,DE           ; anyway
09743   1F10 38 03               JR      C,L1F15         ; forward to REPORT-4 if this passes $FFFF
09744   1F12             
09745   1F12 ED 72               SBC     HL,SP           ; if less than the machine stack pointer
09746   1F14 D8                  RET     C               ; then return - OK.
09747   1F15             
09748   1F15             ;; REPORT-4
09749   1F15 2E 03       L1F15:   LD      L,$03           ; prepare 'Out of Memory' 
09750   1F17 C3 55 00            JP      L0055           ; jump back to ERROR-3 at $0055
09751   1F1A                                             ; Note. this error can't be trapped at $0008
09752   1F1A             
09753   1F1A             ; ------------------------------
09754   1F1A             ; THE 'FREE MEMORY' USER ROUTINE
09755   1F1A             ; ------------------------------
09756   1F1A             ; This routine is not used by the ROM but allows users to evaluate
09757   1F1A             ; approximate free memory with PRINT 65536 - USR 7962.
09758   1F1A             
09759   1F1A             ;; free-mem
09760   1F1A 01 00 00    L1F1A:   LD      BC,$0000        ; allow no overhead.
09761   1F1D             
09762   1F1D CD 05 1F            CALL    L1F05           ; routine TEST-ROOM.
09763   1F20             
09764   1F20 44                  LD      B,H             ; transfer the result
09765   1F21 4D                  LD      C,L             ; to the BC register.
09766   1F22 C9                  RET                     ; the USR function returns value of BC.
09767   1F23             
09768   1F23             ; --------------------
09769   1F23             ; THE 'RETURN' COMMAND
09770   1F23             ; --------------------
09771   1F23             ; As with any command, there are two values on the machine stack at the time 
09772   1F23             ; it is invoked.  The machine stack is below the GOSUB stack.  Both grow 
09773   1F23             ; downwards, the machine stack by two bytes, the GOSUB stack by 3 bytes. 
09774   1F23             ; The highest location is a statement byte followed by a two-byte line number.
09775   1F23             
09776   1F23             ;; RETURN
09777   1F23 C1          L1F23:   POP     BC              ; drop the address STMT-RET.
09778   1F24 E1                  POP     HL              ; now the error address.
09779   1F25 D1                  POP     DE              ; now a possible BASIC return line.
09780   1F26 7A                  LD      A,D             ; the high byte $00 - $27 is 
09781   1F27 FE 3E               CP      $3E             ; compared with the traditional end-marker $3E.
09782   1F29 28 0B               JR      Z,L1F36         ; forward to REPORT-7 with a match.
09783   1F2B                                             ; 'RETURN without GOSUB'
09784   1F2B             
09785   1F2B             ; It was not the end-marker so a single statement byte remains at the base of 
09786   1F2B             ; the calculator stack. It can't be popped off.
09787   1F2B             
09788   1F2B 3B                  DEC     SP              ; adjust stack pointer to create room for two 
09789   1F2C                                             ; bytes.
09790   1F2C E3                  EX      (SP),HL         ; statement to H, error address to base of
09791   1F2D                                             ; new machine stack.
09792   1F2D EB                  EX      DE,HL           ; statement to D,  BASIC line number to HL.
09793   1F2E ED 73 3D 5C         LD      ($5C3D),SP      ; adjust ERR_SP to point to new stack pointer
09794   1F32 C5                  PUSH    BC              ; now re-stack the address STMT-RET
09795   1F33 C3 73 1E            JP      L1E73           ; to GO-TO-2 to update statement and line
09796   1F36                                             ; system variables and exit indirectly to the
09797   1F36                                             ; address just pushed on stack.
09798   1F36             
09799   1F36             ; ---
09800   1F36             
09801   1F36             ;; REPORT-7
09802   1F36 D5          L1F36:   PUSH    DE              ; replace the end-marker.
09803   1F37 E5                  PUSH    HL              ; now restore the error address
09804   1F38                                             ; as will be required in a few clock cycles.
09805   1F38             
09806   1F38 CF                  RST     08H             ; ERROR-1
09807   1F39 06                  DEFB    $06             ; Error Report: RETURN without GOSUB
09808   1F3A             
09809   1F3A             ; --------------------
09810   1F3A             ; Handle PAUSE command
09811   1F3A             ; --------------------
09812   1F3A             ; The pause command takes as its parameter the number of interrupts
09813   1F3A             ; for which to wait. PAUSE 50 pauses for about a second.
09814   1F3A             ; PAUSE 0 pauses indefinitely.
09815   1F3A             ; Both forms can be finished by pressing a key.
09816   1F3A             
09817   1F3A             ;; PAUSE
09818   1F3A CD 99 1E    L1F3A:   CALL    L1E99           ; routine FIND-INT2 puts value in BC
09819   1F3D             
09820   1F3D             ;; PAUSE-1
09821   1F3D 76          L1F3D:   HALT                    ; wait for interrupt.
09822   1F3E 0B                  DEC     BC              ; decrease counter.
09823   1F3F 78                  LD      A,B             ; test if
09824   1F40 B1                  OR      C               ; result is zero.
09825   1F41 28 0C               JR      Z,L1F4F         ; forward to PAUSE-END if so.
09826   1F43             
09827   1F43 78                  LD      A,B             ; test if
09828   1F44 A1                  AND     C               ; now $FFFF
09829   1F45 3C                  INC     A               ; that is, initially zero.
09830   1F46 20 01               JR      NZ,L1F49        ; skip forward to PAUSE-2 if not.
09831   1F48             
09832   1F48 03                  INC     BC              ; restore counter to zero.
09833   1F49             
09834   1F49             ;; PAUSE-2
09835   1F49 FD CB 01 6E L1F49:   BIT     5,(IY+$01)      ; test FLAGS - has a new key been pressed ?
09836   1F4D 28 EE               JR      Z,L1F3D         ; back to PAUSE-1 if not.
09837   1F4F             
09838   1F4F             ;; PAUSE-END
09839   1F4F FD CB 01 AE L1F4F:   RES     5,(IY+$01)      ; update FLAGS - signal no new key
09840   1F53 C9                  RET                     ; and return.
09841   1F54             
09842   1F54             ; -------------------
09843   1F54             ; Check for BREAK key
09844   1F54             ; -------------------
09845   1F54             ; This routine is called from COPY-LINE, when interrupts are disabled,
09846   1F54             ; to test if BREAK (SHIFT - SPACE) is being pressed.
09847   1F54             ; It is also called at STMT-RET after every statement.
09848   1F54             
09849   1F54             ;; BREAK-KEY
09850   1F54 3E 7F       L1F54:   LD      A,$7F           ; Input address: $7FFE
09851   1F56 DB FE               IN      A,($FE)         ; read lower right keys
09852   1F58 1F                  RRA                     ; rotate bit 0 - SPACE
09853   1F59 D8                  RET     C               ; return if not reset
09854   1F5A             
09855   1F5A 3E FE               LD      A,$FE           ; Input address: $FEFE
09856   1F5C DB FE               IN      A,($FE)         ; read lower left keys
09857   1F5E 1F                  RRA                     ; rotate bit 0 - SHIFT
09858   1F5F C9                  RET                     ; carry will be set if not pressed.
09859   1F60                                             ; return with no carry if both keys
09860   1F60                                             ; pressed.
09861   1F60             
09862   1F60             ; ---------------------
09863   1F60             ; Handle DEF FN command
09864   1F60             ; ---------------------
09865   1F60             ; e.g. DEF FN r$(a$,a) = a$(a TO )
09866   1F60             ; this 'command' is ignored in runtime but has its syntax checked
09867   1F60             ; during line-entry.
09868   1F60             
09869   1F60             ;; DEF-FN
09870   1F60 CD 30 25    L1F60:   CALL    L2530           ; routine SYNTAX-Z
09871   1F63 28 05               JR      Z,L1F6A         ; forward to DEF-FN-1 if parsing
09872   1F65             
09873   1F65 3E CE               LD      A,$CE           ; else load A with 'DEF FN' and
09874   1F67 C3 39 1E            JP      L1E39           ; jump back to PASS-BY
09875   1F6A             
09876   1F6A             ; ---
09877   1F6A             
09878   1F6A             ; continue here if checking syntax.
09879   1F6A             
09880   1F6A             ;; DEF-FN-1
09881   1F6A FD CB 01 F6 L1F6A:   SET      6,(IY+$01)     ; set FLAGS  - Assume numeric result
09882   1F6E CD 8D 2C            CALL    L2C8D           ; call routine ALPHA
09883   1F71 30 16               JR      NC,L1F89        ; if not then to DEF-FN-4 to jump to
09884   1F73                                             ; 'Nonsense in BASIC'
09885   1F73             
09886   1F73             
09887   1F73 E7                  RST     20H             ; NEXT-CHAR
09888   1F74 FE 24               CP      $24             ; is it '$' ?
09889   1F76 20 05               JR      NZ,L1F7D        ; to DEF-FN-2 if not as numeric.
09890   1F78             
09891   1F78 FD CB 01 B6         RES     6,(IY+$01)      ; set FLAGS  - Signal string result
09892   1F7C             
09893   1F7C E7                  RST     20H             ; get NEXT-CHAR
09894   1F7D             
09895   1F7D             ;; DEF-FN-2
09896   1F7D FE 28       L1F7D:   CP      $28             ; is it '(' ?
09897   1F7F 20 3C               JR      NZ,L1FBD        ; to DEF-FN-7 'Nonsense in BASIC'
09898   1F81             
09899   1F81             
09900   1F81 E7                  RST     20H             ; NEXT-CHAR
09901   1F82 FE 29               CP      $29             ; is it ')' ?
09902   1F84 28 20               JR      Z,L1FA6         ; to DEF-FN-6 if null argument
09903   1F86             
09904   1F86             ;; DEF-FN-3
09905   1F86 CD 8D 2C    L1F86:   CALL    L2C8D           ; routine ALPHA checks that it is the expected
09906   1F89                                             ; alphabetic character.
09907   1F89             
09908   1F89             ;; DEF-FN-4
09909   1F89 D2 8A 1C    L1F89:   JP      NC,L1C8A        ; to REPORT-C  if not
09910   1F8C                                             ; 'Nonsense in BASIC'.
09911   1F8C             
09912   1F8C EB                  EX      DE,HL           ; save pointer in DE
09913   1F8D             
09914   1F8D E7                  RST     20H             ; NEXT-CHAR re-initializes HL from CH_ADD
09915   1F8E                                             ; and advances.
09916   1F8E FE 24               CP      $24             ; '$' ? is it a string argument.
09917   1F90 20 02               JR      NZ,L1F94        ; forward to DEF-FN-5 if not.
09918   1F92             
09919   1F92 EB                  EX      DE,HL           ; save pointer to '$' in DE
09920   1F93             
09921   1F93 E7                  RST     20H             ; NEXT-CHAR re-initializes HL and advances
09922   1F94             
09923   1F94             ;; DEF-FN-5
09924   1F94 EB          L1F94:   EX      DE,HL           ; bring back pointer.
09925   1F95 01 06 00            LD      BC,$0006        ; the function requires six hidden bytes for
09926   1F98                                             ; each parameter passed.
09927   1F98                                             ; The first byte will be $0E
09928   1F98                                             ; then 5-byte numeric value
09929   1F98                                             ; or 5-byte string pointer.
09930   1F98             
09931   1F98 CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates space in program
09932   1F9B                                             ; area.
09933   1F9B             
09934   1F9B 23                  INC     HL              ; adjust HL (set by LDDR)
09935   1F9C 23                  INC     HL              ; to point to first location.
09936   1F9D 36 0E               LD      (HL),$0E        ; insert the 'hidden' marker.
09937   1F9F             
09938   1F9F             ; Note. these invisible storage locations hold nothing meaningful for the
09939   1F9F             ; moment. They will be used every time the corresponding function is
09940   1F9F             ; evaluated in runtime.
09941   1F9F             ; Now consider the following character fetched earlier.
09942   1F9F             
09943   1F9F FE 2C               CP      $2C             ; is it ',' ? (more than one parameter)
09944   1FA1 20 03               JR      NZ,L1FA6        ; to DEF-FN-6 if not
09945   1FA3             
09946   1FA3             
09947   1FA3 E7                  RST     20H             ; else NEXT-CHAR
09948   1FA4 18 E0               JR      L1F86           ; and back to DEF-FN-3
09949   1FA6             
09950   1FA6             ; ---
09951   1FA6             
09952   1FA6             ;; DEF-FN-6
09953   1FA6 FE 29       L1FA6:   CP      $29             ; should close with a ')'
09954   1FA8 20 13               JR      NZ,L1FBD        ; to DEF-FN-7 if not
09955   1FAA                                             ; 'Nonsense in BASIC'
09956   1FAA             
09957   1FAA             
09958   1FAA E7                  RST     20H             ; get NEXT-CHAR
09959   1FAB FE 3D               CP      $3D             ; is it '=' ?
09960   1FAD 20 0E               JR      NZ,L1FBD        ; to DEF-FN-7 if not 'Nonsense...'
09961   1FAF             
09962   1FAF             
09963   1FAF E7                  RST     20H             ; address NEXT-CHAR
09964   1FB0 3A 3B 5C            LD      A,($5C3B)       ; get FLAGS which has been set above
09965   1FB3 F5                  PUSH    AF              ; and preserve
09966   1FB4             
09967   1FB4 CD FB 24            CALL    L24FB           ; routine SCANNING checks syntax of expression
09968   1FB7                                             ; and also sets flags.
09969   1FB7             
09970   1FB7 F1                  POP     AF              ; restore previous flags
09971   1FB8 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS - bit 6 should be same 
09972   1FBB                                             ; therefore will be reset.
09973   1FBB E6 40               AND     $40             ; isolate bit 6.
09974   1FBD             
09975   1FBD             ;; DEF-FN-7
09976   1FBD C2 8A 1C    L1FBD:   JP      NZ,L1C8A        ; jump back to REPORT-C if the expected result 
09977   1FC0                                             ; is not the same type.
09978   1FC0                                             ; 'Nonsense in BASIC'
09979   1FC0             
09980   1FC0 CD EE 1B            CALL    L1BEE           ; routine CHECK-END will return early if
09981   1FC3                                             ; at end of statement and move onto next
09982   1FC3                                             ; else produce error report. >>>
09983   1FC3             
09984   1FC3                                             ; There will be no return to here.
09985   1FC3             
09986   1FC3             ; -------------------------------
09987   1FC3             ; Returning early from subroutine
09988   1FC3             ; -------------------------------
09989   1FC3             ; All routines are capable of being run in two modes - syntax checking mode
09990   1FC3             ; and runtime mode.  This routine is called often to allow a routine to return 
09991   1FC3             ; early if checking syntax.
09992   1FC3             
09993   1FC3             ;; UNSTACK-Z
09994   1FC3 CD 30 25    L1FC3:   CALL    L2530           ; routine SYNTAX-Z sets zero flag if syntax
09995   1FC6                                             ; is being checked.
09996   1FC6             
09997   1FC6 E1                  POP     HL              ; drop the return address.
09998   1FC7 C8                  RET      Z              ; return to previous call in chain if checking
09999   1FC8                                             ; syntax.
10000   1FC8             
10001   1FC8 E9                  JP      (HL)            ; jump to return address as BASIC program is
10002   1FC9                                             ; actually running.
10003   1FC9             
10004   1FC9             ; ---------------------
10005   1FC9             ; Handle LPRINT command
10006   1FC9             ; ---------------------
10007   1FC9             ; A simple form of 'PRINT #3' although it can output to 16 streams.
10008   1FC9             ; Probably for compatibility with other BASICs particularly ZX81 BASIC.
10009   1FC9             ; An extra UDG might have been better.
10010   1FC9             
10011   1FC9             ;; LPRINT
10012   1FC9 3E 03       L1FC9:   LD      A,$03           ; the printer channel
10013   1FCB 18 02               JR      L1FCF           ; forward to PRINT-1
10014   1FCD             
10015   1FCD             ; ---------------------
10016   1FCD             ; Handle PRINT commands
10017   1FCD             ; ---------------------
10018   1FCD             ; The Spectrum's main stream output command.
10019   1FCD             ; The default stream is stream 2 which is normally the upper screen
10020   1FCD             ; of the computer. However the stream can be altered in range 0 - 15.
10021   1FCD             
10022   1FCD             ;; PRINT
10023   1FCD 3E 02       L1FCD:   LD      A,$02           ; the stream for the upper screen.
10024   1FCF             
10025   1FCF             ; The LPRINT command joins here.
10026   1FCF             
10027   1FCF             ;; PRINT-1
10028   1FCF CD 30 25    L1FCF:   CALL    L2530           ; routine SYNTAX-Z checks if program running
10029   1FD2 C4 01 16            CALL    NZ,L1601        ; routine CHAN-OPEN if so
10030   1FD5 CD 4D 0D            CALL    L0D4D           ; routine TEMPS sets temporary colours.
10031   1FD8 CD DF 1F            CALL    L1FDF           ; routine PRINT-2 - the actual item
10032   1FDB CD EE 1B            CALL    L1BEE           ; routine CHECK-END gives error if not at end
10033   1FDE                                             ; of statement
10034   1FDE C9                  RET                     ; and return >>>
10035   1FDF             
10036   1FDF             ; ------------------------------------
10037   1FDF             ; this subroutine is called from above
10038   1FDF             ; and also from INPUT.
10039   1FDF             
10040   1FDF             ;; PRINT-2
10041   1FDF DF          L1FDF:   RST     18H             ; GET-CHAR gets printable character
10042   1FE0 CD 45 20            CALL    L2045           ; routine PR-END-Z checks if more printing
10043   1FE3 28 0D               JR      Z,L1FF2         ; to PRINT-4 if not     e.g. just 'PRINT :'
10044   1FE5             
10045   1FE5             ; This tight loop deals with combinations of positional controls and
10046   1FE5             ; print items. An early return can be made from within the loop
10047   1FE5             ; if the end of a print sequence is reached.
10048   1FE5             
10049   1FE5             ;; PRINT-3
10050   1FE5 CD 4E 20    L1FE5:   CALL    L204E           ; routine PR-POSN-1 returns zero if more
10051   1FE8                                             ; but returns early at this point if
10052   1FE8                                             ; at end of statement!
10053   1FE8                                             ; 
10054   1FE8 28 FB               JR      Z,L1FE5         ; to PRINT-3 if consecutive positioners
10055   1FEA             
10056   1FEA CD FC 1F            CALL    L1FFC           ; routine PR-ITEM-1 deals with strings etc.
10057   1FED CD 4E 20            CALL    L204E           ; routine PR-POSN-1 for more position codes
10058   1FF0 28 F3               JR      Z,L1FE5         ; loop back to PRINT-3 if so
10059   1FF2             
10060   1FF2             ;; PRINT-4
10061   1FF2 FE 29       L1FF2:   CP      $29             ; return now if this is ')' from input-item.
10062   1FF4                                             ; (see INPUT.)
10063   1FF4 C8                  RET     Z               ; or continue and print carriage return in
10064   1FF5                                             ; runtime
10065   1FF5             
10066   1FF5             ; ---------------------
10067   1FF5             ; Print carriage return
10068   1FF5             ; ---------------------
10069   1FF5             ; This routine which continues from above prints a carriage return
10070   1FF5             ; in run-time. It is also called once from PRINT-POSN.
10071   1FF5             
10072   1FF5             ;; PRINT-CR
10073   1FF5 CD C3 1F    L1FF5:   CALL    L1FC3           ; routine UNSTACK-Z
10074   1FF8             
10075   1FF8 3E 0D               LD      A,$0D           ; prepare a carriage return
10076   1FFA             
10077   1FFA D7                  RST     10H             ; PRINT-A
10078   1FFB C9                  RET                     ; return
10079   1FFC             
10080   1FFC             
10081   1FFC             ; -----------
10082   1FFC             ; Print items
10083   1FFC             ; -----------
10084   1FFC             ; This routine deals with print items as in
10085   1FFC             ; PRINT AT 10,0;"The value of A is ";a
10086   1FFC             ; It returns once a single item has been dealt with as it is part
10087   1FFC             ; of a tight loop that considers sequences of positional and print items
10088   1FFC             
10089   1FFC             ;; PR-ITEM-1
10090   1FFC DF          L1FFC:   RST     18H             ; GET-CHAR
10091   1FFD FE AC               CP      $AC             ; is character 'AT' ?
10092   1FFF 20 0D               JR      NZ,L200E        ; forward to PR-ITEM-2 if not.
10093   2001             
10094   2001 CD 79 1C            CALL    L1C79           ; routine NEXT-2NUM  check for two comma 
10095   2004                                             ; separated numbers placing them on the 
10096   2004                                             ; calculator stack in runtime. 
10097   2004 CD C3 1F            CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
10098   2007             
10099   2007 CD 07 23            CALL    L2307           ; routine STK-TO-BC get the numbers in B and C.
10100   200A 3E 16               LD      A,$16           ; prepare the 'at' control.
10101   200C 18 10               JR      L201E           ; forward to PR-AT-TAB to print the sequence.
10102   200E             
10103   200E             ; ---
10104   200E             
10105   200E             ;; PR-ITEM-2
10106   200E FE AD       L200E:   CP      $AD             ; is character 'TAB' ?
10107   2010 20 12               JR      NZ,L2024        ; to PR-ITEM-3 if not
10108   2012             
10109   2012             
10110   2012 E7                  RST     20H             ; NEXT-CHAR to address next character
10111   2013 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM
10112   2016 CD C3 1F            CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
10113   2019             
10114   2019 CD 99 1E            CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
10115   201C 3E 17               LD      A,$17           ; prepare the 'tab' control.
10116   201E             
10117   201E             ;; PR-AT-TAB
10118   201E D7          L201E:   RST     10H             ; PRINT-A outputs the control
10119   201F             
10120   201F 79                  LD      A,C             ; first value to A
10121   2020 D7                  RST     10H             ; PRINT-A outputs it.
10122   2021             
10123   2021 78                  LD      A,B             ; second value
10124   2022 D7                  RST     10H             ; PRINT-A
10125   2023             
10126   2023 C9                  RET                     ; return - item finished >>>
10127   2024             
10128   2024             ; ---
10129   2024             
10130   2024             ; Now consider paper 2; #2; a$
10131   2024             
10132   2024             ;; PR-ITEM-3
10133   2024 CD F2 21    L2024:   CALL    L21F2           ; routine CO-TEMP-3 will print any colour
10134   2027 D0                  RET     NC              ; items - return if success.
10135   2028             
10136   2028 CD 70 20            CALL    L2070           ; routine STR-ALTER considers new stream
10137   202B D0                  RET     NC              ; return if altered.
10138   202C             
10139   202C CD FB 24            CALL    L24FB           ; routine SCANNING now to evaluate expression
10140   202F CD C3 1F            CALL    L1FC3           ; routine UNSTACK-Z if not runtime.
10141   2032             
10142   2032 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
10143   2036 CC F1 2B            CALL    Z,L2BF1         ; routine STK-FETCH if string.
10144   2039                                             ; note no flags affected.
10145   2039 C2 E3 2D            JP      NZ,L2DE3        ; to PRINT-FP to print if numeric >>>
10146   203C             
10147   203C             ; It was a string expression - start in DE, length in BC
10148   203C             ; Now enter a loop to print it
10149   203C             
10150   203C             ;; PR-STRING
10151   203C 78          L203C:   LD      A,B             ; this tests if the
10152   203D B1                  OR      C               ; length is zero and sets flag accordingly.
10153   203E 0B                  DEC     BC              ; this doesn't but decrements counter.
10154   203F C8                  RET     Z               ; return if zero.
10155   2040             
10156   2040 1A                  LD      A,(DE)          ; fetch character.
10157   2041 13                  INC     DE              ; address next location.
10158   2042             
10159   2042 D7                  RST     10H             ; PRINT-A.
10160   2043             
10161   2043 18 F7               JR      L203C           ; loop back to PR-STRING.
10162   2045             
10163   2045             ; ---------------
10164   2045             ; End of printing
10165   2045             ; ---------------
10166   2045             ; This subroutine returns zero if no further printing is required
10167   2045             ; in the current statement.
10168   2045             ; The first terminator is found in  escaped input items only,
10169   2045             ; the others in print_items.
10170   2045             
10171   2045             ;; PR-END-Z
10172   2045 FE 29       L2045:   CP      $29             ; is character a ')' ?
10173   2047 C8                  RET     Z               ; return if so -        e.g. INPUT (p$); a$
10174   2048             
10175   2048             ;; PR-ST-END
10176   2048 FE 0D       L2048:   CP      $0D             ; is it a carriage return ?
10177   204A C8                  RET     Z               ; return also -         e.g. PRINT a
10178   204B             
10179   204B FE 3A               CP      $3A             ; is character a ':' ?
10180   204D C9                  RET                     ; return - zero flag will be set if so.
10181   204E                                             ;                       e.g. PRINT a :
10182   204E             
10183   204E             ; --------------
10184   204E             ; Print position
10185   204E             ; --------------
10186   204E             ; This routine considers a single positional character ';', ',', '''
10187   204E             
10188   204E             ;; PR-POSN-1
10189   204E DF          L204E:   RST     18H             ; GET-CHAR
10190   204F FE 3B               CP      $3B             ; is it ';' ?             
10191   2051                                             ; i.e. print from last position.
10192   2051 28 14               JR      Z,L2067         ; forward to PR-POSN-3 if so.
10193   2053                                             ; i.e. do nothing.
10194   2053             
10195   2053 FE 2C               CP      $2C             ; is it ',' ?
10196   2055                                             ; i.e. print at next tabstop.
10197   2055 20 0A               JR      NZ,L2061        ; forward to PR-POSN-2 if anything else.
10198   2057             
10199   2057 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
10200   205A 28 0B               JR      Z,L2067         ; forward to PR-POSN-3 if checking syntax.
10201   205C             
10202   205C 3E 06               LD      A,$06           ; prepare the 'comma' control character.
10203   205E             
10204   205E D7                  RST     10H             ; PRINT-A  outputs to current channel in
10205   205F                                             ; run-time.
10206   205F             
10207   205F 18 06               JR      L2067           ; skip to PR-POSN-3.
10208   2061             
10209   2061             ; ---
10210   2061             
10211   2061             ; check for newline.
10212   2061             
10213   2061             ;; PR-POSN-2
10214   2061 FE 27       L2061:   CP      $27             ; is character a "'" ? (newline)
10215   2063 C0                  RET     NZ              ; return if no match              >>>
10216   2064             
10217   2064 CD F5 1F            CALL    L1FF5           ; routine PRINT-CR outputs a carriage return
10218   2067                                             ; in runtime only.
10219   2067             
10220   2067             ;; PR-POSN-3
10221   2067 E7          L2067:   RST     20H             ; NEXT-CHAR to A.
10222   2068 CD 45 20            CALL    L2045           ; routine PR-END-Z checks if at end.
10223   206B 20 01               JR      NZ,L206E        ; to PR-POSN-4 if not.
10224   206D             
10225   206D C1                  POP     BC              ; drop return address if at end.
10226   206E             
10227   206E             ;; PR-POSN-4
10228   206E BF          L206E:   CP      A               ; reset the zero flag.
10229   206F C9                  RET                     ; and return to loop or quit.
10230   2070             
10231   2070             ; ------------
10232   2070             ; Alter stream
10233   2070             ; ------------
10234   2070             ; This routine is called from PRINT ITEMS above, and also LIST as in
10235   2070             ; LIST #15
10236   2070             
10237   2070             ;; STR-ALTER
10238   2070 FE 23       L2070:   CP      $23             ; is character '#' ?
10239   2072 37                  SCF                     ; set carry flag.
10240   2073 C0                  RET     NZ              ; return if no match.
10241   2074             
10242   2074             
10243   2074 E7                  RST      20H            ; NEXT-CHAR
10244   2075 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM gets stream number
10245   2078 A7                  AND     A               ; prepare to exit early with carry reset
10246   2079 CD C3 1F            CALL    L1FC3           ; routine UNSTACK-Z exits early if parsing
10247   207C CD 94 1E            CALL    L1E94           ; routine FIND-INT1 gets number off stack
10248   207F FE 10               CP      $10             ; must be range 0 - 15 decimal.
10249   2081 D2 0E 16            JP      NC,L160E        ; jump back to REPORT-Oa if not
10250   2084                                             ; 'Invalid stream'.
10251   2084             
10252   2084 CD 01 16            CALL    L1601           ; routine CHAN-OPEN
10253   2087 A7                  AND     A               ; clear carry - signal item dealt with.
10254   2088 C9                  RET                     ; return
10255   2089             
10256   2089             ; -------------------
10257   2089             ; THE 'INPUT' COMMAND 
10258   2089             ; -------------------
10259   2089             ; This command is mysterious.
10260   2089             ;
10261   2089             
10262   2089             ;; INPUT
10263   2089 CD 30 25    L2089:   CALL    L2530           ; routine SYNTAX-Z to check if in runtime.
10264   208C             
10265   208C 28 08               JR      Z,L2096         ; forward to INPUT-1 if checking syntax.
10266   208E             
10267   208E 3E 01               LD      A,$01           ; select channel 'K' the keyboard for input.
10268   2090 CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens the channel and sets
10269   2093                                             ; bit 0 of TV_FLAG.
10270   2093             
10271   2093             ;   Note. As a consequence of clearing the lower screen channel 0 is made 
10272   2093             ;   the current channel so the above two instructions are superfluous.
10273   2093             
10274   2093 CD 6E 0D            CALL    L0D6E           ; routine CLS-LOWER clears the lower screen
10275   2096                                             ; and sets DF_SZ to two and TV_FLAG to $01.
10276   2096             
10277   2096             ;; INPUT-1
10278   2096 FD 36 02 01 L2096:   LD      (IY+$02),$01    ; update TV_FLAG - signal lower screen in use
10279   209A                                             ; ensuring that the correct set of system 
10280   209A                                             ; variables are updated and that the border 
10281   209A                                             ; colour is used. 
10282   209A             
10283   209A             ;   Note. The Complete Spectrum ROM Disassembly incorrectly names DF-SZ as the
10284   209A             ;   system variable that is updated above and if, as some have done, you make 
10285   209A             ;   this unnecessary alteration then there will be two blank lines between the
10286   209A             ;   lower screen and the upper screen areas which will also scroll wrongly.
10287   209A             
10288   209A CD C1 20            CALL    L20C1           ; routine IN-ITEM-1 to handle the input.
10289   209D             
10290   209D CD EE 1B            CALL    L1BEE           ; routine CHECK-END will make an early exit
10291   20A0                                             ; if checking syntax. >>>
10292   20A0             
10293   20A0             ;   Keyboard input has been made and it remains to adjust the upper
10294   20A0             ;   screen in case the lower two lines have been extended upwards.
10295   20A0             
10296   20A0 ED 4B 88 5C         LD      BC,($5C88)      ; fetch S_POSN current line/column of
10297   20A4                                             ; the upper screen.
10298   20A4 3A 6B 5C            LD      A,($5C6B)       ; fetch DF_SZ the display file size of
10299   20A7                                             ; the lower screen.
10300   20A7 B8                  CP      B               ; test that lower screen does not overlap
10301   20A8 38 03               JR      C,L20AD         ; forward to INPUT-2 if not.
10302   20AA             
10303   20AA             ; the two screens overlap so adjust upper screen.
10304   20AA             
10305   20AA 0E 21               LD      C,$21           ; set column of upper screen to leftmost.
10306   20AC 47                  LD      B,A             ; and line to one above lower screen.
10307   20AD                                             ; continue forward to update upper screen
10308   20AD                                             ; print position.
10309   20AD             
10310   20AD             ;; INPUT-2
10311   20AD ED 43 88 5C L20AD:   LD      ($5C88),BC      ; set S_POSN update upper screen line/column.
10312   20B1 3E 19               LD      A,$19           ; subtract from twenty five
10313   20B3 90                  SUB     B               ; the new line number.
10314   20B4 32 8C 5C            LD      ($5C8C),A       ; and place result in SCR_CT - scroll count.
10315   20B7 FD CB 02 86         RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use.
10316   20BB             
10317   20BB CD D9 0D            CALL    L0DD9           ; routine CL-SET sets the print position
10318   20BE                                             ; system variables for the upper screen.
10319   20BE             
10320   20BE C3 6E 0D            JP      L0D6E           ; jump back to CLS-LOWER and make
10321   20C1                                             ; an indirect exit >>.
10322   20C1             
10323   20C1             ; ---------------------
10324   20C1             ; INPUT ITEM subroutine
10325   20C1             ; ---------------------
10326   20C1             ;   This subroutine deals with the input items and print items.
10327   20C1             ;   from  the current input channel.
10328   20C1             ;   It is only called from the above INPUT routine but was obviously
10329   20C1             ;   once called from somewhere else in another context.
10330   20C1             
10331   20C1             ;; IN-ITEM-1
10332   20C1 CD 4E 20    L20C1:   CALL    L204E           ; routine PR-POSN-1 deals with a single
10333   20C4                                             ; position item at each call.
10334   20C4 28 FB               JR      Z,L20C1         ; back to IN-ITEM-1 until no more in a
10335   20C6                                             ; sequence.
10336   20C6             
10337   20C6 FE 28               CP      $28             ; is character '(' ?
10338   20C8 20 0E               JR      NZ,L20D8        ; forward to IN-ITEM-2 if not.
10339   20CA             
10340   20CA             ;   any variables within braces will be treated as part, or all, of the prompt
10341   20CA             ;   instead of being used as destination variables.
10342   20CA             
10343   20CA E7                  RST     20H             ; NEXT-CHAR
10344   20CB CD DF 1F            CALL    L1FDF           ; routine PRINT-2 to output the dynamic
10345   20CE                                             ; prompt.
10346   20CE             
10347   20CE DF                  RST     18H             ; GET-CHAR
10348   20CF FE 29               CP      $29             ; is character a matching ')' ?
10349   20D1 C2 8A 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not.
10350   20D4                                             ; 'Nonsense in BASIC'.
10351   20D4             
10352   20D4 E7                  RST     20H             ; NEXT-CHAR
10353   20D5 C3 B2 21            JP      L21B2           ; forward to IN-NEXT-2
10354   20D8             
10355   20D8             ; ---
10356   20D8             
10357   20D8             ;; IN-ITEM-2
10358   20D8 FE CA       L20D8:   CP      $CA             ; is the character the token 'LINE' ?
10359   20DA 20 11               JR      NZ,L20ED        ; forward to IN-ITEM-3 if not.
10360   20DC             
10361   20DC E7                  RST     20H             ; NEXT-CHAR - variable must come next.
10362   20DD CD 1F 1C            CALL    L1C1F           ; routine CLASS-01 returns destination
10363   20E0                                             ; address of variable to be assigned.
10364   20E0                                             ; or generates an error if no variable
10365   20E0                                             ; at this position.
10366   20E0             
10367   20E0 FD CB 37 FE         SET     7,(IY+$37)      ; update FLAGX  - signal handling INPUT LINE
10368   20E4 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS  - numeric or string result ?
10369   20E8 C2 8A 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not string
10370   20EB                                             ; 'Nonsense in BASIC'.
10371   20EB             
10372   20EB 18 0D               JR      L20FA           ; forward to IN-PROMPT to set up workspace.
10373   20ED             
10374   20ED             ; ---
10375   20ED             
10376   20ED             ;   the jump was here for other variables.
10377   20ED             
10378   20ED             ;; IN-ITEM-3
10379   20ED CD 8D 2C    L20ED:   CALL     L2C8D          ; routine ALPHA checks if character is
10380   20F0                                             ; a suitable variable name.
10381   20F0 D2 AF 21            JP      NC,L21AF        ; forward to IN-NEXT-1 if not
10382   20F3             
10383   20F3 CD 1F 1C            CALL    L1C1F           ; routine CLASS-01 returns destination
10384   20F6                                             ; address of variable to be assigned.
10385   20F6 FD CB 37 BE         RES     7,(IY+$37)      ; update FLAGX  - signal not INPUT LINE.
10386   20FA             
10387   20FA             ;; IN-PROMPT
10388   20FA CD 30 25    L20FA:   CALL    L2530           ; routine SYNTAX-Z
10389   20FD CA B2 21            JP      Z,L21B2         ; forward to IN-NEXT-2 if checking syntax.
10390   2100             
10391   2100 CD BF 16            CALL    L16BF           ; routine SET-WORK clears workspace.
10392   2103 21 71 5C            LD      HL,$5C71        ; point to system variable FLAGX
10393   2106 CB B6               RES     6,(HL)          ; signal string result.
10394   2108 CB EE               SET     5,(HL)          ; signal in Input Mode for editor.
10395   210A 01 01 00            LD      BC,$0001        ; initialize space required to one for
10396   210D                                             ; the carriage return.
10397   210D CB 7E               BIT     7,(HL)          ; test FLAGX - INPUT LINE in use ?
10398   210F 20 0B               JR      NZ,L211C        ; forward to IN-PR-2 if so as that is
10399   2111                                             ; all the space that is required.
10400   2111             
10401   2111 3A 3B 5C            LD      A,($5C3B)       ; load accumulator from FLAGS
10402   2114 E6 40               AND     $40             ; mask to test BIT 6 of FLAGS and clear
10403   2116                                             ; the other bits in A.
10404   2116                                             ; numeric result expected ?
10405   2116 20 02               JR      NZ,L211A        ; forward to IN-PR-1 if so
10406   2118             
10407   2118 0E 03               LD      C,$03           ; increase space to three bytes for the
10408   211A                                             ; pair of surrounding quotes.
10409   211A             
10410   211A             ;; IN-PR-1
10411   211A B6          L211A:   OR      (HL)            ; if numeric result, set bit 6 of FLAGX.
10412   211B 77                  LD      (HL),A          ; and update system variable
10413   211C             
10414   211C             ;; IN-PR-2
10415   211C F7          L211C:   RST     30H             ; BC-SPACES opens 1 or 3 bytes in workspace
10416   211D 36 0D               LD      (HL),$0D        ; insert carriage return at last new location.
10417   211F 79                  LD      A,C             ; fetch the length, one or three.
10418   2120 0F                  RRCA                    ; lose bit 0.
10419   2121 0F                  RRCA                    ; test if quotes required.
10420   2122 30 05               JR      NC,L2129        ; forward to IN-PR-3 if not.
10421   2124             
10422   2124 3E 22               LD      A,$22           ; load the '"' character
10423   2126 12                  LD      (DE),A          ; place quote in first new location at DE.
10424   2127 2B                  DEC     HL              ; decrease HL - from carriage return.
10425   2128 77                  LD      (HL),A          ; and place a quote in second location.
10426   2129             
10427   2129             ;; IN-PR-3
10428   2129 22 5B 5C    L2129:   LD      ($5C5B),HL      ; set keyboard cursor K_CUR to HL
10429   212C FD CB 37 7E         BIT     7,(IY+$37)      ; test FLAGX  - is this INPUT LINE ??
10430   2130 20 2C               JR      NZ,L215E        ; forward to IN-VAR-3 if so as input will
10431   2132                                             ; be accepted without checking its syntax.
10432   2132             
10433   2132 2A 5D 5C            LD      HL,($5C5D)      ; fetch CH_ADD
10434   2135 E5                  PUSH    HL              ; and save on stack.
10435   2136 2A 3D 5C            LD      HL,($5C3D)      ; fetch ERR_SP
10436   2139 E5                  PUSH    HL              ; and save on stack
10437   213A             
10438   213A             ;; IN-VAR-1
10439   213A 21 3A 21    L213A:   LD      HL,L213A        ; address: IN-VAR-1 - this address
10440   213D E5                  PUSH    HL              ; is saved on stack to handle errors.
10441   213E FD CB 30 66         BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
10442   2142 28 04               JR      Z,L2148         ; forward to IN-VAR-2 if not using the
10443   2144                                             ; keyboard for input. (??)
10444   2144             
10445   2144 ED 73 3D 5C         LD      ($5C3D),SP      ; set ERR_SP to point to IN-VAR-1 on stack.
10446   2148             
10447   2148             ;; IN-VAR-2
10448   2148 2A 61 5C    L2148:   LD      HL,($5C61)      ; set HL to WORKSP - start of workspace.
10449   214B CD A7 11            CALL    L11A7           ; routine REMOVE-FP removes floating point
10450   214E                                             ; forms when looping in error condition.
10451   214E FD 36 00 FF         LD      (IY+$00),$FF    ; set ERR_NR to 'OK' cancelling the error.
10452   2152                                             ; but X_PTR causes flashing error marker
10453   2152                                             ; to be displayed at each call to the editor.
10454   2152 CD 2C 0F            CALL    L0F2C           ; routine EDITOR allows input to be entered
10455   2155                                             ; or corrected if this is second time around.
10456   2155             
10457   2155             ; if we pass to next then there are no system errors
10458   2155             
10459   2155 FD CB 01 BE         RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax
10460   2159 CD B9 21            CALL    L21B9           ; routine IN-ASSIGN checks syntax using
10461   215C                                             ; the VAL-FET-2 and powerful SCANNING routines.
10462   215C                                             ; any syntax error and its back to IN-VAR-1.
10463   215C                                             ; but with the flashing error marker showing
10464   215C                                             ; where the error is.
10465   215C                                             ; Note. the syntax of string input has to be
10466   215C                                             ; checked as the user may have removed the
10467   215C                                             ; bounding quotes or escaped them as with
10468   215C                                             ; "hat" + "stand" for example.
10469   215C             ; proceed if syntax passed.
10470   215C             
10471   215C 18 03               JR      L2161           ; jump forward to IN-VAR-4
10472   215E             
10473   215E             ; ---
10474   215E             
10475   215E             ; the jump was to here when using INPUT LINE.
10476   215E             
10477   215E             ;; IN-VAR-3
10478   215E CD 2C 0F    L215E:   CALL    L0F2C           ; routine EDITOR is called for input
10479   2161             
10480   2161             ; when ENTER received rejoin other route but with no syntax check.
10481   2161             
10482   2161             ; INPUT and INPUT LINE converge here.
10483   2161             
10484   2161             ;; IN-VAR-4
10485   2161 FD 36 22 00 L2161:   LD      (IY+$22),$00    ; set K_CUR_hi to a low value so that the cursor
10486   2165                                             ; no longer appears in the input line.
10487   2165             
10488   2165 CD D6 21            CALL    L21D6           ; routine IN-CHAN-K tests if the keyboard
10489   2168                                             ; is being used for input.
10490   2168 20 0A               JR      NZ,L2174        ; forward to IN-VAR-5 if using another input 
10491   216A                                             ; channel.
10492   216A             
10493   216A             ; continue here if using the keyboard.
10494   216A             
10495   216A CD 1D 11            CALL    L111D           ; routine ED-COPY overprints the edit line
10496   216D                                             ; to the lower screen. The only visible
10497   216D                                             ; affect is that the cursor disappears.
10498   216D                                             ; if you're inputting more than one item in
10499   216D                                             ; a statement then that becomes apparent.
10500   216D             
10501   216D ED 4B 82 5C         LD      BC,($5C82)      ; fetch line and column from ECHO_E
10502   2171 CD D9 0D            CALL    L0DD9           ; routine CL-SET sets S-POSNL to those
10503   2174                                             ; values.
10504   2174             
10505   2174             ; if using another input channel rejoin here.
10506   2174             
10507   2174             ;; IN-VAR-5
10508   2174 21 71 5C    L2174:   LD      HL,$5C71        ; point HL to FLAGX
10509   2177 CB AE               RES     5,(HL)          ; signal not in input mode
10510   2179 CB 7E               BIT     7,(HL)          ; is this INPUT LINE ?
10511   217B CB BE               RES     7,(HL)          ; cancel the bit anyway.
10512   217D 20 1C               JR      NZ,L219B        ; forward to IN-VAR-6 if INPUT LINE.
10513   217F             
10514   217F E1                  POP     HL              ; drop the looping address
10515   2180 E1                  POP     HL              ; drop the address of previous
10516   2181                                             ; error handler.
10517   2181 22 3D 5C            LD      ($5C3D),HL      ; set ERR_SP to point to it.
10518   2184 E1                  POP     HL              ; drop original CH_ADD which points to
10519   2185                                             ; INPUT command in BASIC line.
10520   2185 22 5F 5C            LD      ($5C5F),HL      ; save in X_PTR while input is assigned.
10521   2188 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS - Signal running program
10522   218C CD B9 21            CALL    L21B9           ; routine IN-ASSIGN is called again
10523   218F                                             ; this time the variable will be assigned
10524   218F                                             ; the input value without error.
10525   218F                                             ; Note. the previous example now
10526   218F                                             ; becomes "hatstand"
10527   218F             
10528   218F 2A 5F 5C            LD      HL,($5C5F)      ; fetch stored CH_ADD value from X_PTR.
10529   2192 FD 36 26 00         LD      (IY+$26),$00    ; set X_PTR_hi so that iy is no longer relevant.
10530   2196 22 5D 5C            LD      ($5C5D),HL      ; put restored value back in CH_ADD
10531   2199 18 17               JR      L21B2           ; forward to IN-NEXT-2 to see if anything
10532   219B                                             ; more in the INPUT list.
10533   219B             
10534   219B             ; ---
10535   219B             
10536   219B             ; the jump was to here with INPUT LINE only
10537   219B             
10538   219B             ;; IN-VAR-6
10539   219B 2A 63 5C    L219B:   LD      HL,($5C63)      ; STKBOT points to the end of the input.
10540   219E ED 5B 61 5C         LD      DE,($5C61)      ; WORKSP points to the beginning.
10541   21A2 37                  SCF                     ; prepare for true subtraction.
10542   21A3 ED 52               SBC     HL,DE           ; subtract to get length
10543   21A5 44                  LD      B,H             ; transfer it to
10544   21A6 4D                  LD      C,L             ; the BC register pair.
10545   21A7 CD B2 2A            CALL    L2AB2           ; routine STK-STO-$ stores parameters on
10546   21AA                                             ; the calculator stack.
10547   21AA CD FF 2A            CALL    L2AFF           ; routine LET assigns it to destination.
10548   21AD 18 03               JR      L21B2           ; forward to IN-NEXT-2 as print items
10549   21AF                                             ; not allowed with INPUT LINE.
10550   21AF                                             ; Note. that "hat" + "stand" will, for
10551   21AF                                             ; example, be unchanged as also would
10552   21AF                                             ; 'PRINT "Iris was here"'.
10553   21AF             
10554   21AF             ; ---
10555   21AF             
10556   21AF             ; the jump was to here when ALPHA found more items while looking for
10557   21AF             ; a variable name.
10558   21AF             
10559   21AF             ;; IN-NEXT-1
10560   21AF CD FC 1F    L21AF:   CALL    L1FFC           ; routine PR-ITEM-1 considers further items.
10561   21B2             
10562   21B2             ;; IN-NEXT-2
10563   21B2 CD 4E 20    L21B2:   CALL    L204E           ; routine PR-POSN-1 handles a position item.
10564   21B5 CA C1 20            JP      Z,L20C1         ; jump back to IN-ITEM-1 if the zero flag
10565   21B8                                             ; indicates more items are present.
10566   21B8             
10567   21B8 C9                  RET                     ; return.
10568   21B9             
10569   21B9             ; ---------------------------
10570   21B9             ; INPUT ASSIGNMENT Subroutine
10571   21B9             ; ---------------------------
10572   21B9             ; This subroutine is called twice from the INPUT command when normal
10573   21B9             ; keyboard input is assigned. On the first occasion syntax is checked
10574   21B9             ; using SCANNING. The final call with the syntax flag reset is to make
10575   21B9             ; the assignment.
10576   21B9             
10577   21B9             ;; IN-ASSIGN
10578   21B9 2A 61 5C    L21B9:   LD      HL,($5C61)      ; fetch WORKSP start of input
10579   21BC 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to first character
10580   21BF             
10581   21BF DF                  RST     18H             ; GET-CHAR ignoring leading white-space.
10582   21C0 FE E2               CP      $E2             ; is it 'STOP'
10583   21C2 28 0C               JR      Z,L21D0         ; forward to IN-STOP if so.
10584   21C4             
10585   21C4 3A 71 5C            LD      A,($5C71)       ; load accumulator from FLAGX
10586   21C7 CD 59 1C            CALL    L1C59           ; routine VAL-FET-2 makes assignment
10587   21CA                                             ; or goes through the motions if checking
10588   21CA                                             ; syntax. SCANNING is used.
10589   21CA             
10590   21CA DF                  RST     18H             ; GET-CHAR
10591   21CB FE 0D               CP      $0D             ; is it carriage return ?
10592   21CD C8                  RET     Z               ; return if so
10593   21CE                                             ; either syntax is OK
10594   21CE                                             ; or assignment has been made.
10595   21CE             
10596   21CE             ; if another character was found then raise an error.
10597   21CE             ; User doesn't see report but the flashing error marker
10598   21CE             ; appears in the lower screen.
10599   21CE             
10600   21CE             ;; REPORT-Cb
10601   21CE CF          L21CE:   RST     08H             ; ERROR-1
10602   21CF 0B                  DEFB    $0B             ; Error Report: Nonsense in BASIC
10603   21D0             
10604   21D0             ;; IN-STOP
10605   21D0 CD 30 25    L21D0:   CALL    L2530           ; routine SYNTAX-Z (UNSTACK-Z?)
10606   21D3 C8                  RET     Z               ; return if checking syntax
10607   21D4                                             ; as user wouldn't see error report.
10608   21D4                                             ; but generate visible error report
10609   21D4                                             ; on second invocation.
10610   21D4             
10611   21D4             ;; REPORT-H
10612   21D4 CF          L21D4:   RST     08H             ; ERROR-1
10613   21D5 10                  DEFB    $10             ; Error Report: STOP in INPUT
10614   21D6             
10615   21D6             ; -----------------------------------
10616   21D6             ; THE 'TEST FOR CHANNEL K' SUBROUTINE
10617   21D6             ; -----------------------------------
10618   21D6             ;   This subroutine is called once from the keyboard INPUT command to check if 
10619   21D6             ;   the input routine in use is the one for the keyboard.
10620   21D6             
10621   21D6             ;; IN-CHAN-K
10622   21D6 2A 51 5C    L21D6:   LD      HL,($5C51)      ; fetch address of current channel CURCHL
10623   21D9 23                  INC     HL              ;
10624   21DA 23                  INC     HL              ; advance past
10625   21DB 23                  INC     HL              ; input and
10626   21DC 23                  INC     HL              ; output streams
10627   21DD 7E                  LD      A,(HL)          ; fetch the channel identifier.
10628   21DE FE 4B               CP      $4B             ; test for 'K'
10629   21E0 C9                  RET                     ; return with zero set if keyboard is use.
10630   21E1             
10631   21E1             ; --------------------
10632   21E1             ; Colour Item Routines
10633   21E1             ; --------------------
10634   21E1             ;
10635   21E1             ; These routines have 3 entry points -
10636   21E1             ; 1) CO-TEMP-2 to handle a series of embedded Graphic colour items.
10637   21E1             ; 2) CO-TEMP-3 to handle a single embedded print colour item.
10638   21E1             ; 3) CO TEMP-4 to handle a colour command such as FLASH 1
10639   21E1             ;
10640   21E1             ; "Due to a bug, if you bring in a peripheral channel and later use a colour
10641   21E1             ;  statement, colour controls will be sent to it by mistake." - Steven Vickers
10642   21E1             ;  Pitman Pocket Guide, 1984.
10643   21E1             ;
10644   21E1             ; To be fair, this only applies if the last channel was other than 'K', 'S'
10645   21E1             ; or 'P', which are all that are supported by this ROM, but if that last
10646   21E1             ; channel was a microdrive file, network channel etc. then
10647   21E1             ; PAPER 6; CLS will not turn the screen yellow and
10648   21E1             ; CIRCLE INK 2; 128,88,50 will not draw a red circle.
10649   21E1             ;
10650   21E1             ; This bug does not apply to embedded PRINT items as it is quite permissible
10651   21E1             ; to mix stream altering commands and colour items.
10652   21E1             ; The fix therefore would be to ensure that CLASS-07 and CLASS-09 make
10653   21E1             ; channel 'S' the current channel when not checking syntax.
10654   21E1             ; -----------------------------------------------------------------
10655   21E1             
10656   21E1             ;; CO-TEMP-1
10657   21E1 E7          L21E1:   RST     20H             ; NEXT-CHAR
10658   21E2             
10659   21E2             ; -> Entry point from CLASS-09. Embedded Graphic colour items.
10660   21E2             ; e.g. PLOT INK 2; PAPER 8; 128,88
10661   21E2             ; Loops till all colour items output, finally addressing the coordinates.
10662   21E2             
10663   21E2             ;; CO-TEMP-2
10664   21E2 CD F2 21    L21E2:   CALL    L21F2           ; routine CO-TEMP-3 to output colour control.
10665   21E5 D8                  RET     C               ; return if nothing more to output. ->
10666   21E6             
10667   21E6             
10668   21E6 DF                  RST     18H             ; GET-CHAR
10669   21E7 FE 2C               CP      $2C             ; is it ',' separator ?
10670   21E9 28 F6               JR      Z,L21E1         ; back if so to CO-TEMP-1
10671   21EB             
10672   21EB FE 3B               CP      $3B             ; is it ';' separator ?
10673   21ED 28 F2               JR      Z,L21E1         ; back to CO-TEMP-1 for more.
10674   21EF             
10675   21EF C3 8A 1C            JP      L1C8A           ; to REPORT-C (REPORT-Cb is within range)
10676   21F2                                             ; 'Nonsense in BASIC'
10677   21F2             
10678   21F2             ; -------------------
10679   21F2             ; CO-TEMP-3
10680   21F2             ; -------------------
10681   21F2             ; -> this routine evaluates and outputs a colour control and parameter.
10682   21F2             ; It is called from above and also from PR-ITEM-3 to handle a single embedded
10683   21F2             ; print item e.g. PRINT PAPER 6; "Hi". In the latter case, the looping for
10684   21F2             ; multiple items is within the PR-ITEM routine.
10685   21F2             ; It is quite permissible to send these to any stream.
10686   21F2             
10687   21F2             ;; CO-TEMP-3
10688   21F2 FE D9       L21F2:   CP      $D9             ; is it 'INK' ?
10689   21F4 D8                  RET     C               ; return if less.
10690   21F5             
10691   21F5 FE DF               CP      $DF             ; compare with 'OUT'
10692   21F7 3F                  CCF                     ; Complement Carry Flag
10693   21F8 D8                  RET     C               ; return if greater than 'OVER', $DE.
10694   21F9             
10695   21F9 F5                  PUSH    AF              ; save the colour token.
10696   21FA             
10697   21FA E7                  RST     20H             ; address NEXT-CHAR
10698   21FB F1                  POP     AF              ; restore token and continue.
10699   21FC             
10700   21FC             ; -> this entry point used by CLASS-07. e.g. the command PAPER 6.
10701   21FC             
10702   21FC             ;; CO-TEMP-4
10703   21FC D6 C9       L21FC:   SUB     $C9             ; reduce to control character $10 (INK)
10704   21FE                                             ; thru $15 (OVER).
10705   21FE F5                  PUSH    AF              ; save control.
10706   21FF CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM stacks addressed
10707   2202                                             ; parameter on calculator stack.
10708   2202 F1                  POP     AF              ; restore control.
10709   2203 A7                  AND     A               ; clear carry
10710   2204             
10711   2204 CD C3 1F            CALL    L1FC3           ; routine UNSTACK-Z returns if checking syntax.
10712   2207             
10713   2207 F5                  PUSH    AF              ; save again
10714   2208 CD 94 1E            CALL    L1E94           ; routine FIND-INT1 fetches parameter to A.
10715   220B 57                  LD      D,A             ; transfer now to D
10716   220C F1                  POP     AF              ; restore control.
10717   220D             
10718   220D D7                  RST     10H             ; PRINT-A outputs the control to current
10719   220E                                             ; channel.
10720   220E 7A                  LD      A,D             ; transfer parameter to A.
10721   220F             
10722   220F D7                  RST     10H             ; PRINT-A outputs parameter.
10723   2210 C9                  RET                     ; return. ->
10724   2211             
10725   2211             ; -------------------------------------------------------------------------
10726   2211             ;
10727   2211             ;         {fl}{br}{   paper   }{  ink    }    The temporary colour attributes
10728   2211             ;          ___ ___ ___ ___ ___ ___ ___ ___    system variable.
10729   2211             ; ATTR_T  |   |   |   |   |   |   |   |   |
10730   2211             ;         |   |   |   |   |   |   |   |   |
10731   2211             ; 23695   |___|___|___|___|___|___|___|___|
10732   2211             ;           7   6   5   4   3   2   1   0
10733   2211             ;
10734   2211             ;
10735   2211             ;         {fl}{br}{   paper   }{  ink    }    The temporary mask used for
10736   2211             ;          ___ ___ ___ ___ ___ ___ ___ ___    transparent colours. Any bit
10737   2211             ; MASK_T  |   |   |   |   |   |   |   |   |   that is 1 shows that the
10738   2211             ;         |   |   |   |   |   |   |   |   |   corresponding attribute is
10739   2211             ; 23696   |___|___|___|___|___|___|___|___|   taken not from ATTR-T but from
10740   2211             ;           7   6   5   4   3   2   1   0     what is already on the screen.
10741   2211             ;
10742   2211             ;
10743   2211             ;         {paper9 }{ ink9 }{ inv1 }{ over1}   The print flags. Even bits are
10744   2211             ;          ___ ___ ___ ___ ___ ___ ___ ___    temporary flags. The odd bits
10745   2211             ; P_FLAG  |   |   |   |   |   |   |   |   |   are the permanent flags.
10746   2211             ;         | p | t | p | t | p | t | p | t |
10747   2211             ; 23697   |___|___|___|___|___|___|___|___|
10748   2211             ;           7   6   5   4   3   2   1   0
10749   2211             ;
10750   2211             ; -----------------------------------------------------------------------
10751   2211             
10752   2211             ; ------------------------------------
10753   2211             ;  The colour system variable handler.
10754   2211             ; ------------------------------------
10755   2211             ; This is an exit branch from PO-1-OPER, PO-2-OPER
10756   2211             ; A holds control $10 (INK) to $15 (OVER)
10757   2211             ; D holds parameter 0-9 for ink/paper 0,1 or 8 for bright/flash,
10758   2211             ; 0 or 1 for over/inverse.
10759   2211             
10760   2211             ;; CO-TEMP-5
10761   2211 D6 11       L2211:   SUB     $11             ; reduce range $FF-$04
10762   2213 CE 00               ADC     A,$00           ; add in carry if INK
10763   2215 28 1D               JR      Z,L2234         ; forward to CO-TEMP-7 with INK and PAPER.
10764   2217             
10765   2217 D6 02               SUB     $02             ; reduce range $FF-$02
10766   2219 CE 00               ADC     A,$00           ; add carry if FLASH
10767   221B 28 56               JR      Z,L2273         ; forward to CO-TEMP-C with FLASH and BRIGHT.
10768   221D             
10769   221D FE 01               CP      $01             ; is it 'INVERSE' ?
10770   221F 7A                  LD      A,D             ; fetch parameter for INVERSE/OVER
10771   2220 06 01               LD      B,$01           ; prepare OVER mask setting bit 0.
10772   2222 20 04               JR      NZ,L2228        ; forward to CO-TEMP-6 if OVER
10773   2224             
10774   2224 07                  RLCA                    ; shift bit 0
10775   2225 07                  RLCA                    ; to bit 2
10776   2226 06 04               LD      B,$04           ; set bit 2 of mask for inverse.
10777   2228             
10778   2228             ;; CO-TEMP-6
10779   2228 4F          L2228:   LD      C,A             ; save the A
10780   2229 7A                  LD      A,D             ; re-fetch parameter
10781   222A FE 02               CP      $02             ; is it less than 2
10782   222C 30 16               JR      NC,L2244        ; to REPORT-K if not 0 or 1.
10783   222E                                             ; 'Invalid colour'.
10784   222E             
10785   222E 79                  LD      A,C             ; restore A
10786   222F 21 91 5C            LD      HL,$5C91        ; address system variable P_FLAG
10787   2232 18 38               JR      L226C           ; forward to exit via routine CO-CHANGE
10788   2234             
10789   2234             ; ---
10790   2234             
10791   2234             ; the branch was here with INK/PAPER and carry set for INK.
10792   2234             
10793   2234             ;; CO-TEMP-7
10794   2234 7A          L2234:   LD      A,D             ; fetch parameter
10795   2235 06 07               LD      B,$07           ; set ink mask 00000111
10796   2237 38 05               JR      C,L223E         ; forward to CO-TEMP-8 with INK
10797   2239             
10798   2239 07                  RLCA                    ; shift bits 0-2
10799   223A 07                  RLCA                    ; to
10800   223B 07                  RLCA                    ; bits 3-5
10801   223C 06 38               LD      B,$38           ; set paper mask 00111000
10802   223E             
10803   223E             ; both paper and ink rejoin here
10804   223E             
10805   223E             ;; CO-TEMP-8
10806   223E 4F          L223E:   LD      C,A             ; value to C
10807   223F 7A                  LD      A,D             ; fetch parameter
10808   2240 FE 0A               CP      $0A             ; is it less than 10d ?
10809   2242 38 02               JR      C,L2246         ; forward to CO-TEMP-9 if so.
10810   2244             
10811   2244             ; ink 10 etc. is not allowed.
10812   2244             
10813   2244             ;; REPORT-K
10814   2244 CF          L2244:   RST     08H             ; ERROR-1
10815   2245 13                  DEFB    $13             ; Error Report: Invalid colour
10816   2246             
10817   2246             ;; CO-TEMP-9
10818   2246 21 8F 5C    L2246:   LD      HL,$5C8F        ; address system variable ATTR_T initially.
10819   2249 FE 08               CP      $08             ; compare with 8
10820   224B 38 0B               JR      C,L2258         ; forward to CO-TEMP-B with 0-7.
10821   224D             
10822   224D 7E                  LD      A,(HL)          ; fetch temporary attribute as no change.
10823   224E 28 07               JR      Z,L2257         ; forward to CO-TEMP-A with INK/PAPER 8
10824   2250             
10825   2250             ; it is either ink 9 or paper 9 (contrasting)
10826   2250             
10827   2250 B0                  OR      B               ; or with mask to make white
10828   2251 2F                  CPL                     ; make black and change other to dark
10829   2252 E6 24               AND     $24             ; 00100100
10830   2254 28 01               JR      Z,L2257         ; forward to CO-TEMP-A if black and
10831   2256                                             ; originally light.
10832   2256             
10833   2256 78                  LD      A,B             ; else just use the mask (white)
10834   2257             
10835   2257             ;; CO-TEMP-A
10836   2257 4F          L2257:   LD      C,A             ; save A in C
10837   2258             
10838   2258             ;; CO-TEMP-B
10839   2258 79          L2258:   LD      A,C             ; load colour to A
10840   2259 CD 6C 22            CALL    L226C           ; routine CO-CHANGE addressing ATTR-T
10841   225C             
10842   225C 3E 07               LD      A,$07           ; put 7 in accumulator
10843   225E BA                  CP      D               ; compare with parameter
10844   225F 9F                  SBC     A,A             ; $00 if 0-7, $FF if 8
10845   2260 CD 6C 22            CALL    L226C           ; routine CO-CHANGE addressing MASK-T
10846   2263                                             ; mask returned in A.
10847   2263             
10848   2263             ; now consider P-FLAG.
10849   2263             
10850   2263 07                  RLCA                    ; 01110000 or 00001110
10851   2264 07                  RLCA                    ; 11100000 or 00011100
10852   2265 E6 50               AND     $50             ; 01000000 or 00010000  (AND 01010000)
10853   2267 47                  LD      B,A             ; transfer to mask
10854   2268 3E 08               LD      A,$08           ; load A with 8
10855   226A BA                  CP      D               ; compare with parameter
10856   226B 9F                  SBC     A,A             ; $FF if was 9,  $00 if 0-8
10857   226C                                             ; continue while addressing P-FLAG
10858   226C                                             ; setting bit 4 if ink 9
10859   226C                                             ; setting bit 6 if paper 9
10860   226C             
10861   226C             ; -----------------------
10862   226C             ; Handle change of colour
10863   226C             ; -----------------------
10864   226C             ; This routine addresses a system variable ATTR_T, MASK_T or P-FLAG in HL.
10865   226C             ; colour value in A, mask in B.
10866   226C             
10867   226C             ;; CO-CHANGE
10868   226C AE          L226C:   XOR     (HL)            ; impress bits specified
10869   226D A0                  AND     B               ; by mask
10870   226E AE                  XOR     (HL)            ; on system variable.
10871   226F 77                  LD      (HL),A          ; update system variable.
10872   2270 23                  INC     HL              ; address next location.
10873   2271 78                  LD      A,B             ; put current value of mask in A
10874   2272 C9                  RET                     ; return.
10875   2273             
10876   2273             ; ---
10877   2273             
10878   2273             ; the branch was here with flash and bright
10879   2273             
10880   2273             ;; CO-TEMP-C
10881   2273 9F          L2273:   SBC     A,A             ; set zero flag for bright.
10882   2274 7A                  LD      A,D             ; fetch original parameter 0,1 or 8
10883   2275 0F                  RRCA                    ; rotate bit 0 to bit 7
10884   2276 06 80               LD      B,$80           ; mask for flash 10000000
10885   2278 20 03               JR      NZ,L227D        ; forward to CO-TEMP-D if flash
10886   227A             
10887   227A 0F                  RRCA                    ; rotate bit 7 to bit 6
10888   227B 06 40               LD      B,$40           ; mask for bright 01000000
10889   227D             
10890   227D             ;; CO-TEMP-D
10891   227D 4F          L227D:   LD      C,A             ; store value in C
10892   227E 7A                  LD      A,D             ; fetch parameter
10893   227F FE 08               CP      $08             ; compare with 8
10894   2281 28 04               JR      Z,L2287         ; forward to CO-TEMP-E if 8
10895   2283             
10896   2283 FE 02               CP      $02             ; test if 0 or 1
10897   2285 30 BD               JR      NC,L2244        ; back to REPORT-K if not
10898   2287                                             ; 'Invalid colour'
10899   2287             
10900   2287             ;; CO-TEMP-E
10901   2287 79          L2287:   LD      A,C             ; value to A
10902   2288 21 8F 5C            LD      HL,$5C8F        ; address ATTR_T
10903   228B CD 6C 22            CALL    L226C           ; routine CO-CHANGE addressing ATTR_T
10904   228E 79                  LD      A,C             ; fetch value
10905   228F 0F                  RRCA                    ; for flash8/bright8 complete
10906   2290 0F                  RRCA                    ; rotations to put set bit in
10907   2291 0F                  RRCA                    ; bit 7 (flash) bit 6 (bright)
10908   2292 18 D8               JR      L226C           ; back to CO-CHANGE addressing MASK_T
10909   2294                                             ; and indirect return.
10910   2294             
10911   2294             ; ---------------------
10912   2294             ; Handle BORDER command
10913   2294             ; ---------------------
10914   2294             ; Command syntax example: BORDER 7
10915   2294             ; This command routine sets the border to one of the eight colours.
10916   2294             ; The colours used for the lower screen are based on this.
10917   2294             
10918   2294             ;; BORDER
10919   2294 CD 94 1E    L2294:   CALL    L1E94           ; routine FIND-INT1
10920   2297 FE 08               CP      $08             ; must be in range 0 (black) to 7 (white)
10921   2299 30 A9               JR      NC,L2244        ; back to REPORT-K if not
10922   229B                                             ; 'Invalid colour'.
10923   229B             
10924   229B D3 FE               OUT     ($FE),A         ; outputting to port effects an immediate
10925   229D                                             ; change.
10926   229D 07                  RLCA                    ; shift the colour to
10927   229E 07                  RLCA                    ; the paper bits setting the
10928   229F 07                  RLCA                    ; ink colour black.
10929   22A0 CB 6F               BIT     5,A             ; is the number light coloured ?
10930   22A2                                             ; i.e. in the range green to white.
10931   22A2 20 02               JR      NZ,L22A6        ; skip to BORDER-1 if so
10932   22A4             
10933   22A4 EE 07               XOR     $07             ; make the ink white.
10934   22A6             
10935   22A6             ;; BORDER-1
10936   22A6 32 48 5C    L22A6:   LD      ($5C48),A       ; update BORDCR with new paper/ink
10937   22A9 C9                  RET                     ; return.
10938   22AA             
10939   22AA             ; -----------------
10940   22AA             ; Get pixel address
10941   22AA             ; -----------------
10942   22AA             ;
10943   22AA             ;
10944   22AA             
10945   22AA             ;; PIXEL-ADD
10946   22AA 3E AF       L22AA:   LD      A,$AF           ; load with 175 decimal.
10947   22AC 90                  SUB     B               ; subtract the y value.
10948   22AD DA F9 24            JP      C,L24F9         ; jump forward to REPORT-Bc if greater.
10949   22B0                                             ; 'Integer out of range'
10950   22B0             
10951   22B0             ; the high byte is derived from Y only.
10952   22B0             ; the first 3 bits are always 010
10953   22B0             ; the next 2 bits denote in which third of the screen the byte is.
10954   22B0             ; the last 3 bits denote in which of the 8 scan lines within a third
10955   22B0             ; the byte is located. There are 24 discrete values.
10956   22B0             
10957   22B0             
10958   22B0 47                  LD      B,A             ; the line number from top of screen to B.
10959   22B1 A7                  AND     A               ; clear carry (already clear)
10960   22B2 1F                  RRA                     ;                     0xxxxxxx
10961   22B3 37                  SCF                     ; set carry flag
10962   22B4 1F                  RRA                     ;                     10xxxxxx
10963   22B5 A7                  AND     A               ; clear carry flag
10964   22B6 1F                  RRA                     ;                     010xxxxx
10965   22B7             
10966   22B7 A8                  XOR     B               ;
10967   22B8 E6 F8               AND     $F8             ; keep the top 5 bits 11111000
10968   22BA A8                  XOR     B               ;                     010xxbbb
10969   22BB 67                  LD      H,A             ; transfer high byte to H.
10970   22BC             
10971   22BC             ; the low byte is derived from both X and Y.
10972   22BC             
10973   22BC 79                  LD      A,C             ; the x value 0-255.
10974   22BD 07                  RLCA                    ;
10975   22BE 07                  RLCA                    ;
10976   22BF 07                  RLCA                    ;
10977   22C0 A8                  XOR     B               ; the y value
10978   22C1 E6 C7               AND     $C7             ; apply mask             11000111
10979   22C3 A8                  XOR     B               ; restore unmasked bits  xxyyyxxx
10980   22C4 07                  RLCA                    ; rotate to              xyyyxxxx
10981   22C5 07                  RLCA                    ; required position.     yyyxxxxx
10982   22C6 6F                  LD      L,A             ; low byte to L.
10983   22C7             
10984   22C7             ; finally form the pixel position in A.
10985   22C7             
10986   22C7 79                  LD      A,C             ; x value to A
10987   22C8 E6 07               AND     $07             ; mod 8
10988   22CA C9                  RET                     ; return
10989   22CB             
10990   22CB             ; ----------------
10991   22CB             ; Point Subroutine
10992   22CB             ; ----------------
10993   22CB             ; The point subroutine is called from s-point via the scanning functions
10994   22CB             ; table.
10995   22CB             
10996   22CB             ;; POINT-SUB
10997   22CB CD 07 23    L22CB:   CALL    L2307           ; routine STK-TO-BC
10998   22CE CD AA 22            CALL    L22AA           ; routine PIXEL-ADD finds address of pixel.
10999   22D1 47                  LD      B,A             ; pixel position to B, 0-7.
11000   22D2 04                  INC     B               ; increment to give rotation count 1-8.
11001   22D3 7E                  LD      A,(HL)          ; fetch byte from screen.
11002   22D4             
11003   22D4             ;; POINT-LP
11004   22D4 07          L22D4:   RLCA                    ; rotate and loop back
11005   22D5 10 FD               DJNZ    L22D4           ; to POINT-LP until pixel at right.
11006   22D7             
11007   22D7 E6 01               AND      $01            ; test to give zero or one.
11008   22D9 C3 28 2D            JP      L2D28           ; jump forward to STACK-A to save result.
11009   22DC             
11010   22DC             ; -------------------
11011   22DC             ; Handle PLOT command
11012   22DC             ; -------------------
11013   22DC             ; Command Syntax example: PLOT 128,88
11014   22DC             ;
11015   22DC             
11016   22DC             ;; PLOT
11017   22DC CD 07 23    L22DC:   CALL    L2307           ; routine STK-TO-BC
11018   22DF CD E5 22            CALL    L22E5           ; routine PLOT-SUB
11019   22E2 C3 4D 0D            JP      L0D4D           ; to TEMPS
11020   22E5             
11021   22E5             ; -------------------
11022   22E5             ; The Plot subroutine
11023   22E5             ; -------------------
11024   22E5             ; A screen byte holds 8 pixels so it is necessary to rotate a mask
11025   22E5             ; into the correct position to leave the other 7 pixels unaffected.
11026   22E5             ; However all 64 pixels in the character cell take any embedded colour
11027   22E5             ; items.
11028   22E5             ; A pixel can be reset (inverse 1), toggled (over 1), or set ( with inverse
11029   22E5             ; and over switches off). With both switches on, the byte is simply put
11030   22E5             ; back on the screen though the colours may change.
11031   22E5             
11032   22E5             ;; PLOT-SUB
11033   22E5 ED 43 7D 5C L22E5:   LD      ($5C7D),BC      ; store new x/y values in COORDS
11034   22E9 CD AA 22            CALL    L22AA           ; routine PIXEL-ADD gets address in HL,
11035   22EC                                             ; count from left 0-7 in B.
11036   22EC 47                  LD      B,A             ; transfer count to B.
11037   22ED 04                  INC     B               ; increase 1-8.
11038   22EE 3E FE               LD      A,$FE           ; 11111110 in A.
11039   22F0             
11040   22F0             ;; PLOT-LOOP
11041   22F0 0F          L22F0:   RRCA                    ; rotate mask.
11042   22F1 10 FD               DJNZ    L22F0           ; to PLOT-LOOP until B circular rotations.
11043   22F3             
11044   22F3 47                  LD      B,A             ; load mask to B
11045   22F4 7E                  LD      A,(HL)          ; fetch screen byte to A
11046   22F5             
11047   22F5 FD 4E 57            LD      C,(IY+$57)      ; P_FLAG to C
11048   22F8 CB 41               BIT     0,C             ; is it to be OVER 1 ?
11049   22FA 20 01               JR      NZ,L22FD        ; forward to PL-TST-IN if so.
11050   22FC             
11051   22FC             ; was over 0
11052   22FC             
11053   22FC A0                  AND     B               ; combine with mask to blank pixel.
11054   22FD             
11055   22FD             ;; PL-TST-IN
11056   22FD CB 51       L22FD:   BIT     2,C             ; is it inverse 1 ?
11057   22FF 20 02               JR      NZ,L2303        ; to PLOT-END if so.
11058   2301             
11059   2301 A8                  XOR     B               ; switch the pixel
11060   2302 2F                  CPL                     ; restore other 7 bits
11061   2303             
11062   2303             ;; PLOT-END
11063   2303 77          L2303:   LD      (HL),A          ; load byte to the screen.
11064   2304 C3 DB 0B            JP      L0BDB           ; exit to PO-ATTR to set colours for cell.
11065   2307             
11066   2307             ; ------------------------------
11067   2307             ; Put two numbers in BC register
11068   2307             ; ------------------------------
11069   2307             ;
11070   2307             ;
11071   2307             
11072   2307             ;; STK-TO-BC
11073   2307 CD 14 23    L2307:   CALL    L2314           ; routine STK-TO-A
11074   230A 47                  LD      B,A             ;
11075   230B C5                  PUSH    BC              ;
11076   230C CD 14 23            CALL    L2314           ; routine STK-TO-A
11077   230F 59                  LD      E,C             ;
11078   2310 C1                  POP     BC              ;
11079   2311 51                  LD      D,C             ;
11080   2312 4F                  LD      C,A             ;
11081   2313 C9                  RET                     ;
11082   2314             
11083   2314             ; -----------------------
11084   2314             ; Put stack in A register
11085   2314             ; -----------------------
11086   2314             ; This routine puts the last value on the calculator stack into the accumulator
11087   2314             ; deleting the last value.
11088   2314             
11089   2314             ;; STK-TO-A
11090   2314 CD D5 2D    L2314:   CALL    L2DD5           ; routine FP-TO-A compresses last value into
11091   2317                                             ; accumulator. e.g. PI would become 3. 
11092   2317                                             ; zero flag set if positive.
11093   2317 DA F9 24            JP      C,L24F9         ; jump forward to REPORT-Bc if >= 255.5.
11094   231A             
11095   231A 0E 01               LD      C,$01           ; prepare a positive sign byte.
11096   231C C8                  RET     Z               ; return if FP-TO-BC indicated positive.
11097   231D             
11098   231D 0E FF               LD      C,$FF           ; prepare negative sign byte and
11099   231F C9                  RET                     ; return.
11100   2320             
11101   2320             
11102   2320             ; --------------------
11103   2320             ; THE 'CIRCLE' COMMAND
11104   2320             ; --------------------
11105   2320             ;   "Goe not Thou about to Square eyther circle" -
11106   2320             ;   - John Donne, Cambridge educated theologian, 1624
11107   2320             ;
11108   2320             ;   The CIRCLE command draws a circle as a series of straight lines.
11109   2320             ;   In some ways it can be regarded as a polygon, but the first line is drawn 
11110   2320             ;   as a tangent, taking the radius as its distance from the centre.
11111   2320             ;
11112   2320             ;   Both the CIRCLE algorithm and the ARC drawing algorithm make use of the
11113   2320             ;   'ROTATION FORMULA' (see later).  It is only necessary to work out where 
11114   2320             ;   the first line will be drawn and how long it is and then the rotation 
11115   2320             ;   formula takes over and calculates all other rotated points.
11116   2320             ;
11117   2320             ;   All Spectrum circles consist of two vertical lines at each side and two 
11118   2320             ;   horizontal lines at the top and bottom. The number of lines is calculated
11119   2320             ;   from the radius of the circle and is always divisible by 4. For complete 
11120   2320             ;   circles it will range from 4 for a square circle to 32 for a circle of 
11121   2320             ;   radius 87. The Spectrum can attempt larger circles e.g. CIRCLE 0,14,255
11122   2320             ;   but these will error as they go off-screen after four lines are drawn.
11123   2320             ;   At the opposite end, CIRCLE 128,88,1.23 will draw a circle as a perfect 3x3
11124   2320             ;   square using 4 straight lines although very small circles are just drawn as 
11125   2320             ;   a dot on the screen.
11126   2320             ;
11127   2320             ;   The first chord drawn is the vertical chord on the right of the circle.
11128   2320             ;   The starting point is at the base of this chord which is drawn upwards and
11129   2320             ;   the circle continues in an anti-clockwise direction. As noted earlier the 
11130   2320             ;   x-coordinate of this point measured from the centre of the circle is the 
11131   2320             ;   radius. 
11132   2320             ;
11133   2320             ;   The CIRCLE command makes extensive use of the calculator and as part of
11134   2320             ;   process of drawing a large circle, free memory is checked 1315 times.
11135   2320             ;   When drawing a large arc, free memory is checked 928 times.
11136   2320             ;   A single call to 'sin' involves 63 memory checks and so values of sine 
11137   2320             ;   and cosine are pre-calculated and held in the mem locations. As a 
11138   2320             ;   clever trick 'cos' is derived from 'sin' using simple arithmetic operations
11139   2320             ;   instead of the more expensive 'cos' function.
11140   2320             ;
11141   2320             ;   Initially, the syntax has been partly checked using the class for the DRAW 
11142   2320             ;   command which stacks the origin of the circle (X,Y).
11143   2320             
11144   2320             ;; CIRCLE
11145   2320 DF          L2320:   RST     18H             ; GET-CHAR              x, y.
11146   2321 FE 2C               CP      $2C             ; Is character the required comma ?
11147   2323 C2 8A 1C            JP      NZ,L1C8A        ; Jump, if not, to REPORT-C
11148   2326                                             ; 'Nonsense in basic'
11149   2326             
11150   2326 E7                  RST     20H             ; NEXT-CHAR advances the parsed character address.
11151   2327 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM stacks radius in runtime.
11152   232A CD EE 1B            CALL    L1BEE           ; routine CHECK-END will return here in runtime
11153   232D                                             ; if nothing follows the command.
11154   232D             
11155   232D             ;   Now make the radius positive and ensure that it is in floating point form 
11156   232D             ;   so that the exponent byte can be accessed for quick testing.
11157   232D             
11158   232D EF                  RST     28H             ;; FP-CALC              x, y, r.
11159   232E 2A                  DEFB    $2A             ;;abs                   x, y, r.
11160   232F 3D                  DEFB    $3D             ;;re-stack              x, y, r.
11161   2330 38                  DEFB    $38             ;;end-calc              x, y, r.
11162   2331             
11163   2331 7E                  LD      A,(HL)          ; Fetch first, floating-point, exponent byte.
11164   2332 FE 81               CP      $81             ; Compare to one.
11165   2334 30 05               JR      NC,L233B        ; Forward to C-R-GRE-1 
11166   2336                                             ; if circle radius is greater than one.
11167   2336             
11168   2336             ;    The circle is no larger than a single pixel so delete the radius from the
11169   2336             ;    calculator stack and plot a point at the centre.
11170   2336             
11171   2336 EF                  RST     28H             ;; FP-CALC              x, y, r.
11172   2337 02                  DEFB    $02             ;;delete                x, y.                  
11173   2338 38                  DEFB    $38             ;;end-calc              x, y.
11174   2339             
11175   2339 18 A1               JR      L22DC           ; back to PLOT routine to just plot x,y.
11176   233B             
11177   233B             ; ---
11178   233B             
11179   233B             ;   Continue when the circle's radius measures greater than one by forming 
11180   233B             ;   the angle 2 * PI radians which is 360 degrees.
11181   233B             
11182   233B             ;; C-R-GRE-1
11183   233B EF          L233B:   RST     28H             ;; FP-CALC      x, y, r
11184   233C A3                  DEFB    $A3             ;;stk-pi/2      x, y, r, pi/2.
11185   233D 38                  DEFB    $38             ;;end-calc      x, y, r, pi/2.
11186   233E             
11187   233E             ;   Change the exponent of pi/2 from $81 to $83 giving 2*PI the central angle.
11188   233E             ;   This is quicker than multiplying by four.
11189   233E             
11190   233E 36 83               LD      (HL),$83        ;               x, y, r, 2*PI.
11191   2340             
11192   2340             ;   Now store this important constant in mem-5 and delete so that other 
11193   2340             ;   parameters can be derived from it, by a routine shared with DRAW.
11194   2340             
11195   2340 EF                  RST     28H             ;; FP-CALC      x, y, r, 2*PI.
11196   2341 C5                  DEFB    $C5             ;;st-mem-5      store 2*PI in mem-5
11197   2342 02                  DEFB    $02             ;;delete        x, y, r.
11198   2343 38                  DEFB    $38             ;;end-calc      x, y, r.
11199   2344             
11200   2344             ;   The parameters derived from mem-5 (A) and from the radius are set up in 
11201   2344             ;   four of the other mem locations by the CIRCLE DRAW PARAMETERS routine which 
11202   2344             ;   also returns the number of straight lines in the B register.
11203   2344             
11204   2344 CD 7D 24            CALL    L247D           ; routine CD-PRMS1
11205   2347             
11206   2347                                             ; mem-0 ; A/No of lines (=a)            unused  
11207   2347                                             ; mem-1 ; sin(a/2)  will be moving x    var
11208   2347                                             ; mem-2 ; -         will be moving y    var
11209   2347                                             ; mem-3 ; cos(a)                        const
11210   2347                                             ; mem-4 ; sin(a)                        const
11211   2347                                             ; mem-5 ; Angle of rotation (A) (2*PI)  const
11212   2347                                             ; B     ; Number of straight lines.
11213   2347             
11214   2347 C5                  PUSH    BC              ; Preserve the number of lines in B.
11215   2348             
11216   2348             ;   Next calculate the length of half a chord by multiplying the sine of half 
11217   2348             ;   the central angle by the radius of the circle.
11218   2348             
11219   2348 EF                  RST     28H             ;; FP-CALC      x, y, r.
11220   2349 31                  DEFB    $31             ;;duplicate     x, y, r, r.
11221   234A E1                  DEFB    $E1             ;;get-mem-1     x, y, r, r, sin(a/2).
11222   234B 04                  DEFB    $04             ;;multiply      x, y, r, half-chord.
11223   234C 38                  DEFB    $38             ;;end-calc      x, y, r, half-chord.
11224   234D             
11225   234D 7E                  LD      A,(HL)          ; fetch exponent  of the half arc to A.
11226   234E FE 80               CP      $80             ; compare to a half pixel
11227   2350 30 08               JR      NC,L235A        ; forward, if greater than .5, to C-ARC-GE1
11228   2352             
11229   2352             ;   If the first line is less than .5 then 4 'lines' would be drawn on the same 
11230   2352             ;   spot so tidy the calculator stack and machine stack and plot the centre.
11231   2352             
11232   2352 EF                  RST     28H             ;; FP-CALC      x, y, r, hc.
11233   2353 02                  DEFB    $02             ;;delete        x, y, r.
11234   2354 02                  DEFB    $02             ;;delete        x, y.
11235   2355 38                  DEFB    $38             ;;end-calc      x, y.
11236   2356             
11237   2356 C1                  POP     BC              ; Balance machine stack by taking chord-count.
11238   2357             
11239   2357 C3 DC 22            JP      L22DC           ; JUMP to PLOT
11240   235A             
11241   235A             ; ---
11242   235A             
11243   235A             ;   The arc is greater than 0.5 so the circle can be drawn.
11244   235A             
11245   235A             ;; C-ARC-GE1
11246   235A EF          L235A:   RST     28H             ;; FP-CALC      x, y, r, hc.
11247   235B C2                  DEFB    $C2             ;;st-mem-2      x, y, r, half chord to mem-2.
11248   235C 01                  DEFB    $01             ;;exchange      x, y, hc, r.
11249   235D C0                  DEFB    $C0             ;;st-mem-0      x, y, hc, r.
11250   235E 02                  DEFB    $02             ;;delete        x, y, hc.
11251   235F             
11252   235F             ;   Subtract the length of the half-chord from the absolute y coordinate to
11253   235F             ;   give the starting y coordinate sy. 
11254   235F             ;   Note that for a circle this is also the end coordinate.
11255   235F             
11256   235F 03                  DEFB    $03             ;;subtract      x, y-hc.  (The start y-coord)
11257   2360 01                  DEFB    $01             ;;exchange      sy, x.
11258   2361             
11259   2361             ;   Next simply add the radius to the x coordinate to give a fuzzy x-coordinate.
11260   2361             ;   Strictly speaking, the radius should be multiplied by cos(a/2) first but
11261   2361             ;   doing it this way makes the circle slightly larger.
11262   2361             
11263   2361 E0                  DEFB    $E0             ;;get-mem-0     sy, x, r.
11264   2362 0F                  DEFB    $0F             ;;addition      sy, x+r.  (The start x-coord)
11265   2363             
11266   2363             ;   We now want three copies of this pair of values on the calculator stack.
11267   2363             ;   The first pair remain on the stack throughout the circle routine and are 
11268   2363             ;   the end points. The next pair will be the moving absolute values of x and y
11269   2363             ;   that are updated after each line is drawn. The final pair will be loaded 
11270   2363             ;   into the COORDS system variable so that the first vertical line starts at 
11271   2363             ;   the right place.
11272   2363             
11273   2363 C0                  DEFB    $C0             ;;st-mem-0      sy, sx.
11274   2364 01                  DEFB    $01             ;;exchange      sx, sy.
11275   2365 31                  DEFB    $31             ;;duplicate     sx, sy, sy.
11276   2366 E0                  DEFB    $E0             ;;get-mem-0     sx, sy, sy, sx.
11277   2367 01                  DEFB    $01             ;;exchange      sx, sy, sx, sy.
11278   2368 31                  DEFB    $31             ;;duplicate     sx, sy, sx, sy, sy.
11279   2369 E0                  DEFB    $E0             ;;get-mem-0     sx, sy, sx, sy, sy, sx.
11280   236A             
11281   236A             ;   Locations mem-1 and mem-2 are the relative x and y values which are updated
11282   236A             ;   after each line is drawn. Since we are drawing a vertical line then the rx
11283   236A             ;   value in mem-1 is zero and the ry value in mem-2 is the full chord.
11284   236A             
11285   236A A0                  DEFB    $A0             ;;stk-zero      sx, sy, sx, sy, sy, sx, 0.
11286   236B C1                  DEFB    $C1             ;;st-mem-1      sx, sy, sx, sy, sy, sx, 0.
11287   236C 02                  DEFB    $02             ;;delete        sx, sy, sx, sy, sy, sx.
11288   236D             
11289   236D             ;   Although the three pairs of x/y values are the same for a circle, they 
11290   236D             ;   will be labelled terminating, absolute and start coordinates.
11291   236D             
11292   236D 38                  DEFB    $38             ;;end-calc      tx, ty, ax, ay, sy, sx.
11293   236E             
11294   236E             ;   Use the exponent manipulating trick again to double the value of mem-2.
11295   236E             
11296   236E FD 34 62            INC     (IY+$62)        ; Increment MEM-2-1st doubling half chord.
11297   2371             
11298   2371             ;   Note. this first vertical chord is drawn at the radius so circles are
11299   2371             ;   slightly displaced to the right.
11300   2371             ;   It is only necessary to place the values (sx) and (sy) in the system 
11301   2371             ;   variable COORDS to ensure that drawing commences at the correct pixel.
11302   2371             ;   Note. a couple of LD (COORDS),A instructions would have been quicker, and 
11303   2371             ;   simpler, than using LD (COORDS),HL.
11304   2371             
11305   2371 CD 94 1E            CALL    L1E94           ; routine FIND-INT1 fetches sx from stack to A.
11306   2374             
11307   2374 6F                  LD      L,A             ; place X value in L.
11308   2375 E5                  PUSH    HL              ; save the holding register.
11309   2376             
11310   2376 CD 94 1E            CALL    L1E94           ; routine FIND-INT1 fetches sy to A
11311   2379             
11312   2379 E1                  POP     HL              ; restore the holding register.
11313   237A 67                  LD      H,A             ; and place y value in high byte.
11314   237B             
11315   237B 22 7D 5C            LD      ($5C7D),HL      ; Update the COORDS system variable.
11316   237E                                             ;
11317   237E                                             ;               tx, ty, ax, ay.
11318   237E             
11319   237E C1                  POP     BC              ; restore the chord count  
11320   237F                                             ; values 4,8,12,16,20,24,28 or 32.
11321   237F             
11322   237F C3 20 24            JP      L2420           ; forward to DRW-STEPS
11323   2382                                             ;               tx, ty, ax, ay.
11324   2382             
11325   2382             ;   Note. the jump to DRW-STEPS is just to decrement B and jump into the 
11326   2382             ;   middle of the arc-drawing loop. The arc count which includes the first 
11327   2382             ;   vertical arc draws one less than the perceived number of arcs. 
11328   2382             ;   The final arc offsets are obtained by subtracting the final COORDS value
11329   2382             ;   from the initial sx and sy values which are kept at the base of the
11330   2382             ;   calculator stack throughout the arc loop. 
11331   2382             ;   This ensures that the final line finishes exactly at the starting pixel 
11332   2382             ;   removing the possibility of any inaccuracy.
11333   2382             ;   Since the initial sx and sy values are not required until the final arc
11334   2382             ;   is drawn, they are not shown until then.
11335   2382             ;   As the calculator stack is quite busy, only the active parts are shown in 
11336   2382             ;   each section.
11337   2382             
11338   2382             
11339   2382             ; ------------------
11340   2382             ; THE 'DRAW' COMMAND
11341   2382             ; ------------------
11342   2382             ;   The Spectrum's DRAW command is overloaded and can take two parameters sets.
11343   2382             ;
11344   2382             ;   With two parameters, it simply draws an approximation to a straight line
11345   2382             ;   at offset x,y using the LINE-DRAW routine.
11346   2382             ;
11347   2382             ;   With three parameters, an arc is drawn to the point at offset x,y turning 
11348   2382             ;   through an angle, in radians, supplied by the third parameter.
11349   2382             ;   The arc will consist of 4 to 252 straight lines each one of which is drawn 
11350   2382             ;   by calls to the DRAW-LINE routine.
11351   2382             
11352   2382             ;; DRAW
11353   2382 DF          L2382:   RST     18H             ; GET-CHAR
11354   2383 FE 2C               CP      $2C             ; is it the comma character ?
11355   2385 28 06               JR      Z,L238D         ; forward, if so, to DR-3-PRMS
11356   2387             
11357   2387             ;   There are two parameters e.g. DRAW 255,175
11358   2387             
11359   2387 CD EE 1B            CALL    L1BEE           ; routine CHECK-END
11360   238A             
11361   238A C3 77 24            JP      L2477           ; jump forward to LINE-DRAW
11362   238D             
11363   238D             ; ---
11364   238D             
11365   238D             ;    There are three parameters e.g. DRAW 255, 175, .5
11366   238D             ;    The first two are relative coordinates and the third is the angle of 
11367   238D             ;    rotation in radians (A).
11368   238D             
11369   238D             ;; DR-3-PRMS
11370   238D E7          L238D:   RST     20H             ; NEXT-CHAR skips over the 'comma'.
11371   238E             
11372   238E CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM stacks the rotation angle.
11373   2391             
11374   2391 CD EE 1B            CALL    L1BEE           ; routine CHECK-END
11375   2394             
11376   2394             ;   Now enter the calculator and store the complete rotation angle in mem-5 
11377   2394             
11378   2394 EF                  RST     28H             ;; FP-CALC      x, y, A.
11379   2395 C5                  DEFB    $C5             ;;st-mem-5      x, y, A.
11380   2396             
11381   2396             ;   Test the angle for the special case of 360 degrees.
11382   2396             
11383   2396 A2                  DEFB    $A2             ;;stk-half      x, y, A, 1/2.
11384   2397 04                  DEFB    $04             ;;multiply      x, y, A/2.
11385   2398 1F                  DEFB    $1F             ;;sin           x, y, sin(A/2).
11386   2399 31                  DEFB    $31             ;;duplicate     x, y, sin(A/2),sin(A/2)
11387   239A 30                  DEFB    $30             ;;not           x, y, sin(A/2), (0/1).
11388   239B 30                  DEFB    $30             ;;not           x, y, sin(A/2), (1/0).
11389   239C 00                  DEFB    $00             ;;jump-true     x, y, sin(A/2).
11390   239D             
11391   239D 06                  DEFB    $06             ;;forward to L23A3, DR-SIN-NZ
11392   239E                                             ; if sin(r/2) is not zero.
11393   239E             
11394   239E             ;   The third parameter is 2*PI (or a multiple of 2*PI) so a 360 degrees turn
11395   239E             ;   would just be a straight line.  Eliminating this case here prevents 
11396   239E             ;   division by zero at later stage.
11397   239E             
11398   239E 02                  DEFB    $02             ;;delete        x, y.
11399   239F 38                  DEFB    $38             ;;end-calc      x, y.
11400   23A0             
11401   23A0 C3 77 24            JP      L2477           ; forward to LINE-DRAW
11402   23A3             
11403   23A3             ; ---
11404   23A3             
11405   23A3             ;   An arc can be drawn.
11406   23A3             
11407   23A3             ;; DR-SIN-NZ
11408   23A3 C0          L23A3:   DEFB    $C0             ;;st-mem-0      x, y, sin(A/2).   store mem-0
11409   23A4 02                  DEFB    $02             ;;delete        x, y.
11410   23A5             
11411   23A5             ;   The next step calculates (roughly) the diameter of the circle of which the 
11412   23A5             ;   arc will form part.  This value does not have to be too accurate as it is
11413   23A5             ;   only used to evaluate the number of straight lines and then discarded.
11414   23A5             ;   After all for a circle, the radius is used. Consequently, a circle of 
11415   23A5             ;   radius 50 will have 24 straight lines but an arc of radius 50 will have 20
11416   23A5             ;   straight lines - when drawn in any direction.
11417   23A5             ;   So that simple arithmetic can be used, the length of the chord can be 
11418   23A5             ;   calculated as X+Y rather than by Pythagoras Theorem and the sine of the
11419   23A5             ;   nearest angle within reach is used.
11420   23A5             
11421   23A5 C1                  DEFB    $C1             ;;st-mem-1      x, y.             store mem-1
11422   23A6 02                  DEFB    $02             ;;delete        x.
11423   23A7             
11424   23A7 31                  DEFB    $31             ;;duplicate     x, x.
11425   23A8 2A                  DEFB    $2A             ;;abs           x, x (+ve).
11426   23A9 E1                  DEFB    $E1             ;;get-mem-1     x, X, y.
11427   23AA 01                  DEFB    $01             ;;exchange      x, y, X.
11428   23AB E1                  DEFB    $E1             ;;get-mem-1     x, y, X, y.
11429   23AC 2A                  DEFB    $2A             ;;abs           x, y, X, Y (+ve).
11430   23AD 0F                  DEFB    $0F             ;;addition      x, y, X+Y.
11431   23AE E0                  DEFB    $E0             ;;get-mem-0     x, y, X+Y, sin(A/2).
11432   23AF 05                  DEFB    $05             ;;division      x, y, X+Y/sin(A/2).
11433   23B0 2A                  DEFB    $2A             ;;abs           x, y, X+Y/sin(A/2) = D.
11434   23B1             
11435   23B1             ;    Bring back sin(A/2) from mem-0 which will shortly get trashed.
11436   23B1             ;    Then bring D to the top of the stack again.
11437   23B1             
11438   23B1 E0                  DEFB    $E0             ;;get-mem-0     x, y, D, sin(A/2).
11439   23B2 01                  DEFB    $01             ;;exchange      x, y, sin(A/2), D.
11440   23B3             
11441   23B3             ;   Note. that since the value at the top of the stack has arisen as a result
11442   23B3             ;   of division then it can no longer be in integer form and the next re-stack
11443   23B3             ;   is unnecessary. Only the Sinclair ZX80 had integer division.
11444   23B3             
11445   23B3 3D                  DEFB    $3D             ;;re-stack      (unnecessary)
11446   23B4             
11447   23B4 38                  DEFB    $38             ;;end-calc      x, y, sin(A/2), D.
11448   23B5             
11449   23B5             ;   The next test avoids drawing 4 straight lines when the start and end pixels
11450   23B5             ;   are adjacent (or the same) but is probably best dispensed with.
11451   23B5             
11452   23B5 7E                  LD      A,(HL)          ; fetch exponent byte of D.
11453   23B6 FE 81               CP      $81             ; compare to 1
11454   23B8 30 07               JR      NC,L23C1        ; forward, if > 1,  to DR-PRMS
11455   23BA             
11456   23BA             ;   else delete the top two stack values and draw a simple straight line.
11457   23BA             
11458   23BA EF                  RST     28H             ;; FP-CALC
11459   23BB 02                  DEFB    $02             ;;delete
11460   23BC 02                  DEFB    $02             ;;delete
11461   23BD 38                  DEFB    $38             ;;end-calc      x, y.
11462   23BE             
11463   23BE C3 77 24            JP      L2477           ; to LINE-DRAW
11464   23C1             
11465   23C1             ; ---
11466   23C1             
11467   23C1             ;   The ARC will consist of multiple straight lines so call the CIRCLE-DRAW
11468   23C1             ;   PARAMETERS ROUTINE to pre-calculate sine values from the angle (in mem-5)
11469   23C1             ;   and determine also the number of straight lines from that value and the
11470   23C1             ;   'diameter' which is at the top of the calculator stack.
11471   23C1             
11472   23C1             ;; DR-PRMS
11473   23C1 CD 7D 24    L23C1:   CALL    L247D           ; routine CD-PRMS1
11474   23C4             
11475   23C4                                             ; mem-0 ; (A)/No. of lines (=a) (step angle)
11476   23C4                                             ; mem-1 ; sin(a/2) 
11477   23C4                                             ; mem-2 ; -
11478   23C4                                             ; mem-3 ; cos(a)                        const
11479   23C4                                             ; mem-4 ; sin(a)                        const
11480   23C4                                             ; mem-5 ; Angle of rotation (A)         in
11481   23C4                                             ; B     ; Count of straight lines - max 252.
11482   23C4             
11483   23C4 C5                  PUSH    BC              ; Save the line count on the machine stack.
11484   23C5             
11485   23C5             ;   Remove the now redundant diameter value D.
11486   23C5             
11487   23C5 EF                  RST     28H             ;; FP-CALC      x, y, sin(A/2), D.
11488   23C6 02                  DEFB    $02             ;;delete        x, y, sin(A/2).
11489   23C7             
11490   23C7             ;   Dividing the sine of the step angle by the sine of the total angle gives
11491   23C7             ;   the length of the initial chord on a unary circle. This factor f is used
11492   23C7             ;   to scale the coordinates of the first line which still points in the 
11493   23C7             ;   direction of the end point and may be larger.
11494   23C7             
11495   23C7 E1                  DEFB    $E1             ;;get-mem-1     x, y, sin(A/2), sin(a/2)
11496   23C8 01                  DEFB    $01             ;;exchange      x, y, sin(a/2), sin(A/2)
11497   23C9 05                  DEFB    $05             ;;division      x, y, sin(a/2)/sin(A/2)
11498   23CA C1                  DEFB    $C1             ;;st-mem-1      x, y. f.
11499   23CB 02                  DEFB    $02             ;;delete        x, y.
11500   23CC             
11501   23CC             ;   With the factor stored, scale the x coordinate first.
11502   23CC             
11503   23CC 01                  DEFB    $01             ;;exchange      y, x.
11504   23CD 31                  DEFB    $31             ;;duplicate     y, x, x.
11505   23CE E1                  DEFB    $E1             ;;get-mem-1     y, x, x, f.
11506   23CF 04                  DEFB    $04             ;;multiply      y, x, x*f    (=xx)
11507   23D0 C2                  DEFB    $C2             ;;st-mem-2      y, x, xx.
11508   23D1 02                  DEFB    $02             ;;delete        y. x.
11509   23D2             
11510   23D2             ;   Now scale the y coordinate.
11511   23D2             
11512   23D2 01                  DEFB    $01             ;;exchange      x, y.
11513   23D3 31                  DEFB    $31             ;;duplicate     x, y, y.
11514   23D4 E1                  DEFB    $E1             ;;get-mem-1     x, y, y, f
11515   23D5 04                  DEFB    $04             ;;multiply      x, y, y*f    (=yy)
11516   23D6             
11517   23D6             ;   Note. 'sin' and 'cos' trash locations mem-0 to mem-2 so fetch mem-2 to the 
11518   23D6             ;   calculator stack for safe keeping.
11519   23D6             
11520   23D6 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy, xx.
11521   23D7             
11522   23D7             ;   Once we get the coordinates of the first straight line then the 'ROTATION
11523   23D7             ;   FORMULA' used in the arc loop will take care of all other points, but we
11524   23D7             ;   now use a variation of that formula to rotate the first arc through (A-a)/2
11525   23D7             ;   radians. 
11526   23D7             ;   
11527   23D7             ;       xRotated = y * sin(angle) + x * cos(angle)
11528   23D7             ;       yRotated = y * cos(angle) - x * sin(angle)
11529   23D7             ;
11530   23D7              
11531   23D7 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy, xx, A.
11532   23D8 E0                  DEFB    $E0             ;;get-mem-0     x, y, yy, xx, A, a.
11533   23D9 03                  DEFB    $03             ;;subtract      x, y, yy, xx, A-a.
11534   23DA A2                  DEFB    $A2             ;;stk-half      x, y, yy, xx, A-a, 1/2.
11535   23DB 04                  DEFB    $04             ;;multiply      x, y, yy, xx, (A-a)/2. (=angle)
11536   23DC 31                  DEFB    $31             ;;duplicate     x, y, yy, xx, angle, angle.
11537   23DD 1F                  DEFB    $1F             ;;sin           x, y, yy, xx, angle, sin(angle)
11538   23DE C5                  DEFB    $C5             ;;st-mem-5      x, y, yy, xx, angle, sin(angle)
11539   23DF 02                  DEFB    $02             ;;delete        x, y, yy, xx, angle
11540   23E0             
11541   23E0 20                  DEFB    $20             ;;cos           x, y, yy, xx, cos(angle).
11542   23E1             
11543   23E1             ;   Note. mem-0, mem-1 and mem-2 can be used again now...
11544   23E1             
11545   23E1 C0                  DEFB    $C0             ;;st-mem-0      x, y, yy, xx, cos(angle).
11546   23E2 02                  DEFB    $02             ;;delete        x, y, yy, xx.
11547   23E3             
11548   23E3 C2                  DEFB    $C2             ;;st-mem-2      x, y, yy, xx.
11549   23E4 02                  DEFB    $02             ;;delete        x, y, yy.
11550   23E5             
11551   23E5 C1                  DEFB    $C1             ;;st-mem-1      x, y, yy.
11552   23E6 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy, sin(angle)
11553   23E7 04                  DEFB    $04             ;;multiply      x, y, yy*sin(angle).
11554   23E8 E0                  DEFB    $E0             ;;get-mem-0     x, y, yy*sin(angle), cos(angle)
11555   23E9 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy*sin(angle), cos(angle), xx.
11556   23EA 04                  DEFB    $04             ;;multiply      x, y, yy*sin(angle), xx*cos(angle).
11557   23EB 0F                  DEFB    $0F             ;;addition      x, y, xRotated.
11558   23EC E1                  DEFB    $E1             ;;get-mem-1     x, y, xRotated, yy.
11559   23ED 01                  DEFB    $01             ;;exchange      x, y, yy, xRotated.
11560   23EE C1                  DEFB    $C1             ;;st-mem-1      x, y, yy, xRotated.
11561   23EF 02                  DEFB    $02             ;;delete        x, y, yy.
11562   23F0             
11563   23F0 E0                  DEFB    $E0             ;;get-mem-0     x, y, yy, cos(angle).
11564   23F1 04                  DEFB    $04             ;;multiply      x, y, yy*cos(angle).
11565   23F2 E2                  DEFB    $E2             ;;get-mem-2     x, y, yy*cos(angle), xx.
11566   23F3 E5                  DEFB    $E5             ;;get-mem-5     x, y, yy*cos(angle), xx, sin(angle).
11567   23F4 04                  DEFB    $04             ;;multiply      x, y, yy*cos(angle), xx*sin(angle).
11568   23F5 03                  DEFB    $03             ;;subtract      x, y, yRotated.
11569   23F6 C2                  DEFB    $C2             ;;st-mem-2      x, y, yRotated.
11570   23F7             
11571   23F7             ;   Now the initial x and y coordinates are made positive and summed to see 
11572   23F7             ;   if they measure up to anything significant.
11573   23F7             
11574   23F7 2A                  DEFB    $2A             ;;abs           x, y, yRotated'.
11575   23F8 E1                  DEFB    $E1             ;;get-mem-1     x, y, yRotated', xRotated.
11576   23F9 2A                  DEFB    $2A             ;;abs           x, y, yRotated', xRotated'.
11577   23FA 0F                  DEFB    $0F             ;;addition      x, y, yRotated+xRotated.
11578   23FB 02                  DEFB    $02             ;;delete        x, y. 
11579   23FC             
11580   23FC 38                  DEFB    $38             ;;end-calc      x, y. 
11581   23FD             
11582   23FD             ;   Although the test value has been deleted it is still above the calculator
11583   23FD             ;   stack in memory and conveniently DE which points to the first free byte
11584   23FD             ;   addresses the exponent of the test value.
11585   23FD             
11586   23FD 1A                  LD      A,(DE)          ; Fetch exponent of the length indicator.
11587   23FE FE 81               CP      $81             ; Compare to that for 1
11588   2400             
11589   2400 C1                  POP     BC              ; Balance the machine stack
11590   2401             
11591   2401 DA 77 24            JP      C,L2477         ; forward, if the coordinates of first line
11592   2404                                             ; don't add up to more than 1, to LINE-DRAW 
11593   2404             
11594   2404             ;   Continue when the arc will have a discernable shape.
11595   2404             
11596   2404 C5                  PUSH    BC              ; Restore line counter to the machine stack.
11597   2405             
11598   2405             ;   The parameters of the DRAW command were relative and they are now converted 
11599   2405             ;   to absolute coordinates by adding to the coordinates of the last point 
11600   2405             ;   plotted. The first two values on the stack are the terminal tx and ty 
11601   2405             ;   coordinates.  The x-coordinate is converted first but first the last point 
11602   2405             ;   plotted is saved as it will initialize the moving ax, value. 
11603   2405             
11604   2405 EF                  RST     28H             ;; FP-CALC      x, y.
11605   2406 01                  DEFB    $01             ;;exchange      y, x.
11606   2407 38                  DEFB    $38             ;;end-calc      y, x.
11607   2408             
11608   2408 3A 7D 5C            LD      A,($5C7D)       ; Fetch System Variable COORDS-x
11609   240B CD 28 2D            CALL    L2D28           ; routine STACK-A
11610   240E             
11611   240E EF                  RST     28H             ;; FP-CALC      y, x, last-x.
11612   240F             
11613   240F             ;   Store the last point plotted to initialize the moving ax value.
11614   240F             
11615   240F C0                  DEFB    $C0             ;;st-mem-0      y, x, last-x.
11616   2410 0F                  DEFB    $0F             ;;addition      y, absolute x.
11617   2411 01                  DEFB    $01             ;;exchange      tx, y.
11618   2412 38                  DEFB    $38             ;;end-calc      tx, y.
11619   2413             
11620   2413 3A 7E 5C            LD      A,($5C7E)       ; Fetch System Variable COORDS-y
11621   2416 CD 28 2D            CALL    L2D28           ; routine STACK-A
11622   2419             
11623   2419 EF                  RST     28H             ;; FP-CALC      tx, y, last-y.
11624   241A             
11625   241A             ;   Store the last point plotted to initialize the moving ay value.
11626   241A             
11627   241A C5                  DEFB    $C5             ;;st-mem-5      tx, y, last-y.
11628   241B 0F                  DEFB    $0F             ;;addition      tx, ty.
11629   241C             
11630   241C             ;   Fetch the moving ax and ay to the calculator stack.
11631   241C             
11632   241C E0                  DEFB    $E0             ;;get-mem-0     tx, ty, ax.
11633   241D E5                  DEFB    $E5             ;;get-mem-5     tx, ty, ax, ay.
11634   241E 38                  DEFB    $38             ;;end-calc      tx, ty, ax, ay.
11635   241F             
11636   241F C1                  POP     BC              ; Restore the straight line count.
11637   2420             
11638   2420             ; -----------------------------------
11639   2420             ; THE 'CIRCLE/DRAW CONVERGENCE POINT'
11640   2420             ; -----------------------------------
11641   2420             ;   The CIRCLE and ARC-DRAW commands converge here. 
11642   2420             ;
11643   2420             ;   Note. for both the CIRCLE and ARC commands the minimum initial line count 
11644   2420             ;   is 4 (as set up by the CD_PARAMS routine) and so the zero flag will never 
11645   2420             ;   be set and the loop is always entered.  The first test is superfluous and
11646   2420             ;   the jump will always be made to ARC-START.
11647   2420             
11648   2420             ;; DRW-STEPS
11649   2420 05          L2420:   DEC     B               ; decrement the arc count (4,8,12,16...).            
11650   2421             
11651   2421 28 3C               JR      Z,L245F         ; forward, if zero (not possible), to ARC-END
11652   2423             
11653   2423 18 14               JR      L2439           ; forward to ARC-START
11654   2425             
11655   2425             ; --------------
11656   2425             ; THE 'ARC LOOP'
11657   2425             ; --------------
11658   2425             ;
11659   2425             ;   The arc drawing loop will draw up to 31 straight lines for a circle and up 
11660   2425             ;   251 straight lines for an arc between two points. In both cases the final
11661   2425             ;   closing straight line is drawn at ARC_END, but it otherwise loops back to 
11662   2425             ;   here to calculate the next coordinate using the ROTATION FORMULA where (a)
11663   2425             ;   is the previously calculated, constant CENTRAL ANGLE of the arcs.
11664   2425             ;
11665   2425             ;       Xrotated = x * cos(a) - y * sin(a)
11666   2425             ;       Yrotated = x * sin(a) + y * cos(a)
11667   2425             ;
11668   2425             ;   The values cos(a) and sin(a) are pre-calculated and held in mem-3 and mem-4 
11669   2425             ;   for the duration of the routine.
11670   2425             ;   Memory location mem-1 holds the last relative x value (rx) and mem-2 holds
11671   2425             ;   the last relative y value (ry) used by DRAW.
11672   2425             ;
11673   2425             ;   Note. that this is a very clever twist on what is after all a very clever,
11674   2425             ;   well-used formula.  Normally the rotation formula is used with the x and y
11675   2425             ;   coordinates from the centre of the circle (or arc) and a supplied angle to 
11676   2425             ;   produce two new x and y coordinates in an anticlockwise direction on the 
11677   2425             ;   circumference of the circle.
11678   2425             ;   What is being used here, instead, is the relative X and Y parameters from
11679   2425             ;   the last point plotted that are required to get to the current point and 
11680   2425             ;   the formula returns the next relative coordinates to use. 
11681   2425             
11682   2425             ;; ARC-LOOP
11683   2425 EF          L2425:   RST     28H             ;; FP-CALC      
11684   2426 E1                  DEFB    $E1             ;;get-mem-1     rx.
11685   2427 31                  DEFB    $31             ;;duplicate     rx, rx.
11686   2428 E3                  DEFB    $E3             ;;get-mem-3     cos(a)
11687   2429 04                  DEFB    $04             ;;multiply      rx, rx*cos(a).
11688   242A E2                  DEFB    $E2             ;;get-mem-2     rx, rx*cos(a), ry.
11689   242B E4                  DEFB    $E4             ;;get-mem-4     rx, rx*cos(a), ry, sin(a). 
11690   242C 04                  DEFB    $04             ;;multiply      rx, rx*cos(a), ry*sin(a).
11691   242D 03                  DEFB    $03             ;;subtract      rx, rx*cos(a) - ry*sin(a)
11692   242E C1                  DEFB    $C1             ;;st-mem-1      rx, new relative x rotated.
11693   242F 02                  DEFB    $02             ;;delete        rx.
11694   2430             
11695   2430 E4                  DEFB    $E4             ;;get-mem-4     rx, sin(a).
11696   2431 04                  DEFB    $04             ;;multiply      rx*sin(a)
11697   2432 E2                  DEFB    $E2             ;;get-mem-2     rx*sin(a), ry.
11698   2433 E3                  DEFB    $E3             ;;get-mem-3     rx*sin(a), ry, cos(a).
11699   2434 04                  DEFB    $04             ;;multiply      rx*sin(a), ry*cos(a).
11700   2435 0F                  DEFB    $0F             ;;addition      rx*sin(a) + ry*cos(a).
11701   2436 C2                  DEFB    $C2             ;;st-mem-2      new relative y rotated.
11702   2437 02                  DEFB    $02             ;;delete        .
11703   2438 38                  DEFB    $38             ;;end-calc      .  
11704   2439             
11705   2439             ;   Note. the calculator stack actually holds   tx, ty, ax, ay
11706   2439             ;   and the last absolute values of x and y 
11707   2439             ;   are now brought into play.
11708   2439             ;
11709   2439             ;   Magically, the two new rotated coordinates rx and ry are all that we would
11710   2439             ;   require to draw a circle or arc - on paper!
11711   2439             ;   The Spectrum DRAW routine draws to the rounded x and y coordinate and so 
11712   2439             ;   repetitions of values like 3.49 would mean that the fractional parts 
11713   2439             ;   would be lost until eventually the draw coordinates might differ from the 
11714   2439             ;   floating point values used above by several pixels.
11715   2439             ;   For this reason the accurate offsets calculated above are added to the 
11716   2439             ;   accurate, absolute coordinates maintained in ax and ay and these new 
11717   2439             ;   coordinates have the integer coordinates of the last plot position 
11718   2439             ;   ( from System Variable COORDS ) subtracted from them to give the relative 
11719   2439             ;   coordinates required by the DRAW routine.
11720   2439             
11721   2439             ;   The mid entry point.
11722   2439             
11723   2439             ;; ARC-START
11724   2439 C5          L2439:   PUSH    BC              ; Preserve the arc counter on the machine stack.
11725   243A             
11726   243A             ;   Store the absolute ay in temporary variable mem-0 for the moment.
11727   243A             
11728   243A EF                  RST     28H             ;; FP-CALC      ax, ay.
11729   243B C0                  DEFB    $C0             ;;st-mem-0      ax, ay.
11730   243C 02                  DEFB    $02             ;;delete        ax.
11731   243D             
11732   243D             ;   Now add the fractional relative x coordinate to the fractional absolute
11733   243D             ;   x coordinate to obtain a new fractional x-coordinate.
11734   243D             
11735   243D E1                  DEFB    $E1             ;;get-mem-1     ax, xr.
11736   243E 0F                  DEFB    $0F             ;;addition      ax+xr (= new ax).  
11737   243F 31                  DEFB    $31             ;;duplicate     ax, ax.
11738   2440 38                  DEFB    $38             ;;end-calc      ax, ax. 
11739   2441             
11740   2441 3A 7D 5C            LD      A,($5C7D)       ; COORDS-x      last x    (integer ix 0-255)
11741   2444 CD 28 2D            CALL    L2D28           ; routine STACK-A
11742   2447             
11743   2447 EF                  RST     28H             ;; FP-CALC      ax, ax, ix.
11744   2448 03                  DEFB    $03             ;;subtract      ax, ax-ix  = relative DRAW Dx.
11745   2449             
11746   2449             ;   Having calculated the x value for DRAW do the same for the y value.
11747   2449             
11748   2449 E0                  DEFB    $E0             ;;get-mem-0     ax, Dx, ay.
11749   244A E2                  DEFB    $E2             ;;get-mem-2     ax, Dx, ay, ry.
11750   244B 0F                  DEFB    $0F             ;;addition      ax, Dx, ay+ry (= new ay).
11751   244C C0                  DEFB    $C0             ;;st-mem-0      ax, Dx, ay.
11752   244D 01                  DEFB    $01             ;;exchange      ax, ay, Dx,
11753   244E E0                  DEFB    $E0             ;;get-mem-0     ax, ay, Dx, ay.
11754   244F 38                  DEFB    $38             ;;end-calc      ax, ay, Dx, ay.
11755   2450             
11756   2450 3A 7E 5C            LD      A,($5C7E)       ; COORDS-y      last y (integer iy 0-175)
11757   2453 CD 28 2D            CALL    L2D28           ; routine STACK-A
11758   2456             
11759   2456 EF                  RST     28H             ;; FP-CALC      ax, ay, Dx, ay, iy.
11760   2457 03                  DEFB    $03             ;;subtract      ax, ay, Dx, ay-iy ( = Dy).
11761   2458 38                  DEFB    $38             ;;end-calc      ax, ay, Dx, Dy.
11762   2459             
11763   2459 CD B7 24            CALL    L24B7           ; Routine DRAW-LINE draws (Dx,Dy) relative to
11764   245C                                             ; the last pixel plotted leaving absolute x 
11765   245C                                             ; and y on the calculator stack.
11766   245C                                             ;               ax, ay.
11767   245C             
11768   245C C1                  POP     BC              ; Restore the arc counter from the machine stack.
11769   245D             
11770   245D 10 C6               DJNZ    L2425           ; Decrement and loop while > 0 to ARC-LOOP
11771   245F             
11772   245F             ; -------------
11773   245F             ; THE 'ARC END'
11774   245F             ; -------------
11775   245F             
11776   245F             ;   To recap the full calculator stack is       tx, ty, ax, ay.
11777   245F             
11778   245F             ;   Just as one would do if drawing the curve on paper, the final line would
11779   245F             ;   be drawn by joining the last point plotted to the initial start point 
11780   245F             ;   in the case of a CIRCLE or to the calculated end point in the case of 
11781   245F             ;   an ARC.
11782   245F             ;   The moving absolute values of x and y are no longer required and they
11783   245F             ;   can be deleted to expose the closing coordinates.
11784   245F             
11785   245F             ;; ARC-END
11786   245F EF          L245F:   RST     28H             ;; FP-CALC      tx, ty, ax, ay.
11787   2460 02                  DEFB    $02             ;;delete        tx, ty, ax.
11788   2461 02                  DEFB    $02             ;;delete        tx, ty.
11789   2462 01                  DEFB    $01             ;;exchange      ty, tx.
11790   2463 38                  DEFB    $38             ;;end-calc      ty, tx.
11791   2464             
11792   2464             ;   First calculate the relative x coordinate to the end-point.
11793   2464             
11794   2464 3A 7D 5C            LD      A,($5C7D)       ; COORDS-x
11795   2467 CD 28 2D            CALL    L2D28           ; routine STACK-A
11796   246A             
11797   246A EF                  RST     28H             ;; FP-CALC      ty, tx, coords_x.
11798   246B 03                  DEFB    $03             ;;subtract      ty, rx.
11799   246C             
11800   246C             ;   Next calculate the relative y coordinate to the end-point.
11801   246C             
11802   246C 01                  DEFB    $01             ;;exchange      rx, ty.
11803   246D 38                  DEFB    $38             ;;end-calc      rx, ty.
11804   246E             
11805   246E 3A 7E 5C            LD      A,($5C7E)       ; COORDS-y
11806   2471 CD 28 2D            CALL    L2D28           ; routine STACK-A
11807   2474             
11808   2474 EF                  RST     28H             ;; FP-CALC      rx, ty, coords_y
11809   2475 03                  DEFB    $03             ;;subtract      rx, ry.
11810   2476 38                  DEFB    $38             ;;end-calc      rx, ry.
11811   2477             
11812   2477             ;   Finally draw the last straight line.
11813   2477             
11814   2477             ;; LINE-DRAW
11815   2477 CD B7 24    L2477:   CALL    L24B7           ; routine DRAW-LINE draws to the relative 
11816   247A                                             ; coordinates (rx, ry).
11817   247A             
11818   247A C3 4D 0D            JP      L0D4D           ; jump back and exit via TEMPS          >>>
11819   247D             
11820   247D             
11821   247D             ; --------------------------------------------
11822   247D             ; THE 'INITIAL CIRCLE/DRAW PARAMETERS' ROUTINE
11823   247D             ; --------------------------------------------
11824   247D             ;   Begin by calculating the number of chords which will be returned in B.
11825   247D             ;   A rule of thumb is employed that uses a value z which for a circle is the
11826   247D             ;   radius and for an arc is the diameter with, as it happens, a pinch more if 
11827   247D             ;   the arc is on a slope.
11828   247D             ;
11829   247D             ;   NUMBER OF STRAIGHT LINES = ANGLE OF ROTATION * SQUARE ROOT ( Z ) / 2
11830   247D             
11831   247D             ;; CD-PRMS1
11832   247D EF          L247D:   RST     28H             ;; FP-CALC      z.
11833   247E 31                  DEFB    $31             ;;duplicate     z, z.
11834   247F 28                  DEFB    $28             ;;sqr           z, sqr(z).
11835   2480 34                  DEFB    $34             ;;stk-data      z, sqr(z), 2.
11836   2481 32                  DEFB    $32             ;;Exponent: $82, Bytes: 1
11837   2482 00                  DEFB    $00             ;;(+00,+00,+00)
11838   2483 01                  DEFB    $01             ;;exchange      z, 2, sqr(z).
11839   2484 05                  DEFB    $05             ;;division      z, 2/sqr(z).
11840   2485 E5                  DEFB    $E5             ;;get-mem-5     z, 2/sqr(z), ANGLE.
11841   2486 01                  DEFB    $01             ;;exchange      z, ANGLE, 2/sqr (z)
11842   2487 05                  DEFB    $05             ;;division      z, ANGLE*sqr(z)/2 (= No. of lines)
11843   2488 2A                  DEFB    $2A             ;;abs           (for arc only)
11844   2489 38                  DEFB    $38             ;;end-calc      z, number of lines.
11845   248A             
11846   248A             ;    As an example for a circle of radius 87 the number of lines will be 29.
11847   248A             
11848   248A CD D5 2D            CALL    L2DD5           ; routine FP-TO-A
11849   248D             
11850   248D             ;    The value is compressed into A register, no carry with valid circle.
11851   248D             
11852   248D 38 06               JR      C,L2495         ; forward, if over 256, to USE-252
11853   248F             
11854   248F             ;    now make a multiple of 4 e.g. 29 becomes 28
11855   248F             
11856   248F E6 FC               AND     $FC             ; AND 252
11857   2491             
11858   2491             ;    Adding 4 could set carry for arc, for the circle example, 28 becomes 32.
11859   2491             
11860   2491 C6 04               ADD     A,$04           ; adding 4 could set carry if result is 256.
11861   2493                     
11862   2493 30 02               JR      NC,L2497        ; forward if less than 256 to DRAW-SAVE
11863   2495             
11864   2495             ;    For an arc, a limit of 252 is imposed.
11865   2495             
11866   2495             ;; USE-252
11867   2495 3E FC       L2495:   LD      A,$FC           ; Use a value of 252 (for arc).
11868   2497             
11869   2497             
11870   2497             ;   For both arcs and circles, constants derived from the central angle are
11871   2497             ;   stored in the 'mem' locations.  Some are not relevant for the circle.
11872   2497             
11873   2497             ;; DRAW-SAVE
11874   2497 F5          L2497:   PUSH    AF              ; Save the line count (A) on the machine stack.
11875   2498             
11876   2498 CD 28 2D            CALL    L2D28           ; Routine STACK-A stacks the modified count(A).
11877   249B             
11878   249B EF                  RST     28H             ;; FP-CALC      z, A.
11879   249C E5                  DEFB    $E5             ;;get-mem-5     z, A, ANGLE.
11880   249D 01                  DEFB    $01             ;;exchange      z, ANGLE, A.
11881   249E 05                  DEFB    $05             ;;division      z, ANGLE/A. (Angle/count = a)
11882   249F 31                  DEFB    $31             ;;duplicate     z, a, a. 
11883   24A0             
11884   24A0             ;  Note. that cos (a) could be formed here directly using 'cos' and stored in 
11885   24A0             ;  mem-3 but that would spoil a good story and be slightly slower, as also 
11886   24A0             ;  would using square roots to form cos (a) from sin (a).
11887   24A0             
11888   24A0 1F                  DEFB    $1F             ;;sin           z, a, sin(a)
11889   24A1 C4                  DEFB    $C4             ;;st-mem-4      z, a, sin(a)
11890   24A2 02                  DEFB    $02             ;;delete        z, a.
11891   24A3 31                  DEFB    $31             ;;duplicate     z, a, a.            
11892   24A4 A2                  DEFB    $A2             ;;stk-half      z, a, a, 1/2.
11893   24A5 04                  DEFB    $04             ;;multiply      z, a, a/2.
11894   24A6 1F                  DEFB    $1F             ;;sin           z, a, sin(a/2).
11895   24A7             
11896   24A7             ;   Note. after second sin, mem-0 and mem-1 become free.
11897   24A7             
11898   24A7 C1                  DEFB    $C1             ;;st-mem-1      z, a, sin(a/2).
11899   24A8 01                  DEFB    $01             ;;exchange      z, sin(a/2), a.
11900   24A9 C0                  DEFB    $C0             ;;st-mem-0      z, sin(a/2), a.  (for arc only)
11901   24AA             
11902   24AA             ;   Now form cos(a) from sin(a/2) using the 'DOUBLE ANGLE FORMULA'.
11903   24AA             
11904   24AA 02                  DEFB    $02             ;;delete        z, sin(a/2).
11905   24AB 31                  DEFB    $31             ;;duplicate     z, sin(a/2), sin(a/2).
11906   24AC 04                  DEFB    $04             ;;multiply      z, sin(a/2)*sin(a/2).
11907   24AD 31                  DEFB    $31             ;;duplicate     z, sin(a/2)*sin(a/2),
11908   24AE                                             ;;                           sin(a/2)*sin(a/2).
11909   24AE 0F                  DEFB    $0F             ;;addition      z, 2*sin(a/2)*sin(a/2).
11910   24AF A1                  DEFB    $A1             ;;stk-one       z, 2*sin(a/2)*sin(a/2), 1.
11911   24B0 03                  DEFB    $03             ;;subtract      z, 2*sin(a/2)*sin(a/2)-1.
11912   24B1             
11913   24B1 1B                  DEFB    $1B             ;;negate        z, 1-2*sin(a/2)*sin(a/2).  
11914   24B2             
11915   24B2 C3                  DEFB    $C3             ;;st-mem-3      z, cos(a).
11916   24B3 02                  DEFB    $02             ;;delete        z.
11917   24B4 38                  DEFB    $38             ;;end-calc      z.
11918   24B5             
11919   24B5             ;   The radius/diameter is left on the calculator stack.
11920   24B5             
11921   24B5 C1                  POP     BC              ; Restore the line count to the B register.
11922   24B6             
11923   24B6 C9                  RET                     ; Return.
11924   24B7             
11925   24B7             ; --------------------------
11926   24B7             ; THE 'DOUBLE ANGLE FORMULA'
11927   24B7             ; --------------------------
11928   24B7             ;   This formula forms cos(a) from sin(a/2) using simple arithmetic.
11929   24B7             ;
11930   24B7             ;   THE GEOMETRIC PROOF OF FORMULA   cos (a) = 1 - 2 * sin(a/2) * sin(a/2)
11931   24B7             ;                                                                    
11932   24B7             ;                                                                   
11933   24B7             ;                                            A                     
11934   24B7             ;                                                                 
11935   24B7             ;                                         . /|\                      
11936   24B7             ;                                     .    / | \                     
11937   24B7             ;                                  .      /  |  \                    
11938   24B7             ;                               .        /   |a/2\                   
11939   24B7             ;                            .          /    |    \                  
11940   24B7             ;                         .          1 /     |     \                 
11941   24B7             ;                      .              /      |      \                
11942   24B7             ;                   .                /       |       \               
11943   24B7             ;                .                  /        |        \              
11944   24B7             ;             .  a/2             D / a      E|-+       \             
11945   24B7             ;          B ---------------------/----------+-+--------\ C
11946   24B7             ;            <-         1       -><-       1           ->           
11947   24B7             ;
11948   24B7             ;   cos a = 1 - 2 * sin(a/2) * sin(a/2)
11949   24B7             ;
11950   24B7             ;   The figure shows a right triangle that inscribes a circle of radius 1 with
11951   24B7             ;   centre, or origin, D.  Line BC is the diameter of length 2 and A is a point 
11952   24B7             ;   on the circle. The periphery angle BAC is therefore a right angle by the 
11953   24B7             ;   Rule of Thales.
11954   24B7             ;   Line AC is a chord touching two points on the circle and the angle at the 
11955   24B7             ;   centre is (a).
11956   24B7             ;   Since the vertex of the largest triangle B touches the circle, the 
11957   24B7             ;   inscribed angle (a/2) is half the central angle (a).
11958   24B7             ;   The cosine of (a) is the length DE as the hypotenuse is of length 1.
11959   24B7             ;   This can also be expressed as 1-length CE.  Examining the triangle at the
11960   24B7             ;   right, the top angle is also (a/2) as angle BAE and EBA add to give a right
11961   24B7             ;   angle as do BAE and EAC.
11962   24B7             ;   So cos (a) = 1 - AC * sin(a/2) 
11963   24B7             ;   Looking at the largest triangle, side AC can be expressed as 
11964   24B7             ;   AC = 2 * sin(a/2)   and so combining these we get 
11965   24B7             ;   cos (a) = 1 - 2 * sin(a/2) * sin(a/2).
11966   24B7             ;
11967   24B7             ;   "I will be sufficiently rewarded if when telling it to others, you will 
11968   24B7             ;    not claim the discovery as your own, but will say it is mine."
11969   24B7             ;   - Thales, 640 - 546 B.C.
11970   24B7             ;
11971   24B7             ; --------------------------
11972   24B7             ; THE 'LINE DRAWING' ROUTINE
11973   24B7             ; --------------------------
11974   24B7             ;
11975   24B7             ;
11976   24B7             
11977   24B7             ;; DRAW-LINE
11978   24B7 CD 07 23    L24B7:   CALL    L2307           ; routine STK-TO-BC
11979   24BA 79                  LD      A,C             ;
11980   24BB B8                  CP      B               ;
11981   24BC 30 06               JR      NC,L24C4        ; to DL-X-GE-Y
11982   24BE             
11983   24BE 69                  LD      L,C             ;
11984   24BF D5                  PUSH    DE              ;
11985   24C0 AF                  XOR     A               ;
11986   24C1 5F                  LD      E,A             ;
11987   24C2 18 07               JR      L24CB           ; to DL-LARGER
11988   24C4             
11989   24C4             ; ---
11990   24C4             
11991   24C4             ;; DL-X-GE-Y
11992   24C4 B1          L24C4:   OR      C               ;
11993   24C5 C8                  RET     Z               ;
11994   24C6             
11995   24C6 68                  LD      L,B             ;
11996   24C7 41                  LD      B,C             ;
11997   24C8 D5                  PUSH    DE              ;
11998   24C9 16 00               LD      D,$00           ;
11999   24CB             
12000   24CB             ;; DL-LARGER
12001   24CB 60          L24CB:   LD      H,B             ;
12002   24CC 78                  LD      A,B             ;
12003   24CD 1F                  RRA                     ;
12004   24CE             
12005   24CE             ;; D-L-LOOP
12006   24CE 85          L24CE:   ADD     A,L             ;
12007   24CF 38 03               JR      C,L24D4         ; to D-L-DIAG
12008   24D1             
12009   24D1 BC                  CP      H               ;
12010   24D2 38 07               JR      C,L24DB         ; to D-L-HR-VT
12011   24D4             
12012   24D4             ;; D-L-DIAG
12013   24D4 94          L24D4:   SUB     H               ;
12014   24D5 4F                  LD      C,A             ;
12015   24D6 D9                  EXX                     ;
12016   24D7 C1                  POP     BC              ;
12017   24D8 C5                  PUSH    BC              ;
12018   24D9 18 04               JR      L24DF           ; to D-L-STEP
12019   24DB             
12020   24DB             ; ---
12021   24DB             
12022   24DB             ;; D-L-HR-VT
12023   24DB 4F          L24DB:   LD      C,A             ;
12024   24DC D5                  PUSH    DE              ;
12025   24DD D9                  EXX                     ;
12026   24DE C1                  POP     BC              ;
12027   24DF             
12028   24DF             ;; D-L-STEP
12029   24DF 2A 7D 5C    L24DF:   LD      HL,($5C7D)      ; COORDS
12030   24E2 78                  LD      A,B             ;
12031   24E3 84                  ADD     A,H             ;
12032   24E4 47                  LD      B,A             ;
12033   24E5 79                  LD      A,C             ;
12034   24E6 3C                  INC     A               ;
12035   24E7 85                  ADD     A,L             ;
12036   24E8 38 0D               JR      C,L24F7         ; to D-L-RANGE
12037   24EA             
12038   24EA 28 0D               JR      Z,L24F9         ; to REPORT-Bc
12039   24EC             
12040   24EC             ;; D-L-PLOT
12041   24EC 3D          L24EC:   DEC     A               ;
12042   24ED 4F                  LD      C,A             ;
12043   24EE CD E5 22            CALL    L22E5           ; routine PLOT-SUB
12044   24F1 D9                  EXX                     ;
12045   24F2 79                  LD      A,C             ;
12046   24F3 10 D9               DJNZ    L24CE           ; to D-L-LOOP
12047   24F5             
12048   24F5 D1                  POP     DE              ;
12049   24F6 C9                  RET                     ;
12050   24F7             
12051   24F7             ; ---
12052   24F7             
12053   24F7             ;; D-L-RANGE
12054   24F7 28 F3       L24F7:   JR      Z,L24EC         ; to D-L-PLOT
12055   24F9             
12056   24F9             
12057   24F9             ;; REPORT-Bc
12058   24F9 CF          L24F9:   RST     08H             ; ERROR-1
12059   24FA 0A                  DEFB    $0A             ; Error Report: Integer out of range
12060   24FB             
12061   24FB             
12062   24FB             
12063   24FB             ;***********************************
12064   24FB             ;** Part 8. EXPRESSION EVALUATION **
12065   24FB             ;***********************************
12066   24FB             ;
12067   24FB             ; It is a this stage of the ROM that the Spectrum ceases altogether to be
12068   24FB             ; just a colourful novelty. One remarkable feature is that in all previous
12069   24FB             ; commands when the Spectrum is expecting a number or a string then an
12070   24FB             ; expression of the same type can be substituted ad infinitum.
12071   24FB             ; This is the routine that evaluates that expression.
12072   24FB             ; This is what causes 2 + 2 to give the answer 4.
12073   24FB             ; That is quite easy to understand. However you don't have to make it much
12074   24FB             ; more complex to start a remarkable juggling act.
12075   24FB             ; e.g. PRINT 2 * (VAL "2+2" + TAN 3)
12076   24FB             ; In fact, provided there is enough free RAM, the Spectrum can evaluate
12077   24FB             ; an expression of unlimited complexity.
12078   24FB             ; Apart from a couple of minor glitches, which you can now correct, the
12079   24FB             ; system is remarkably robust.
12080   24FB             
12081   24FB             
12082   24FB             ; ---------------------------------
12083   24FB             ; Scan expression or sub-expression
12084   24FB             ; ---------------------------------
12085   24FB             ;
12086   24FB             ;
12087   24FB             
12088   24FB             ;; SCANNING
12089   24FB DF          L24FB:   RST     18H             ; GET-CHAR
12090   24FC 06 00               LD      B,$00           ; priority marker zero is pushed on stack
12091   24FE                                             ; to signify end of expression when it is
12092   24FE                                             ; popped off again.
12093   24FE C5                  PUSH    BC              ; put in on stack.
12094   24FF                                             ; and proceed to consider the first character
12095   24FF                                             ; of the expression.
12096   24FF             
12097   24FF             ;; S-LOOP-1
12098   24FF 4F          L24FF:   LD      C,A             ; store the character while a look up is done.
12099   2500 21 96 25            LD      HL,L2596        ; Address: scan-func
12100   2503 CD DC 16            CALL    L16DC           ; routine INDEXER is called to see if it is
12101   2506                                             ; part of a limited range '+', '(', 'ATTR' etc.
12102   2506             
12103   2506 79                  LD      A,C             ; fetch the character back
12104   2507 D2 84 26            JP      NC,L2684        ; jump forward to S-ALPHNUM if not in primary
12105   250A                                             ; operators and functions to consider in the
12106   250A                                             ; first instance a digit or a variable and
12107   250A                                             ; then anything else.                >>>
12108   250A             
12109   250A 06 00               LD      B,$00           ; but here if it was found in table so
12110   250C 4E                  LD      C,(HL)          ; fetch offset from table and make B zero.
12111   250D 09                  ADD     HL,BC           ; add the offset to position found
12112   250E E9                  JP      (HL)            ; and jump to the routine e.g. S-BIN
12113   250F                                             ; making an indirect exit from there.
12114   250F             
12115   250F             ; -------------------------------------------------------------------------
12116   250F             ; The four service subroutines for routines in the scanning function table
12117   250F             ; -------------------------------------------------------------------------
12118   250F             
12119   250F             ; PRINT """Hooray!"" he cried."
12120   250F             
12121   250F             ;; S-QUOTE-S
12122   250F CD 74 00    L250F:   CALL    L0074           ; routine CH-ADD+1 points to next character
12123   2512                                             ; and fetches that character.
12124   2512 03                  INC     BC              ; increase length counter.
12125   2513 FE 0D               CP      $0D             ; is it carriage return ?
12126   2515                                             ; inside a quote.
12127   2515 CA 8A 1C            JP      Z,L1C8A         ; jump back to REPORT-C if so.
12128   2518                                             ; 'Nonsense in BASIC'.
12129   2518             
12130   2518 FE 22               CP      $22             ; is it a quote '"' ?
12131   251A 20 F3               JR      NZ,L250F        ; back to S-QUOTE-S if not for more.
12132   251C             
12133   251C CD 74 00            CALL    L0074           ; routine CH-ADD+1
12134   251F FE 22               CP      $22             ; compare with possible adjacent quote
12135   2521 C9                  RET                     ; return. with zero set if two together.
12136   2522             
12137   2522             ; ---
12138   2522             
12139   2522             ; This subroutine is used to get two coordinate expressions for the three
12140   2522             ; functions SCREEN$, ATTR and POINT that have two fixed parameters and
12141   2522             ; therefore require surrounding braces.
12142   2522             
12143   2522             ;; S-2-COORD
12144   2522 E7          L2522:   RST     20H             ; NEXT-CHAR
12145   2523 FE 28               CP      $28             ; is it the opening '(' ?
12146   2525 20 06               JR      NZ,L252D        ; forward to S-RPORT-C if not
12147   2527                                             ; 'Nonsense in BASIC'.
12148   2527             
12149   2527 CD 79 1C            CALL    L1C79           ; routine NEXT-2NUM gets two comma-separated
12150   252A                                             ; numeric expressions. Note. this could cause
12151   252A                                             ; many more recursive calls to SCANNING but
12152   252A                                             ; the parent function will be evaluated fully
12153   252A                                             ; before rejoining the main juggling act.
12154   252A             
12155   252A DF                  RST     18H             ; GET-CHAR
12156   252B FE 29               CP      $29             ; is it the closing ')' ?
12157   252D             
12158   252D             ;; S-RPORT-C
12159   252D C2 8A 1C    L252D:   JP      NZ,L1C8A        ; jump back to REPORT-C if not.
12160   2530                                             ; 'Nonsense in BASIC'.
12161   2530             
12162   2530             ; ------------
12163   2530             ; Check syntax
12164   2530             ; ------------
12165   2530             ; This routine is called on a number of occasions to check if syntax is being
12166   2530             ; checked or if the program is being run. To test the flag inline would use
12167   2530             ; four bytes of code, but a call instruction only uses 3 bytes of code.
12168   2530             
12169   2530             ;; SYNTAX-Z
12170   2530 FD CB 01 7E L2530:   BIT     7,(IY+$01)      ; test FLAGS  - checking syntax only ?
12171   2534 C9                  RET                     ; return.
12172   2535             
12173   2535             ; ----------------
12174   2535             ; Scanning SCREEN$
12175   2535             ; ----------------
12176   2535             ; This function returns the code of a bit-mapped character at screen
12177   2535             ; position at line C, column B. It is unable to detect the mosaic characters
12178   2535             ; which are not bit-mapped but detects the ASCII 32 - 127 range.
12179   2535             ; The bit-mapped UDGs are ignored which is curious as it requires only a
12180   2535             ; few extra bytes of code. As usual, anything to do with CHARS is weird.
12181   2535             ; If no match is found a null string is returned.
12182   2535             ; No actual check on ranges is performed - that's up to the BASIC programmer.
12183   2535             ; No real harm can come from SCREEN$(255,255) although the BASIC manual
12184   2535             ; says that invalid values will be trapped.
12185   2535             ; Interestingly, in the Pitman pocket guide, 1984, Vickers says that the
12186   2535             ; range checking will be performed. 
12187   2535             
12188   2535             ;; S-SCRN$-S
12189   2535 CD 07 23    L2535:   CALL    L2307           ; routine STK-TO-BC.
12190   2538 2A 36 5C            LD      HL,($5C36)      ; fetch address of CHARS.
12191   253B 11 00 01            LD      DE,$0100        ; fetch offset to chr$ 32
12192   253E 19                  ADD     HL,DE           ; and find start of bitmaps.
12193   253F                                             ; Note. not inc h. ??
12194   253F 79                  LD      A,C             ; transfer line to A.
12195   2540 0F                  RRCA                    ; multiply
12196   2541 0F                  RRCA                    ; by
12197   2542 0F                  RRCA                    ; thirty-two.
12198   2543 E6 E0               AND     $E0             ; and with 11100000
12199   2545 A8                  XOR     B               ; combine with column $00 - $1F
12200   2546 5F                  LD      E,A             ; to give the low byte of top line
12201   2547 79                  LD      A,C             ; column to A range 00000000 to 00011111
12202   2548 E6 18               AND     $18             ; and with 00011000
12203   254A EE 40               XOR     $40             ; xor with 01000000 (high byte screen start)
12204   254C 57                  LD      D,A             ; register DE now holds start address of cell.
12205   254D 06 60               LD      B,$60           ; there are 96 characters in ASCII set.
12206   254F             
12207   254F             ;; S-SCRN-LP
12208   254F C5          L254F:   PUSH    BC              ; save count
12209   2550 D5                  PUSH    DE              ; save screen start address
12210   2551 E5                  PUSH    HL              ; save bitmap start
12211   2552 1A                  LD      A,(DE)          ; first byte of screen to A
12212   2553 AE                  XOR     (HL)            ; xor with corresponding character byte
12213   2554 28 04               JR      Z,L255A         ; forward to S-SC-MTCH if they match
12214   2556                                             ; if inverse result would be $FF
12215   2556                                             ; if any other then mismatch
12216   2556             
12217   2556 3C                  INC     A               ; set to $00 if inverse
12218   2557 20 1A               JR      NZ,L2573        ; forward to S-SCR-NXT if a mismatch
12219   2559             
12220   2559 3D                  DEC     A               ; restore $FF
12221   255A             
12222   255A             ; a match has been found so seven more to test.
12223   255A             
12224   255A             ;; S-SC-MTCH
12225   255A 4F          L255A:   LD      C,A             ; load C with inverse mask $00 or $FF
12226   255B 06 07               LD      B,$07           ; count seven more bytes
12227   255D             
12228   255D             ;; S-SC-ROWS
12229   255D 14          L255D:   INC     D               ; increment screen address.
12230   255E 23                  INC     HL              ; increment bitmap address.
12231   255F 1A                  LD      A,(DE)          ; byte to A
12232   2560 AE                  XOR     (HL)            ; will give $00 or $FF (inverse)
12233   2561 A9                  XOR     C               ; xor with inverse mask
12234   2562 20 0F               JR      NZ,L2573        ; forward to S-SCR-NXT if no match.
12235   2564             
12236   2564 10 F7               DJNZ    L255D           ; back to S-SC-ROWS until all eight matched.
12237   2566             
12238   2566             ; continue if a match of all eight bytes was found
12239   2566             
12240   2566 C1                  POP     BC              ; discard the
12241   2567 C1                  POP     BC              ; saved
12242   2568 C1                  POP     BC              ; pointers
12243   2569 3E 80               LD      A,$80           ; the endpoint of character set
12244   256B 90                  SUB     B               ; subtract the counter
12245   256C                                             ; to give the code 32-127
12246   256C 01 01 00            LD      BC,$0001        ; make one space in workspace.
12247   256F             
12248   256F F7                  RST     30H             ; BC-SPACES creates the space sliding
12249   2570                                             ; the calculator stack upwards.
12250   2570 12                  LD      (DE),A          ; start is addressed by DE, so insert code
12251   2571 18 0A               JR      L257D           ; forward to S-SCR-STO
12252   2573             
12253   2573             ; ---
12254   2573             
12255   2573             ; the jump was here if no match and more bitmaps to test.
12256   2573             
12257   2573             ;; S-SCR-NXT
12258   2573 E1          L2573:   POP     HL              ; restore the last bitmap start
12259   2574 11 08 00            LD      DE,$0008        ; and prepare to add 8.
12260   2577 19                  ADD     HL,DE           ; now addresses next character bitmap.
12261   2578 D1                  POP     DE              ; restore screen address
12262   2579 C1                  POP     BC              ; and character counter in B
12263   257A 10 D3               DJNZ    L254F           ; back to S-SCRN-LP if more characters.
12264   257C             
12265   257C 48                  LD      C,B             ; B is now zero, so BC now zero.
12266   257D             
12267   257D             ;; S-SCR-STO
12268   257D C3 B2 2A    L257D:   JP      L2AB2           ; to STK-STO-$ to store the string in
12269   2580                                             ; workspace or a string with zero length.
12270   2580                                             ; (value of DE doesn't matter in last case)
12271   2580             
12272   2580             ; Note. this exit seems correct but the general-purpose routine S-STRING
12273   2580             ; that calls this one will also stack any of its string results so this
12274   2580             ; leads to a double storing of the result in this case.
12275   2580             ; The instruction at L257D should just be a RET.
12276   2580             ; credit Stephen Kelly and others, 1982.
12277   2580             
12278   2580             ; -------------
12279   2580             ; Scanning ATTR
12280   2580             ; -------------
12281   2580             ; This function subroutine returns the attributes of a screen location -
12282   2580             ; a numeric result.
12283   2580             ; Again it's up to the BASIC programmer to supply valid values of line/column.
12284   2580             
12285   2580             ;; S-ATTR-S
12286   2580 CD 07 23    L2580:   CALL    L2307           ; routine STK-TO-BC fetches line to C,
12287   2583                                             ; and column to B.
12288   2583 79                  LD      A,C             ; line to A $00 - $17   (max 00010111)
12289   2584 0F                  RRCA                    ; rotate
12290   2585 0F                  RRCA                    ; bits
12291   2586 0F                  RRCA                    ; left.
12292   2587 4F                  LD      C,A             ; store in C as an intermediate value.
12293   2588             
12294   2588 E6 E0               AND     $E0             ; pick up bits 11100000 ( was 00011100 )
12295   258A A8                  XOR     B               ; combine with column $00 - $1F
12296   258B 6F                  LD      L,A             ; low byte now correct.
12297   258C             
12298   258C 79                  LD      A,C             ; bring back intermediate result from C
12299   258D E6 03               AND     $03             ; mask to give correct third of
12300   258F                                             ; screen $00 - $02
12301   258F EE 58               XOR     $58             ; combine with base address.
12302   2591 67                  LD      H,A             ; high byte correct.
12303   2592 7E                  LD      A,(HL)          ; pick up the colour attribute.
12304   2593 C3 28 2D            JP      L2D28           ; forward to STACK-A to store result
12305   2596                                             ; and make an indirect exit.
12306   2596             
12307   2596             ; -----------------------
12308   2596             ; Scanning function table
12309   2596             ; -----------------------
12310   2596             ; This table is used by INDEXER routine to find the offsets to
12311   2596             ; four operators and eight functions. e.g. $A8 is the token 'FN'.
12312   2596             ; This table is used in the first instance for the first character of an
12313   2596             ; expression or by a recursive call to SCANNING for the first character of
12314   2596             ; any sub-expression. It eliminates functions that have no argument or
12315   2596             ; functions that can have more than one argument and therefore require
12316   2596             ; braces. By eliminating and dealing with these now it can later take a
12317   2596             ; simplistic approach to all other functions and assume that they have
12318   2596             ; one argument.
12319   2596             ; Similarly by eliminating BIN and '.' now it is later able to assume that
12320   2596             ; all numbers begin with a digit and that the presence of a number or
12321   2596             ; variable can be detected by a call to ALPHANUM.
12322   2596             ; By default all expressions are positive and the spurious '+' is eliminated
12323   2596             ; now as in print +2. This should not be confused with the operator '+'.
12324   2596             ; Note. this does allow a degree of nonsense to be accepted as in
12325   2596             ; PRINT +"3 is the greatest.".
12326   2596             ; An acquired programming skill is the ability to include brackets where
12327   2596             ; they are not necessary.
12328   2596             ; A bracket at the start of a sub-expression may be spurious or necessary
12329   2596             ; to denote that the contained expression is to be evaluated as an entity.
12330   2596             ; In either case this is dealt with by recursive calls to SCANNING.
12331   2596             ; An expression that begins with a quote requires special treatment.
12332   2596             
12333   2596             ;; scan-func
12334   2596 22 1C       L2596:   DEFB    $22, L25B3-$-1  ; $1C offset to S-QUOTE
12335   2598 28 4F               DEFB    '(', L25E8-$-1  ; $4F offset to S-BRACKET
12336   259A 2E F2               DEFB    '.', L268D-$-1  ; $F2 offset to S-DECIMAL
12337   259C 2B 12               DEFB    '+', L25AF-$-1  ; $12 offset to S-U-PLUS
12338   259E             
12339   259E A8 56               DEFB    $A8, L25F5-$-1  ; $56 offset to S-FN
12340   25A0 A5 57               DEFB    $A5, L25F8-$-1  ; $57 offset to S-RND
12341   25A2 A7 84               DEFB    $A7, L2627-$-1  ; $84 offset to S-PI
12342   25A4 A6 8F               DEFB    $A6, L2634-$-1  ; $8F offset to S-INKEY$
12343   25A6 C4 E6               DEFB    $C4, L268D-$-1  ; $E6 offset to S-BIN
12344   25A8 AA BF               DEFB    $AA, L2668-$-1  ; $BF offset to S-SCREEN$
12345   25AA AB C7               DEFB    $AB, L2672-$-1  ; $C7 offset to S-ATTR
12346   25AC A9 CE               DEFB    $A9, L267B-$-1  ; $CE offset to S-POINT
12347   25AE             
12348   25AE 00                  DEFB    $00             ; zero end marker
12349   25AF             
12350   25AF             ; --------------------------
12351   25AF             ; Scanning function routines
12352   25AF             ; --------------------------
12353   25AF             ; These are the 11 subroutines accessed by the above table.
12354   25AF             ; S-BIN and S-DECIMAL are the same
12355   25AF             ; The 1-byte offset limits their location to within 255 bytes of their
12356   25AF             ; entry in the table.
12357   25AF             
12358   25AF             ; ->
12359   25AF             ;; S-U-PLUS
12360   25AF E7          L25AF:   RST     20H             ; NEXT-CHAR just ignore
12361   25B0 C3 FF 24            JP      L24FF           ; to S-LOOP-1
12362   25B3             
12363   25B3             ; ---
12364   25B3             
12365   25B3             ; ->
12366   25B3             ;; S-QUOTE
12367   25B3 DF          L25B3:   RST     18H             ; GET-CHAR
12368   25B4 23                  INC     HL              ; address next character (first in quotes)
12369   25B5 E5                  PUSH    HL              ; save start of quoted text.
12370   25B6 01 00 00            LD      BC,$0000        ; initialize length of string to zero.
12371   25B9 CD 0F 25            CALL    L250F           ; routine S-QUOTE-S
12372   25BC 20 1B               JR      NZ,L25D9        ; forward to S-Q-PRMS if
12373   25BE             
12374   25BE             ;; S-Q-AGAIN
12375   25BE CD 0F 25    L25BE:   CALL    L250F           ; routine S-QUOTE-S copies string until a
12376   25C1                                             ; quote is encountered
12377   25C1 28 FB               JR      Z,L25BE         ; back to S-Q-AGAIN if two quotes WERE
12378   25C3                                             ; together.
12379   25C3             
12380   25C3             ; but if just an isolated quote then that terminates the string.
12381   25C3             
12382   25C3 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
12383   25C6 28 11               JR      Z,L25D9         ; forward to S-Q-PRMS if checking syntax.
12384   25C8             
12385   25C8             
12386   25C8 F7                  RST     30H             ; BC-SPACES creates the space for true
12387   25C9                                             ; copy of string in workspace.
12388   25C9 E1                  POP     HL              ; re-fetch start of quoted text.
12389   25CA D5                  PUSH    DE              ; save start in workspace.
12390   25CB             
12391   25CB             ;; S-Q-COPY
12392   25CB 7E          L25CB:   LD      A,(HL)          ; fetch a character from source.
12393   25CC 23                  INC     HL              ; advance source address.
12394   25CD 12                  LD      (DE),A          ; place in destination.
12395   25CE 13                  INC     DE              ; advance destination address.
12396   25CF FE 22               CP      $22             ; was it a '"' just copied ?
12397   25D1 20 F8               JR      NZ,L25CB        ; back to S-Q-COPY to copy more if not
12398   25D3             
12399   25D3 7E                  LD      A,(HL)          ; fetch adjacent character from source.
12400   25D4 23                  INC     HL              ; advance source address.
12401   25D5 FE 22               CP      $22             ; is this '"' ? - i.e. two quotes together ?
12402   25D7 28 F2               JR      Z,L25CB         ; to S-Q-COPY if so including just one of the
12403   25D9                                             ; pair of quotes.
12404   25D9             
12405   25D9             ; proceed when terminating quote encountered.
12406   25D9             
12407   25D9             ;; S-Q-PRMS
12408   25D9 0B          L25D9:   DEC     BC              ; decrease count by 1.
12409   25DA D1                  POP     DE              ; restore start of string in workspace.
12410   25DB             
12411   25DB             ;; S-STRING
12412   25DB 21 3B 5C    L25DB:   LD      HL,$5C3B        ; Address FLAGS system variable.
12413   25DE CB B6               RES     6,(HL)          ; signal string result.
12414   25E0 CB 7E               BIT     7,(HL)          ; is syntax being checked.
12415   25E2 C4 B2 2A            CALL    NZ,L2AB2        ; routine STK-STO-$ is called in runtime.
12416   25E5 C3 12 27            JP      L2712           ; jump forward to S-CONT-2          ===>
12417   25E8             
12418   25E8             ; ---
12419   25E8             
12420   25E8             ; ->
12421   25E8             ;; S-BRACKET
12422   25E8 E7          L25E8:   RST     20H             ; NEXT-CHAR
12423   25E9 CD FB 24            CALL    L24FB           ; routine SCANNING is called recursively.
12424   25EC FE 29               CP      $29             ; is it the closing ')' ?
12425   25EE C2 8A 1C            JP      NZ,L1C8A        ; jump back to REPORT-C if not
12426   25F1                                             ; 'Nonsense in BASIC'
12427   25F1             
12428   25F1 E7                  RST     20H             ; NEXT-CHAR
12429   25F2 C3 12 27            JP      L2712           ; jump forward to S-CONT-2          ===>
12430   25F5             
12431   25F5             ; ---
12432   25F5             
12433   25F5             ; ->
12434   25F5             ;; S-FN
12435   25F5 C3 BD 27    L25F5:   JP      L27BD           ; jump forward to S-FN-SBRN.
12436   25F8             
12437   25F8             ; --------------------------------------------------------------------
12438   25F8             ;
12439   25F8             ;   RANDOM THEORY from the ZX81 manual by Steven Vickers
12440   25F8             ;
12441   25F8             ;   (same algorithm as the ZX Spectrum).
12442   25F8             ; 
12443   25F8             ;   Chapter 5. Exercise 6. (For mathematicians only.)
12444   25F8             ;
12445   25F8             ;   Let p be a [large] prime, & let a be a primitive root modulo p.
12446   25F8             ;   Then if b_i is the residue of a^i modulo p (1<=b_i<p-1), the 
12447   25F8             ;   sequence             
12448   25F8             ;   
12449   25F8             ;                           (b_i-1)/(p-1)
12450   25F8             ;               
12451   25F8             ;   is a cyclical sequence of p-1 distinct numbers in the range 0 to 1
12452   25F8             ;   (excluding 1). By choosing a suitably, these can be made to look 
12453   25F8             ;   fairly random.
12454   25F8             ;
12455   25F8             ;     65537 is a Mersenne prime 2^16-1. Note.
12456   25F8             ;
12457   25F8             ;   Use this, & Gauss' law of quadratic reciprocity, to show that 75 
12458   25F8             ;   is a primitive root modulo 65537.
12459   25F8             ;
12460   25F8             ;     The ZX81 uses p=65537 & a=75, & stores some b_i-1 in memory. 
12461   25F8             ;   The function RND involves replacing b_i-1 in memory by b_(i+1)-1, 
12462   25F8             ;   & yielding the result (b_(i+1)-1)/(p-1). RAND n (with 1<=n<=65535)
12463   25F8             ;   makes b_i equal to n+1.
12464   25F8             ;
12465   25F8             ; --------------------------------------------------------------------
12466   25F8             ;
12467   25F8             ; Steven Vickers writing in comp.sys.sinclair on 20-DEC-1993
12468   25F8             ; 
12469   25F8             ;   Note. (Of course, 65537 is 2^16 + 1, not -1.)
12470   25F8             ;
12471   25F8             ;   Consider arithmetic modulo a prime p. There are p residue classes, and the
12472   25F8             ;   non-zero ones are all invertible. Hence under multiplication they form a
12473   25F8             ;   group (Fp*, say) of order p-1; moreover (and not so obvious) Fp* is cyclic.
12474   25F8             ;   Its generators are the "primitive roots". The "quadratic residues modulo p"
12475   25F8             ;   are the squares in Fp*, and the "Legendre symbol" (d/p) is defined (when p
12476   25F8             ;   does not divide d) as +1 or -1, according as d is or is not a quadratic
12477   25F8             ;   residue mod p.
12478   25F8             ;
12479   25F8             ;   In the case when p = 65537, we can show that d is a primitive root if and
12480   25F8             ;   only if it's not a quadratic residue. For let w be a primitive root, d
12481   25F8             ;   congruent to w^r (mod p). If d is not primitive, then its order is a proper
12482   25F8             ;   factor of 65536: hence w^{32768*r} = 1 (mod p), so 65536 divides 32768*r,
12483   25F8             ;   and hence r is even and d is a square (mod p). Conversely, the squares in
12484   25F8             ;   Fp* form a subgroup of (Fp*)^2 of index 2, and so cannot be generators.
12485   25F8             ;
12486   25F8             ;   Hence to check whether 75 is primitive mod 65537, we want to calculate that
12487   25F8             ;   (75/65537) = -1. There is a multiplicative formula (ab/p) = (a/p)(b/p) (mod
12488   25F8             ;   p), so (75/65537) = (5/65537)^2 * (3/65537) = (3/65537). Now the law of
12489   25F8             ;   quadratic reciprocity says that if p and q are distinct odd primes, then
12490   25F8             ;
12491   25F8             ;    (p/q)(q/p) = (-1)^{(p-1)(q-1)/4}
12492   25F8             ;
12493   25F8             ;   Hence (3/65537) = (65537/3) * (-1)^{65536*2/4} = (65537/3)
12494   25F8             ;            = (2/3)  (because 65537 = 2 mod 3)
12495   25F8             ;            = -1
12496   25F8             ;
12497   25F8             ;   (I referred to Pierre Samuel's "Algebraic Theory of Numbers".)
12498   25F8             ;
12499   25F8             ; ->
12500   25F8             
12501   25F8             ;; S-RND
12502   25F8 CD 30 25    L25F8:   CALL    L2530           ; routine SYNTAX-Z
12503   25FB 28 28               JR      Z,L2625         ; forward to S-RND-END if checking syntax.
12504   25FD             
12505   25FD ED 4B 76 5C         LD      BC,($5C76)      ; fetch system variable SEED
12506   2601 CD 2B 2D            CALL    L2D2B           ; routine STACK-BC places on calculator stack
12507   2604             
12508   2604 EF                  RST     28H             ;; FP-CALC           ;s.
12509   2605 A1                  DEFB    $A1             ;;stk-one            ;s,1.
12510   2606 0F                  DEFB    $0F             ;;addition           ;s+1.
12511   2607 34                  DEFB    $34             ;;stk-data           ;
12512   2608 37                  DEFB    $37             ;;Exponent: $87,
12513   2609                                             ;;Bytes: 1
12514   2609 16                  DEFB    $16             ;;(+00,+00,+00)      ;s+1,75.
12515   260A 04                  DEFB    $04             ;;multiply           ;(s+1)*75 = v
12516   260B 34                  DEFB    $34             ;;stk-data           ;v.
12517   260C 80                  DEFB    $80             ;;Bytes: 3
12518   260D 41                  DEFB    $41             ;;Exponent $91
12519   260E 00 00 80            DEFB    $00,$00,$80     ;;(+00)              ;v,65537.
12520   2611 32                  DEFB    $32             ;;n-mod-m            ;remainder, result.
12521   2612 02                  DEFB    $02             ;;delete             ;remainder.
12522   2613 A1                  DEFB    $A1             ;;stk-one            ;remainder, 1.
12523   2614 03                  DEFB    $03             ;;subtract           ;remainder - 1. = rnd
12524   2615 31                  DEFB    $31             ;;duplicate          ;rnd,rnd.
12525   2616 38                  DEFB    $38             ;;end-calc
12526   2617             
12527   2617 CD A2 2D            CALL    L2DA2           ; routine FP-TO-BC
12528   261A ED 43 76 5C         LD      ($5C76),BC      ; store in SEED for next starting point.
12529   261E 7E                  LD      A,(HL)          ; fetch exponent
12530   261F A7                  AND     A               ; is it zero ?
12531   2620 28 03               JR      Z,L2625         ; forward if so to S-RND-END
12532   2622             
12533   2622 D6 10               SUB     $10             ; reduce exponent by 2^16
12534   2624 77                  LD      (HL),A          ; place back
12535   2625             
12536   2625             ;; S-RND-END
12537   2625 18 09       L2625:   JR      L2630           ; forward to S-PI-END
12538   2627             
12539   2627             ; ---
12540   2627             
12541   2627             ; the number PI 3.14159...
12542   2627             
12543   2627             ; ->
12544   2627             ;; S-PI
12545   2627 CD 30 25    L2627:   CALL    L2530           ; routine SYNTAX-Z
12546   262A 28 04               JR      Z,L2630         ; to S-PI-END if checking syntax.
12547   262C             
12548   262C EF                  RST     28H             ;; FP-CALC
12549   262D A3                  DEFB    $A3             ;;stk-pi/2                          pi/2.
12550   262E 38                  DEFB    $38             ;;end-calc
12551   262F             
12552   262F 34                  INC     (HL)            ; increment the exponent leaving pi
12553   2630                                             ; on the calculator stack.
12554   2630             
12555   2630             ;; S-PI-END
12556   2630 E7          L2630:   RST     20H             ; NEXT-CHAR
12557   2631 C3 C3 26            JP      L26C3           ; jump forward to S-NUMERIC
12558   2634             
12559   2634             ; ---
12560   2634             
12561   2634             ; ->
12562   2634             ;; S-INKEY$
12563   2634 01 5A 10    L2634:   LD      BC,$105A        ; priority $10, operation code $1A ('read-in')
12564   2637                                             ; +$40 for string result, numeric operand.
12565   2637                                             ; set this up now in case we need to use the
12566   2637                                             ; calculator.
12567   2637 E7                  RST     20H             ; NEXT-CHAR
12568   2638 FE 23               CP      $23             ; '#' ?
12569   263A CA 0D 27            JP      Z,L270D         ; to S-PUSH-PO if so to use the calculator
12570   263D                                             ; single operation
12571   263D                                             ; to read from network/RS232 etc. .
12572   263D             
12573   263D             ; else read a key from the keyboard.
12574   263D             
12575   263D 21 3B 5C            LD      HL,$5C3B        ; fetch FLAGS
12576   2640 CB B6               RES     6,(HL)          ; signal string result.
12577   2642 CB 7E               BIT     7,(HL)          ; checking syntax ?
12578   2644 28 1F               JR      Z,L2665         ; forward to S-INK$-EN if so
12579   2646             
12580   2646 CD 8E 02            CALL    L028E           ; routine KEY-SCAN key in E, shift in D.
12581   2649 0E 00               LD      C,$00           ; the length of an empty string
12582   264B 20 13               JR      NZ,L2660        ; to S-IK$-STK to store empty string if
12583   264D                                             ; no key returned.
12584   264D             
12585   264D CD 1E 03            CALL    L031E           ; routine K-TEST get main code in A
12586   2650 30 0E               JR      NC,L2660        ; to S-IK$-STK to stack null string if
12587   2652                                             ; invalid
12588   2652             
12589   2652 15                  DEC     D               ; D is expected to be FLAGS so set bit 3 $FF
12590   2653                                             ; 'L' Mode so no keywords.
12591   2653 5F                  LD      E,A             ; main key to A
12592   2654                                             ; C is MODE 0 'KLC' from above still.
12593   2654 CD 33 03            CALL    L0333           ; routine K-DECODE
12594   2657 F5                  PUSH    AF              ; save the code
12595   2658 01 01 00            LD      BC,$0001        ; make room for one character
12596   265B             
12597   265B F7                  RST     30H             ; BC-SPACES
12598   265C F1                  POP     AF              ; bring the code back
12599   265D 12                  LD      (DE),A          ; put the key in workspace
12600   265E 0E 01               LD      C,$01           ; set C length to one
12601   2660             
12602   2660             ;; S-IK$-STK
12603   2660 06 00       L2660:   LD      B,$00           ; set high byte of length to zero
12604   2662 CD B2 2A            CALL    L2AB2           ; routine STK-STO-$
12605   2665             
12606   2665             ;; S-INK$-EN
12607   2665 C3 12 27    L2665:   JP      L2712           ; to S-CONT-2            ===>
12608   2668             
12609   2668             ; ---
12610   2668             
12611   2668             ; ->
12612   2668             ;; S-SCREEN$
12613   2668 CD 22 25    L2668:   CALL    L2522           ; routine S-2-COORD
12614   266B C4 35 25            CALL    NZ,L2535        ; routine S-SCRN$-S
12615   266E             
12616   266E E7                  RST     20H             ; NEXT-CHAR
12617   266F C3 DB 25            JP      L25DB           ; forward to S-STRING to stack result
12618   2672             
12619   2672             ; ---
12620   2672             
12621   2672             ; ->
12622   2672             ;; S-ATTR
12623   2672 CD 22 25    L2672:   CALL    L2522           ; routine S-2-COORD
12624   2675 C4 80 25            CALL    NZ,L2580        ; routine S-ATTR-S
12625   2678             
12626   2678 E7                  RST     20H             ; NEXT-CHAR
12627   2679 18 48               JR      L26C3           ; forward to S-NUMERIC
12628   267B             
12629   267B             ; ---
12630   267B             
12631   267B             ; ->
12632   267B             ;; S-POINT
12633   267B CD 22 25    L267B:   CALL    L2522           ; routine S-2-COORD
12634   267E C4 CB 22            CALL    NZ,L22CB        ; routine POINT-SUB
12635   2681             
12636   2681 E7                  RST     20H             ; NEXT-CHAR
12637   2682 18 3F               JR      L26C3           ; forward to S-NUMERIC
12638   2684             
12639   2684             ; -----------------------------
12640   2684             
12641   2684             ; ==> The branch was here if not in table.
12642   2684             
12643   2684             ;; S-ALPHNUM
12644   2684 CD 88 2C    L2684:   CALL    L2C88           ; routine ALPHANUM checks if variable or
12645   2687                                             ; a digit.
12646   2687 30 56               JR      NC,L26DF        ; forward to S-NEGATE if not to consider
12647   2689                                             ; a '-' character then functions.
12648   2689             
12649   2689 FE 41               CP      $41             ; compare 'A'
12650   268B 30 3C               JR      NC,L26C9        ; forward to S-LETTER if alpha       ->
12651   268D                                             ; else must have been numeric so continue
12652   268D                                             ; into that routine.
12653   268D             
12654   268D             ; This important routine is called during runtime and from LINE-SCAN
12655   268D             ; when a BASIC line is checked for syntax. It is this routine that
12656   268D             ; inserts, during syntax checking, the invisible floating point numbers
12657   268D             ; after the numeric expression. During runtime it just picks these
12658   268D             ; numbers up. It also handles BIN format numbers.
12659   268D             
12660   268D             ; ->
12661   268D             ;; S-BIN
12662   268D             ;; S-DECIMAL
12663   268D CD 30 25    L268D:   CALL    L2530           ; routine SYNTAX-Z
12664   2690 20 23               JR      NZ,L26B5        ; to S-STK-DEC in runtime
12665   2692             
12666   2692             ; this route is taken when checking syntax.
12667   2692             
12668   2692 CD 9B 2C            CALL    L2C9B           ; routine DEC-TO-FP to evaluate number
12669   2695             
12670   2695 DF                  RST     18H             ; GET-CHAR to fetch HL
12671   2696 01 06 00            LD      BC,$0006        ; six locations required
12672   2699 CD 55 16            CALL    L1655           ; routine MAKE-ROOM
12673   269C 23                  INC     HL              ; to first new location
12674   269D 36 0E               LD      (HL),$0E        ; insert number marker
12675   269F 23                  INC     HL              ; address next
12676   26A0 EB                  EX      DE,HL           ; make DE destination.
12677   26A1 2A 65 5C            LD      HL,($5C65)      ; STKEND points to end of stack.
12678   26A4 0E 05               LD      C,$05           ; result is five locations lower
12679   26A6 A7                  AND     A               ; prepare for true subtraction
12680   26A7 ED 42               SBC     HL,BC           ; point to start of value.
12681   26A9 22 65 5C            LD      ($5C65),HL      ; update STKEND as we are taking number.
12682   26AC ED B0               LDIR                    ; Copy five bytes to program location
12683   26AE EB                  EX      DE,HL           ; transfer pointer to HL
12684   26AF 2B                  DEC     HL              ; adjust
12685   26B0 CD 77 00            CALL    L0077           ; routine TEMP-PTR1 sets CH-ADD
12686   26B3 18 0E               JR      L26C3           ; to S-NUMERIC to record nature of result
12687   26B5             
12688   26B5             ; ---
12689   26B5             
12690   26B5             ; branch here in runtime.
12691   26B5             
12692   26B5             ;; S-STK-DEC
12693   26B5 DF          L26B5:   RST     18H             ; GET-CHAR positions HL at digit.
12694   26B6             
12695   26B6             ;; S-SD-SKIP
12696   26B6 23          L26B6:   INC     HL              ; advance pointer
12697   26B7 7E                  LD      A,(HL)          ; until we find
12698   26B8 FE 0E               CP      $0E             ; chr 14d - the number indicator
12699   26BA 20 FA               JR      NZ,L26B6        ; to S-SD-SKIP until a match
12700   26BC                                             ; it has to be here.
12701   26BC             
12702   26BC 23                  INC     HL              ; point to first byte of number
12703   26BD CD B4 33            CALL    L33B4           ; routine STACK-NUM stacks it
12704   26C0 22 5D 5C            LD      ($5C5D),HL      ; update system variable CH_ADD
12705   26C3             
12706   26C3             ;; S-NUMERIC
12707   26C3 FD CB 01 F6 L26C3:   SET     6,(IY+$01)      ; update FLAGS  - Signal numeric result
12708   26C7 18 14               JR      L26DD           ; forward to S-CONT-1               ===>
12709   26C9                                             ; actually S-CONT-2 is destination but why
12710   26C9                                             ; waste a byte on a jump when a JR will do.
12711   26C9                                             ; Actually a JR L2712 can be used. Rats.
12712   26C9             
12713   26C9             ; end of functions accessed from scanning functions table.
12714   26C9             
12715   26C9             ; --------------------------
12716   26C9             ; Scanning variable routines
12717   26C9             ; --------------------------
12718   26C9             ;
12719   26C9             ;
12720   26C9             
12721   26C9             ;; S-LETTER
12722   26C9 CD B2 28    L26C9:   CALL    L28B2           ; routine LOOK-VARS
12723   26CC             
12724   26CC DA 2E 1C            JP      C,L1C2E         ; jump back to REPORT-2 if variable not found
12725   26CF                                             ; 'Variable not found'
12726   26CF                                             ; but a variable is always 'found' if syntax
12727   26CF                                             ; is being checked.
12728   26CF             
12729   26CF CC 96 29            CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
12730   26D2 3A 3B 5C            LD      A,($5C3B)       ; fetch FLAGS value
12731   26D5 FE C0               CP      $C0             ; compare 11000000
12732   26D7 38 04               JR      C,L26DD         ; step forward to S-CONT-1 if string  ===>
12733   26D9             
12734   26D9 23                  INC     HL              ; advance pointer
12735   26DA CD B4 33            CALL    L33B4           ; routine STACK-NUM
12736   26DD             
12737   26DD             ;; S-CONT-1
12738   26DD 18 33       L26DD:   JR      L2712           ; forward to S-CONT-2                 ===>
12739   26DF             
12740   26DF             ; ----------------------------------------
12741   26DF             ; -> the scanning branch was here if not alphanumeric.
12742   26DF             ; All the remaining functions will be evaluated by a single call to the
12743   26DF             ; calculator. The correct priority for the operation has to be placed in
12744   26DF             ; the B register and the operation code, calculator literal in the C register.
12745   26DF             ; the operation code has bit 7 set if result is numeric and bit 6 is
12746   26DF             ; set if operand is numeric. so
12747   26DF             ; $C0 = numeric result, numeric operand.            e.g. 'sin'
12748   26DF             ; $80 = numeric result, string operand.             e.g. 'code'
12749   26DF             ; $40 = string result, numeric operand.             e.g. 'str$'
12750   26DF             ; $00 = string result, string operand.              e.g. 'val$'
12751   26DF             
12752   26DF             ;; S-NEGATE
12753   26DF 01 DB 09    L26DF:   LD      BC,$09DB        ; prepare priority 09, operation code $C0 + 
12754   26E2                                             ; 'negate' ($1B) - bits 6 and 7 set for numeric
12755   26E2                                             ; result and numeric operand.
12756   26E2             
12757   26E2 FE 2D               CP      $2D             ; is it '-' ?
12758   26E4 28 27               JR      Z,L270D         ; forward if so to S-PUSH-PO
12759   26E6             
12760   26E6 01 18 10            LD      BC,$1018        ; prepare priority $10, operation code 'val$' -
12761   26E9                                             ; bits 6 and 7 reset for string result and
12762   26E9                                             ; string operand.
12763   26E9                     
12764   26E9 FE AE               CP      $AE             ; is it 'VAL$' ?
12765   26EB 28 20               JR      Z,L270D         ; forward if so to S-PUSH-PO
12766   26ED             
12767   26ED D6 AF               SUB     $AF             ; subtract token 'CODE' value to reduce
12768   26EF                                             ; functions 'CODE' to 'NOT' although the
12769   26EF                                             ; upper range is, as yet, unchecked.
12770   26EF                                             ; valid range would be $00 - $14.
12771   26EF             
12772   26EF DA 8A 1C            JP      C,L1C8A         ; jump back to REPORT-C with anything else
12773   26F2                                             ; 'Nonsense in BASIC'
12774   26F2             
12775   26F2 01 F0 04            LD      BC,$04F0        ; prepare priority $04, operation $C0 + 
12776   26F5                                             ; 'not' ($30)
12777   26F5             
12778   26F5 FE 14               CP      $14             ; is it 'NOT'
12779   26F7 28 14               JR      Z,L270D         ; forward to S-PUSH-PO if so
12780   26F9             
12781   26F9 D2 8A 1C            JP      NC,L1C8A        ; to REPORT-C if higher
12782   26FC                                             ; 'Nonsense in BASIC'
12783   26FC             
12784   26FC 06 10               LD      B,$10           ; priority $10 for all the rest
12785   26FE C6 DC               ADD     A,$DC           ; make range $DC - $EF
12786   2700                                             ; $C0 + 'code'($1C) thru 'chr$' ($2F)
12787   2700             
12788   2700 4F                  LD      C,A             ; transfer 'function' to C
12789   2701 FE DF               CP      $DF             ; is it 'sin' ?
12790   2703 30 02               JR      NC,L2707        ; forward to S-NO-TO-$  with 'sin' through
12791   2705                                             ; 'chr$' as operand is numeric.
12792   2705             
12793   2705             ; all the rest 'cos' through 'chr$' give a numeric result except 'str$'
12794   2705             ; and 'chr$'.
12795   2705             
12796   2705 CB B1               RES     6,C             ; signal string operand for 'code', 'val' and
12797   2707                                             ; 'len'.
12798   2707             
12799   2707             ;; S-NO-TO-$
12800   2707 FE EE       L2707:   CP      $EE             ; compare 'str$'
12801   2709 38 02               JR      C,L270D         ; forward to S-PUSH-PO if lower as result
12802   270B                                             ; is numeric.
12803   270B             
12804   270B CB B9               RES     7,C             ; reset bit 7 of op code for 'str$', 'chr$'
12805   270D                                             ; as result is string.
12806   270D             
12807   270D             ; >> This is where they were all headed for.
12808   270D             
12809   270D             ;; S-PUSH-PO
12810   270D C5          L270D:   PUSH    BC              ; push the priority and calculator operation
12811   270E                                             ; code.
12812   270E             
12813   270E E7                  RST     20H             ; NEXT-CHAR
12814   270F C3 FF 24            JP      L24FF           ; jump back to S-LOOP-1 to go round the loop
12815   2712                                             ; again with the next character.
12816   2712             
12817   2712             ; --------------------------------
12818   2712             
12819   2712             ; ===>  there were many branches forward to here
12820   2712             
12821   2712             ;   An important step after the evaluation of an expression is to test for
12822   2712             ;   a string expression and allow it to be sliced.  If a numeric expression is 
12823   2712             ;   followed by a '(' then the numeric expression is complete.
12824   2712             ;   Since a string slice can itself be sliced then loop repeatedly 
12825   2712             ;   e.g. (STR$ PI) (3 TO) (TO 2)    or "nonsense" (4 TO )
12826   2712             
12827   2712             ;; S-CONT-2
12828   2712 DF          L2712:   RST     18H             ; GET-CHAR
12829   2713             
12830   2713             ;; S-CONT-3
12831   2713 FE 28       L2713:   CP      $28             ; is it '(' ?
12832   2715 20 0C               JR      NZ,L2723        ; forward, if not, to S-OPERTR 
12833   2717             
12834   2717 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
12835   271B 20 17               JR      NZ,L2734        ; forward, if numeric, to S-LOOP
12836   271D             
12837   271D             ;   if a string expression preceded the '(' then slice it.
12838   271D             
12839   271D CD 52 2A            CALL    L2A52           ; routine SLICING
12840   2720             
12841   2720 E7                  RST     20H             ; NEXT-CHAR
12842   2721 18 F0               JR      L2713           ; loop back to S-CONT-3
12843   2723             
12844   2723             ; ---------------------------
12845   2723             
12846   2723             ;   the branch was here when possibility of a '(' has been excluded.
12847   2723             
12848   2723             ;; S-OPERTR
12849   2723 06 00       L2723:   LD      B,$00           ; prepare to add
12850   2725 4F                  LD      C,A             ; possible operator to C
12851   2726 21 95 27            LD      HL,L2795        ; Address: $2795 - tbl-of-ops
12852   2729 CD DC 16            CALL    L16DC           ; routine INDEXER
12853   272C 30 06               JR      NC,L2734        ; forward to S-LOOP if not in table
12854   272E             
12855   272E             ;   but if found in table the priority has to be looked up.
12856   272E             
12857   272E 4E                  LD      C,(HL)          ; operation code to C ( B is still zero )
12858   272F 21 ED 26            LD      HL,L27B0 - $C3  ; $26ED is base of table
12859   2732 09                  ADD     HL,BC           ; index into table.
12860   2733 46                  LD      B,(HL)          ; priority to B.
12861   2734             
12862   2734             ; ------------------
12863   2734             ; Scanning main loop
12864   2734             ; ------------------
12865   2734             ; the juggling act
12866   2734             
12867   2734             ;; S-LOOP
12868   2734 D1          L2734:   POP     DE              ; fetch last priority and operation
12869   2735 7A                  LD      A,D             ; priority to A
12870   2736 B8                  CP      B               ; compare with this one
12871   2737 38 3A               JR      C,L2773         ; forward to S-TIGHTER to execute the
12872   2739                                             ; last operation before this one as it has
12873   2739                                             ; higher priority.
12874   2739             
12875   2739             ; the last priority was greater or equal this one.
12876   2739             
12877   2739 A7                  AND     A               ; if it is zero then so is this
12878   273A CA 18 00            JP      Z,L0018         ; jump to exit via get-char pointing at
12879   273D                                             ; next character.
12880   273D                                             ; This may be the character after the
12881   273D                                             ; expression or, if exiting a recursive call,
12882   273D                                             ; the next part of the expression to be
12883   273D                                             ; evaluated.
12884   273D             
12885   273D C5                  PUSH    BC              ; save current priority/operation
12886   273E                                             ; as it has lower precedence than the one
12887   273E                                             ; now in DE.
12888   273E             
12889   273E             ; the 'USR' function is special in that it is overloaded to give two types
12890   273E             ; of result.
12891   273E             
12892   273E 21 3B 5C            LD      HL,$5C3B        ; address FLAGS
12893   2741 7B                  LD      A,E             ; new operation to A register
12894   2742 FE ED               CP      $ED             ; is it $C0 + 'usr-no' ($2D)  ?
12895   2744 20 06               JR      NZ,L274C        ; forward to S-STK-LST if not
12896   2746             
12897   2746 CB 76               BIT     6,(HL)          ; string result expected ?
12898   2748                                             ; (from the lower priority operand we've
12899   2748                                             ; just pushed on stack )
12900   2748 20 02               JR      NZ,L274C        ; forward to S-STK-LST if numeric
12901   274A                                             ; as operand bits match.
12902   274A             
12903   274A 1E 99               LD      E,$99           ; reset bit 6 and substitute $19 'usr-$'
12904   274C                                             ; for string operand.
12905   274C             
12906   274C             ;; S-STK-LST
12907   274C D5          L274C:   PUSH    DE              ; now stack this priority/operation
12908   274D CD 30 25            CALL    L2530           ; routine SYNTAX-Z
12909   2750 28 09               JR      Z,L275B         ; forward to S-SYNTEST if checking syntax.
12910   2752             
12911   2752 7B                  LD      A,E             ; fetch the operation code
12912   2753 E6 3F               AND     $3F             ; mask off the result/operand bits to leave
12913   2755                                             ; a calculator literal.
12914   2755 47                  LD      B,A             ; transfer to B register
12915   2756             
12916   2756             ; now use the calculator to perform the single operation - operand is on
12917   2756             ; the calculator stack.
12918   2756             ; Note. although the calculator is performing a single operation most
12919   2756             ; functions e.g. TAN are written using other functions and literals and
12920   2756             ; these in turn are written using further strings of calculator literals so
12921   2756             ; another level of magical recursion joins the juggling act for a while
12922   2756             ; as the calculator too is calling itself.
12923   2756             
12924   2756 EF                  RST     28H             ;; FP-CALC
12925   2757 3B                  DEFB    $3B             ;;fp-calc-2
12926   2758 38          L2758:   DEFB    $38             ;;end-calc
12927   2759             
12928   2759 18 09               JR      L2764           ; forward to S-RUNTEST
12929   275B             
12930   275B             ; ---
12931   275B             
12932   275B             ; the branch was here if checking syntax only. 
12933   275B             
12934   275B             ;; S-SYNTEST
12935   275B 7B          L275B:   LD      A,E             ; fetch the operation code to accumulator
12936   275C FD AE 01            XOR     (IY+$01)        ; compare with bits of FLAGS
12937   275F E6 40               AND     $40             ; bit 6 will be zero now if operand
12938   2761                                             ; matched expected result.
12939   2761             
12940   2761             ;; S-RPORT-C2
12941   2761 C2 8A 1C    L2761:   JP      NZ,L1C8A        ; to REPORT-C if mismatch
12942   2764                                             ; 'Nonsense in BASIC'
12943   2764                                             ; else continue to set flags for next
12944   2764             
12945   2764             ; the branch is to here in runtime after a successful operation.
12946   2764             
12947   2764             ;; S-RUNTEST
12948   2764 D1          L2764:   POP     DE              ; fetch the last operation from stack
12949   2765 21 3B 5C            LD      HL,$5C3B        ; address FLAGS
12950   2768 CB F6               SET     6,(HL)          ; set default to numeric result in FLAGS
12951   276A CB 7B               BIT     7,E             ; test the operational result
12952   276C 20 02               JR      NZ,L2770        ; forward to S-LOOPEND if numeric
12953   276E             
12954   276E CB B6               RES     6,(HL)          ; reset bit 6 of FLAGS to show string result.
12955   2770             
12956   2770             ;; S-LOOPEND
12957   2770 C1          L2770:   POP     BC              ; fetch the previous priority/operation
12958   2771 18 C1               JR      L2734           ; back to S-LOOP to perform these
12959   2773             
12960   2773             ; ---
12961   2773             
12962   2773             ; the branch was here when a stacked priority/operator had higher priority
12963   2773             ; than the current one.
12964   2773             
12965   2773             ;; S-TIGHTER
12966   2773 D5          L2773:   PUSH    DE              ; save high priority op on stack again
12967   2774 79                  LD      A,C             ; fetch lower priority operation code
12968   2775 FD CB 01 76         BIT     6,(IY+$01)      ; test FLAGS - Numeric or string result ?
12969   2779 20 15               JR      NZ,L2790        ; forward to S-NEXT if numeric result
12970   277B             
12971   277B             ; if this is lower priority yet has string then must be a comparison.
12972   277B             ; Since these can only be evaluated in context and were defaulted to
12973   277B             ; numeric in operator look up they must be changed to string equivalents.
12974   277B             
12975   277B E6 3F               AND     $3F             ; mask to give true calculator literal
12976   277D C6 08               ADD     A,$08           ; augment numeric literals to string
12977   277F                                             ; equivalents.
12978   277F                                             ; 'no-&-no'  => 'str-&-no'
12979   277F                                             ; 'no-l-eql' => 'str-l-eql'
12980   277F                                             ; 'no-gr-eq' => 'str-gr-eq'
12981   277F                                             ; 'nos-neql' => 'strs-neql'
12982   277F                                             ; 'no-grtr'  => 'str-grtr'
12983   277F                                             ; 'no-less'  => 'str-less'
12984   277F                                             ; 'nos-eql'  => 'strs-eql'
12985   277F                                             ; 'addition' => 'strs-add'
12986   277F 4F                  LD      C,A             ; put modified comparison operator back
12987   2780 FE 10               CP      $10             ; is it now 'str-&-no' ?
12988   2782 20 04               JR      NZ,L2788        ; forward to S-NOT-AND  if not.
12989   2784             
12990   2784 CB F1               SET     6,C             ; set numeric operand bit
12991   2786 18 08               JR      L2790           ; forward to S-NEXT
12992   2788             
12993   2788             ; ---
12994   2788             
12995   2788             ;; S-NOT-AND
12996   2788 38 D7       L2788:   JR      C,L2761         ; back to S-RPORT-C2 if less
12997   278A                                             ; 'Nonsense in BASIC'.
12998   278A                                             ; e.g. a$ * b$
12999   278A             
13000   278A FE 17               CP      $17             ; is it 'strs-add' ?
13001   278C 28 02               JR      Z,L2790         ; forward to S-NEXT if so
13002   278E                                             ; (bit 6 and 7 are reset)
13003   278E             
13004   278E CB F9               SET     7,C             ; set numeric (Boolean) result for all others
13005   2790             
13006   2790             ;; S-NEXT
13007   2790 C5          L2790:   PUSH    BC              ; now save this priority/operation on stack
13008   2791             
13009   2791 E7                  RST     20H             ; NEXT-CHAR
13010   2792 C3 FF 24            JP      L24FF           ; jump back to S-LOOP-1
13011   2795             
13012   2795             ; ------------------
13013   2795             ; Table of operators
13014   2795             ; ------------------
13015   2795             ; This table is used to look up the calculator literals associated with
13016   2795             ; the operator character. The thirteen calculator operations $03 - $0F
13017   2795             ; have bits 6 and 7 set to signify a numeric result.
13018   2795             ; Some of these codes and bits may be altered later if the context suggests
13019   2795             ; a string comparison or operation.
13020   2795             ; that is '+', '=', '>', '<', '<=', '>=' or '<>'.
13021   2795             
13022   2795             ;; tbl-of-ops
13023   2795 2B CF       L2795:   DEFB    '+', $CF        ;        $C0 + 'addition'
13024   2797 2D C3               DEFB    '-', $C3        ;        $C0 + 'subtract'
13025   2799 2A C4               DEFB    '*', $C4        ;        $C0 + 'multiply'
13026   279B 2F C5               DEFB    '/', $C5        ;        $C0 + 'division'
13027   279D 5E C6               DEFB    '^', $C6        ;        $C0 + 'to-power'
13028   279F 3D CE               DEFB    '=', $CE        ;        $C0 + 'nos-eql'
13029   27A1 3E CC               DEFB    '>', $CC        ;        $C0 + 'no-grtr'
13030   27A3 3C CD               DEFB    '<', $CD        ;        $C0 + 'no-less'
13031   27A5             
13032   27A5 C7 C9               DEFB    $C7, $C9        ; '<='   $C0 + 'no-l-eql'
13033   27A7 C8 CA               DEFB    $C8, $CA        ; '>='   $C0 + 'no-gr-eql'
13034   27A9 C9 CB               DEFB    $C9, $CB        ; '<>'   $C0 + 'nos-neql'
13035   27AB C5 C7               DEFB    $C5, $C7        ; 'OR'   $C0 + 'or'
13036   27AD C6 C8               DEFB    $C6, $C8        ; 'AND'  $C0 + 'no-&-no'
13037   27AF             
13038   27AF 00                  DEFB    $00             ; zero end-marker.
13039   27B0             
13040   27B0             
13041   27B0             ; -------------------
13042   27B0             ; Table of priorities
13043   27B0             ; -------------------
13044   27B0             ; This table is indexed with the operation code obtained from the above
13045   27B0             ; table $C3 - $CF to obtain the priority for the respective operation.
13046   27B0             
13047   27B0             ;; tbl-priors
13048   27B0 06          L27B0:   DEFB    $06             ; '-'   opcode $C3
13049   27B1 08                  DEFB    $08             ; '*'   opcode $C4
13050   27B2 08                  DEFB    $08             ; '/'   opcode $C5
13051   27B3 0A                  DEFB    $0A             ; '^'   opcode $C6
13052   27B4 02                  DEFB    $02             ; 'OR'  opcode $C7
13053   27B5 03                  DEFB    $03             ; 'AND' opcode $C8
13054   27B6 05                  DEFB    $05             ; '<='  opcode $C9
13055   27B7 05                  DEFB    $05             ; '>='  opcode $CA
13056   27B8 05                  DEFB    $05             ; '<>'  opcode $CB
13057   27B9 05                  DEFB    $05             ; '>'   opcode $CC
13058   27BA 05                  DEFB    $05             ; '<'   opcode $CD
13059   27BB 05                  DEFB    $05             ; '='   opcode $CE
13060   27BC 06                  DEFB    $06             ; '+'   opcode $CF
13061   27BD             
13062   27BD             ; ----------------------
13063   27BD             ; Scanning function (FN)
13064   27BD             ; ----------------------
13065   27BD             ; This routine deals with user-defined functions.
13066   27BD             ; The definition can be anywhere in the program area but these are best
13067   27BD             ; placed near the start of the program as we shall see.
13068   27BD             ; The evaluation process is quite complex as the Spectrum has to parse two
13069   27BD             ; statements at the same time. Syntax of both has been checked previously
13070   27BD             ; and hidden locations have been created immediately after each argument
13071   27BD             ; of the DEF FN statement. Each of the arguments of the FN function is
13072   27BD             ; evaluated by SCANNING and placed in the hidden locations. Then the
13073   27BD             ; expression to the right of the DEF FN '=' is evaluated by SCANNING and for
13074   27BD             ; any variables encountered, a search is made in the DEF FN variable list
13075   27BD             ; in the program area before searching in the normal variables area.
13076   27BD             ;
13077   27BD             ; Recursion is not allowed: i.e. the definition of a function should not use
13078   27BD             ; the same function, either directly or indirectly ( through another function).
13079   27BD             ; You'll normally get error 4, ('Out of memory'), although sometimes the system
13080   27BD             ; will crash. - Vickers, Pitman 1984.
13081   27BD             ;
13082   27BD             ; As the definition is just an expression, there would seem to be no means
13083   27BD             ; of breaking out of such recursion.
13084   27BD             ; However, by the clever use of string expressions and VAL, such recursion is
13085   27BD             ; possible.
13086   27BD             ; e.g. DEF FN a(n) = VAL "n+FN a(n-1)+0" ((n<1) * 10 + 1 TO )
13087   27BD             ; will evaluate the full 11-character expression for all values where n is
13088   27BD             ; greater than zero but just the 11th character, "0", when n drops to zero
13089   27BD             ; thereby ending the recursion producing the correct result.
13090   27BD             ; Recursive string functions are possible using VAL$ instead of VAL and the
13091   27BD             ; null string as the final addend.
13092   27BD             ; - from a turn of the century newsgroup discussion initiated by Mike Wynne.
13093   27BD             
13094   27BD             ;; S-FN-SBRN
13095   27BD CD 30 25    L27BD:   CALL    L2530           ; routine SYNTAX-Z
13096   27C0 20 35               JR      NZ,L27F7        ; forward to SF-RUN in runtime
13097   27C2             
13098   27C2             
13099   27C2 E7                  RST     20H             ; NEXT-CHAR
13100   27C3 CD 8D 2C            CALL    L2C8D           ; routine ALPHA check for letters A-Z a-z
13101   27C6 D2 8A 1C            JP      NC,L1C8A        ; jump back to REPORT-C if not
13102   27C9                                             ; 'Nonsense in BASIC'
13103   27C9             
13104   27C9             
13105   27C9 E7                  RST     20H             ; NEXT-CHAR
13106   27CA FE 24               CP      $24             ; is it '$' ?
13107   27CC F5                  PUSH    AF              ; save character and flags
13108   27CD 20 01               JR      NZ,L27D0        ; forward to SF-BRKT-1 with numeric function
13109   27CF             
13110   27CF             
13111   27CF E7                  RST     20H             ; NEXT-CHAR
13112   27D0             
13113   27D0             ;; SF-BRKT-1
13114   27D0 FE 28       L27D0:   CP      $28             ; is '(' ?
13115   27D2 20 12               JR      NZ,L27E6        ; forward to SF-RPRT-C if not
13116   27D4                                             ; 'Nonsense in BASIC'
13117   27D4             
13118   27D4             
13119   27D4 E7                  RST     20H             ; NEXT-CHAR
13120   27D5 FE 29               CP      $29             ; is it ')' ?
13121   27D7 28 10               JR      Z,L27E9         ; forward to SF-FLAG-6 if no arguments.
13122   27D9             
13123   27D9             ;; SF-ARGMTS
13124   27D9 CD FB 24    L27D9:   CALL    L24FB           ; routine SCANNING checks each argument
13125   27DC                                             ; which may be an expression.
13126   27DC             
13127   27DC DF                  RST     18H             ; GET-CHAR
13128   27DD FE 2C               CP      $2C             ; is it a ',' ?
13129   27DF 20 03               JR      NZ,L27E4        ; forward if not to SF-BRKT-2 to test bracket
13130   27E1             
13131   27E1             
13132   27E1 E7                  RST     20H             ; NEXT-CHAR if a comma was found
13133   27E2 18 F5               JR      L27D9           ; back to SF-ARGMTS to parse all arguments.
13134   27E4             
13135   27E4             ; ---
13136   27E4             
13137   27E4             ;; SF-BRKT-2
13138   27E4 FE 29       L27E4:   CP      $29             ; is character the closing ')' ?
13139   27E6             
13140   27E6             ;; SF-RPRT-C
13141   27E6 C2 8A 1C    L27E6:   JP      NZ,L1C8A        ; jump to REPORT-C
13142   27E9                                             ; 'Nonsense in BASIC'
13143   27E9             
13144   27E9             ; at this point any optional arguments have had their syntax checked.
13145   27E9             
13146   27E9             ;; SF-FLAG-6
13147   27E9 E7          L27E9:   RST     20H             ; NEXT-CHAR
13148   27EA 21 3B 5C            LD      HL,$5C3B        ; address system variable FLAGS
13149   27ED CB B6               RES     6,(HL)          ; signal string result
13150   27EF F1                  POP     AF              ; restore test against '$'.
13151   27F0 28 02               JR      Z,L27F4         ; forward to SF-SYN-EN if string function.
13152   27F2             
13153   27F2 CB F6               SET     6,(HL)          ; signal numeric result
13154   27F4             
13155   27F4             ;; SF-SYN-EN
13156   27F4 C3 12 27    L27F4:   JP      L2712           ; jump back to S-CONT-2 to continue scanning.
13157   27F7             
13158   27F7             ; ---
13159   27F7             
13160   27F7             ; the branch was here in runtime.
13161   27F7             
13162   27F7             ;; SF-RUN
13163   27F7 E7          L27F7:   RST     20H             ; NEXT-CHAR fetches name
13164   27F8 E6 DF               AND     $DF             ; AND 11101111 - reset bit 5 - upper-case.
13165   27FA 47                  LD      B,A             ; save in B
13166   27FB             
13167   27FB E7                  RST     20H             ; NEXT-CHAR
13168   27FC D6 24               SUB     $24             ; subtract '$'
13169   27FE 4F                  LD      C,A             ; save result in C
13170   27FF 20 01               JR      NZ,L2802        ; forward if not '$' to SF-ARGMT1
13171   2801             
13172   2801 E7                  RST     20H             ; NEXT-CHAR advances to bracket
13173   2802             
13174   2802             ;; SF-ARGMT1
13175   2802 E7          L2802:   RST     20H             ; NEXT-CHAR advances to start of argument
13176   2803 E5                  PUSH    HL              ; save address
13177   2804 2A 53 5C            LD      HL,($5C53)      ; fetch start of program area from PROG
13178   2807 2B                  DEC     HL              ; the search starting point is the previous
13179   2808                                             ; location.
13180   2808             
13181   2808             ;; SF-FND-DF
13182   2808 11 CE 00    L2808:   LD      DE,$00CE        ; search is for token 'DEF FN' in E,
13183   280B                                             ; statement count in D.
13184   280B C5                  PUSH    BC              ; save C the string test, and B the letter.
13185   280C CD 86 1D            CALL    L1D86           ; routine LOOK-PROG will search for token.
13186   280F C1                  POP     BC              ; restore BC.
13187   2810 30 02               JR      NC,L2814        ; forward to SF-CP-DEF if a match was found.
13188   2812             
13189   2812             
13190   2812             ;; REPORT-P
13191   2812 CF          L2812:   RST     08H             ; ERROR-1
13192   2813 18                  DEFB    $18             ; Error Report: FN without DEF
13193   2814             
13194   2814             ;; SF-CP-DEF
13195   2814 E5          L2814:   PUSH    HL              ; save address of DEF FN
13196   2815 CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips over white-space etc.
13197   2818                                             ; without disturbing CH-ADD.
13198   2818 E6 DF               AND     $DF             ; make fetched character upper-case.
13199   281A B8                  CP      B               ; compare with FN name
13200   281B 20 08               JR      NZ,L2825        ; forward to SF-NOT-FD if no match.
13201   281D             
13202   281D             ; the letters match so test the type.
13203   281D             
13204   281D CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips white-space
13205   2820 D6 24               SUB     $24             ; subtract '$' from fetched character
13206   2822 B9                  CP      C               ; compare with saved result of same operation
13207   2823                                             ; on FN name.
13208   2823 28 0C               JR      Z,L2831         ; forward to SF-VALUES with a match.
13209   2825             
13210   2825             ; the letters matched but one was string and the other numeric.
13211   2825             
13212   2825             ;; SF-NOT-FD
13213   2825 E1          L2825:   POP     HL              ; restore search point.
13214   2826 2B                  DEC     HL              ; make location before
13215   2827 11 00 02            LD      DE,$0200        ; the search is to be for the end of the
13216   282A                                             ; current definition - 2 statements forward.
13217   282A C5                  PUSH    BC              ; save the letter/type
13218   282B CD 8B 19            CALL    L198B           ; routine EACH-STMT steps past rejected
13219   282E                                             ; definition.
13220   282E C1                  POP     BC              ; restore letter/type
13221   282F 18 D7               JR      L2808           ; back to SF-FND-DF to continue search
13222   2831             
13223   2831             ; ---
13224   2831             
13225   2831             ; Success!
13226   2831             ; the branch was here with matching letter and numeric/string type.
13227   2831             
13228   2831             ;; SF-VALUES
13229   2831 A7          L2831:   AND     A               ; test A ( will be zero if string '$' - '$' )
13230   2832             
13231   2832 CC AB 28            CALL    Z,L28AB         ; routine FN-SKPOVR advances HL past '$'.
13232   2835             
13233   2835 D1                  POP     DE              ; discard pointer to 'DEF FN'.
13234   2836 D1                  POP     DE              ; restore pointer to first FN argument.
13235   2837 ED 53 5D 5C         LD      ($5C5D),DE      ; save in CH_ADD
13236   283B             
13237   283B CD AB 28            CALL    L28AB           ; routine FN-SKPOVR advances HL past '('
13238   283E E5                  PUSH    HL              ; save start address in DEF FN  ***
13239   283F FE 29               CP      $29             ; is character a ')' ?
13240   2841 28 42               JR      Z,L2885         ; forward to SF-R-BR-2 if no arguments.
13241   2843             
13242   2843             ;; SF-ARG-LP
13243   2843 23          L2843:   INC     HL              ; point to next character.
13244   2844 7E                  LD      A,(HL)          ; fetch it.
13245   2845 FE 0E               CP      $0E             ; is it the number marker
13246   2847 16 40               LD      D,$40           ; signal numeric in D.
13247   2849 28 07               JR      Z,L2852         ; forward to SF-ARG-VL if numeric.
13248   284B             
13249   284B 2B                  DEC     HL              ; back to letter
13250   284C CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips any white-space
13251   284F 23                  INC     HL              ; advance past the expected '$' to 
13252   2850                                             ; the 'hidden' marker.
13253   2850 16 00               LD      D,$00           ; signal string.
13254   2852             
13255   2852             ;; SF-ARG-VL
13256   2852 23          L2852:   INC     HL              ; now address first of 5-byte location.
13257   2853 E5                  PUSH    HL              ; save address in DEF FN statement
13258   2854 D5                  PUSH    DE              ; save D - result type
13259   2855             
13260   2855 CD FB 24            CALL    L24FB           ; routine SCANNING evaluates expression in
13261   2858                                             ; the FN statement setting FLAGS and leaving
13262   2858                                             ; result as last value on calculator stack.
13263   2858             
13264   2858 F1                  POP     AF              ; restore saved result type to A
13265   2859             
13266   2859 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS
13267   285C E6 40               AND     $40             ; and with 01000000 to test bit 6
13268   285E 20 2B               JR      NZ,L288B        ; forward to REPORT-Q if type mismatch.
13269   2860                                             ; 'Parameter error'
13270   2860             
13271   2860 E1                  POP     HL              ; pop the start address in DEF FN statement
13272   2861 EB                  EX      DE,HL           ; transfer to DE ?? pop straight into de ?
13273   2862             
13274   2862 2A 65 5C            LD      HL,($5C65)      ; set HL to STKEND location after value
13275   2865 01 05 00            LD      BC,$0005        ; five bytes to move
13276   2868 ED 42               SBC     HL,BC           ; decrease HL by 5 to point to start.
13277   286A 22 65 5C            LD      ($5C65),HL      ; set STKEND 'removing' value from stack.
13278   286D             
13279   286D ED B0               LDIR                    ; copy value into DEF FN statement
13280   286F EB                  EX      DE,HL           ; set HL to location after value in DEF FN
13281   2870 2B                  DEC     HL              ; step back one
13282   2871 CD AB 28            CALL    L28AB           ; routine FN-SKPOVR gets next valid character
13283   2874 FE 29               CP      $29             ; is it ')' end of arguments ?
13284   2876 28 0D               JR      Z,L2885         ; forward to SF-R-BR-2 if so.
13285   2878             
13286   2878             ; a comma separator has been encountered in the DEF FN argument list.
13287   2878             
13288   2878 E5                  PUSH    HL              ; save position in DEF FN statement
13289   2879             
13290   2879 DF                  RST     18H             ; GET-CHAR from FN statement
13291   287A FE 2C               CP      $2C             ; is it ',' ?
13292   287C 20 0D               JR      NZ,L288B        ; forward to REPORT-Q if not
13293   287E                                             ; 'Parameter error'
13294   287E             
13295   287E E7                  RST     20H             ; NEXT-CHAR in FN statement advances to next
13296   287F                                             ; argument.
13297   287F             
13298   287F E1                  POP     HL              ; restore DEF FN pointer
13299   2880 CD AB 28            CALL    L28AB           ; routine FN-SKPOVR advances to corresponding
13300   2883                                             ; argument.
13301   2883             
13302   2883 18 BE               JR      L2843           ; back to SF-ARG-LP looping until all
13303   2885                                             ; arguments are passed into the DEF FN
13304   2885                                             ; hidden locations.
13305   2885             
13306   2885             ; ---
13307   2885             
13308   2885             ; the branch was here when all arguments passed.
13309   2885             
13310   2885             ;; SF-R-BR-2
13311   2885 E5          L2885:   PUSH    HL              ; save location of ')' in DEF FN
13312   2886             
13313   2886 DF                  RST     18H             ; GET-CHAR gets next character in FN
13314   2887 FE 29               CP      $29             ; is it a ')' also ?
13315   2889 28 02               JR      Z,L288D         ; forward to SF-VALUE if so.
13316   288B             
13317   288B             
13318   288B             ;; REPORT-Q
13319   288B CF          L288B:   RST     08H             ; ERROR-1
13320   288C 19                  DEFB    $19             ; Error Report: Parameter error
13321   288D             
13322   288D             ;; SF-VALUE
13323   288D D1          L288D:   POP     DE              ; location of ')' in DEF FN to DE.
13324   288E EB                  EX      DE,HL           ; now to HL, FN ')' pointer to DE.
13325   288F 22 5D 5C            LD      ($5C5D),HL      ; initialize CH_ADD to this value.
13326   2892             
13327   2892             ; At this point the start of the DEF FN argument list is on the machine stack.
13328   2892             ; We also have to consider that this defined function may form part of the
13329   2892             ; definition of another defined function (though not itself).
13330   2892             ; As this defined function may be part of a hierarchy of defined functions
13331   2892             ; currently being evaluated by recursive calls to SCANNING, then we have to
13332   2892             ; preserve the original value of DEFADD and not assume that it is zero.
13333   2892             
13334   2892 2A 0B 5C            LD      HL,($5C0B)      ; get original DEFADD address
13335   2895 E3                  EX      (SP),HL         ; swap with DEF FN address on stack ***
13336   2896 22 0B 5C            LD      ($5C0B),HL      ; set DEFADD to point to this argument list
13337   2899                                             ; during scanning.
13338   2899             
13339   2899 D5                  PUSH    DE              ; save FN ')' pointer.
13340   289A             
13341   289A E7                  RST     20H             ; NEXT-CHAR advances past ')' in define
13342   289B             
13343   289B E7                  RST     20H             ; NEXT-CHAR advances past '=' to expression
13344   289C             
13345   289C CD FB 24            CALL    L24FB           ; routine SCANNING evaluates but searches
13346   289F                                             ; initially for variables at DEFADD
13347   289F             
13348   289F E1                  POP     HL              ; pop the FN ')' pointer
13349   28A0 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to this
13350   28A3 E1                  POP     HL              ; pop the original DEFADD value
13351   28A4 22 0B 5C            LD      ($5C0B),HL      ; and re-insert into DEFADD system variable.
13352   28A7             
13353   28A7 E7                  RST     20H             ; NEXT-CHAR advances to character after ')'
13354   28A8 C3 12 27            JP      L2712           ; to S-CONT-2 - to continue current
13355   28AB                                             ; invocation of scanning
13356   28AB             
13357   28AB             ; --------------------
13358   28AB             ; Used to parse DEF FN
13359   28AB             ; --------------------
13360   28AB             ; e.g. DEF FN     s $ ( x )     =  b     $ (  TO  x  ) : REM exaggerated
13361   28AB             ;
13362   28AB             ; This routine is used 10 times to advance along a DEF FN statement
13363   28AB             ; skipping spaces and colour control codes. It is similar to NEXT-CHAR
13364   28AB             ; which is, at the same time, used to skip along the corresponding FN function
13365   28AB             ; except the latter has to deal with AT and TAB characters in string
13366   28AB             ; expressions. These cannot occur in a program area so this routine is
13367   28AB             ; simpler as both colour controls and their parameters are less than space.
13368   28AB             
13369   28AB             ;; FN-SKPOVR
13370   28AB 23          L28AB:   INC     HL              ; increase pointer
13371   28AC 7E                  LD      A,(HL)          ; fetch addressed character
13372   28AD FE 21               CP      $21             ; compare with space + 1
13373   28AF 38 FA               JR      C,L28AB         ; back to FN-SKPOVR if less
13374   28B1             
13375   28B1 C9                  RET                     ; return pointing to a valid character.
13376   28B2             
13377   28B2             ; ---------
13378   28B2             ; LOOK-VARS
13379   28B2             ; ---------
13380   28B2             ;
13381   28B2             ;
13382   28B2             
13383   28B2             ;; LOOK-VARS
13384   28B2 FD CB 01 F6 L28B2:   SET     6,(IY+$01)      ; update FLAGS - presume numeric result
13385   28B6             
13386   28B6 DF                  RST     18H             ; GET-CHAR
13387   28B7 CD 8D 2C            CALL    L2C8D           ; routine ALPHA tests for A-Za-z
13388   28BA D2 8A 1C            JP      NC,L1C8A        ; jump to REPORT-C if not.
13389   28BD                                             ; 'Nonsense in BASIC'
13390   28BD             
13391   28BD E5                  PUSH    HL              ; save pointer to first letter       ^1
13392   28BE E6 1F               AND     $1F             ; mask lower bits, 1 - 26 decimal     000xxxxx
13393   28C0 4F                  LD      C,A             ; store in C.
13394   28C1             
13395   28C1 E7                  RST     20H             ; NEXT-CHAR
13396   28C2 E5                  PUSH    HL              ; save pointer to second character   ^2
13397   28C3 FE 28               CP      $28             ; is it '(' - an array ?
13398   28C5 28 28               JR      Z,L28EF         ; forward to V-RUN/SYN if so.
13399   28C7             
13400   28C7 CB F1               SET     6,C             ; set 6 signaling string if solitary  010
13401   28C9 FE 24               CP      $24             ; is character a '$' ?
13402   28CB 28 11               JR      Z,L28DE         ; forward to V-STR-VAR
13403   28CD             
13404   28CD CB E9               SET     5,C             ; signal numeric                       011
13405   28CF CD 88 2C            CALL    L2C88           ; routine ALPHANUM sets carry if second
13406   28D2                                             ; character is alphanumeric.
13407   28D2 30 0F               JR      NC,L28E3        ; forward to V-TEST-FN if just one character
13408   28D4             
13409   28D4             ; It is more than one character but re-test current character so that 6 reset
13410   28D4             ; This loop renders the similar loop at V-PASS redundant.
13411   28D4             
13412   28D4             ;; V-CHAR
13413   28D4 CD 88 2C    L28D4:   CALL    L2C88           ; routine ALPHANUM
13414   28D7 30 16               JR      NC,L28EF        ; to V-RUN/SYN when no more
13415   28D9             
13416   28D9 CB B1               RES     6,C             ; make long named type                 001
13417   28DB             
13418   28DB E7                  RST     20H             ; NEXT-CHAR
13419   28DC 18 F6               JR      L28D4           ; loop back to V-CHAR
13420   28DE             
13421   28DE             ; ---
13422   28DE             
13423   28DE             
13424   28DE             ;; V-STR-VAR
13425   28DE E7          L28DE:   RST     20H             ; NEXT-CHAR advances past '$'
13426   28DF FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS - signal string result.
13427   28E3             
13428   28E3             ;; V-TEST-FN
13429   28E3 3A 0C 5C    L28E3:   LD      A,($5C0C)       ; load A with DEFADD_hi
13430   28E6 A7                  AND     A               ; and test for zero.
13431   28E7 28 06               JR      Z,L28EF         ; forward to V-RUN/SYN if a defined function
13432   28E9                                             ; is not being evaluated.
13433   28E9             
13434   28E9             ; Note.
13435   28E9             
13436   28E9 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
13437   28EC C2 51 29            JP      NZ,L2951        ; JUMP to STK-F-ARG in runtime and then
13438   28EF                                             ; back to this point if no variable found.
13439   28EF             
13440   28EF             ;; V-RUN/SYN
13441   28EF 41          L28EF:   LD      B,C             ; save flags in B
13442   28F0 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
13443   28F3 20 08               JR      NZ,L28FD        ; to V-RUN to look for the variable in runtime
13444   28F5             
13445   28F5             ; if checking syntax the letter is not returned
13446   28F5             
13447   28F5 79                  LD      A,C             ; copy letter/flags to A
13448   28F6 E6 E0               AND     $E0             ; and with 11100000 to get rid of the letter
13449   28F8 CB FF               SET     7,A             ; use spare bit to signal checking syntax.
13450   28FA 4F                  LD      C,A             ; and transfer to C.
13451   28FB 18 37               JR      L2934           ; forward to V-SYNTAX
13452   28FD             
13453   28FD             ; ---
13454   28FD             
13455   28FD             ; but in runtime search for the variable.
13456   28FD             
13457   28FD             ;; V-RUN
13458   28FD 2A 4B 5C    L28FD:   LD      HL,($5C4B)      ; set HL to start of variables from VARS
13459   2900             
13460   2900             ;; V-EACH
13461   2900 7E          L2900:   LD      A,(HL)          ; get first character
13462   2901 E6 7F               AND     $7F             ; and with 01111111
13463   2903                                             ; ignoring bit 7 which distinguishes
13464   2903                                             ; arrays or for/next variables.
13465   2903             
13466   2903 28 2D               JR      Z,L2932         ; to V-80-BYTE if zero as must be 10000000
13467   2905                                             ; the variables end-marker.
13468   2905             
13469   2905 B9                  CP      C               ; compare with supplied value.
13470   2906 20 22               JR      NZ,L292A        ; forward to V-NEXT if no match.
13471   2908             
13472   2908 17                  RLA                     ; destructively test
13473   2909 87                  ADD     A,A             ; bits 5 and 6 of A
13474   290A                                             ; jumping if bit 5 reset or 6 set
13475   290A             
13476   290A F2 3F 29            JP      P,L293F         ; to V-FOUND-2  strings and arrays
13477   290D             
13478   290D 38 30               JR      C,L293F         ; to V-FOUND-2  simple and for next
13479   290F             
13480   290F             ; leaving long name variables.
13481   290F             
13482   290F D1                  POP     DE              ; pop pointer to 2nd. char
13483   2910 D5                  PUSH    DE              ; save it again
13484   2911 E5                  PUSH    HL              ; save variable first character pointer
13485   2912             
13486   2912             ;; V-MATCHES
13487   2912 23          L2912:   INC     HL              ; address next character in vars area
13488   2913             
13489   2913             ;; V-SPACES
13490   2913 1A          L2913:   LD      A,(DE)          ; pick up letter from prog area
13491   2914 13                  INC     DE              ; and advance address
13492   2915 FE 20               CP      $20             ; is it a space
13493   2917 28 FA               JR      Z,L2913         ; back to V-SPACES until non-space
13494   2919             
13495   2919 F6 20               OR      $20             ; convert to range 1 - 26.
13496   291B BE                  CP      (HL)            ; compare with addressed variables character
13497   291C 28 F4               JR      Z,L2912         ; loop back to V-MATCHES if a match on an
13498   291E                                             ; intermediate letter.
13499   291E             
13500   291E F6 80               OR      $80             ; now set bit 7 as last character of long
13501   2920                                             ; names are inverted.
13502   2920 BE                  CP      (HL)            ; compare again
13503   2921 20 06               JR      NZ,L2929        ; forward to V-GET-PTR if no match
13504   2923             
13505   2923             ; but if they match check that this is also last letter in prog area
13506   2923             
13507   2923 1A                  LD      A,(DE)          ; fetch next character
13508   2924 CD 88 2C            CALL    L2C88           ; routine ALPHANUM sets carry if not alphanum
13509   2927 30 15               JR      NC,L293E        ; forward to V-FOUND-1 with a full match.
13510   2929             
13511   2929             ;; V-GET-PTR
13512   2929 E1          L2929:   POP     HL              ; pop saved pointer to char 1
13513   292A             
13514   292A             ;; V-NEXT
13515   292A C5          L292A:   PUSH    BC              ; save flags
13516   292B CD B8 19            CALL    L19B8           ; routine NEXT-ONE gets next variable in DE
13517   292E EB                  EX      DE,HL           ; transfer to HL.
13518   292F C1                  POP     BC              ; restore the flags
13519   2930 18 CE               JR      L2900           ; loop back to V-EACH
13520   2932                                             ; to compare each variable
13521   2932             
13522   2932             ; ---
13523   2932             
13524   2932             ;; V-80-BYTE
13525   2932 CB F8       L2932:   SET     7,B             ; will signal not found
13526   2934             
13527   2934             ; the branch was here when checking syntax
13528   2934             
13529   2934             ;; V-SYNTAX
13530   2934 D1          L2934:   POP     DE              ; discard the pointer to 2nd. character  v2
13531   2935                                             ; in BASIC line/workspace.
13532   2935             
13533   2935 DF                  RST     18H             ; GET-CHAR gets character after variable name.
13534   2936 FE 28               CP      $28             ; is it '(' ?
13535   2938 28 09               JR      Z,L2943         ; forward to V-PASS
13536   293A                                             ; Note. could go straight to V-END ?
13537   293A             
13538   293A CB E8               SET     5,B             ; signal not an array
13539   293C 18 0D               JR      L294B           ; forward to V-END
13540   293E             
13541   293E             ; ---------------------------
13542   293E             
13543   293E             ; the jump was here when a long name matched and HL pointing to last character
13544   293E             ; in variables area.
13545   293E             
13546   293E             ;; V-FOUND-1
13547   293E D1          L293E:   POP     DE              ; discard pointer to first var letter
13548   293F             
13549   293F             ; the jump was here with all other matches HL points to first var char.
13550   293F             
13551   293F             ;; V-FOUND-2
13552   293F D1          L293F:   POP     DE              ; discard pointer to 2nd prog char       v2
13553   2940 D1                  POP     DE              ; drop pointer to 1st prog char          v1
13554   2941 E5                  PUSH    HL              ; save pointer to last char in vars
13555   2942             
13556   2942 DF                  RST     18H             ; GET-CHAR
13557   2943             
13558   2943             ;; V-PASS
13559   2943 CD 88 2C    L2943:   CALL    L2C88           ; routine ALPHANUM
13560   2946 30 03               JR      NC,L294B        ; forward to V-END if not
13561   2948             
13562   2948             ; but it never will be as we advanced past long-named variables earlier.
13563   2948             
13564   2948 E7                  RST     20H             ; NEXT-CHAR
13565   2949 18 F8               JR      L2943           ; back to V-PASS
13566   294B             
13567   294B             ; ---
13568   294B             
13569   294B             ;; V-END
13570   294B E1          L294B:   POP     HL              ; pop the pointer to first character in
13571   294C                                             ; BASIC line/workspace.
13572   294C CB 10               RL      B               ; rotate the B register left
13573   294E                                             ; bit 7 to carry
13574   294E CB 70               BIT     6,B             ; test the array indicator bit.
13575   2950 C9                  RET                     ; return
13576   2951             
13577   2951             ; -----------------------
13578   2951             ; Stack function argument
13579   2951             ; -----------------------
13580   2951             ; This branch is taken from LOOK-VARS when a defined function is currently
13581   2951             ; being evaluated.
13582   2951             ; Scanning is evaluating the expression after the '=' and the variable
13583   2951             ; found could be in the argument list to the left of the '=' or in the
13584   2951             ; normal place after the program. Preference will be given to the former.
13585   2951             ; The variable name to be matched is in C.
13586   2951             
13587   2951             ;; STK-F-ARG
13588   2951 2A 0B 5C    L2951:   LD      HL,($5C0B)      ; set HL to DEFADD
13589   2954 7E                  LD      A,(HL)          ; load the first character
13590   2955 FE 29               CP      $29             ; is it ')' ?
13591   2957 CA EF 28            JP      Z,L28EF         ; JUMP back to V-RUN/SYN, if so, as there are
13592   295A                                             ; no arguments.
13593   295A             
13594   295A             ; but proceed to search argument list of defined function first if not empty.
13595   295A             
13596   295A             ;; SFA-LOOP
13597   295A 7E          L295A:   LD      A,(HL)          ; fetch character again.
13598   295B F6 60               OR      $60             ; or with 01100000 presume a simple variable.
13599   295D 47                  LD      B,A             ; save result in B.
13600   295E 23                  INC     HL              ; address next location.
13601   295F 7E                  LD      A,(HL)          ; pick up byte.
13602   2960 FE 0E               CP      $0E             ; is it the number marker ?
13603   2962 28 07               JR      Z,L296B         ; forward to SFA-CP-VR if so.
13604   2964             
13605   2964             ; it was a string. White-space may be present but syntax has been checked.
13606   2964             
13607   2964 2B                  DEC     HL              ; point back to letter.
13608   2965 CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips to the '$'
13609   2968 23                  INC     HL              ; now address the hidden marker.
13610   2969 CB A8               RES     5,B             ; signal a string variable.
13611   296B             
13612   296B             ;; SFA-CP-VR
13613   296B 78          L296B:   LD      A,B             ; transfer found variable letter to A.
13614   296C B9                  CP      C               ; compare with expected.
13615   296D 28 12               JR      Z,L2981         ; forward to SFA-MATCH with a match.
13616   296F             
13617   296F 23                  INC     HL              ; step
13618   2970 23                  INC     HL              ; past
13619   2971 23                  INC     HL              ; the
13620   2972 23                  INC     HL              ; five
13621   2973 23                  INC     HL              ; bytes.
13622   2974             
13623   2974 CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips to next character
13624   2977 FE 29               CP      $29             ; is it ')' ?
13625   2979 CA EF 28            JP      Z,L28EF         ; jump back if so to V-RUN/SYN to look in
13626   297C                                             ; normal variables area.
13627   297C             
13628   297C CD AB 28            CALL    L28AB           ; routine FN-SKPOVR skips past the ','
13629   297F                                             ; all syntax has been checked and these
13630   297F                                             ; things can be taken as read.
13631   297F 18 D9               JR      L295A           ; back to SFA-LOOP while there are more
13632   2981                                             ; arguments.
13633   2981             
13634   2981             ; ---
13635   2981             
13636   2981             ;; SFA-MATCH
13637   2981 CB 69       L2981:   BIT     5,C             ; test if numeric
13638   2983 20 0C               JR      NZ,L2991        ; to SFA-END if so as will be stacked
13639   2985                                             ; by scanning
13640   2985             
13641   2985 23                  INC     HL              ; point to start of string descriptor
13642   2986 ED 5B 65 5C         LD      DE,($5C65)      ; set DE to STKEND
13643   298A CD C0 33            CALL    L33C0           ; routine MOVE-FP puts parameters on stack.
13644   298D EB                  EX      DE,HL           ; new free location to HL.
13645   298E 22 65 5C            LD      ($5C65),HL      ; use it to set STKEND system variable.
13646   2991             
13647   2991             ;; SFA-END
13648   2991 D1          L2991:   POP     DE              ; discard
13649   2992 D1                  POP     DE              ; pointers.
13650   2993 AF                  XOR     A               ; clear carry flag.
13651   2994 3C                  INC     A               ; and zero flag.
13652   2995 C9                  RET                     ; return.
13653   2996             
13654   2996             ; ------------------------
13655   2996             ; Stack variable component
13656   2996             ; ------------------------
13657   2996             ; This is called to evaluate a complex structure that has been found, in
13658   2996             ; runtime, by LOOK-VARS in the variables area.
13659   2996             ; In this case HL points to the initial letter, bits 7-5
13660   2996             ; of which indicate the type of variable.
13661   2996             ; 010 - simple string, 110 - string array, 100 - array of numbers.
13662   2996             ;
13663   2996             ; It is called from CLASS-01 when assigning to a string or array including
13664   2996             ; a slice.
13665   2996             ; It is called from SCANNING to isolate the required part of the structure.
13666   2996             ;
13667   2996             ; An important part of the runtime process is to check that the number of
13668   2996             ; dimensions of the variable match the number of subscripts supplied in the
13669   2996             ; BASIC line.
13670   2996             ;
13671   2996             ; If checking syntax,
13672   2996             ; the B register, which counts dimensions is set to zero (256) to allow
13673   2996             ; the loop to continue till all subscripts are checked. While doing this it
13674   2996             ; is reading dimension sizes from some arbitrary area of memory. Although
13675   2996             ; these are meaningless it is of no concern as the limit is never checked by
13676   2996             ; int-exp during syntax checking.
13677   2996             ;
13678   2996             ; The routine is also called from the syntax path of DIM command to check the
13679   2996             ; syntax of both string and numeric arrays definitions except that bit 6 of C
13680   2996             ; is reset so both are checked as numeric arrays. This ruse avoids a terminal
13681   2996             ; slice being accepted as part of the DIM command.
13682   2996             ; All that is being checked is that there are a valid set of comma-separated
13683   2996             ; expressions before a terminal ')', although, as above, it will still go
13684   2996             ; through the motions of checking dummy dimension sizes.
13685   2996             
13686   2996             ;; STK-VAR
13687   2996 AF          L2996:   XOR     A               ; clear A
13688   2997 47                  LD      B,A             ; and B, the syntax dimension counter (256)
13689   2998 CB 79               BIT     7,C             ; checking syntax ?
13690   299A 20 4B               JR      NZ,L29E7        ; forward to SV-COUNT if so.
13691   299C             
13692   299C             ; runtime evaluation.
13693   299C             
13694   299C CB 7E               BIT     7,(HL)          ; will be reset if a simple string.
13695   299E 20 0E               JR      NZ,L29AE        ; forward to SV-ARRAYS otherwise
13696   29A0             
13697   29A0 3C                  INC     A               ; set A to 1, simple string.
13698   29A1             
13699   29A1             ;; SV-SIMPLE$
13700   29A1 23          L29A1:   INC     HL              ; address length low
13701   29A2 4E                  LD      C,(HL)          ; place in C
13702   29A3 23                  INC     HL              ; address length high
13703   29A4 46                  LD      B,(HL)          ; place in B
13704   29A5 23                  INC     HL              ; address start of string
13705   29A6 EB                  EX      DE,HL           ; DE = start now.
13706   29A7 CD B2 2A            CALL    L2AB2           ; routine STK-STO-$ stacks string parameters
13707   29AA                                             ; DE start in variables area,
13708   29AA                                             ; BC length, A=1 simple string
13709   29AA             
13710   29AA             ; the only thing now is to consider if a slice is required.
13711   29AA             
13712   29AA DF                  RST     18H             ; GET-CHAR puts character at CH_ADD in A
13713   29AB C3 49 2A            JP      L2A49           ; jump forward to SV-SLICE? to test for '('
13714   29AE             
13715   29AE             ; --------------------------------------------------------
13716   29AE             
13717   29AE             ; the branch was here with string and numeric arrays in runtime.
13718   29AE             
13719   29AE             ;; SV-ARRAYS
13720   29AE 23          L29AE:   INC     HL              ; step past
13721   29AF 23                  INC     HL              ; the total length
13722   29B0 23                  INC     HL              ; to address Number of dimensions.
13723   29B1 46                  LD      B,(HL)          ; transfer to B overwriting zero.
13724   29B2 CB 71               BIT     6,C             ; a numeric array ?
13725   29B4 28 0A               JR      Z,L29C0         ; forward to SV-PTR with numeric arrays
13726   29B6             
13727   29B6 05                  DEC     B               ; ignore the final element of a string array
13728   29B7                                             ; the fixed string size.
13729   29B7             
13730   29B7 28 E8               JR      Z,L29A1         ; back to SV-SIMPLE$ if result is zero as has
13731   29B9                                             ; been created with DIM a$(10) for instance
13732   29B9                                             ; and can be treated as a simple string.
13733   29B9             
13734   29B9             ; proceed with multi-dimensioned string arrays in runtime.
13735   29B9             
13736   29B9 EB                  EX      DE,HL           ; save pointer to dimensions in DE
13737   29BA             
13738   29BA DF                  RST     18H             ; GET-CHAR looks at the BASIC line
13739   29BB FE 28               CP      $28             ; is character '(' ?
13740   29BD 20 61               JR      NZ,L2A20        ; to REPORT-3 if not
13741   29BF                                             ; 'Subscript wrong'
13742   29BF             
13743   29BF EB                  EX      DE,HL           ; dimensions pointer to HL to synchronize
13744   29C0                                             ; with next instruction.
13745   29C0             
13746   29C0             ; runtime numeric arrays path rejoins here.
13747   29C0             
13748   29C0             ;; SV-PTR
13749   29C0 EB          L29C0:   EX      DE,HL           ; save dimension pointer in DE
13750   29C1 18 24               JR      L29E7           ; forward to SV-COUNT with true no of dims 
13751   29C3                                             ; in B. As there is no initial comma the 
13752   29C3                                             ; loop is entered at the midpoint.
13753   29C3             
13754   29C3             ; ----------------------------------------------------------
13755   29C3             ; the dimension counting loop which is entered at mid-point.
13756   29C3             
13757   29C3             ;; SV-COMMA
13758   29C3 E5          L29C3:   PUSH    HL              ; save counter
13759   29C4             
13760   29C4 DF                  RST     18H             ; GET-CHAR
13761   29C5             
13762   29C5 E1                  POP     HL              ; pop counter
13763   29C6 FE 2C               CP      $2C             ; is character ',' ?
13764   29C8 28 20               JR      Z,L29EA         ; forward to SV-LOOP if so
13765   29CA             
13766   29CA             ; in runtime the variable definition indicates a comma should appear here
13767   29CA             
13768   29CA CB 79               BIT     7,C             ; checking syntax ?
13769   29CC 28 52               JR      Z,L2A20         ; forward to REPORT-3 if not
13770   29CE                                             ; 'Subscript error'
13771   29CE             
13772   29CE             ; proceed if checking syntax of an array?
13773   29CE             
13774   29CE CB 71               BIT     6,C             ; array of strings
13775   29D0 20 06               JR      NZ,L29D8        ; forward to SV-CLOSE if so
13776   29D2             
13777   29D2             ; an array of numbers.
13778   29D2             
13779   29D2 FE 29               CP      $29             ; is character ')' ?
13780   29D4 20 3C               JR      NZ,L2A12        ; forward to SV-RPT-C if not
13781   29D6                                             ; 'Nonsense in BASIC'
13782   29D6             
13783   29D6 E7                  RST     20H             ; NEXT-CHAR moves CH-ADD past the statement
13784   29D7 C9                  RET                     ; return ->
13785   29D8             
13786   29D8             ; ---
13787   29D8             
13788   29D8             ; the branch was here with an array of strings.
13789   29D8             
13790   29D8             ;; SV-CLOSE
13791   29D8 FE 29       L29D8:   CP      $29             ; as above ')' could follow the expression
13792   29DA 28 6C               JR      Z,L2A48         ; forward to SV-DIM if so
13793   29DC             
13794   29DC FE CC               CP      $CC             ; is it 'TO' ?
13795   29DE 20 32               JR      NZ,L2A12        ; to SV-RPT-C with anything else
13796   29E0                                             ; 'Nonsense in BASIC'
13797   29E0             
13798   29E0             ; now backtrack CH_ADD to set up for slicing routine.
13799   29E0             ; Note. in a BASIC line we can safely backtrack to a colour parameter.
13800   29E0             
13801   29E0             ;; SV-CH-ADD
13802   29E0 DF          L29E0:   RST     18H             ; GET-CHAR
13803   29E1 2B                  DEC     HL              ; backtrack HL
13804   29E2 22 5D 5C            LD      ($5C5D),HL      ; to set CH_ADD up for slicing routine
13805   29E5 18 5E               JR      L2A45           ; forward to SV-SLICE and make a return
13806   29E7                                             ; when all slicing complete.
13807   29E7             
13808   29E7             ; ----------------------------------------
13809   29E7             ; -> the mid-point entry point of the loop
13810   29E7             
13811   29E7             ;; SV-COUNT
13812   29E7 21 00 00    L29E7:   LD      HL,$0000        ; initialize data pointer to zero.
13813   29EA             
13814   29EA             ;; SV-LOOP
13815   29EA E5          L29EA:   PUSH    HL              ; save the data pointer.
13816   29EB             
13817   29EB E7                  RST     20H             ; NEXT-CHAR in BASIC area points to an
13818   29EC                                             ; expression.
13819   29EC             
13820   29EC E1                  POP     HL              ; restore the data pointer.
13821   29ED 79                  LD      A,C             ; transfer name/type to A.
13822   29EE FE C0               CP      $C0             ; is it 11000000 ?
13823   29F0                                             ; Note. the letter component is absent if
13824   29F0                                             ; syntax checking.
13825   29F0 20 09               JR      NZ,L29FB        ; forward to SV-MULT if not an array of
13826   29F2                                             ; strings.
13827   29F2             
13828   29F2             ; proceed to check string arrays during syntax.
13829   29F2             
13830   29F2 DF                  RST     18H             ; GET-CHAR
13831   29F3 FE 29               CP      $29             ; ')'  end of subscripts ?
13832   29F5 28 51               JR      Z,L2A48         ; forward to SV-DIM to consider further slice
13833   29F7             
13834   29F7 FE CC               CP      $CC             ; is it 'TO' ?
13835   29F9 28 E5               JR      Z,L29E0         ; back to SV-CH-ADD to consider a slice.
13836   29FB                                             ; (no need to repeat get-char at L29E0)
13837   29FB             
13838   29FB             ; if neither, then an expression is required so rejoin runtime loop ??
13839   29FB             ; registers HL and DE only point to somewhere meaningful in runtime so 
13840   29FB             ; comments apply to that situation.
13841   29FB             
13842   29FB             ;; SV-MULT
13843   29FB C5          L29FB:   PUSH    BC              ; save dimension number.
13844   29FC E5                  PUSH    HL              ; push data pointer/rubbish.
13845   29FD                                             ; DE points to current dimension.
13846   29FD CD EE 2A            CALL    L2AEE           ; routine DE,(DE+1) gets next dimension in DE
13847   2A00                                             ; and HL points to it.
13848   2A00 E3                  EX      (SP),HL         ; dim pointer to stack, data pointer to HL (*)
13849   2A01 EB                  EX      DE,HL           ; data pointer to DE, dim size to HL.
13850   2A02             
13851   2A02 CD CC 2A            CALL    L2ACC           ; routine INT-EXP1 checks integer expression
13852   2A05                                             ; and gets result in BC in runtime.
13853   2A05 38 19               JR      C,L2A20         ; to REPORT-3 if > HL
13854   2A07                                             ; 'Subscript out of range'
13855   2A07             
13856   2A07 0B                  DEC     BC              ; adjust returned result from 1-x to 0-x
13857   2A08 CD F4 2A            CALL    L2AF4           ; routine GET-HL*DE multiplies data pointer by
13858   2A0B                                             ; dimension size.
13859   2A0B 09                  ADD     HL,BC           ; add the integer returned by expression.
13860   2A0C D1                  POP     DE              ; pop the dimension pointer.                              ***
13861   2A0D C1                  POP     BC              ; pop dimension counter.
13862   2A0E 10 B3               DJNZ    L29C3           ; back to SV-COMMA if more dimensions
13863   2A10                                             ; Note. during syntax checking, unless there
13864   2A10                                             ; are more than 256 subscripts, the branch
13865   2A10                                             ; back to SV-COMMA is always taken.
13866   2A10             
13867   2A10 CB 79               BIT     7,C             ; are we checking syntax ?
13868   2A12                                             ; then we've got a joker here.
13869   2A12             
13870   2A12             ;; SV-RPT-C
13871   2A12 20 66       L2A12:   JR      NZ,L2A7A        ; forward to SL-RPT-C if so
13872   2A14                                             ; 'Nonsense in BASIC'
13873   2A14                                             ; more than 256 subscripts in BASIC line.
13874   2A14             
13875   2A14             ; but in runtime the number of subscripts are at least the same as dims
13876   2A14             
13877   2A14 E5                  PUSH    HL              ; save data pointer.
13878   2A15 CB 71               BIT     6,C             ; is it a string array ?
13879   2A17 20 13               JR      NZ,L2A2C        ; forward to SV-ELEM$ if so.
13880   2A19             
13881   2A19             ; a runtime numeric array subscript.
13882   2A19             
13883   2A19 42                  LD      B,D             ; register DE has advanced past all dimensions
13884   2A1A 4B                  LD      C,E             ; and points to start of data in variable.
13885   2A1B                                             ; transfer it to BC.
13886   2A1B             
13887   2A1B DF                  RST     18H             ; GET-CHAR checks BASIC line
13888   2A1C FE 29               CP      $29             ; must be a ')' ?
13889   2A1E 28 02               JR      Z,L2A22         ; skip to SV-NUMBER if so
13890   2A20             
13891   2A20             ; else more subscripts in BASIC line than the variable definition.
13892   2A20             
13893   2A20             ;; REPORT-3
13894   2A20 CF          L2A20:   RST     08H             ; ERROR-1
13895   2A21 02                  DEFB    $02             ; Error Report: Subscript wrong
13896   2A22             
13897   2A22             ; continue if subscripts matched the numeric array.
13898   2A22             
13899   2A22             ;; SV-NUMBER
13900   2A22 E7          L2A22:   RST     20H             ; NEXT-CHAR moves CH_ADD to next statement
13901   2A23                                             ; - finished parsing.
13902   2A23             
13903   2A23 E1                  POP     HL              ; pop the data pointer.
13904   2A24 11 05 00            LD      DE,$0005        ; each numeric element is 5 bytes.
13905   2A27 CD F4 2A            CALL    L2AF4           ; routine GET-HL*DE multiplies.
13906   2A2A 09                  ADD     HL,BC           ; now add to start of data in the variable.
13907   2A2B             
13908   2A2B C9                  RET                     ; return with HL pointing at the numeric
13909   2A2C                                             ; array subscript.                       ->
13910   2A2C             
13911   2A2C             ; ---------------------------------------------------------------
13912   2A2C             
13913   2A2C             ; the branch was here for string subscripts when the number of subscripts
13914   2A2C             ; in the BASIC line was one less than in variable definition.
13915   2A2C             
13916   2A2C             ;; SV-ELEM$
13917   2A2C CD EE 2A    L2A2C:   CALL    L2AEE           ; routine DE,(DE+1) gets final dimension
13918   2A2F                                             ; the length of strings in this array.
13919   2A2F E3                  EX      (SP),HL         ; start pointer to stack, data pointer to HL.
13920   2A30 CD F4 2A            CALL    L2AF4           ; routine GET-HL*DE multiplies by element
13921   2A33                                             ; size.
13922   2A33 C1                  POP     BC              ; the start of data pointer is added
13923   2A34 09                  ADD     HL,BC           ; in - now points to location before.
13924   2A35 23                  INC     HL              ; point to start of required string.
13925   2A36 42                  LD      B,D             ; transfer the length (final dimension size)
13926   2A37 4B                  LD      C,E             ; from DE to BC.
13927   2A38 EB                  EX      DE,HL           ; put start in DE.
13928   2A39 CD B1 2A            CALL    L2AB1           ; routine STK-ST-0 stores the string parameters
13929   2A3C                                             ; with A=0 - a slice or subscript.
13930   2A3C             
13931   2A3C             ; now check that there were no more subscripts in the BASIC line.
13932   2A3C             
13933   2A3C DF                  RST     18H             ; GET-CHAR
13934   2A3D FE 29               CP      $29             ; is it ')' ?
13935   2A3F 28 07               JR      Z,L2A48         ; forward to SV-DIM to consider a separate
13936   2A41                                             ; subscript or/and a slice.
13937   2A41             
13938   2A41 FE 2C               CP      $2C             ; a comma is allowed if the final subscript
13939   2A43                                             ; is to be sliced e.g. a$(2,3,4 TO 6).
13940   2A43 20 DB               JR      NZ,L2A20        ; to REPORT-3 with anything else
13941   2A45                                             ; 'Subscript error'
13942   2A45             
13943   2A45             ;; SV-SLICE
13944   2A45 CD 52 2A    L2A45:   CALL    L2A52           ; routine SLICING slices the string.
13945   2A48             
13946   2A48             ; but a slice of a simple string can itself be sliced.
13947   2A48             
13948   2A48             ;; SV-DIM
13949   2A48 E7          L2A48:   RST     20H             ; NEXT-CHAR
13950   2A49             
13951   2A49             ;; SV-SLICE?
13952   2A49 FE 28       L2A49:   CP      $28             ; is character '(' ?
13953   2A4B 28 F8               JR      Z,L2A45         ; loop back if so to SV-SLICE
13954   2A4D             
13955   2A4D FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS  - Signal string result
13956   2A51 C9                  RET                     ; and return.
13957   2A52             
13958   2A52             ; ---
13959   2A52             
13960   2A52             ; The above section deals with the flexible syntax allowed.
13961   2A52             ; DIM a$(3,3,10) can be considered as two dimensional array of ten-character
13962   2A52             ; strings or a 3-dimensional array of characters.
13963   2A52             ; a$(1,1) will return a 10-character string as will a$(1,1,1 TO 10)
13964   2A52             ; a$(1,1,1) will return a single character.
13965   2A52             ; a$(1,1) (1 TO 6) is the same as a$(1,1,1 TO 6)
13966   2A52             ; A slice can itself be sliced ad infinitum
13967   2A52             ; b$ () () () () () () (2 TO 10) (2 TO 9) (3) is the same as b$(5)
13968   2A52             
13969   2A52             
13970   2A52             
13971   2A52             ; -------------------------
13972   2A52             ; Handle slicing of strings
13973   2A52             ; -------------------------
13974   2A52             ; The syntax of string slicing is very natural and it is as well to reflect
13975   2A52             ; on the permutations possible.
13976   2A52             ; a$() and a$( TO ) indicate the entire string although just a$ would do
13977   2A52             ; and would avoid coming here.
13978   2A52             ; h$(16) indicates the single character at position 16.
13979   2A52             ; a$( TO 32) indicates the first 32 characters.
13980   2A52             ; a$(257 TO) indicates all except the first 256 characters.
13981   2A52             ; a$(19000 TO 19999) indicates the thousand characters at position 19000.
13982   2A52             ; Also a$(9 TO 5) returns a null string not an error.
13983   2A52             ; This enables a$(2 TO) to return a null string if the passed string is
13984   2A52             ; of length zero or 1.
13985   2A52             ; A string expression in brackets can be sliced. e.g. (STR$ PI) (3 TO )
13986   2A52             ; We arrived here from SCANNING with CH-ADD pointing to the initial '('
13987   2A52             ; or from above.
13988   2A52             
13989   2A52             ;; SLICING
13990   2A52 CD 30 25    L2A52:   CALL    L2530           ; routine SYNTAX-Z
13991   2A55 C4 F1 2B            CALL    NZ,L2BF1        ; routine STK-FETCH fetches parameters of
13992   2A58                                             ; string at runtime, start in DE, length 
13993   2A58                                             ; in BC. This could be an array subscript.
13994   2A58             
13995   2A58 E7                  RST     20H             ; NEXT-CHAR
13996   2A59 FE 29               CP      $29             ; is it ')' ?     e.g. a$()
13997   2A5B 28 50               JR      Z,L2AAD         ; forward to SL-STORE to store entire string.
13998   2A5D             
13999   2A5D D5                  PUSH    DE              ; else save start address of string
14000   2A5E             
14001   2A5E AF                  XOR     A               ; clear accumulator to use as a running flag.
14002   2A5F F5                  PUSH    AF              ; and save on stack before any branching.
14003   2A60             
14004   2A60 C5                  PUSH    BC              ; save length of string to be sliced.
14005   2A61 11 01 00            LD      DE,$0001        ; default the start point to position 1.
14006   2A64             
14007   2A64 DF                  RST     18H             ; GET-CHAR
14008   2A65             
14009   2A65 E1                  POP     HL              ; pop length to HL as default end point
14010   2A66                                             ; and limit.
14011   2A66             
14012   2A66 FE CC               CP      $CC             ; is it 'TO' ?    e.g. a$( TO 10000)
14013   2A68 28 17               JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter.
14014   2A6A             
14015   2A6A F1                  POP     AF              ; pop the running flag.
14016   2A6B             
14017   2A6B CD CD 2A            CALL    L2ACD           ; routine INT-EXP2 fetches first parameter.
14018   2A6E             
14019   2A6E F5                  PUSH    AF              ; save flag (will be $FF if parameter>limit)
14020   2A6F             
14021   2A6F 50                  LD      D,B             ; transfer the start
14022   2A70 59                  LD      E,C             ; to DE overwriting 0001.
14023   2A71 E5                  PUSH    HL              ; save original length.
14024   2A72             
14025   2A72 DF                  RST     18H             ; GET-CHAR
14026   2A73 E1                  POP     HL              ; pop the limit length.
14027   2A74 FE CC               CP      $CC             ; is it 'TO' after a start ?
14028   2A76 28 09               JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter
14029   2A78             
14030   2A78 FE 29               CP      $29             ; is it ')' ?       e.g. a$(365)
14031   2A7A             
14032   2A7A             ;; SL-RPT-C
14033   2A7A C2 8A 1C    L2A7A:   JP      NZ,L1C8A        ; jump to REPORT-C with anything else
14034   2A7D                                             ; 'Nonsense in BASIC'
14035   2A7D             
14036   2A7D 62                  LD      H,D             ; copy start
14037   2A7E 6B                  LD      L,E             ; to end - just a one character slice.
14038   2A7F 18 13               JR      L2A94           ; forward to SL-DEFINE.
14039   2A81             
14040   2A81             ; ---------------------
14041   2A81             
14042   2A81             ;; SL-SECOND
14043   2A81 E5          L2A81:   PUSH    HL              ; save limit length.
14044   2A82             
14045   2A82 E7                  RST     20H             ; NEXT-CHAR
14046   2A83             
14047   2A83 E1                  POP     HL              ; pop the length.
14048   2A84             
14049   2A84 FE 29               CP      $29             ; is character ')' ?        e.g. a$(7 TO )
14050   2A86 28 0C               JR      Z,L2A94         ; to SL-DEFINE using length as end point.
14051   2A88             
14052   2A88 F1                  POP     AF              ; else restore flag.
14053   2A89 CD CD 2A            CALL    L2ACD           ; routine INT-EXP2 gets second expression.
14054   2A8C             
14055   2A8C F5                  PUSH    AF              ; save the running flag.
14056   2A8D             
14057   2A8D DF                  RST     18H             ; GET-CHAR
14058   2A8E             
14059   2A8E 60                  LD      H,B             ; transfer second parameter
14060   2A8F 69                  LD      L,C             ; to HL.              e.g. a$(42 to 99)
14061   2A90 FE 29               CP      $29             ; is character a ')' ?
14062   2A92 20 E6               JR      NZ,L2A7A        ; to SL-RPT-C if not
14063   2A94                                             ; 'Nonsense in BASIC'
14064   2A94             
14065   2A94             ; we now have start in DE and an end in HL.
14066   2A94             
14067   2A94             ;; SL-DEFINE
14068   2A94 F1          L2A94:   POP     AF              ; pop the running flag.
14069   2A95 E3                  EX      (SP),HL         ; put end point on stack, start address to HL
14070   2A96 19                  ADD     HL,DE           ; add address of string to the start point.
14071   2A97 2B                  DEC     HL              ; point to first character of slice.
14072   2A98 E3                  EX      (SP),HL         ; start address to stack, end point to HL (*)
14073   2A99 A7                  AND     A               ; prepare to subtract.
14074   2A9A ED 52               SBC     HL,DE           ; subtract start point from end point.
14075   2A9C 01 00 00            LD      BC,$0000        ; default the length result to zero.
14076   2A9F 38 07               JR      C,L2AA8         ; forward to SL-OVER if start > end.
14077   2AA1             
14078   2AA1 23                  INC     HL              ; increment the length for inclusive byte.
14079   2AA2             
14080   2AA2 A7                  AND     A               ; now test the running flag.
14081   2AA3 FA 20 2A            JP      M,L2A20         ; jump back to REPORT-3 if $FF.
14082   2AA6                                             ; 'Subscript out of range'
14083   2AA6             
14084   2AA6 44                  LD      B,H             ; transfer the length
14085   2AA7 4D                  LD      C,L             ; to BC.
14086   2AA8             
14087   2AA8             ;; SL-OVER
14088   2AA8 D1          L2AA8:   POP     DE              ; restore start address from machine stack ***
14089   2AA9 FD CB 01 B6         RES     6,(IY+$01)      ; update FLAGS - signal string result for
14090   2AAD                                             ; syntax.
14091   2AAD             
14092   2AAD             ;; SL-STORE
14093   2AAD CD 30 25    L2AAD:   CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
14094   2AB0 C8                  RET     Z               ; return if checking syntax.
14095   2AB1                                             ; but continue to store the string in runtime.
14096   2AB1             
14097   2AB1             ; ------------------------------------
14098   2AB1             ; other than from above, this routine is called from STK-VAR to stack
14099   2AB1             ; a known string array element.
14100   2AB1             ; ------------------------------------
14101   2AB1             
14102   2AB1             ;; STK-ST-0
14103   2AB1 AF          L2AB1:   XOR     A               ; clear to signal a sliced string or element.
14104   2AB2             
14105   2AB2             ; -------------------------
14106   2AB2             ; this routine is called from chr$, scrn$ etc. to store a simple string result.
14107   2AB2             ; --------------------------
14108   2AB2             
14109   2AB2             ;; STK-STO-$
14110   2AB2 FD CB 01 B6 L2AB2:   RES     6,(IY+$01)      ; update FLAGS - signal string result.
14111   2AB6                                             ; and continue to store parameters of string.
14112   2AB6             
14113   2AB6             ; ---------------------------------------
14114   2AB6             ; Pass five registers to calculator stack
14115   2AB6             ; ---------------------------------------
14116   2AB6             ; This subroutine puts five registers on the calculator stack.
14117   2AB6             
14118   2AB6             ;; STK-STORE
14119   2AB6 C5          L2AB6:   PUSH    BC              ; save two registers
14120   2AB7 CD A9 33            CALL    L33A9           ; routine TEST-5-SP checks room and puts 5 
14121   2ABA                                             ; in BC.
14122   2ABA C1                  POP     BC              ; fetch the saved registers.
14123   2ABB 2A 65 5C            LD      HL,($5C65)      ; make HL point to first empty location STKEND
14124   2ABE 77                  LD      (HL),A          ; place the 5 registers.
14125   2ABF 23                  INC     HL              ;
14126   2AC0 73                  LD      (HL),E          ;
14127   2AC1 23                  INC     HL              ;
14128   2AC2 72                  LD      (HL),D          ;
14129   2AC3 23                  INC     HL              ;
14130   2AC4 71                  LD      (HL),C          ;
14131   2AC5 23                  INC     HL              ;
14132   2AC6 70                  LD      (HL),B          ;
14133   2AC7 23                  INC     HL              ;
14134   2AC8 22 65 5C            LD      ($5C65),HL      ; update system variable STKEND.
14135   2ACB C9                  RET                     ; and return.
14136   2ACC             
14137   2ACC             ; -------------------------------------------
14138   2ACC             ; Return result of evaluating next expression
14139   2ACC             ; -------------------------------------------
14140   2ACC             ; This clever routine is used to check and evaluate an integer expression
14141   2ACC             ; which is returned in BC, setting A to $FF, if greater than a limit supplied
14142   2ACC             ; in HL. It is used to check array subscripts, parameters of a string slice
14143   2ACC             ; and the arguments of the DIM command. In the latter case, the limit check
14144   2ACC             ; is not required and H is set to $FF. When checking optional string slice
14145   2ACC             ; parameters, it is entered at the second entry point so as not to disturb
14146   2ACC             ; the running flag A, which may be $00 or $FF from a previous invocation.
14147   2ACC             
14148   2ACC             ;; INT-EXP1
14149   2ACC AF          L2ACC:   XOR     A               ; set result flag to zero.
14150   2ACD             
14151   2ACD             ; -> The entry point is here if A is used as a running flag.
14152   2ACD             
14153   2ACD             ;; INT-EXP2
14154   2ACD D5          L2ACD:   PUSH    DE              ; preserve DE register throughout.
14155   2ACE E5                  PUSH    HL              ; save the supplied limit.
14156   2ACF F5                  PUSH    AF              ; save the flag.
14157   2AD0             
14158   2AD0 CD 82 1C            CALL    L1C82           ; routine EXPT-1NUM evaluates expression
14159   2AD3                                             ; at CH_ADD returning if numeric result,
14160   2AD3                                             ; with value on calculator stack.
14161   2AD3             
14162   2AD3 F1                  POP     AF              ; pop the flag.
14163   2AD4 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
14164   2AD7 28 12               JR      Z,L2AEB         ; forward to I-RESTORE if checking syntax so
14165   2AD9                                             ; avoiding a comparison with supplied limit.
14166   2AD9             
14167   2AD9 F5                  PUSH    AF              ; save the flag.
14168   2ADA             
14169   2ADA CD 99 1E            CALL    L1E99           ; routine FIND-INT2 fetches value from
14170   2ADD                                             ; calculator stack to BC producing an error
14171   2ADD                                             ; if too high.
14172   2ADD             
14173   2ADD D1                  POP     DE              ; pop the flag to D.
14174   2ADE 78                  LD      A,B             ; test value for zero and reject
14175   2ADF B1                  OR      C               ; as arrays and strings begin at 1.
14176   2AE0 37                  SCF                     ; set carry flag.
14177   2AE1 28 05               JR      Z,L2AE8         ; forward to I-CARRY if zero.
14178   2AE3             
14179   2AE3 E1                  POP     HL              ; restore the limit.
14180   2AE4 E5                  PUSH    HL              ; and save.
14181   2AE5 A7                  AND     A               ; prepare to subtract.
14182   2AE6 ED 42               SBC     HL,BC           ; subtract value from limit.
14183   2AE8             
14184   2AE8             ;; I-CARRY
14185   2AE8 7A          L2AE8:   LD      A,D             ; move flag to accumulator $00 or $FF.
14186   2AE9 DE 00               SBC     A,$00           ; will set to $FF if carry set.
14187   2AEB             
14188   2AEB             ;; I-RESTORE
14189   2AEB E1          L2AEB:   POP     HL              ; restore the limit.
14190   2AEC D1                  POP     DE              ; and DE register.
14191   2AED C9                  RET                     ; return.
14192   2AEE             
14193   2AEE             
14194   2AEE             ; -----------------------
14195   2AEE             ; LD DE,(DE+1) Subroutine
14196   2AEE             ; -----------------------
14197   2AEE             ; This routine just loads the DE register with the contents of the two
14198   2AEE             ; locations following the location addressed by DE.
14199   2AEE             ; It is used to step along the 16-bit dimension sizes in array definitions.
14200   2AEE             ; Note. Such code is made into subroutines to make programs easier to
14201   2AEE             ; write and it would use less space to include the five instructions in-line.
14202   2AEE             ; However, there are so many exchanges going on at the places this is invoked
14203   2AEE             ; that to implement it in-line would make the code hard to follow.
14204   2AEE             ; It probably had a zippier label though as the intention is to simplify the
14205   2AEE             ; program.
14206   2AEE             
14207   2AEE             ;; DE,(DE+1)
14208   2AEE EB          L2AEE:   EX      DE,HL           ;
14209   2AEF 23                  INC     HL              ;
14210   2AF0 5E                  LD      E,(HL)          ;
14211   2AF1 23                  INC     HL              ;
14212   2AF2 56                  LD      D,(HL)          ;
14213   2AF3 C9                  RET                     ;
14214   2AF4             
14215   2AF4             ; -------------------
14216   2AF4             ; HL=HL*DE Subroutine
14217   2AF4             ; -------------------
14218   2AF4             ; This routine calls the mathematical routine to multiply HL by DE in runtime.
14219   2AF4             ; It is called from STK-VAR and from DIM. In the latter case syntax is not
14220   2AF4             ; being checked so the entry point could have been at the second CALL
14221   2AF4             ; instruction to save a few clock-cycles.
14222   2AF4             
14223   2AF4             ;; GET-HL*DE
14224   2AF4 CD 30 25    L2AF4:   CALL    L2530           ; routine SYNTAX-Z.
14225   2AF7 C8                  RET     Z               ; return if checking syntax.
14226   2AF8             
14227   2AF8 CD A9 30            CALL    L30A9           ; routine HL-HL*DE.
14228   2AFB DA 15 1F            JP      C,L1F15         ; jump back to REPORT-4 if over 65535.
14229   2AFE             
14230   2AFE C9                  RET                     ; else return with 16-bit result in HL.
14231   2AFF             
14232   2AFF             ; -----------------
14233   2AFF             ; THE 'LET' COMMAND
14234   2AFF             ; -----------------
14235   2AFF             ; Sinclair BASIC adheres to the ANSI-78 standard and a LET is required in
14236   2AFF             ; assignments e.g. LET a = 1  :   LET h$ = "hat".
14237   2AFF             ;
14238   2AFF             ; Long names may contain spaces but not colour controls (when assigned).
14239   2AFF             ; a substring can appear to the left of the equals sign.
14240   2AFF             
14241   2AFF             ; An earlier mathematician Lewis Carroll may have been pleased that
14242   2AFF             ; 10 LET Babies cannot manage crocodiles = Babies are illogical AND
14243   2AFF             ;    Nobody is despised who can manage a crocodile AND Illogical persons
14244   2AFF             ;    are despised
14245   2AFF             ; does not give the 'Nonsense..' error if the three variables exist.
14246   2AFF             ; I digress.
14247   2AFF             
14248   2AFF             ;; LET
14249   2AFF 2A 4D 5C    L2AFF:   LD      HL,($5C4D)      ; fetch system variable DEST to HL.
14250   2B02 FD CB 37 4E         BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
14251   2B06 28 5E               JR      Z,L2B66         ; forward to L-EXISTS if not.
14252   2B08             
14253   2B08             ; continue for a new variable. DEST points to start in BASIC line.
14254   2B08             ; from the CLASS routines.
14255   2B08             
14256   2B08 01 05 00            LD      BC,$0005        ; assume numeric and assign an initial 5 bytes
14257   2B0B             
14258   2B0B             ;; L-EACH-CH
14259   2B0B 03          L2B0B:   INC     BC              ; increase byte count for each relevant
14260   2B0C                                             ; character
14261   2B0C             
14262   2B0C             ;; L-NO-SP
14263   2B0C 23          L2B0C:   INC     HL              ; increase pointer.
14264   2B0D 7E                  LD      A,(HL)          ; fetch character.
14265   2B0E FE 20               CP      $20             ; is it a space ?
14266   2B10 28 FA               JR      Z,L2B0C         ; back to L-NO-SP is so.
14267   2B12             
14268   2B12 30 0B               JR      NC,L2B1F        ; forward to L-TEST-CH if higher.
14269   2B14             
14270   2B14 FE 10               CP      $10             ; is it $00 - $0F ?
14271   2B16 38 11               JR      C,L2B29         ; forward to L-SPACES if so.
14272   2B18             
14273   2B18 FE 16               CP      $16             ; is it $16 - $1F ?
14274   2B1A 30 0D               JR      NC,L2B29        ; forward to L-SPACES if so.
14275   2B1C             
14276   2B1C             ; it was $10 - $15  so step over a colour code.
14277   2B1C             
14278   2B1C 23                  INC     HL              ; increase pointer.
14279   2B1D 18 ED               JR      L2B0C           ; loop back to L-NO-SP.
14280   2B1F             
14281   2B1F             ; ---
14282   2B1F             
14283   2B1F             ; the branch was to here if higher than space.
14284   2B1F             
14285   2B1F             ;; L-TEST-CH
14286   2B1F CD 88 2C    L2B1F:   CALL    L2C88           ; routine ALPHANUM sets carry if alphanumeric
14287   2B22 38 E7               JR      C,L2B0B         ; loop back to L-EACH-CH for more if so.
14288   2B24             
14289   2B24 FE 24               CP      $24             ; is it '$' ?
14290   2B26 CA C0 2B            JP      Z,L2BC0         ; jump forward if so, to L-NEW$
14291   2B29                                             ; with a new string.
14292   2B29             
14293   2B29             ;; L-SPACES
14294   2B29 79          L2B29:   LD      A,C             ; save length lo in A.
14295   2B2A 2A 59 5C            LD      HL,($5C59)      ; fetch E_LINE to HL.
14296   2B2D 2B                  DEC     HL              ; point to location before, the variables
14297   2B2E                                             ; end-marker.
14298   2B2E CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates BC spaces
14299   2B31                                             ; for name and numeric value.
14300   2B31 23                  INC     HL              ; advance to first new location.
14301   2B32 23                  INC     HL              ; then to second.
14302   2B33 EB                  EX      DE,HL           ; set DE to second location.
14303   2B34 D5                  PUSH    DE              ; save this pointer.
14304   2B35 2A 4D 5C            LD      HL,($5C4D)      ; reload HL with DEST.
14305   2B38 1B                  DEC     DE              ; point to first.
14306   2B39 D6 06               SUB     $06             ; subtract six from length_lo.
14307   2B3B 47                  LD      B,A             ; save count in B.
14308   2B3C 28 11               JR      Z,L2B4F         ; forward to L-SINGLE if it was just
14309   2B3E                                             ; one character.
14310   2B3E             
14311   2B3E             ; HL points to start of variable name after 'LET' in BASIC line.
14312   2B3E             
14313   2B3E             ;; L-CHAR
14314   2B3E 23          L2B3E:   INC     HL              ; increase pointer.
14315   2B3F 7E                  LD      A,(HL)          ; pick up character.
14316   2B40 FE 21               CP      $21             ; is it space or higher ?
14317   2B42 38 FA               JR      C,L2B3E         ; back to L-CHAR with space and less.
14318   2B44             
14319   2B44 F6 20               OR      $20             ; make variable lower-case.
14320   2B46 13                  INC     DE              ; increase destination pointer.
14321   2B47 12                  LD      (DE),A          ; and load to edit line.
14322   2B48 10 F4               DJNZ    L2B3E           ; loop back to L-CHAR until B is zero.
14323   2B4A             
14324   2B4A F6 80               OR      $80             ; invert the last character.
14325   2B4C 12                  LD      (DE),A          ; and overwrite that in edit line.
14326   2B4D             
14327   2B4D             ; now consider first character which has bit 6 set
14328   2B4D             
14329   2B4D 3E C0               LD      A,$C0           ; set A 11000000 is xor mask for a long name.
14330   2B4F                                             ; %101      is xor/or  result
14331   2B4F             
14332   2B4F             ; single character numerics rejoin here with %00000000 in mask.
14333   2B4F             ;                                            %011      will be xor/or result
14334   2B4F             
14335   2B4F             ;; L-SINGLE
14336   2B4F 2A 4D 5C    L2B4F:   LD      HL,($5C4D)      ; fetch DEST - HL addresses first character.
14337   2B52 AE                  XOR     (HL)            ; apply variable type indicator mask (above).
14338   2B53 F6 20               OR      $20             ; make lowercase - set bit 5.
14339   2B55 E1                  POP     HL              ; restore pointer to 2nd character.
14340   2B56 CD EA 2B            CALL    L2BEA           ; routine L-FIRST puts A in first character.
14341   2B59                                             ; and returns with HL holding
14342   2B59                                             ; new E_LINE-1  the $80 vars end-marker.
14343   2B59             
14344   2B59             ;; L-NUMERIC
14345   2B59 E5          L2B59:   PUSH    HL              ; save the pointer.
14346   2B5A             
14347   2B5A             ; the value of variable is deleted but remains after calculator stack.
14348   2B5A             
14349   2B5A EF                  RST     28H             ;; FP-CALC
14350   2B5B 02                  DEFB    $02             ;;delete      ; delete variable value
14351   2B5C 38                  DEFB    $38             ;;end-calc
14352   2B5D             
14353   2B5D             ; DE (STKEND) points to start of value.
14354   2B5D             
14355   2B5D E1                  POP     HL              ; restore the pointer.
14356   2B5E 01 05 00            LD      BC,$0005        ; start of number is five bytes before.
14357   2B61 A7                  AND     A               ; prepare for true subtraction.
14358   2B62 ED 42               SBC     HL,BC           ; HL points to start of value.
14359   2B64 18 40               JR      L2BA6           ; forward to L-ENTER  ==>
14360   2B66             
14361   2B66             ; ---
14362   2B66             
14363   2B66             
14364   2B66             ; the jump was to here if the variable already existed.
14365   2B66             
14366   2B66             ;; L-EXISTS
14367   2B66 FD CB 01 76 L2B66:   BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
14368   2B6A 28 06               JR      Z,L2B72         ; skip forward to L-DELETE$   -*->
14369   2B6C                                             ; if string result.
14370   2B6C             
14371   2B6C             ; A numeric variable could be simple or an array element.
14372   2B6C             ; They are treated the same and the old value is overwritten.
14373   2B6C             
14374   2B6C 11 06 00            LD      DE,$0006        ; six bytes forward points to loc past value.
14375   2B6F 19                  ADD     HL,DE           ; add to start of number.
14376   2B70 18 E7               JR      L2B59           ; back to L-NUMERIC to overwrite value.
14377   2B72             
14378   2B72             ; ---
14379   2B72             
14380   2B72             ; -*-> the branch was here if a string existed.
14381   2B72             
14382   2B72             ;; L-DELETE$
14383   2B72 2A 4D 5C    L2B72:   LD      HL,($5C4D)      ; fetch DEST to HL.
14384   2B75                                             ; (still set from first instruction)
14385   2B75 ED 4B 72 5C         LD      BC,($5C72)      ; fetch STRLEN to BC.
14386   2B79 FD CB 37 46         BIT     0,(IY+$37)      ; test FLAGX - handling a complete simple
14387   2B7D                                             ; string ?
14388   2B7D 20 30               JR      NZ,L2BAF        ; forward to L-ADD$ if so.
14389   2B7F             
14390   2B7F             ; must be a string array or a slice in workspace.
14391   2B7F             ; Note. LET a$(3 TO 6) = h$   will assign "hat " if h$ = "hat"
14392   2B7F             ;                                  and    "hats" if h$ = "hatstand".
14393   2B7F             ;
14394   2B7F             ; This is known as Procrustean lengthening and shortening after a
14395   2B7F             ; character Procrustes in Greek legend who made travellers sleep in his bed,
14396   2B7F             ; cutting off their feet or stretching them so they fitted the bed perfectly.
14397   2B7F             ; The bloke was hatstand and slain by Theseus.
14398   2B7F             
14399   2B7F 78                  LD      A,B             ; test if length
14400   2B80 B1                  OR      C               ; is zero and
14401   2B81 C8                  RET     Z               ; return if so.
14402   2B82             
14403   2B82 E5                  PUSH    HL              ; save pointer to start.
14404   2B83             
14405   2B83 F7                  RST     30H             ; BC-SPACES creates room.
14406   2B84 D5                  PUSH    DE              ; save pointer to first new location.
14407   2B85 C5                  PUSH    BC              ; and length            (*)
14408   2B86 54                  LD      D,H             ; set DE to point to last location.
14409   2B87 5D                  LD      E,L             ;
14410   2B88 23                  INC     HL              ; set HL to next location.
14411   2B89 36 20               LD      (HL),$20        ; place a space there.
14412   2B8B ED B8               LDDR                    ; copy bytes filling with spaces.
14413   2B8D             
14414   2B8D E5                  PUSH    HL              ; save pointer to start.
14415   2B8E CD F1 2B            CALL    L2BF1           ; routine STK-FETCH start to DE,
14416   2B91                                             ; length to BC.
14417   2B91 E1                  POP     HL              ; restore the pointer.
14418   2B92 E3                  EX      (SP),HL         ; (*) length to HL, pointer to stack.
14419   2B93 A7                  AND     A               ; prepare for true subtraction.
14420   2B94 ED 42               SBC     HL,BC           ; subtract old length from new.
14421   2B96 09                  ADD     HL,BC           ; and add back.
14422   2B97 30 02               JR      NC,L2B9B        ; forward if it fits to L-LENGTH.
14423   2B99             
14424   2B99 44                  LD      B,H             ; otherwise set
14425   2B9A 4D                  LD      C,L             ; length to old length.
14426   2B9B                                             ; "hatstand" becomes "hats"
14427   2B9B             
14428   2B9B             ;; L-LENGTH
14429   2B9B E3          L2B9B:   EX      (SP),HL         ; (*) length to stack, pointer to HL.
14430   2B9C EB                  EX      DE,HL           ; pointer to DE, start of string to HL.
14431   2B9D 78                  LD      A,B             ; is the length zero ?
14432   2B9E B1                  OR      C               ;
14433   2B9F 28 02               JR      Z,L2BA3         ; forward to L-IN-W/S if so
14434   2BA1                                             ; leaving prepared spaces.
14435   2BA1             
14436   2BA1 ED B0               LDIR                    ; else copy bytes overwriting some spaces.
14437   2BA3             
14438   2BA3             ;; L-IN-W/S
14439   2BA3 C1          L2BA3:   POP     BC              ; pop the new length.  (*)
14440   2BA4 D1                  POP     DE              ; pop pointer to new area.
14441   2BA5 E1                  POP     HL              ; pop pointer to variable in assignment.
14442   2BA6                                             ; and continue copying from workspace
14443   2BA6                                             ; to variables area.
14444   2BA6             
14445   2BA6             ; ==> branch here from  L-NUMERIC
14446   2BA6             
14447   2BA6             ;; L-ENTER
14448   2BA6 EB          L2BA6:   EX      DE,HL           ; exchange pointers HL=STKEND DE=end of vars.
14449   2BA7 78                  LD      A,B             ; test the length
14450   2BA8 B1                  OR      C               ; and make a 
14451   2BA9 C8                  RET     Z               ; return if zero (strings only).
14452   2BAA             
14453   2BAA D5                  PUSH    DE              ; save start of destination.
14454   2BAB ED B0               LDIR                    ; copy bytes.
14455   2BAD E1                  POP     HL              ; address the start.
14456   2BAE C9                  RET                     ; and return.
14457   2BAF             
14458   2BAF             ; ---
14459   2BAF             
14460   2BAF             ; the branch was here from L-DELETE$ if an existing simple string.
14461   2BAF             ; register HL addresses start of string in variables area.
14462   2BAF             
14463   2BAF             ;; L-ADD$
14464   2BAF 2B          L2BAF:   DEC     HL              ; point to high byte of length.
14465   2BB0 2B                  DEC     HL              ; to low byte.
14466   2BB1 2B                  DEC     HL              ; to letter.
14467   2BB2 7E                  LD      A,(HL)          ; fetch masked letter to A.
14468   2BB3 E5                  PUSH    HL              ; save the pointer on stack.
14469   2BB4 C5                  PUSH    BC              ; save new length.
14470   2BB5 CD C6 2B            CALL    L2BC6           ; routine L-STRING adds new string at end
14471   2BB8                                             ; of variables area.
14472   2BB8                                             ; if no room we still have old one.
14473   2BB8 C1                  POP     BC              ; restore length.
14474   2BB9 E1                  POP     HL              ; restore start.
14475   2BBA 03                  INC     BC              ; increase
14476   2BBB 03                  INC     BC              ; length by three
14477   2BBC 03                  INC     BC              ; to include character and length bytes.
14478   2BBD C3 E8 19            JP      L19E8           ; jump to indirect exit via RECLAIM-2
14479   2BC0                                             ; deleting old version and adjusting pointers.
14480   2BC0             
14481   2BC0             ; ---
14482   2BC0             
14483   2BC0             ; the jump was here with a new string variable.
14484   2BC0             
14485   2BC0             ;; L-NEW$
14486   2BC0 3E DF       L2BC0:   LD      A,$DF           ; indicator mask %11011111 for
14487   2BC2                                             ;                %010xxxxx will be result
14488   2BC2 2A 4D 5C            LD      HL,($5C4D)      ; address DEST first character.
14489   2BC5 A6                  AND     (HL)            ; combine mask with character.
14490   2BC6             
14491   2BC6             ;; L-STRING
14492   2BC6 F5          L2BC6:   PUSH    AF              ; save first character and mask.
14493   2BC7 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH fetches parameters of
14494   2BCA                                             ; the string.
14495   2BCA EB                  EX      DE,HL           ; transfer start to HL.
14496   2BCB 09                  ADD     HL,BC           ; add to length.
14497   2BCC C5                  PUSH    BC              ; save the length.
14498   2BCD 2B                  DEC     HL              ; point to end of string.
14499   2BCE 22 4D 5C            LD      ($5C4D),HL      ; save pointer in DEST.
14500   2BD1                                             ; (updated by POINTERS if in workspace)
14501   2BD1 03                  INC     BC              ; extra byte for letter.
14502   2BD2 03                  INC     BC              ; two bytes
14503   2BD3 03                  INC     BC              ; for the length of string.
14504   2BD4 2A 59 5C            LD      HL,($5C59)      ; address E_LINE.
14505   2BD7 2B                  DEC     HL              ; now end of VARS area.
14506   2BD8 CD 55 16            CALL    L1655           ; routine MAKE-ROOM makes room for string.
14507   2BDB                                             ; updating pointers including DEST.
14508   2BDB 2A 4D 5C            LD      HL,($5C4D)      ; pick up pointer to end of string from DEST.
14509   2BDE C1                  POP     BC              ; restore length from stack.
14510   2BDF C5                  PUSH    BC              ; and save again on stack.
14511   2BE0 03                  INC     BC              ; add a byte.
14512   2BE1 ED B8               LDDR                    ; copy bytes from end to start.
14513   2BE3 EB                  EX      DE,HL           ; HL addresses length low
14514   2BE4 23                  INC     HL              ; increase to address high byte
14515   2BE5 C1                  POP     BC              ; restore length to BC
14516   2BE6 70                  LD      (HL),B          ; insert high byte
14517   2BE7 2B                  DEC     HL              ; address low byte location
14518   2BE8 71                  LD      (HL),C          ; insert that byte
14519   2BE9 F1                  POP     AF              ; restore character and mask
14520   2BEA             
14521   2BEA             ;; L-FIRST
14522   2BEA 2B          L2BEA:   DEC     HL              ; address variable name
14523   2BEB 77                  LD      (HL),A          ; and insert character.
14524   2BEC 2A 59 5C            LD      HL,($5C59)      ; load HL with E_LINE.
14525   2BEF 2B                  DEC     HL              ; now end of VARS area.
14526   2BF0 C9                  RET                     ; return
14527   2BF1             
14528   2BF1             ; ------------------------------------
14529   2BF1             ; Get last value from calculator stack
14530   2BF1             ; ------------------------------------
14531   2BF1             ;
14532   2BF1             ;
14533   2BF1             
14534   2BF1             ;; STK-FETCH
14535   2BF1 2A 65 5C    L2BF1:   LD      HL,($5C65)      ; STKEND
14536   2BF4 2B                  DEC     HL              ;
14537   2BF5 46                  LD      B,(HL)          ;
14538   2BF6 2B                  DEC     HL              ;
14539   2BF7 4E                  LD      C,(HL)          ;
14540   2BF8 2B                  DEC     HL              ;
14541   2BF9 56                  LD      D,(HL)          ;
14542   2BFA 2B                  DEC     HL              ;
14543   2BFB 5E                  LD      E,(HL)          ;
14544   2BFC 2B                  DEC     HL              ;
14545   2BFD 7E                  LD      A,(HL)          ;
14546   2BFE 22 65 5C            LD      ($5C65),HL      ; STKEND
14547   2C01 C9                  RET                     ;
14548   2C02             
14549   2C02             ; ------------------
14550   2C02             ; Handle DIM command
14551   2C02             ; ------------------
14552   2C02             ; e.g. DIM a(2,3,4,7): DIM a$(32) : DIM b$(20,2,768) : DIM c$(20000)
14553   2C02             ; the only limit to dimensions is memory so, for example,
14554   2C02             ; DIM a(2,2,2,2,2,2,2,2,2,2,2,2,2) is possible and creates a multi-
14555   2C02             ; dimensional array of zeros. String arrays are initialized to spaces.
14556   2C02             ; It is not possible to erase an array, but it can be re-dimensioned to
14557   2C02             ; a minimal size of 1, after use, to free up memory.
14558   2C02             
14559   2C02             ;; DIM
14560   2C02 CD B2 28    L2C02:   CALL    L28B2           ; routine LOOK-VARS
14561   2C05             
14562   2C05             ;; D-RPORT-C
14563   2C05 C2 8A 1C    L2C05:   JP      NZ,L1C8A        ; jump to REPORT-C if a long-name variable.
14564   2C08                                             ; DIM lottery numbers(49) doesn't work.
14565   2C08             
14566   2C08 CD 30 25            CALL    L2530           ; routine SYNTAX-Z
14567   2C0B 20 08               JR      NZ,L2C15        ; forward to D-RUN in runtime.
14568   2C0D             
14569   2C0D CB B1               RES     6,C             ; signal 'numeric' array even if string as
14570   2C0F                                             ; this simplifies the syntax checking.
14571   2C0F             
14572   2C0F CD 96 29            CALL    L2996           ; routine STK-VAR checks syntax.
14573   2C12 CD EE 1B            CALL    L1BEE           ; routine CHECK-END performs early exit ->
14574   2C15             
14575   2C15             ; the branch was here in runtime.
14576   2C15             
14577   2C15             ;; D-RUN
14578   2C15 38 08       L2C15:   JR      C,L2C1F         ; skip to D-LETTER if variable did not exist.
14579   2C17                                             ; else reclaim the old one.
14580   2C17             
14581   2C17 C5                  PUSH    BC              ; save type in C.
14582   2C18 CD B8 19            CALL    L19B8           ; routine NEXT-ONE find following variable
14583   2C1B                                             ; or position of $80 end-marker.
14584   2C1B CD E8 19            CALL    L19E8           ; routine RECLAIM-2 reclaims the 
14585   2C1E                                             ; space between.
14586   2C1E C1                  POP     BC              ; pop the type.
14587   2C1F             
14588   2C1F             ;; D-LETTER
14589   2C1F CB F9       L2C1F:   SET     7,C             ; signal array.
14590   2C21 06 00               LD      B,$00           ; initialize dimensions to zero and
14591   2C23 C5                  PUSH    BC              ; save with the type.
14592   2C24 21 01 00            LD      HL,$0001        ; make elements one character presuming string
14593   2C27 CB 71               BIT     6,C             ; is it a string ?
14594   2C29 20 02               JR      NZ,L2C2D        ; forward to D-SIZE if so.
14595   2C2B             
14596   2C2B 2E 05               LD      L,$05           ; make elements 5 bytes as is numeric.
14597   2C2D             
14598   2C2D             ;; D-SIZE
14599   2C2D EB          L2C2D:   EX      DE,HL           ; save the element size in DE.
14600   2C2E             
14601   2C2E             ; now enter a loop to parse each of the integers in the list.
14602   2C2E             
14603   2C2E             ;; D-NO-LOOP
14604   2C2E E7          L2C2E:   RST     20H             ; NEXT-CHAR
14605   2C2F 26 FF               LD      H,$FF           ; disable limit check by setting HL high
14606   2C31 CD CC 2A            CALL    L2ACC           ; routine INT-EXP1
14607   2C34 DA 20 2A            JP      C,L2A20         ; to REPORT-3 if > 65280 and then some
14608   2C37                                             ; 'Subscript out of range'
14609   2C37             
14610   2C37 E1                  POP     HL              ; pop dimension counter, array type
14611   2C38 C5                  PUSH    BC              ; save dimension size                     ***
14612   2C39 24                  INC     H               ; increment the dimension counter
14613   2C3A E5                  PUSH    HL              ; save the dimension counter
14614   2C3B 60                  LD      H,B             ; transfer size
14615   2C3C 69                  LD      L,C             ; to HL
14616   2C3D CD F4 2A            CALL    L2AF4           ; routine GET-HL*DE multiplies dimension by
14617   2C40                                             ; running total of size required initially
14618   2C40                                             ; 1 or 5.
14619   2C40 EB                  EX      DE,HL           ; save running total in DE
14620   2C41             
14621   2C41 DF                  RST     18H             ; GET-CHAR
14622   2C42 FE 2C               CP      $2C             ; is it ',' ?
14623   2C44 28 E8               JR      Z,L2C2E         ; loop back to D-NO-LOOP until all dimensions
14624   2C46                                             ; have been considered
14625   2C46             
14626   2C46             ; when loop complete continue.
14627   2C46             
14628   2C46 FE 29               CP      $29             ; is it ')' ?
14629   2C48 20 BB               JR      NZ,L2C05        ; to D-RPORT-C with anything else
14630   2C4A                                             ; 'Nonsense in BASIC'
14631   2C4A             
14632   2C4A             
14633   2C4A E7                  RST     20H             ; NEXT-CHAR advances to next statement/CR
14634   2C4B             
14635   2C4B C1                  POP     BC              ; pop dimension counter/type
14636   2C4C 79                  LD      A,C             ; type to A
14637   2C4D             
14638   2C4D             ; now calculate space required for array variable
14639   2C4D             
14640   2C4D 68                  LD      L,B             ; dimensions to L since these require 16 bits
14641   2C4E                                             ; then this value will be doubled
14642   2C4E 26 00               LD      H,$00           ; set high byte to zero
14643   2C50             
14644   2C50             ; another four bytes are required for letter(1), total length(2), number of
14645   2C50             ; dimensions(1) but since we have yet to double allow for two
14646   2C50             
14647   2C50 23                  INC     HL              ; increment
14648   2C51 23                  INC     HL              ; increment
14649   2C52             
14650   2C52 29                  ADD     HL,HL           ; now double giving 4 + dimensions * 2
14651   2C53             
14652   2C53 19                  ADD     HL,DE           ; add to space required for array contents
14653   2C54             
14654   2C54 DA 15 1F            JP      C,L1F15         ; to REPORT-4 if > 65535
14655   2C57                                             ; 'Out of memory'
14656   2C57             
14657   2C57 D5                  PUSH    DE              ; save data space
14658   2C58 C5                  PUSH    BC              ; save dimensions/type
14659   2C59 E5                  PUSH    HL              ; save total space
14660   2C5A 44                  LD      B,H             ; total space
14661   2C5B 4D                  LD      C,L             ; to BC
14662   2C5C 2A 59 5C            LD      HL,($5C59)      ; address E_LINE - first location after
14663   2C5F                                             ; variables area
14664   2C5F 2B                  DEC     HL              ; point to location before - the $80 end-marker
14665   2C60 CD 55 16            CALL    L1655           ; routine MAKE-ROOM creates the space if
14666   2C63                                             ; memory is available.
14667   2C63             
14668   2C63 23                  INC     HL              ; point to first new location and
14669   2C64 77                  LD      (HL),A          ; store letter/type
14670   2C65             
14671   2C65 C1                  POP     BC              ; pop total space
14672   2C66 0B                  DEC     BC              ; exclude name
14673   2C67 0B                  DEC     BC              ; exclude the 16-bit
14674   2C68 0B                  DEC     BC              ; counter itself
14675   2C69 23                  INC     HL              ; point to next location the 16-bit counter
14676   2C6A 71                  LD      (HL),C          ; insert low byte
14677   2C6B 23                  INC     HL              ; address next
14678   2C6C 70                  LD      (HL),B          ; insert high byte
14679   2C6D             
14680   2C6D C1                  POP     BC              ; pop the number of dimensions.
14681   2C6E 78                  LD      A,B             ; dimensions to A
14682   2C6F 23                  INC     HL              ; address next
14683   2C70 77                  LD      (HL),A          ; and insert "No. of dims"
14684   2C71             
14685   2C71 62                  LD      H,D             ; transfer DE space + 1 from make-room
14686   2C72 6B                  LD      L,E             ; to HL
14687   2C73 1B                  DEC     DE              ; set DE to next location down.
14688   2C74 36 00               LD      (HL),$00        ; presume numeric and insert a zero
14689   2C76 CB 71               BIT     6,C             ; test bit 6 of C. numeric or string ?
14690   2C78 28 02               JR      Z,L2C7C         ; skip to DIM-CLEAR if numeric
14691   2C7A             
14692   2C7A 36 20               LD      (HL),$20        ; place a space character in HL
14693   2C7C             
14694   2C7C             ;; DIM-CLEAR
14695   2C7C C1          L2C7C:   POP     BC              ; pop the data length
14696   2C7D             
14697   2C7D ED B8               LDDR                    ; LDDR sets to zeros or spaces
14698   2C7F             
14699   2C7F             ; The number of dimensions is still in A.
14700   2C7F             ; A loop is now entered to insert the size of each dimension that was pushed
14701   2C7F             ; during the D-NO-LOOP working downwards from position before start of data.
14702   2C7F             
14703   2C7F             ;; DIM-SIZES
14704   2C7F C1          L2C7F:   POP     BC              ; pop a dimension size                    ***
14705   2C80 70                  LD      (HL),B          ; insert high byte at position
14706   2C81 2B                  DEC     HL              ; next location down
14707   2C82 71                  LD      (HL),C          ; insert low byte
14708   2C83 2B                  DEC     HL              ; next location down
14709   2C84 3D                  DEC     A               ; decrement dimension counter
14710   2C85 20 F8               JR      NZ,L2C7F        ; back to DIM-SIZES until all done.
14711   2C87             
14712   2C87 C9                  RET                     ; return.
14713   2C88             
14714   2C88             ; -----------------------------
14715   2C88             ; Check whether digit or letter
14716   2C88             ; -----------------------------
14717   2C88             ; This routine checks that the character in A is alphanumeric
14718   2C88             ; returning with carry set if so.
14719   2C88             
14720   2C88             ;; ALPHANUM
14721   2C88 CD 1B 2D    L2C88:   CALL    L2D1B           ; routine NUMERIC will reset carry if so.
14722   2C8B 3F                  CCF                     ; Complement Carry Flag
14723   2C8C D8                  RET     C               ; Return if numeric else continue into
14724   2C8D                                             ; next routine.
14725   2C8D             
14726   2C8D             ; This routine checks that the character in A is alphabetic
14727   2C8D             
14728   2C8D             ;; ALPHA
14729   2C8D FE 41       L2C8D:   CP      $41             ; less than 'A' ?
14730   2C8F 3F                  CCF                     ; Complement Carry Flag
14731   2C90 D0                  RET     NC              ; return if so
14732   2C91             
14733   2C91 FE 5B               CP      $5B             ; less than 'Z'+1 ?
14734   2C93 D8                  RET     C               ; is within first range
14735   2C94             
14736   2C94 FE 61               CP      $61             ; less than 'a' ?
14737   2C96 3F                  CCF                     ; Complement Carry Flag
14738   2C97 D0                  RET     NC              ; return if so.
14739   2C98             
14740   2C98 FE 7B               CP      $7B             ; less than 'z'+1 ?
14741   2C9A C9                  RET                     ; carry set if within a-z.
14742   2C9B             
14743   2C9B             ; -------------------------
14744   2C9B             ; Decimal to floating point
14745   2C9B             ; -------------------------
14746   2C9B             ; This routine finds the floating point number represented by an expression
14747   2C9B             ; beginning with BIN, '.' or a digit.
14748   2C9B             ; Note that BIN need not have any '0's or '1's after it.
14749   2C9B             ; BIN is really just a notational symbol and not a function.
14750   2C9B             
14751   2C9B             ;; DEC-TO-FP
14752   2C9B FE C4       L2C9B:   CP      $C4             ; 'BIN' token ?
14753   2C9D 20 19               JR      NZ,L2CB8        ; to NOT-BIN if not
14754   2C9F             
14755   2C9F 11 00 00            LD      DE,$0000        ; initialize 16 bit buffer register.
14756   2CA2             
14757   2CA2             ;; BIN-DIGIT
14758   2CA2 E7          L2CA2:   RST     20H             ; NEXT-CHAR
14759   2CA3 D6 31               SUB     $31             ; '1'
14760   2CA5 CE 00               ADC     A,$00           ; will be zero if '1' or '0'
14761   2CA7                                             ; carry will be set if was '0'
14762   2CA7 20 0A               JR      NZ,L2CB3        ; forward to BIN-END if result not zero
14763   2CA9             
14764   2CA9 EB                  EX      DE,HL           ; buffer to HL
14765   2CAA 3F                  CCF                     ; Carry now set if originally '1'
14766   2CAB ED 6A               ADC     HL,HL           ; shift the carry into HL
14767   2CAD DA AD 31            JP      C,L31AD         ; to REPORT-6 if overflow - too many digits
14768   2CB0                                             ; after first '1'. There can be an unlimited
14769   2CB0                                             ; number of leading zeros.
14770   2CB0                                             ; 'Number too big' - raise an error
14771   2CB0             
14772   2CB0 EB                  EX      DE,HL           ; save the buffer
14773   2CB1 18 EF               JR      L2CA2           ; back to BIN-DIGIT for more digits
14774   2CB3             
14775   2CB3             ; ---
14776   2CB3             
14777   2CB3             ;; BIN-END
14778   2CB3 42          L2CB3:   LD      B,D             ; transfer 16 bit buffer
14779   2CB4 4B                  LD      C,E             ; to BC register pair.
14780   2CB5 C3 2B 2D            JP      L2D2B           ; JUMP to STACK-BC to put on calculator stack
14781   2CB8             
14782   2CB8             ; ---
14783   2CB8             
14784   2CB8             ; continue here with .1,  42, 3.14, 5., 2.3 E -4
14785   2CB8             
14786   2CB8             ;; NOT-BIN
14787   2CB8 FE 2E       L2CB8:   CP      $2E             ; '.' - leading decimal point ?
14788   2CBA 28 0F               JR      Z,L2CCB         ; skip to DECIMAL if so.
14789   2CBC             
14790   2CBC CD 3B 2D            CALL    L2D3B           ; routine INT-TO-FP to evaluate all digits
14791   2CBF                                             ; This number 'x' is placed on stack.
14792   2CBF FE 2E               CP      $2E             ; '.' - mid decimal point ?
14793   2CC1             
14794   2CC1 20 28               JR      NZ,L2CEB        ; to E-FORMAT if not to consider that format
14795   2CC3             
14796   2CC3 E7                  RST     20H             ; NEXT-CHAR
14797   2CC4 CD 1B 2D            CALL    L2D1B           ; routine NUMERIC returns carry reset if 0-9
14798   2CC7             
14799   2CC7 38 22               JR      C,L2CEB         ; to E-FORMAT if not a digit e.g. '1.'
14800   2CC9             
14801   2CC9 18 0A               JR      L2CD5           ; to DEC-STO-1 to add the decimal part to 'x'
14802   2CCB             
14803   2CCB             ; ---
14804   2CCB             
14805   2CCB             ; a leading decimal point has been found in a number.
14806   2CCB             
14807   2CCB             ;; DECIMAL
14808   2CCB E7          L2CCB:   RST     20H             ; NEXT-CHAR
14809   2CCC CD 1B 2D            CALL    L2D1B           ; routine NUMERIC will reset carry if digit
14810   2CCF             
14811   2CCF             ;; DEC-RPT-C
14812   2CCF DA 8A 1C    L2CCF:   JP      C,L1C8A         ; to REPORT-C if just a '.'
14813   2CD2                                             ; raise 'Nonsense in BASIC'
14814   2CD2             
14815   2CD2             ; since there is no leading zero put one on the calculator stack.
14816   2CD2             
14817   2CD2 EF                  RST     28H             ;; FP-CALC
14818   2CD3 A0                  DEFB    $A0             ;;stk-zero  ; 0.
14819   2CD4 38                  DEFB    $38             ;;end-calc
14820   2CD5             
14821   2CD5             ; If rejoining from earlier there will be a value 'x' on stack.
14822   2CD5             ; If continuing from above the value zero.
14823   2CD5             ; Now store 1 in mem-0.
14824   2CD5             ; Note. At each pass of the digit loop this will be divided by ten.
14825   2CD5             
14826   2CD5             ;; DEC-STO-1
14827   2CD5 EF          L2CD5:   RST     28H             ;; FP-CALC
14828   2CD6 A1                  DEFB    $A1             ;;stk-one   ;x or 0,1.
14829   2CD7 C0                  DEFB    $C0             ;;st-mem-0  ;x or 0,1.
14830   2CD8 02                  DEFB    $02             ;;delete    ;x or 0.
14831   2CD9 38                  DEFB    $38             ;;end-calc
14832   2CDA             
14833   2CDA             
14834   2CDA             ;; NXT-DGT-1
14835   2CDA DF          L2CDA:   RST     18H             ; GET-CHAR
14836   2CDB CD 22 2D            CALL    L2D22           ; routine STK-DIGIT stacks single digit 'd'
14837   2CDE 38 0B               JR      C,L2CEB         ; exit to E-FORMAT when digits exhausted  >
14838   2CE0             
14839   2CE0             
14840   2CE0 EF                  RST     28H             ;; FP-CALC   ;x or 0,d.           first pass.
14841   2CE1 E0                  DEFB    $E0             ;;get-mem-0  ;x or 0,d,1.
14842   2CE2 A4                  DEFB    $A4             ;;stk-ten    ;x or 0,d,1,10.
14843   2CE3 05                  DEFB    $05             ;;division   ;x or 0,d,1/10.
14844   2CE4 C0                  DEFB    $C0             ;;st-mem-0   ;x or 0,d,1/10.
14845   2CE5 04                  DEFB    $04             ;;multiply   ;x or 0,d/10.
14846   2CE6 0F                  DEFB    $0F             ;;addition   ;x or 0 + d/10.
14847   2CE7 38                  DEFB    $38             ;;end-calc   last value.
14848   2CE8             
14849   2CE8 E7                  RST     20H             ; NEXT-CHAR  moves to next character
14850   2CE9 18 EF               JR      L2CDA           ; back to NXT-DGT-1
14851   2CEB             
14852   2CEB             ; ---
14853   2CEB             
14854   2CEB             ; although only the first pass is shown it can be seen that at each pass
14855   2CEB             ; the new less significant digit is multiplied by an increasingly smaller
14856   2CEB             ; factor (1/100, 1/1000, 1/10000 ... ) before being added to the previous
14857   2CEB             ; last value to form a new last value.
14858   2CEB             
14859   2CEB             ; Finally see if an exponent has been input.
14860   2CEB             
14861   2CEB             ;; E-FORMAT
14862   2CEB FE 45       L2CEB:   CP      $45             ; is character 'E' ?
14863   2CED 28 03               JR      Z,L2CF2         ; to SIGN-FLAG if so
14864   2CEF             
14865   2CEF FE 65               CP      $65             ; 'e' is acceptable as well.
14866   2CF1 C0                  RET     NZ              ; return as no exponent.
14867   2CF2             
14868   2CF2             ;; SIGN-FLAG
14869   2CF2 06 FF       L2CF2:   LD      B,$FF           ; initialize temporary sign byte to $FF
14870   2CF4             
14871   2CF4 E7                  RST     20H             ; NEXT-CHAR
14872   2CF5 FE 2B               CP      $2B             ; is character '+' ?
14873   2CF7 28 05               JR      Z,L2CFE         ; to SIGN-DONE
14874   2CF9             
14875   2CF9 FE 2D               CP      $2D             ; is character '-' ?
14876   2CFB 20 02               JR      NZ,L2CFF        ; to ST-E-PART as no sign
14877   2CFD             
14878   2CFD 04                  INC     B               ; set sign to zero
14879   2CFE             
14880   2CFE             ; now consider digits of exponent.
14881   2CFE             ; Note. incidentally this is the only occasion in Spectrum BASIC when an
14882   2CFE             ; expression may not be used when a number is expected.
14883   2CFE             
14884   2CFE             ;; SIGN-DONE
14885   2CFE E7          L2CFE:   RST     20H             ; NEXT-CHAR
14886   2CFF             
14887   2CFF             ;; ST-E-PART
14888   2CFF CD 1B 2D    L2CFF:   CALL    L2D1B           ; routine NUMERIC
14889   2D02 38 CB               JR      C,L2CCF         ; to DEC-RPT-C if not
14890   2D04                                             ; raise 'Nonsense in BASIC'.
14891   2D04             
14892   2D04 C5                  PUSH    BC              ; save sign (in B)
14893   2D05 CD 3B 2D            CALL    L2D3B           ; routine INT-TO-FP places exponent on stack
14894   2D08 CD D5 2D            CALL    L2DD5           ; routine FP-TO-A  transfers it to A
14895   2D0B C1                  POP     BC              ; restore sign
14896   2D0C DA AD 31            JP      C,L31AD         ; to REPORT-6 if overflow (over 255)
14897   2D0F                                             ; raise 'Number too big'.
14898   2D0F             
14899   2D0F A7                  AND     A               ; set flags
14900   2D10 FA AD 31            JP      M,L31AD         ; to REPORT-6 if over '127'.
14901   2D13                                             ; raise 'Number too big'.
14902   2D13                                             ; 127 is still way too high and it is
14903   2D13                                             ; impossible to enter an exponent greater
14904   2D13                                             ; than 39 from the keyboard. The error gets
14905   2D13                                             ; raised later in E-TO-FP so two different
14906   2D13                                             ; error messages depending how high A is.
14907   2D13             
14908   2D13 04                  INC     B               ; $FF to $00 or $00 to $01 - expendable now.
14909   2D14 28 02               JR      Z,L2D18         ; forward to E-FP-JUMP if exponent positive
14910   2D16             
14911   2D16 ED 44               NEG                     ; Negate the exponent.
14912   2D18             
14913   2D18             ;; E-FP-JUMP
14914   2D18 C3 4F 2D    L2D18:   JP      L2D4F           ; JUMP forward to E-TO-FP to assign to
14915   2D1B                                             ; last value x on stack x * 10 to power A
14916   2D1B                                             ; a relative jump would have done.
14917   2D1B             
14918   2D1B             ; ---------------------
14919   2D1B             ; Check for valid digit
14920   2D1B             ; ---------------------
14921   2D1B             ; This routine checks that the ASCII character in A is numeric
14922   2D1B             ; returning with carry reset if so.
14923   2D1B             
14924   2D1B             ;; NUMERIC
14925   2D1B FE 30       L2D1B:   CP      $30             ; '0'
14926   2D1D D8                  RET     C               ; return if less than zero character.
14927   2D1E             
14928   2D1E FE 3A               CP      $3A             ; The upper test is '9'
14929   2D20 3F                  CCF                     ; Complement Carry Flag
14930   2D21 C9                  RET                     ; Return - carry clear if character '0' - '9'
14931   2D22             
14932   2D22             ; -----------
14933   2D22             ; Stack Digit
14934   2D22             ; -----------
14935   2D22             ; This subroutine is called from INT-TO-FP and DEC-TO-FP to stack a digit
14936   2D22             ; on the calculator stack.
14937   2D22             
14938   2D22             ;; STK-DIGIT
14939   2D22 CD 1B 2D    L2D22:   CALL    L2D1B           ; routine NUMERIC
14940   2D25 D8                  RET     C               ; return if not numeric character
14941   2D26             
14942   2D26 D6 30               SUB     $30             ; convert from ASCII to digit
14943   2D28             
14944   2D28             ; -----------------
14945   2D28             ; Stack accumulator
14946   2D28             ; -----------------
14947   2D28             ;
14948   2D28             ;
14949   2D28             
14950   2D28             ;; STACK-A
14951   2D28 4F          L2D28:   LD      C,A             ; transfer to C
14952   2D29 06 00               LD      B,$00           ; and make B zero
14953   2D2B             
14954   2D2B             ; ----------------------
14955   2D2B             ; Stack BC register pair
14956   2D2B             ; ----------------------
14957   2D2B             ;
14958   2D2B             
14959   2D2B             ;; STACK-BC
14960   2D2B FD 21 3A 5C L2D2B:   LD      IY,$5C3A        ; re-initialize ERR_NR
14961   2D2F             
14962   2D2F AF                  XOR     A               ; clear to signal small integer
14963   2D30 5F                  LD      E,A             ; place in E for sign
14964   2D31 51                  LD      D,C             ; LSB to D
14965   2D32 48                  LD      C,B             ; MSB to C
14966   2D33 47                  LD      B,A             ; last byte not used
14967   2D34 CD B6 2A            CALL    L2AB6           ; routine STK-STORE
14968   2D37             
14969   2D37 EF                  RST     28H             ;; FP-CALC
14970   2D38 38                  DEFB    $38             ;;end-calc  make HL = STKEND-5
14971   2D39             
14972   2D39 A7                  AND     A               ; clear carry
14973   2D3A C9                  RET                     ; before returning
14974   2D3B             
14975   2D3B             ; -------------------------
14976   2D3B             ; Integer to floating point
14977   2D3B             ; -------------------------
14978   2D3B             ; This routine places one or more digits found in a BASIC line
14979   2D3B             ; on the calculator stack multiplying the previous value by ten each time
14980   2D3B             ; before adding in the new digit to form a last value on calculator stack.
14981   2D3B             
14982   2D3B             ;; INT-TO-FP
14983   2D3B F5          L2D3B:   PUSH    AF              ; save first character
14984   2D3C             
14985   2D3C EF                  RST     28H             ;; FP-CALC
14986   2D3D A0                  DEFB    $A0             ;;stk-zero    ; v=0. initial value
14987   2D3E 38                  DEFB    $38             ;;end-calc
14988   2D3F             
14989   2D3F F1                  POP     AF              ; fetch first character back.
14990   2D40             
14991   2D40             ;; NXT-DGT-2
14992   2D40 CD 22 2D    L2D40:   CALL    L2D22           ; routine STK-DIGIT puts 0-9 on stack
14993   2D43 D8                  RET     C               ; will return when character is not numeric >
14994   2D44             
14995   2D44 EF                  RST     28H             ;; FP-CALC    ; v, d.
14996   2D45 01                  DEFB    $01             ;;exchange    ; d, v.
14997   2D46 A4                  DEFB    $A4             ;;stk-ten     ; d, v, 10.
14998   2D47 04                  DEFB    $04             ;;multiply    ; d, v*10.
14999   2D48 0F                  DEFB    $0F             ;;addition    ; d + v*10 = newvalue
15000   2D49 38                  DEFB    $38             ;;end-calc    ; v.
15001   2D4A             
15002   2D4A CD 74 00            CALL    L0074           ; routine CH-ADD+1 get next character
15003   2D4D 18 F1               JR      L2D40           ; back to NXT-DGT-2 to process as a digit
15004   2D4F             
15005   2D4F             
15006   2D4F             ;*********************************
15007   2D4F             ;** Part 9. ARITHMETIC ROUTINES **
15008   2D4F             ;*********************************
15009   2D4F             
15010   2D4F             ; --------------------------
15011   2D4F             ; E-format to floating point
15012   2D4F             ; --------------------------
15013   2D4F             ; This subroutine is used by the PRINT-FP routine and the decimal to FP
15014   2D4F             ; routines to stack a number expressed in exponent format.
15015   2D4F             ; Note. Though not used by the ROM as such, it has also been set up as
15016   2D4F             ; a unary calculator literal but this will not work as the accumulator
15017   2D4F             ; is not available from within the calculator.
15018   2D4F             
15019   2D4F             ; on entry there is a value x on the calculator stack and an exponent of ten
15020   2D4F             ; in A.    The required value is x + 10 ^ A
15021   2D4F             
15022   2D4F             ;; e-to-fp
15023   2D4F             ;; E-TO-FP
15024   2D4F 07          L2D4F:   RLCA                    ; this will set the          x.
15025   2D50 0F                  RRCA                    ; carry if bit 7 is set
15026   2D51             
15027   2D51 30 02               JR      NC,L2D55        ; to E-SAVE  if positive.
15028   2D53             
15029   2D53 2F                  CPL                     ; make negative positive
15030   2D54 3C                  INC     A               ; without altering carry.
15031   2D55             
15032   2D55             ;; E-SAVE
15033   2D55 F5          L2D55:   PUSH    AF              ; save positive exp and sign in carry
15034   2D56             
15035   2D56 21 92 5C            LD      HL,$5C92        ; address MEM-0
15036   2D59             
15037   2D59 CD 0B 35            CALL    L350B           ; routine FP-0/1
15038   2D5C                                             ; places an integer zero, if no carry,
15039   2D5C                                             ; else a one in mem-0 as a sign flag
15040   2D5C             
15041   2D5C EF                  RST     28H             ;; FP-CALC
15042   2D5D A4                  DEFB    $A4             ;;stk-ten                    x, 10.
15043   2D5E 38                  DEFB    $38             ;;end-calc
15044   2D5F             
15045   2D5F F1                  POP     AF              ; pop the exponent.
15046   2D60             
15047   2D60             ; now enter a loop
15048   2D60             
15049   2D60             ;; E-LOOP
15050   2D60 CB 3F       L2D60:   SRL     A               ; 0>76543210>C
15051   2D62             
15052   2D62 30 0D               JR      NC,L2D71        ; forward to E-TST-END if no bit
15053   2D64             
15054   2D64 F5                  PUSH    AF              ; save shifted exponent.
15055   2D65             
15056   2D65 EF                  RST     28H             ;; FP-CALC
15057   2D66 C1                  DEFB    $C1             ;;st-mem-1                   x, 10.
15058   2D67 E0                  DEFB    $E0             ;;get-mem-0                  x, 10, (0/1).
15059   2D68 00                  DEFB    $00             ;;jump-true
15060   2D69             
15061   2D69 04                  DEFB    $04             ;;to L2D6D, E-DIVSN
15062   2D6A             
15063   2D6A 04                  DEFB    $04             ;;multiply                   x*10.
15064   2D6B 33                  DEFB    $33             ;;jump
15065   2D6C             
15066   2D6C 02                  DEFB    $02             ;;to L2D6E, E-FETCH
15067   2D6D             
15068   2D6D             ;; E-DIVSN
15069   2D6D 05          L2D6D:   DEFB    $05             ;;division                   x/10.
15070   2D6E             
15071   2D6E             ;; E-FETCH
15072   2D6E E1          L2D6E:   DEFB    $E1             ;;get-mem-1                  x/10 or x*10, 10.
15073   2D6F 38                  DEFB    $38             ;;end-calc                   new x, 10.
15074   2D70             
15075   2D70 F1                  POP     AF              ; restore shifted exponent
15076   2D71             
15077   2D71             ; the loop branched to here with no carry
15078   2D71             
15079   2D71             ;; E-TST-END
15080   2D71 28 08       L2D71:   JR      Z,L2D7B         ; forward to E-END  if A emptied of bits
15081   2D73             
15082   2D73 F5                  PUSH    AF              ; re-save shifted exponent
15083   2D74             
15084   2D74 EF                  RST     28H             ;; FP-CALC
15085   2D75 31                  DEFB    $31             ;;duplicate                  new x, 10, 10.
15086   2D76 04                  DEFB    $04             ;;multiply                   new x, 100.
15087   2D77 38                  DEFB    $38             ;;end-calc
15088   2D78             
15089   2D78 F1                  POP     AF              ; restore shifted exponent
15090   2D79 18 E5               JR      L2D60           ; back to E-LOOP  until all bits done.
15091   2D7B             
15092   2D7B             ; ---
15093   2D7B             
15094   2D7B             ; although only the first pass is shown it can be seen that for each set bit
15095   2D7B             ; representing a power of two, x is multiplied or divided by the
15096   2D7B             ; corresponding power of ten.
15097   2D7B             
15098   2D7B             ;; E-END
15099   2D7B EF          L2D7B:   RST     28H             ;; FP-CALC                   final x, factor.
15100   2D7C 02                  DEFB    $02             ;;delete                     final x.
15101   2D7D 38                  DEFB    $38             ;;end-calc                   x.
15102   2D7E             
15103   2D7E C9                  RET                     ; return
15104   2D7F             
15105   2D7F             
15106   2D7F             
15107   2D7F             
15108   2D7F             ; -------------
15109   2D7F             ; Fetch integer
15110   2D7F             ; -------------
15111   2D7F             ; This routine is called by the mathematical routines - FP-TO-BC, PRINT-FP,
15112   2D7F             ; mult, re-stack and negate to fetch an integer from address HL.
15113   2D7F             ; HL points to the stack or a location in MEM and no deletion occurs.
15114   2D7F             ; If the number is negative then a similar process to that used in INT-STORE
15115   2D7F             ; is used to restore the twos complement number to normal in DE and a sign
15116   2D7F             ; in C.
15117   2D7F             
15118   2D7F             ;; INT-FETCH
15119   2D7F 23          L2D7F:   INC     HL              ; skip zero indicator.
15120   2D80 4E                  LD      C,(HL)          ; fetch sign to C
15121   2D81 23                  INC     HL              ; address low byte
15122   2D82 7E                  LD      A,(HL)          ; fetch to A
15123   2D83 A9                  XOR     C               ; two's complement
15124   2D84 91                  SUB     C               ;
15125   2D85 5F                  LD      E,A             ; place in E
15126   2D86 23                  INC     HL              ; address high byte
15127   2D87 7E                  LD      A,(HL)          ; fetch to A
15128   2D88 89                  ADC     A,C             ; two's complement
15129   2D89 A9                  XOR     C               ;
15130   2D8A 57                  LD      D,A             ; place in D
15131   2D8B C9                  RET                     ; return
15132   2D8C             
15133   2D8C             ; ------------------------
15134   2D8C             ; Store a positive integer
15135   2D8C             ; ------------------------
15136   2D8C             ; This entry point is not used in this ROM but would
15137   2D8C             ; store any integer as positive.
15138   2D8C             
15139   2D8C             ;; p-int-sto
15140   2D8C 0E 00       L2D8C:   LD      C,$00           ; make sign byte positive and continue
15141   2D8E             
15142   2D8E             ; -------------
15143   2D8E             ; Store integer
15144   2D8E             ; -------------
15145   2D8E             ; this routine stores an integer in DE at address HL.
15146   2D8E             ; It is called from mult, truncate, negate and sgn.
15147   2D8E             ; The sign byte $00 +ve or $FF -ve is in C.
15148   2D8E             ; If negative, the number is stored in 2's complement form so that it is
15149   2D8E             ; ready to be added.
15150   2D8E             
15151   2D8E             ;; INT-STORE
15152   2D8E E5          L2D8E:   PUSH    HL              ; preserve HL
15153   2D8F             
15154   2D8F 36 00               LD      (HL),$00        ; first byte zero shows integer not exponent
15155   2D91 23                  INC     HL              ;
15156   2D92 71                  LD      (HL),C          ; then store the sign byte
15157   2D93 23                  INC     HL              ;
15158   2D94                                             ; e.g.             +1             -1
15159   2D94 7B                  LD      A,E             ; fetch low byte   00000001       00000001
15160   2D95 A9                  XOR     C               ; xor sign         00000000   or  11111111
15161   2D96                                             ; gives            00000001   or  11111110
15162   2D96 91                  SUB     C               ; sub sign         00000000   or  11111111
15163   2D97                                             ; gives            00000001>0 or  11111111>C
15164   2D97 77                  LD      (HL),A          ; store 2's complement.
15165   2D98 23                  INC     HL              ;
15166   2D99 7A                  LD      A,D             ; high byte        00000000       00000000
15167   2D9A 89                  ADC     A,C             ; sign             00000000<0     11111111<C
15168   2D9B                                             ; gives            00000000   or  00000000
15169   2D9B A9                  XOR     C               ; xor sign         00000000       11111111
15170   2D9C 77                  LD      (HL),A          ; store 2's complement.
15171   2D9D 23                  INC     HL              ;
15172   2D9E 36 00               LD      (HL),$00        ; last byte always zero for integers.
15173   2DA0                                             ; is not used and need not be looked at when
15174   2DA0                                             ; testing for zero but comes into play should
15175   2DA0                                             ; an integer be converted to fp.
15176   2DA0 E1                  POP     HL              ; restore HL
15177   2DA1 C9                  RET                     ; return.
15178   2DA2             
15179   2DA2             
15180   2DA2             ; -----------------------------
15181   2DA2             ; Floating point to BC register
15182   2DA2             ; -----------------------------
15183   2DA2             ; This routine gets a floating point number e.g. 127.4 from the calculator
15184   2DA2             ; stack to the BC register.
15185   2DA2             
15186   2DA2             ;; FP-TO-BC
15187   2DA2 EF          L2DA2:   RST     28H             ;; FP-CALC            set HL to
15188   2DA3 38                  DEFB    $38             ;;end-calc            point to last value.
15189   2DA4             
15190   2DA4 7E                  LD      A,(HL)          ; get first of 5 bytes
15191   2DA5 A7                  AND     A               ; and test
15192   2DA6 28 05               JR      Z,L2DAD         ; forward to FP-DELETE if an integer
15193   2DA8             
15194   2DA8             ; The value is first rounded up and then converted to integer.
15195   2DA8             
15196   2DA8 EF                  RST     28H             ;; FP-CALC           x.
15197   2DA9 A2                  DEFB    $A2             ;;stk-half           x. 1/2.
15198   2DAA 0F                  DEFB    $0F             ;;addition           x + 1/2.
15199   2DAB 27                  DEFB    $27             ;;int                int(x + .5)
15200   2DAC 38                  DEFB    $38             ;;end-calc
15201   2DAD             
15202   2DAD             ; now delete but leave HL pointing at integer
15203   2DAD             
15204   2DAD             ;; FP-DELETE
15205   2DAD EF          L2DAD:   RST     28H             ;; FP-CALC
15206   2DAE 02                  DEFB    $02             ;;delete
15207   2DAF 38                  DEFB    $38             ;;end-calc
15208   2DB0             
15209   2DB0 E5                  PUSH    HL              ; save pointer.
15210   2DB1 D5                  PUSH    DE              ; and STKEND.
15211   2DB2 EB                  EX      DE,HL           ; make HL point to exponent/zero indicator
15212   2DB3 46                  LD      B,(HL)          ; indicator to B
15213   2DB4 CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH
15214   2DB7                                             ; gets int in DE sign byte to C
15215   2DB7                                             ; but meaningless values if a large integer
15216   2DB7             
15217   2DB7 AF                  XOR     A               ; clear A
15218   2DB8 90                  SUB     B               ; subtract indicator byte setting carry
15219   2DB9                                             ; if not a small integer.
15220   2DB9             
15221   2DB9 CB 79               BIT     7,C             ; test a bit of the sign byte setting zero
15222   2DBB                                             ; if positive.
15223   2DBB             
15224   2DBB 42                  LD      B,D             ; transfer int
15225   2DBC 4B                  LD      C,E             ; to BC
15226   2DBD 7B                  LD      A,E             ; low byte to A as a useful return value.
15227   2DBE             
15228   2DBE D1                  POP     DE              ; pop STKEND
15229   2DBF E1                  POP     HL              ; and pointer to last value
15230   2DC0 C9                  RET                     ; return
15231   2DC1                                             ; if carry is set then the number was too big.
15232   2DC1             
15233   2DC1             ; ------------
15234   2DC1             ; LOG(2^A)
15235   2DC1             ; ------------
15236   2DC1             ; This routine is used when printing floating point numbers to calculate
15237   2DC1             ; the number of digits before the decimal point.
15238   2DC1             
15239   2DC1             ; first convert a one-byte signed integer to its five byte form.
15240   2DC1             
15241   2DC1             ;; LOG(2^A)
15242   2DC1 57          L2DC1:   LD      D,A             ; store a copy of A in D.
15243   2DC2 17                  RLA                     ; test sign bit of A.
15244   2DC3 9F                  SBC     A,A             ; now $FF if negative or $00
15245   2DC4 5F                  LD      E,A             ; sign byte to E.
15246   2DC5 4F                  LD      C,A             ; and to C
15247   2DC6 AF                  XOR     A               ; clear A
15248   2DC7 47                  LD      B,A             ; and B.
15249   2DC8 CD B6 2A            CALL    L2AB6           ; routine STK-STORE stacks number AEDCB
15250   2DCB             
15251   2DCB             ;  so 00 00 XX 00 00 (positive) or 00 FF XX FF 00 (negative).
15252   2DCB             ;  i.e. integer indicator, sign byte, low, high, unused.
15253   2DCB             
15254   2DCB             ; now multiply exponent by log to the base 10 of two.
15255   2DCB             
15256   2DCB EF                  RST      28H            ;; FP-CALC
15257   2DCC             
15258   2DCC 34                  DEFB    $34             ;;stk-data                      .30103 (log 2)
15259   2DCD EF                  DEFB    $EF             ;;Exponent: $7F, Bytes: 4
15260   2DCE 1A 20 9A 85         DEFB    $1A,$20,$9A,$85 ;;
15261   2DD2 04                  DEFB    $04             ;;multiply
15262   2DD3             
15263   2DD3 27                  DEFB    $27             ;;int
15264   2DD4             
15265   2DD4 38                  DEFB    $38             ;;end-calc
15266   2DD5             
15267   2DD5             ; -------------------
15268   2DD5             ; Floating point to A
15269   2DD5             ; -------------------
15270   2DD5             ; this routine collects a floating point number from the stack into the
15271   2DD5             ; accumulator returning carry set if not in range 0 - 255.
15272   2DD5             ; Not all the calling routines raise an error with overflow so no attempt
15273   2DD5             ; is made to produce an error report here.
15274   2DD5             
15275   2DD5             ;; FP-TO-A
15276   2DD5 CD A2 2D    L2DD5:   CALL    L2DA2           ; routine FP-TO-BC returns with C in A also.
15277   2DD8 D8                  RET     C               ; return with carry set if > 65535, overflow
15278   2DD9             
15279   2DD9 F5                  PUSH    AF              ; save the value and flags
15280   2DDA 05                  DEC     B               ; and test that
15281   2DDB 04                  INC     B               ; the high byte is zero.
15282   2DDC 28 03               JR      Z,L2DE1         ; forward  FP-A-END if zero
15283   2DDE             
15284   2DDE             ; else there has been 8-bit overflow
15285   2DDE             
15286   2DDE F1                  POP     AF              ; retrieve the value
15287   2DDF 37                  SCF                     ; set carry flag to show overflow
15288   2DE0 C9                  RET                     ; and return.
15289   2DE1             
15290   2DE1             ; ---
15291   2DE1             
15292   2DE1             ;; FP-A-END
15293   2DE1 F1          L2DE1:   POP     AF              ; restore value and success flag and
15294   2DE2 C9                  RET                     ; return.
15295   2DE3             
15296   2DE3             
15297   2DE3             ; -----------------------------
15298   2DE3             ; Print a floating point number
15299   2DE3             ; -----------------------------
15300   2DE3             ; Not a trivial task.
15301   2DE3             ; Begin by considering whether to print a leading sign for negative numbers.
15302   2DE3             
15303   2DE3             ;; PRINT-FP
15304   2DE3 EF          L2DE3:   RST     28H             ;; FP-CALC
15305   2DE4 31                  DEFB    $31             ;;duplicate
15306   2DE5 36                  DEFB    $36             ;;less-0
15307   2DE6 00                  DEFB    $00             ;;jump-true
15308   2DE7             
15309   2DE7 0B                  DEFB    $0B             ;;to L2DF2, PF-NEGTVE
15310   2DE8             
15311   2DE8 31                  DEFB    $31             ;;duplicate
15312   2DE9 37                  DEFB    $37             ;;greater-0
15313   2DEA 00                  DEFB    $00             ;;jump-true
15314   2DEB             
15315   2DEB 0D                  DEFB    $0D             ;;to L2DF8, PF-POSTVE
15316   2DEC             
15317   2DEC             ; must be zero itself
15318   2DEC             
15319   2DEC 02                  DEFB    $02             ;;delete
15320   2DED 38                  DEFB    $38             ;;end-calc
15321   2DEE             
15322   2DEE 3E 30               LD      A,$30           ; prepare the character '0'
15323   2DF0             
15324   2DF0 D7                  RST     10H             ; PRINT-A
15325   2DF1 C9                  RET                     ; return.                 ->
15326   2DF2             ; ---
15327   2DF2             
15328   2DF2             ;; PF-NEGTVE
15329   2DF2 2A          L2DF2:   DEFB    $2A             ;;abs
15330   2DF3 38                  DEFB    $38             ;;end-calc
15331   2DF4             
15332   2DF4 3E 2D               LD      A,$2D           ; the character '-'
15333   2DF6             
15334   2DF6 D7                  RST     10H             ; PRINT-A
15335   2DF7             
15336   2DF7             ; and continue to print the now positive number.
15337   2DF7             
15338   2DF7 EF                  RST     28H             ;; FP-CALC
15339   2DF8             
15340   2DF8             ;; PF-POSTVE
15341   2DF8 A0          L2DF8:   DEFB    $A0             ;;stk-zero     x,0.     begin by
15342   2DF9 C3                  DEFB    $C3             ;;st-mem-3     x,0.     clearing a temporary
15343   2DFA C4                  DEFB    $C4             ;;st-mem-4     x,0.     output buffer to
15344   2DFB C5                  DEFB    $C5             ;;st-mem-5     x,0.     fifteen zeros.
15345   2DFC 02                  DEFB    $02             ;;delete       x.
15346   2DFD 38                  DEFB    $38             ;;end-calc     x.
15347   2DFE             
15348   2DFE D9                  EXX                     ; in case called from 'str$' then save the
15349   2DFF E5                  PUSH    HL              ; pointer to whatever comes after
15350   2E00 D9                  EXX                     ; str$ as H'L' will be used.
15351   2E01             
15352   2E01             ; now enter a loop?
15353   2E01             
15354   2E01             ;; PF-LOOP
15355   2E01 EF          L2E01:   RST     28H             ;; FP-CALC
15356   2E02 31                  DEFB    $31             ;;duplicate    x,x.
15357   2E03 27                  DEFB    $27             ;;int          x,int x.
15358   2E04 C2                  DEFB    $C2             ;;st-mem-2     x,int x.
15359   2E05 03                  DEFB    $03             ;;subtract     x-int x.     fractional part.
15360   2E06 E2                  DEFB    $E2             ;;get-mem-2    x-int x, int x.
15361   2E07 01                  DEFB    $01             ;;exchange     int x, x-int x.
15362   2E08 C2                  DEFB    $C2             ;;st-mem-2     int x, x-int x.
15363   2E09 02                  DEFB    $02             ;;delete       int x.
15364   2E0A 38                  DEFB    $38             ;;end-calc     int x.
15365   2E0B                                             ;
15366   2E0B                                             ; mem-2 holds the fractional part.
15367   2E0B             
15368   2E0B             ; HL points to last value int x
15369   2E0B             
15370   2E0B 7E                  LD      A,(HL)          ; fetch exponent of int x.
15371   2E0C A7                  AND     A               ; test
15372   2E0D 20 47               JR      NZ,L2E56        ; forward to PF-LARGE if a large integer
15373   2E0F                                             ; > 65535
15374   2E0F             
15375   2E0F             ; continue with small positive integer components in range 0 - 65535 
15376   2E0F             ; if original number was say .999 then this integer component is zero. 
15377   2E0F             
15378   2E0F CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH gets x in DE
15379   2E12                                             ; (but x is not deleted)
15380   2E12             
15381   2E12 06 10               LD      B,$10           ; set B, bit counter, to 16d
15382   2E14             
15383   2E14 7A                  LD      A,D             ; test if
15384   2E15 A7                  AND     A               ; high byte is zero
15385   2E16 20 06               JR      NZ,L2E1E        ; forward to PF-SAVE if 16-bit integer.
15386   2E18             
15387   2E18             ; and continue with integer in range 0 - 255.
15388   2E18             
15389   2E18 B3                  OR      E               ; test the low byte for zero
15390   2E19                                             ; i.e. originally just point something or other.
15391   2E19 28 09               JR      Z,L2E24         ; forward if so to PF-SMALL 
15392   2E1B             
15393   2E1B             ; 
15394   2E1B             
15395   2E1B 53                  LD      D,E             ; transfer E to D
15396   2E1C 06 08               LD      B,$08           ; and reduce the bit counter to 8.
15397   2E1E             
15398   2E1E             ;; PF-SAVE
15399   2E1E D5          L2E1E:   PUSH    DE              ; save the part before decimal point.
15400   2E1F D9                  EXX                     ;
15401   2E20 D1                  POP     DE              ; and pop in into D'E'
15402   2E21 D9                  EXX                     ;
15403   2E22 18 57               JR      L2E7B           ; forward to PF-BITS
15404   2E24             
15405   2E24             ; ---------------------
15406   2E24             
15407   2E24             ; the branch was here when 'int x' was found to be zero as in say 0.5.
15408   2E24             ; The zero has been fetched from the calculator stack but not deleted and
15409   2E24             ; this should occur now. This omission leaves the stack unbalanced and while
15410   2E24             ; that causes no problems with a simple PRINT statement, it will if str$ is
15411   2E24             ; being used in an expression e.g. "2" + STR$ 0.5 gives the result "0.5"
15412   2E24             ; instead of the expected result "20.5".
15413   2E24             ; credit Tony Stratton, 1982.
15414   2E24             ; A DEFB 02 delete is required immediately on using the calculator.
15415   2E24             
15416   2E24             ;; PF-SMALL
15417   2E24 EF          L2E24:   RST     28H             ;; FP-CALC       int x = 0.
15418   2E25 E2          L2E25:   DEFB    $E2             ;;get-mem-2      int x = 0, x-int x.
15419   2E26 38                  DEFB    $38             ;;end-calc
15420   2E27             
15421   2E27 7E                  LD      A,(HL)          ; fetch exponent of positive fractional number
15422   2E28 D6 7E               SUB     $7E             ; subtract 
15423   2E2A             
15424   2E2A CD C1 2D            CALL    L2DC1           ; routine LOG(2^A) calculates leading digits.
15425   2E2D             
15426   2E2D 57                  LD      D,A             ; transfer count to D
15427   2E2E 3A AC 5C            LD      A,($5CAC)       ; fetch total MEM-5-1
15428   2E31 92                  SUB     D               ;
15429   2E32 32 AC 5C            LD      ($5CAC),A       ; MEM-5-1
15430   2E35 7A                  LD      A,D             ; 
15431   2E36 CD 4F 2D            CALL    L2D4F           ; routine E-TO-FP
15432   2E39             
15433   2E39 EF                  RST     28H             ;; FP-CALC
15434   2E3A 31                  DEFB    $31             ;;duplicate
15435   2E3B 27                  DEFB    $27             ;;int
15436   2E3C C1                  DEFB    $C1             ;;st-mem-1
15437   2E3D 03                  DEFB    $03             ;;subtract
15438   2E3E E1                  DEFB    $E1             ;;get-mem-1
15439   2E3F 38                  DEFB    $38             ;;end-calc
15440   2E40             
15441   2E40 CD D5 2D            CALL    L2DD5           ; routine FP-TO-A
15442   2E43             
15443   2E43 E5                  PUSH    HL              ; save HL
15444   2E44 32 A1 5C            LD      ($5CA1),A       ; MEM-3-1
15445   2E47 3D                  DEC     A               ;
15446   2E48 17                  RLA                     ;
15447   2E49 9F                  SBC     A,A             ;
15448   2E4A 3C                  INC     A               ;
15449   2E4B             
15450   2E4B 21 AB 5C            LD      HL,$5CAB        ; address MEM-5-1 leading digit counter
15451   2E4E 77                  LD      (HL),A          ; store counter
15452   2E4F 23                  INC     HL              ; address MEM-5-2 total digits
15453   2E50 86                  ADD     A,(HL)          ; add counter to contents
15454   2E51 77                  LD      (HL),A          ; and store updated value
15455   2E52 E1                  POP     HL              ; restore HL
15456   2E53             
15457   2E53 C3 CF 2E            JP      L2ECF           ; JUMP forward to PF-FRACTN
15458   2E56             
15459   2E56             ; ---
15460   2E56             
15461   2E56             ; Note. while it would be pedantic to comment on every occasion a JP
15462   2E56             ; instruction could be replaced with a JR instruction, this applies to the
15463   2E56             ; above, which is useful if you wish to correct the unbalanced stack error
15464   2E56             ; by inserting a 'DEFB 02 delete' at L2E25, and maintain main addresses.
15465   2E56             
15466   2E56             ; the branch was here with a large positive integer > 65535 e.g. 123456789
15467   2E56             ; the accumulator holds the exponent.
15468   2E56             
15469   2E56             ;; PF-LARGE
15470   2E56 D6 80       L2E56:   SUB     $80             ; make exponent positive
15471   2E58 FE 1C               CP      $1C             ; compare to 28
15472   2E5A 38 13               JR      C,L2E6F         ; to PF-MEDIUM if integer <= 2^27
15473   2E5C             
15474   2E5C CD C1 2D            CALL    L2DC1           ; routine LOG(2^A)
15475   2E5F D6 07               SUB     $07             ;
15476   2E61 47                  LD      B,A             ;
15477   2E62 21 AC 5C            LD      HL,$5CAC        ; address MEM-5-1 the leading digits counter.
15478   2E65 86                  ADD     A,(HL)          ; add A to contents
15479   2E66 77                  LD      (HL),A          ; store updated value.
15480   2E67 78                  LD      A,B             ; 
15481   2E68 ED 44               NEG                     ; negate
15482   2E6A CD 4F 2D            CALL    L2D4F           ; routine E-TO-FP
15483   2E6D 18 92               JR      L2E01           ; back to PF-LOOP
15484   2E6F             
15485   2E6F             ; ----------------------------
15486   2E6F             
15487   2E6F             ;; PF-MEDIUM
15488   2E6F EB          L2E6F:   EX      DE,HL           ;
15489   2E70 CD BA 2F            CALL    L2FBA           ; routine FETCH-TWO
15490   2E73 D9                  EXX                     ;
15491   2E74 CB FA               SET     7,D             ;
15492   2E76 7D                  LD      A,L             ;
15493   2E77 D9                  EXX                     ;
15494   2E78 D6 80               SUB     $80             ;
15495   2E7A 47                  LD      B,A             ;
15496   2E7B             
15497   2E7B             ; the branch was here to handle bits in DE with 8 or 16 in B  if small int
15498   2E7B             ; and integer in D'E', 6 nibbles will accommodate 065535 but routine does
15499   2E7B             ; 32-bit numbers as well from above
15500   2E7B             
15501   2E7B             ;; PF-BITS
15502   2E7B CB 23       L2E7B:   SLA     E               ;  C<xxxxxxxx<0
15503   2E7D CB 12               RL      D               ;  C<xxxxxxxx<C
15504   2E7F D9                  EXX                     ;
15505   2E80 CB 13               RL      E               ;  C<xxxxxxxx<C
15506   2E82 CB 12               RL      D               ;  C<xxxxxxxx<C
15507   2E84 D9                  EXX                     ;
15508   2E85             
15509   2E85 21 AA 5C            LD      HL,$5CAA        ; set HL to mem-4-5th last byte of buffer
15510   2E88 0E 05               LD      C,$05           ; set byte count to 5 -  10 nibbles
15511   2E8A             
15512   2E8A             ;; PF-BYTES
15513   2E8A 7E          L2E8A:   LD      A,(HL)          ; fetch 0 or prev value
15514   2E8B 8F                  ADC     A,A             ; shift left add in carry    C<xxxxxxxx<C
15515   2E8C             
15516   2E8C 27                  DAA                     ; Decimal Adjust Accumulator.
15517   2E8D                                             ; if greater than 9 then the left hand
15518   2E8D                                             ; nibble is incremented. If greater than
15519   2E8D                                             ; 99 then adjusted and carry set.
15520   2E8D                                             ; so if we'd built up 7 and a carry came in
15521   2E8D                                             ;      0000 0111 < C
15522   2E8D                                             ;      0000 1111
15523   2E8D                                             ; daa     1 0101  which is 15 in BCD
15524   2E8D             
15525   2E8D 77                  LD      (HL),A          ; put back
15526   2E8E 2B                  DEC     HL              ; work down thru mem 4
15527   2E8F 0D                  DEC     C               ; decrease the 5 counter.
15528   2E90 20 F8               JR      NZ,L2E8A        ; back to PF-BYTES until the ten nibbles rolled
15529   2E92             
15530   2E92 10 E7               DJNZ    L2E7B           ; back to PF-BITS until 8 or 16 (or 32) done
15531   2E94             
15532   2E94             ; at most 9 digits for 32-bit number will have been loaded with digits
15533   2E94             ; each of the 9 nibbles in mem 4 is placed into ten bytes in mem-3 and mem 4
15534   2E94             ; unless the nibble is zero as the buffer is already zero.
15535   2E94             ; ( or in the case of mem-5 will become zero as a result of RLD instruction )
15536   2E94             
15537   2E94 AF                  XOR     A               ; clear to accept
15538   2E95 21 A6 5C            LD      HL,$5CA6        ; address MEM-4-0 byte destination.
15539   2E98 11 A1 5C            LD      DE,$5CA1        ; address MEM-3-0 nibble source.
15540   2E9B 06 09               LD      B,$09           ; the count is 9 (not ten) as the first 
15541   2E9D                                             ; nibble is known to be blank.
15542   2E9D             
15543   2E9D ED 6F               RLD                     ; shift RH nibble to left in (HL)
15544   2E9F                                             ;    A           (HL)
15545   2E9F                                             ; 0000 0000 < 0000 3210
15546   2E9F                                             ; 0000 0000   3210 0000
15547   2E9F                                             ; A picks up the blank nibble
15548   2E9F             
15549   2E9F             
15550   2E9F 0E FF               LD      C,$FF           ; set a flag to indicate when a significant
15551   2EA1                                             ; digit has been encountered.
15552   2EA1             
15553   2EA1             ;; PF-DIGITS
15554   2EA1 ED 6F       L2EA1:   RLD                     ; pick up leftmost nibble from (HL)
15555   2EA3                                             ;    A           (HL)
15556   2EA3                                             ; 0000 0000 < 7654 3210
15557   2EA3                                             ; 0000 7654   3210 0000
15558   2EA3             
15559   2EA3             
15560   2EA3 20 04               JR      NZ,L2EA9        ; to PF-INSERT if non-zero value picked up.
15561   2EA5             
15562   2EA5 0D                  DEC     C               ; test
15563   2EA6 0C                  INC     C               ; flag
15564   2EA7 20 0A               JR      NZ,L2EB3        ; skip forward to PF-TEST-2 if flag still $FF
15565   2EA9                                             ; indicating this is a leading zero.
15566   2EA9             
15567   2EA9             ; but if the zero is a significant digit e.g. 10 then include in digit totals.
15568   2EA9             ; the path for non-zero digits rejoins here.
15569   2EA9             
15570   2EA9             ;; PF-INSERT
15571   2EA9 12          L2EA9:   LD      (DE),A          ; insert digit at destination
15572   2EAA 13                  INC     DE              ; increase the destination pointer
15573   2EAB FD 34 71            INC     (IY+$71)        ; increment MEM-5-1st  digit counter
15574   2EAE FD 34 72            INC     (IY+$72)        ; increment MEM-5-2nd  leading digit counter
15575   2EB1 0E 00               LD      C,$00           ; set flag to zero indicating that any 
15576   2EB3                                             ; subsequent zeros are significant and not 
15577   2EB3                                             ; leading.
15578   2EB3             
15579   2EB3             ;; PF-TEST-2
15580   2EB3 CB 40       L2EB3:   BIT     0,B             ; test if the nibble count is even
15581   2EB5 28 01               JR      Z,L2EB8         ; skip to PF-ALL-9 if so to deal with the
15582   2EB7                                             ; other nibble in the same byte
15583   2EB7             
15584   2EB7 23                  INC     HL              ; point to next source byte if not
15585   2EB8             
15586   2EB8             ;; PF-ALL-9
15587   2EB8 10 E7       L2EB8:   DJNZ    L2EA1           ; decrement the nibble count, back to PF-DIGITS
15588   2EBA                                             ; if all nine not done.
15589   2EBA             
15590   2EBA             ; For 8-bit integers there will be at most 3 digits.
15591   2EBA             ; For 16-bit integers there will be at most 5 digits. 
15592   2EBA             ; but for larger integers there could be nine leading digits.
15593   2EBA             ; if nine digits complete then the last one is rounded up as the number will
15594   2EBA             ; be printed using E-format notation
15595   2EBA             
15596   2EBA 3A AB 5C            LD      A,($5CAB)       ; fetch digit count from MEM-5-1st
15597   2EBD D6 09               SUB     $09             ; subtract 9 - max possible
15598   2EBF 38 0A               JR      C,L2ECB         ; forward if less to PF-MORE
15599   2EC1             
15600   2EC1 FD 35 71            DEC     (IY+$71)        ; decrement digit counter MEM-5-1st to 8
15601   2EC4 3E 04               LD      A,$04           ; load A with the value 4.
15602   2EC6 FD BE 6F            CP      (IY+$6F)        ; compare with MEM-4-4th - the ninth digit
15603   2EC9 18 41               JR      L2F0C           ; forward to PF-ROUND
15604   2ECB                                             ; to consider rounding.
15605   2ECB             
15606   2ECB             ; ---------------------------------------
15607   2ECB              
15608   2ECB             ; now delete int x from calculator stack and fetch fractional part.
15609   2ECB             
15610   2ECB             ;; PF-MORE
15611   2ECB EF          L2ECB:   RST     28H             ;; FP-CALC        int x.
15612   2ECC 02                  DEFB    $02             ;;delete          .
15613   2ECD E2                  DEFB    $E2             ;;get-mem-2       x - int x = f.
15614   2ECE 38                  DEFB    $38             ;;end-calc        f.
15615   2ECF             
15616   2ECF             ;; PF-FRACTN
15617   2ECF EB          L2ECF:   EX      DE,HL           ;
15618   2ED0 CD BA 2F            CALL    L2FBA           ; routine FETCH-TWO
15619   2ED3 D9                  EXX                     ;
15620   2ED4 3E 80               LD      A,$80           ;
15621   2ED6 95                  SUB     L               ;
15622   2ED7 2E 00               LD      L,$00           ;
15623   2ED9 CB FA               SET     7,D             ;
15624   2EDB D9                  EXX                     ;
15625   2EDC CD DD 2F            CALL    L2FDD           ; routine SHIFT-FP
15626   2EDF             
15627   2EDF             ;; PF-FRN-LP
15628   2EDF FD 7E 71    L2EDF:   LD      A,(IY+$71)      ; MEM-5-1st
15629   2EE2 FE 08               CP      $08             ;
15630   2EE4 38 06               JR      C,L2EEC         ; to PF-FR-DGT
15631   2EE6             
15632   2EE6 D9                  EXX                     ;
15633   2EE7 CB 12               RL      D               ;
15634   2EE9 D9                  EXX                     ;
15635   2EEA 18 20               JR      L2F0C           ; to PF-ROUND
15636   2EEC             
15637   2EEC             ; ---
15638   2EEC             
15639   2EEC             ;; PF-FR-DGT
15640   2EEC 01 00 02    L2EEC:   LD      BC,$0200        ;
15641   2EEF             
15642   2EEF             ;; PF-FR-EXX
15643   2EEF 7B          L2EEF:   LD      A,E             ;
15644   2EF0 CD 8B 2F            CALL    L2F8B           ; routine CA-10*A+C
15645   2EF3 5F                  LD      E,A             ;
15646   2EF4 7A                  LD      A,D             ;
15647   2EF5 CD 8B 2F            CALL    L2F8B           ; routine CA-10*A+C
15648   2EF8 57                  LD      D,A             ;
15649   2EF9 C5                  PUSH    BC              ;
15650   2EFA D9                  EXX                     ;
15651   2EFB C1                  POP     BC              ;
15652   2EFC 10 F1               DJNZ    L2EEF           ; to PF-FR-EXX
15653   2EFE             
15654   2EFE 21 A1 5C            LD      HL,$5CA1        ; MEM-3
15655   2F01 79                  LD      A,C             ;
15656   2F02 FD 4E 71            LD      C,(IY+$71)      ; MEM-5-1st
15657   2F05 09                  ADD     HL,BC           ;
15658   2F06 77                  LD      (HL),A          ;
15659   2F07 FD 34 71            INC     (IY+$71)        ; MEM-5-1st
15660   2F0A 18 D3               JR      L2EDF           ; to PF-FRN-LP
15661   2F0C             
15662   2F0C             ; ----------------
15663   2F0C             
15664   2F0C             ; 1) with 9 digits but 8 in mem-5-1 and A holding 4, carry set if rounding up.
15665   2F0C             ; e.g. 
15666   2F0C             ;      999999999 is printed as 1E+9
15667   2F0C             ;      100000001 is printed as 1E+8
15668   2F0C             ;      100000009 is printed as 1.0000001E+8
15669   2F0C             
15670   2F0C             ;; PF-ROUND
15671   2F0C F5          L2F0C:   PUSH    AF              ; save A and flags
15672   2F0D 21 A1 5C            LD      HL,$5CA1        ; address MEM-3 start of digits
15673   2F10 FD 4E 71            LD      C,(IY+$71)      ; MEM-5-1st No. of digits to C
15674   2F13 06 00               LD      B,$00           ; prepare to add
15675   2F15 09                  ADD     HL,BC           ; address last digit + 1
15676   2F16 41                  LD      B,C             ; No. of digits to B counter
15677   2F17 F1                  POP     AF              ; restore A and carry flag from comparison.
15678   2F18             
15679   2F18             ;; PF-RND-LP
15680   2F18 2B          L2F18:   DEC     HL              ; address digit at rounding position.
15681   2F19 7E                  LD      A,(HL)          ; fetch it
15682   2F1A CE 00               ADC     A,$00           ; add carry from the comparison
15683   2F1C 77                  LD      (HL),A          ; put back result even if $0A.
15684   2F1D A7                  AND     A               ; test A
15685   2F1E 28 05               JR      Z,L2F25         ; skip to PF-R-BACK if ZERO?
15686   2F20             
15687   2F20 FE 0A               CP      $0A             ; compare to 'ten' - overflow
15688   2F22 3F                  CCF                     ; complement carry flag so that set if ten.
15689   2F23 30 08               JR      NC,L2F2D        ; forward to PF-COUNT with 1 - 9.
15690   2F25             
15691   2F25             ;; PF-R-BACK
15692   2F25 10 F1       L2F25:   DJNZ    L2F18           ; loop back to PF-RND-LP
15693   2F27             
15694   2F27             ; if B counts down to zero then we've rounded right back as in 999999995.
15695   2F27             ; and the first 8 locations all hold $0A.
15696   2F27             
15697   2F27             
15698   2F27 36 01               LD      (HL),$01        ; load first location with digit 1.
15699   2F29 04                  INC     B               ; make B hold 1 also.
15700   2F2A                                             ; could save an instruction byte here.
15701   2F2A FD 34 72            INC     (IY+$72)        ; make MEM-5-2nd hold 1.
15702   2F2D                                             ; and proceed to initialize total digits to 1.
15703   2F2D             
15704   2F2D             ;; PF-COUNT
15705   2F2D FD 70 71    L2F2D:   LD      (IY+$71),B      ; MEM-5-1st
15706   2F30             
15707   2F30             ; now balance the calculator stack by deleting  it
15708   2F30             
15709   2F30 EF                  RST     28H             ;; FP-CALC
15710   2F31 02                  DEFB    $02             ;;delete
15711   2F32 38                  DEFB    $38             ;;end-calc
15712   2F33             
15713   2F33             ; note if used from str$ then other values may be on the calculator stack.
15714   2F33             ; we can also restore the next literal pointer from its position on the
15715   2F33             ; machine stack.
15716   2F33             
15717   2F33 D9                  EXX                     ;
15718   2F34 E1                  POP     HL              ; restore next literal pointer.
15719   2F35 D9                  EXX                     ;
15720   2F36             
15721   2F36 ED 4B AB 5C         LD      BC,($5CAB)      ; set C to MEM-5-1st digit counter.
15722   2F3A                                             ; set B to MEM-5-2nd leading digit counter.
15723   2F3A 21 A1 5C            LD      HL,$5CA1        ; set HL to start of digits at MEM-3-1
15724   2F3D 78                  LD      A,B             ;
15725   2F3E FE 09               CP      $09             ;
15726   2F40 38 04               JR      C,L2F46         ; to PF-NOT-E
15727   2F42             
15728   2F42 FE FC               CP      $FC             ;
15729   2F44 38 26               JR      C,L2F6C         ; to PF-E-FRMT
15730   2F46             
15731   2F46             ;; PF-NOT-E
15732   2F46 A7          L2F46:   AND     A               ; test for zero leading digits as in .123
15733   2F47             
15734   2F47 CC EF 15            CALL    Z,L15EF         ; routine OUT-CODE prints a zero e.g. 0.123
15735   2F4A             
15736   2F4A             ;; PF-E-SBRN
15737   2F4A AF          L2F4A:   XOR     A               ;
15738   2F4B 90                  SUB     B               ;
15739   2F4C FA 52 2F            JP      M,L2F52         ; skip forward to PF-OUT-LP if originally +ve
15740   2F4F             
15741   2F4F 47                  LD      B,A             ; else negative count now +ve
15742   2F50 18 0C               JR      L2F5E           ; forward to PF-DC-OUT       ->
15743   2F52             
15744   2F52             ; ---
15745   2F52             
15746   2F52             ;; PF-OUT-LP
15747   2F52 79          L2F52:   LD      A,C             ; fetch total digit count
15748   2F53 A7                  AND     A               ; test for zero
15749   2F54 28 03               JR      Z,L2F59         ; forward to PF-OUT-DT if so
15750   2F56             
15751   2F56 7E                  LD      A,(HL)          ; fetch digit
15752   2F57 23                  INC     HL              ; address next digit
15753   2F58 0D                  DEC     C               ; decrease total digit counter
15754   2F59             
15755   2F59             ;; PF-OUT-DT
15756   2F59 CD EF 15    L2F59:   CALL    L15EF           ; routine OUT-CODE outputs it.
15757   2F5C 10 F4               DJNZ    L2F52           ; loop back to PF-OUT-LP until B leading 
15758   2F5E                                             ; digits output.
15759   2F5E             
15760   2F5E             ;; PF-DC-OUT
15761   2F5E 79          L2F5E:   LD      A,C             ; fetch total digits and
15762   2F5F A7                  AND     A               ; test if also zero
15763   2F60 C8                  RET     Z               ; return if so              -->
15764   2F61             
15765   2F61             ; 
15766   2F61             
15767   2F61 04                  INC     B               ; increment B
15768   2F62 3E 2E               LD      A,$2E           ; prepare the character '.'
15769   2F64             
15770   2F64             ;; PF-DEC-0S
15771   2F64 D7          L2F64:   RST     10H             ; PRINT-A outputs the character '.' or '0'
15772   2F65             
15773   2F65 3E 30               LD      A,$30           ; prepare the character '0'
15774   2F67                                             ; (for cases like .000012345678)
15775   2F67 10 FB               DJNZ    L2F64           ; loop back to PF-DEC-0S for B times.
15776   2F69             
15777   2F69 41                  LD      B,C             ; load B with now trailing digit counter.
15778   2F6A 18 E6               JR      L2F52           ; back to PF-OUT-LP
15779   2F6C             
15780   2F6C             ; ---------------------------------
15781   2F6C             
15782   2F6C             ; the branch was here for E-format printing e.g. 123456789 => 1.2345679e+8
15783   2F6C             
15784   2F6C             ;; PF-E-FRMT
15785   2F6C 50          L2F6C:   LD      D,B             ; counter to D
15786   2F6D 15                  DEC     D               ; decrement
15787   2F6E 06 01               LD      B,$01           ; load B with 1.
15788   2F70             
15789   2F70 CD 4A 2F            CALL    L2F4A           ; routine PF-E-SBRN above
15790   2F73             
15791   2F73 3E 45               LD      A,$45           ; prepare character 'e'
15792   2F75 D7                  RST     10H             ; PRINT-A
15793   2F76             
15794   2F76 4A                  LD      C,D             ; exponent to C
15795   2F77 79                  LD      A,C             ; and to A
15796   2F78 A7                  AND     A               ; test exponent
15797   2F79 F2 83 2F            JP      P,L2F83         ; to PF-E-POS if positive
15798   2F7C             
15799   2F7C ED 44               NEG                     ; negate
15800   2F7E 4F                  LD      C,A             ; positive exponent to C
15801   2F7F 3E 2D               LD      A,$2D           ; prepare character '-'
15802   2F81 18 02               JR      L2F85           ; skip to PF-E-SIGN
15803   2F83             
15804   2F83             ; ---
15805   2F83             
15806   2F83             ;; PF-E-POS
15807   2F83 3E 2B       L2F83:   LD      A,$2B           ; prepare character '+'
15808   2F85             
15809   2F85             ;; PF-E-SIGN
15810   2F85 D7          L2F85:   RST     10H             ; PRINT-A outputs the sign
15811   2F86             
15812   2F86 06 00               LD      B,$00           ; make the high byte zero.
15813   2F88 C3 1B 1A            JP      L1A1B           ; exit via OUT-NUM-1 to print exponent in BC
15814   2F8B             
15815   2F8B             ; ------------------------------
15816   2F8B             ; Handle printing floating point
15817   2F8B             ; ------------------------------
15818   2F8B             ; This subroutine is called twice from above when printing floating-point
15819   2F8B             ; numbers. It returns 10*A +C in registers C and A
15820   2F8B             
15821   2F8B             ;; CA-10*A+C
15822   2F8B D5          L2F8B:   PUSH    DE              ; preserve DE.
15823   2F8C 6F                  LD      L,A             ; transfer A to L
15824   2F8D 26 00               LD      H,$00           ; zero high byte.
15825   2F8F 5D                  LD      E,L             ; copy HL
15826   2F90 54                  LD      D,H             ; to DE.
15827   2F91 29                  ADD     HL,HL           ; double (*2)
15828   2F92 29                  ADD     HL,HL           ; double (*4)
15829   2F93 19                  ADD     HL,DE           ; add DE (*5)
15830   2F94 29                  ADD     HL,HL           ; double (*10)
15831   2F95 59                  LD      E,C             ; copy C to E    (D is 0)
15832   2F96 19                  ADD     HL,DE           ; and add to give required result.
15833   2F97 4C                  LD      C,H             ; transfer to
15834   2F98 7D                  LD      A,L             ; destination registers.
15835   2F99 D1                  POP     DE              ; restore DE
15836   2F9A C9                  RET                     ; return with result.
15837   2F9B             
15838   2F9B             ; --------------
15839   2F9B             ; Prepare to add
15840   2F9B             ; --------------
15841   2F9B             ; This routine is called twice by addition to prepare the two numbers. The
15842   2F9B             ; exponent is picked up in A and the location made zero. Then the sign bit
15843   2F9B             ; is tested before being set to the implied state. Negative numbers are twos
15844   2F9B             ; complemented.
15845   2F9B             
15846   2F9B             ;; PREP-ADD
15847   2F9B 7E          L2F9B:   LD      A,(HL)          ; pick up exponent
15848   2F9C 36 00               LD      (HL),$00        ; make location zero
15849   2F9E A7                  AND     A               ; test if number is zero
15850   2F9F C8                  RET     Z               ; return if so
15851   2FA0             
15852   2FA0 23                  INC     HL              ; address mantissa
15853   2FA1 CB 7E               BIT     7,(HL)          ; test the sign bit
15854   2FA3 CB FE               SET     7,(HL)          ; set it to implied state
15855   2FA5 2B                  DEC     HL              ; point to exponent
15856   2FA6 C8                  RET     Z               ; return if positive number.
15857   2FA7             
15858   2FA7 C5                  PUSH    BC              ; preserve BC
15859   2FA8 01 05 00            LD      BC,$0005        ; length of number
15860   2FAB 09                  ADD     HL,BC           ; point HL past end
15861   2FAC 41                  LD      B,C             ; set B to 5 counter
15862   2FAD 4F                  LD      C,A             ; store exponent in C
15863   2FAE 37                  SCF                     ; set carry flag
15864   2FAF             
15865   2FAF             ;; NEG-BYTE
15866   2FAF 2B          L2FAF:   DEC     HL              ; work from LSB to MSB
15867   2FB0 7E                  LD      A,(HL)          ; fetch byte
15868   2FB1 2F                  CPL                     ; complement
15869   2FB2 CE 00               ADC     A,$00           ; add in initial carry or from prev operation
15870   2FB4 77                  LD      (HL),A          ; put back
15871   2FB5 10 F8               DJNZ    L2FAF           ; loop to NEG-BYTE till all 5 done
15872   2FB7             
15873   2FB7 79                  LD      A,C             ; stored exponent to A
15874   2FB8 C1                  POP     BC              ; restore original BC
15875   2FB9 C9                  RET                     ; return
15876   2FBA             
15877   2FBA             ; -----------------
15878   2FBA             ; Fetch two numbers
15879   2FBA             ; -----------------
15880   2FBA             ; This routine is called twice when printing floating point numbers and also
15881   2FBA             ; to fetch two numbers by the addition, multiply and division routines.
15882   2FBA             ; HL addresses the first number, DE addresses the second number.
15883   2FBA             ; For arithmetic only, A holds the sign of the result which is stored in
15884   2FBA             ; the second location. 
15885   2FBA             
15886   2FBA             ;; FETCH-TWO
15887   2FBA E5          L2FBA:   PUSH    HL              ; save pointer to first number, result if math.
15888   2FBB F5                  PUSH    AF              ; save result sign.
15889   2FBC             
15890   2FBC 4E                  LD      C,(HL)          ;
15891   2FBD 23                  INC     HL              ;
15892   2FBE             
15893   2FBE 46                  LD      B,(HL)          ;
15894   2FBF 77                  LD      (HL),A          ; store the sign at correct location in 
15895   2FC0                                             ; destination 5 bytes for arithmetic only.
15896   2FC0 23                  INC     HL              ;
15897   2FC1             
15898   2FC1 79                  LD      A,C             ;
15899   2FC2 4E                  LD      C,(HL)          ;
15900   2FC3 C5                  PUSH    BC              ;
15901   2FC4 23                  INC     HL              ;
15902   2FC5 4E                  LD      C,(HL)          ;
15903   2FC6 23                  INC     HL              ;
15904   2FC7 46                  LD      B,(HL)          ;
15905   2FC8 EB                  EX      DE,HL           ;
15906   2FC9 57                  LD      D,A             ;
15907   2FCA 5E                  LD      E,(HL)          ;
15908   2FCB D5                  PUSH    DE              ;
15909   2FCC 23                  INC     HL              ;
15910   2FCD 56                  LD      D,(HL)          ;
15911   2FCE 23                  INC     HL              ;
15912   2FCF 5E                  LD      E,(HL)          ;
15913   2FD0 D5                  PUSH    DE              ;
15914   2FD1 D9                  EXX                     ;
15915   2FD2 D1                  POP     DE              ;
15916   2FD3 E1                  POP     HL              ;
15917   2FD4 C1                  POP     BC              ;
15918   2FD5 D9                  EXX                     ;
15919   2FD6 23                  INC     HL              ;
15920   2FD7 56                  LD      D,(HL)          ;
15921   2FD8 23                  INC     HL              ;
15922   2FD9 5E                  LD      E,(HL)          ;
15923   2FDA             
15924   2FDA F1                  POP     AF              ; restore possible result sign.
15925   2FDB E1                  POP     HL              ; and pointer to possible result.
15926   2FDC C9                  RET                     ; return.
15927   2FDD             
15928   2FDD             ; ---------------------------------
15929   2FDD             ; Shift floating point number right
15930   2FDD             ; ---------------------------------
15931   2FDD             ;
15932   2FDD             ;
15933   2FDD             
15934   2FDD             ;; SHIFT-FP
15935   2FDD A7          L2FDD:   AND     A               ;
15936   2FDE C8                  RET     Z               ;
15937   2FDF             
15938   2FDF FE 21               CP      $21             ;
15939   2FE1 30 16               JR      NC,L2FF9        ; to ADDEND-0
15940   2FE3             
15941   2FE3 C5                  PUSH    BC              ;
15942   2FE4 47                  LD      B,A             ;
15943   2FE5             
15944   2FE5             ;; ONE-SHIFT
15945   2FE5 D9          L2FE5:   EXX                     ;
15946   2FE6 CB 2D               SRA     L               ;
15947   2FE8 CB 1A               RR      D               ;
15948   2FEA CB 1B               RR      E               ;
15949   2FEC D9                  EXX                     ;
15950   2FED CB 1A               RR      D               ;
15951   2FEF CB 1B               RR      E               ;
15952   2FF1 10 F2               DJNZ    L2FE5           ; to ONE-SHIFT
15953   2FF3             
15954   2FF3 C1                  POP     BC              ;
15955   2FF4 D0                  RET     NC              ;
15956   2FF5             
15957   2FF5 CD 04 30            CALL    L3004           ; routine ADD-BACK
15958   2FF8 C0                  RET     NZ              ;
15959   2FF9             
15960   2FF9             ;; ADDEND-0
15961   2FF9 D9          L2FF9:   EXX                     ;
15962   2FFA AF                  XOR     A               ;
15963   2FFB             
15964   2FFB             ;; ZEROS-4/5
15965   2FFB 2E 00       L2FFB:   LD      L,$00           ;
15966   2FFD 57                  LD      D,A             ;
15967   2FFE 5D                  LD      E,L             ;
15968   2FFF D9                  EXX                     ;
15969   3000 11 00 00            LD      DE,$0000        ;
15970   3003 C9                  RET                     ;
15971   3004             
15972   3004             ; ------------------
15973   3004             ; Add back any carry
15974   3004             ; ------------------
15975   3004             ;
15976   3004             ;
15977   3004             
15978   3004             ;; ADD-BACK
15979   3004 1C          L3004:   INC     E               ;
15980   3005 C0                  RET     NZ              ;
15981   3006             
15982   3006 14                  INC      D              ;
15983   3007 C0                  RET     NZ              ;
15984   3008             
15985   3008 D9                  EXX                     ;
15986   3009 1C                  INC     E               ;
15987   300A 20 01               JR      NZ,L300D        ; to ALL-ADDED
15988   300C             
15989   300C 14                  INC     D               ;
15990   300D             
15991   300D             ;; ALL-ADDED
15992   300D D9          L300D:   EXX                     ;
15993   300E C9                  RET                     ;
15994   300F             
15995   300F             ; -----------------------
15996   300F             ; Handle subtraction (03)
15997   300F             ; -----------------------
15998   300F             ; Subtraction is done by switching the sign byte/bit of the second number
15999   300F             ; which may be integer of floating point and continuing into addition.
16000   300F             
16001   300F             ;; subtract
16002   300F EB          L300F:   EX      DE,HL           ; address second number with HL
16003   3010             
16004   3010 CD 6E 34            CALL    L346E           ; routine NEGATE switches sign
16005   3013             
16006   3013 EB                  EX      DE,HL           ; address first number again
16007   3014                                             ; and continue.
16008   3014             
16009   3014             ; --------------------
16010   3014             ; Handle addition (0F)
16011   3014             ; --------------------
16012   3014             ; HL points to first number, DE to second.
16013   3014             ; If they are both integers, then go for the easy route.
16014   3014             
16015   3014             ;; addition
16016   3014 1A          L3014:   LD      A,(DE)          ; fetch first byte of second
16017   3015 B6                  OR      (HL)            ; combine with first byte of first
16018   3016 20 26               JR      NZ,L303E        ; forward to FULL-ADDN if at least one was
16019   3018                                             ; in floating point form.
16020   3018             
16021   3018             ; continue if both were small integers.
16022   3018             
16023   3018 D5                  PUSH    DE              ; save pointer to lowest number for result.
16024   3019             
16025   3019 23                  INC     HL              ; address sign byte and
16026   301A E5                  PUSH    HL              ; push the pointer.
16027   301B             
16028   301B 23                  INC     HL              ; address low byte
16029   301C 5E                  LD      E,(HL)          ; to E
16030   301D 23                  INC     HL              ; address high byte
16031   301E 56                  LD      D,(HL)          ; to D
16032   301F 23                  INC     HL              ; address unused byte
16033   3020             
16034   3020 23                  INC     HL              ; address known zero indicator of 1st number
16035   3021 23                  INC     HL              ; address sign byte
16036   3022             
16037   3022 7E                  LD      A,(HL)          ; sign to A, $00 or $FF
16038   3023             
16039   3023 23                  INC     HL              ; address low byte
16040   3024 4E                  LD      C,(HL)          ; to C
16041   3025 23                  INC     HL              ; address high byte
16042   3026 46                  LD      B,(HL)          ; to B
16043   3027             
16044   3027 E1                  POP     HL              ; pop result sign pointer
16045   3028 EB                  EX      DE,HL           ; integer to HL
16046   3029             
16047   3029 09                  ADD     HL,BC           ; add to the other one in BC
16048   302A                                             ; setting carry if overflow.
16049   302A             
16050   302A EB                  EX      DE,HL           ; save result in DE bringing back sign pointer
16051   302B             
16052   302B 8E                  ADC     A,(HL)          ; if pos/pos A=01 with overflow else 00
16053   302C                                             ; if neg/neg A=FF with overflow else FE
16054   302C                                             ; if mixture A=00 with overflow else FF
16055   302C             
16056   302C 0F                  RRCA                    ; bit 0 to (C)
16057   302D             
16058   302D CE 00               ADC     A,$00           ; both acceptable signs now zero
16059   302F             
16060   302F 20 0B               JR      NZ,L303C        ; forward to ADDN-OFLW if not
16061   3031             
16062   3031 9F                  SBC     A,A             ; restore a negative result sign
16063   3032             
16064   3032 77                  LD      (HL),A          ;
16065   3033 23                  INC     HL              ;
16066   3034 73                  LD      (HL),E          ;
16067   3035 23                  INC     HL              ;
16068   3036 72                  LD      (HL),D          ;
16069   3037 2B                  DEC     HL              ;
16070   3038 2B                  DEC     HL              ;
16071   3039 2B                  DEC     HL              ;
16072   303A             
16073   303A D1                  POP     DE              ; STKEND
16074   303B C9                  RET                     ;
16075   303C             
16076   303C             ; ---
16077   303C             
16078   303C             ;; ADDN-OFLW
16079   303C 2B          L303C:   DEC     HL              ;
16080   303D D1                  POP     DE              ;
16081   303E             
16082   303E             ;; FULL-ADDN
16083   303E CD 93 32    L303E:   CALL    L3293           ; routine RE-ST-TWO
16084   3041 D9                  EXX                     ;
16085   3042 E5                  PUSH    HL              ;
16086   3043 D9                  EXX                     ;
16087   3044 D5                  PUSH    DE              ;
16088   3045 E5                  PUSH    HL              ;
16089   3046 CD 9B 2F            CALL    L2F9B           ; routine PREP-ADD
16090   3049 47                  LD      B,A             ;
16091   304A EB                  EX      DE,HL           ;
16092   304B CD 9B 2F            CALL    L2F9B           ; routine PREP-ADD
16093   304E 4F                  LD       C,A            ;
16094   304F B8                  CP      B               ;
16095   3050 30 03               JR      NC,L3055        ; to SHIFT-LEN
16096   3052             
16097   3052 78                  LD      A,B             ;
16098   3053 41                  LD      B,C             ;
16099   3054 EB                  EX      DE,HL           ;
16100   3055             
16101   3055             ;; SHIFT-LEN
16102   3055 F5          L3055:   PUSH    AF              ;
16103   3056 90                  SUB     B               ;
16104   3057 CD BA 2F            CALL    L2FBA           ; routine FETCH-TWO
16105   305A CD DD 2F            CALL    L2FDD           ; routine SHIFT-FP
16106   305D F1                  POP     AF              ;
16107   305E E1                  POP     HL              ;
16108   305F 77                  LD      (HL),A          ;
16109   3060 E5                  PUSH    HL              ;
16110   3061 68                  LD      L,B             ;
16111   3062 61                  LD      H,C             ;
16112   3063 19                  ADD     HL,DE           ;
16113   3064 D9                  EXX                     ;
16114   3065 EB                  EX      DE,HL           ;
16115   3066 ED 4A               ADC     HL,BC           ;
16116   3068 EB                  EX      DE,HL           ;
16117   3069 7C                  LD      A,H             ;
16118   306A 8D                  ADC     A,L             ;
16119   306B 6F                  LD      L,A             ;
16120   306C 1F                  RRA                     ;
16121   306D AD                  XOR     L               ;
16122   306E D9                  EXX                     ;
16123   306F EB                  EX      DE,HL           ;
16124   3070 E1                  POP     HL              ;
16125   3071 1F                  RRA                     ;
16126   3072 30 08               JR      NC,L307C        ; to TEST-NEG
16127   3074             
16128   3074 3E 01               LD      A,$01           ;
16129   3076 CD DD 2F            CALL    L2FDD           ; routine SHIFT-FP
16130   3079 34                  INC     (HL)            ;
16131   307A 28 23               JR      Z,L309F         ; to ADD-REP-6
16132   307C             
16133   307C             ;; TEST-NEG
16134   307C D9          L307C:   EXX                     ;
16135   307D 7D                  LD      A,L             ;
16136   307E E6 80               AND     $80             ;
16137   3080 D9                  EXX                     ;
16138   3081 23                  INC     HL              ;
16139   3082 77                  LD      (HL),A          ;
16140   3083 2B                  DEC     HL              ;
16141   3084 28 1F               JR      Z,L30A5         ; to GO-NC-MLT
16142   3086             
16143   3086 7B                  LD      A,E             ;
16144   3087 ED 44               NEG                     ; Negate
16145   3089 3F                  CCF                     ; Complement Carry Flag
16146   308A 5F                  LD      E,A             ;
16147   308B 7A                  LD      A,D             ;
16148   308C 2F                  CPL                     ;
16149   308D CE 00               ADC     A,$00           ;
16150   308F 57                  LD      D,A             ;
16151   3090 D9                  EXX                     ;
16152   3091 7B                  LD      A,E             ;
16153   3092 2F                  CPL                     ;
16154   3093 CE 00               ADC     A,$00           ;
16155   3095 5F                  LD      E,A             ;
16156   3096 7A                  LD      A,D             ;
16157   3097 2F                  CPL                     ;
16158   3098 CE 00               ADC     A,$00           ;
16159   309A 30 07               JR      NC,L30A3        ; to END-COMPL
16160   309C             
16161   309C 1F                  RRA                     ;
16162   309D D9                  EXX                     ;
16163   309E 34                  INC     (HL)            ;
16164   309F             
16165   309F             ;; ADD-REP-6
16166   309F CA AD 31    L309F:   JP      Z,L31AD         ; to REPORT-6
16167   30A2             
16168   30A2 D9                  EXX                     ;
16169   30A3             
16170   30A3             ;; END-COMPL
16171   30A3 57          L30A3:   LD      D,A             ;
16172   30A4 D9                  EXX                     ;
16173   30A5             
16174   30A5             ;; GO-NC-MLT
16175   30A5 AF          L30A5:   XOR     A               ;
16176   30A6 C3 55 31            JP      L3155           ; to TEST-NORM
16177   30A9             
16178   30A9             ; -----------------------------
16179   30A9             ; Used in 16 bit multiplication
16180   30A9             ; -----------------------------
16181   30A9             ; This routine is used, in the first instance, by the multiply calculator
16182   30A9             ; literal to perform an integer multiplication in preference to
16183   30A9             ; 32-bit multiplication to which it will resort if this overflows.
16184   30A9             ;
16185   30A9             ; It is also used by STK-VAR to calculate array subscripts and by DIM to
16186   30A9             ; calculate the space required for multi-dimensional arrays.
16187   30A9             
16188   30A9             ;; HL-HL*DE
16189   30A9 C5          L30A9:   PUSH    BC              ; preserve BC throughout
16190   30AA 06 10               LD      B,$10           ; set B to 16
16191   30AC 7C                  LD      A,H             ; save H in A high byte
16192   30AD 4D                  LD      C,L             ; save L in C low byte
16193   30AE 21 00 00            LD      HL,$0000        ; initialize result to zero
16194   30B1             
16195   30B1             ; now enter a loop.
16196   30B1             
16197   30B1             ;; HL-LOOP
16198   30B1 29          L30B1:   ADD     HL,HL           ; double result
16199   30B2 38 0A               JR      C,L30BE         ; to HL-END if overflow
16200   30B4             
16201   30B4 CB 11               RL      C               ; shift AC left into carry
16202   30B6 17                  RLA                     ;
16203   30B7 30 03               JR      NC,L30BC        ; to HL-AGAIN to skip addition if no carry
16204   30B9             
16205   30B9 19                  ADD     HL,DE           ; add in DE
16206   30BA 38 02               JR      C,L30BE         ; to HL-END if overflow
16207   30BC             
16208   30BC             ;; HL-AGAIN
16209   30BC 10 F3       L30BC:   DJNZ    L30B1           ; back to HL-LOOP for all 16 bits
16210   30BE             
16211   30BE             ;; HL-END
16212   30BE C1          L30BE:   POP     BC              ; restore preserved BC
16213   30BF C9                  RET                     ; return with carry reset if successful
16214   30C0                                             ; and result in HL.
16215   30C0             
16216   30C0             ; ----------------------------------------------
16217   30C0             ; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
16218   30C0             ; ----------------------------------------------
16219   30C0             ;   This routine is called in succession from multiply and divide to prepare
16220   30C0             ;   two mantissas by setting the leftmost bit that is used for the sign.
16221   30C0             ;   On the first call A holds zero and picks up the sign bit. On the second
16222   30C0             ;   call the two bits are XORed to form the result sign - minus * minus giving
16223   30C0             ;   plus etc. If either number is zero then this is flagged.
16224   30C0             ;   HL addresses the exponent.
16225   30C0             
16226   30C0             ;; PREP-M/D
16227   30C0 CD E9 34    L30C0:   CALL    L34E9           ; routine TEST-ZERO  preserves accumulator.
16228   30C3 D8                  RET     C               ; return carry set if zero
16229   30C4             
16230   30C4 23                  INC     HL              ; address first byte of mantissa
16231   30C5 AE                  XOR     (HL)            ; pick up the first or xor with first.
16232   30C6 CB FE               SET     7,(HL)          ; now set to give true 32-bit mantissa
16233   30C8 2B                  DEC     HL              ; point to exponent
16234   30C9 C9                  RET                     ; return with carry reset
16235   30CA             
16236   30CA             ; ----------------------
16237   30CA             ; THE 'MULTIPLY' ROUTINE     
16238   30CA             ; ----------------------
16239   30CA             ; (offset: $04 'multiply')
16240   30CA             ;
16241   30CA             ;
16242   30CA             ;   "He said go forth and something about mathematics, I wasn't really 
16243   30CA             ;    listening" - overheard conversation between two unicorns.
16244   30CA             ;    [ The Odd Streak ].
16245   30CA             
16246   30CA             ;; multiply
16247   30CA 1A          L30CA:   LD      A,(DE)          ;
16248   30CB B6                  OR      (HL)            ;
16249   30CC 20 22               JR      NZ,L30F0        ; to MULT-LONG
16250   30CE             
16251   30CE D5                  PUSH    DE              ;
16252   30CF E5                  PUSH    HL              ;
16253   30D0 D5                  PUSH    DE              ;
16254   30D1 CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH
16255   30D4 EB                  EX      DE,HL           ;
16256   30D5 E3                  EX      (SP),HL         ;
16257   30D6 41                  LD      B,C             ;
16258   30D7 CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH
16259   30DA 78                  LD      A,B             ;
16260   30DB A9                  XOR     C               ;
16261   30DC 4F                  LD      C,A             ;
16262   30DD E1                  POP     HL              ;
16263   30DE CD A9 30            CALL    L30A9           ; routine HL-HL*DE
16264   30E1 EB                  EX      DE,HL           ;
16265   30E2 E1                  POP     HL              ;
16266   30E3 38 0A               JR      C,L30EF         ; to MULT-OFLW
16267   30E5             
16268   30E5 7A                  LD      A,D             ;
16269   30E6 B3                  OR      E               ;
16270   30E7 20 01               JR      NZ,L30EA        ; to MULT-RSLT
16271   30E9             
16272   30E9 4F                  LD      C,A             ;
16273   30EA             
16274   30EA             ;; MULT-RSLT
16275   30EA CD 8E 2D    L30EA:   CALL    L2D8E           ; routine INT-STORE
16276   30ED D1                  POP      DE             ;
16277   30EE C9                  RET                     ;
16278   30EF             
16279   30EF             ; ---
16280   30EF             
16281   30EF             ;; MULT-OFLW
16282   30EF D1          L30EF:   POP     DE              ;
16283   30F0             
16284   30F0             ;; MULT-LONG
16285   30F0 CD 93 32    L30F0:   CALL    L3293           ; routine RE-ST-TWO
16286   30F3 AF                  XOR     A               ;
16287   30F4 CD C0 30            CALL    L30C0           ; routine PREP-M/D
16288   30F7 D8                  RET     C               ;
16289   30F8             
16290   30F8 D9                  EXX                     ;
16291   30F9 E5                  PUSH    HL              ;
16292   30FA D9                  EXX                     ;
16293   30FB D5                  PUSH    DE              ;
16294   30FC EB                  EX      DE,HL           ;
16295   30FD CD C0 30            CALL    L30C0           ; routine PREP-M/D
16296   3100 EB                  EX      DE,HL           ;
16297   3101 38 5A               JR      C,L315D         ; to ZERO-RSLT
16298   3103             
16299   3103 E5                  PUSH    HL              ;
16300   3104 CD BA 2F            CALL    L2FBA           ; routine FETCH-TWO
16301   3107 78                  LD      A,B             ;
16302   3108 A7                  AND     A               ;
16303   3109 ED 62               SBC     HL,HL           ;
16304   310B D9                  EXX                     ;
16305   310C E5                  PUSH    HL              ;
16306   310D ED 62               SBC     HL,HL           ;
16307   310F D9                  EXX                     ;
16308   3110 06 21               LD      B,$21           ;
16309   3112 18 11               JR      L3125           ; to STRT-MLT
16310   3114             
16311   3114             ; ---
16312   3114             
16313   3114             ;; MLT-LOOP
16314   3114 30 05       L3114:   JR      NC,L311B        ; to NO-ADD
16315   3116             
16316   3116 19                  ADD     HL,DE           ;
16317   3117 D9                  EXX                     ;
16318   3118 ED 5A               ADC     HL,DE           ;
16319   311A D9                  EXX                     ;
16320   311B             
16321   311B             ;; NO-ADD
16322   311B D9          L311B:   EXX                     ;
16323   311C CB 1C               RR      H               ;
16324   311E CB 1D               RR      L               ;
16325   3120 D9                  EXX                     ;
16326   3121 CB 1C               RR      H               ;
16327   3123 CB 1D               RR      L               ;
16328   3125             
16329   3125             ;; STRT-MLT
16330   3125 D9          L3125:   EXX                     ;
16331   3126 CB 18               RR      B               ;
16332   3128 CB 19               RR      C               ;
16333   312A D9                  EXX                     ;
16334   312B CB 19               RR      C               ;
16335   312D 1F                  RRA                     ;
16336   312E 10 E4               DJNZ    L3114           ; to MLT-LOOP
16337   3130             
16338   3130 EB                  EX      DE,HL           ;
16339   3131 D9                  EXX                     ;
16340   3132 EB                  EX      DE,HL           ;
16341   3133 D9                  EXX                     ;
16342   3134 C1                  POP     BC              ;
16343   3135 E1                  POP     HL              ;
16344   3136 78                  LD      A,B             ;
16345   3137 81                  ADD     A,C             ;
16346   3138 20 01               JR      NZ,L313B        ; to MAKE-EXPT
16347   313A             
16348   313A A7                  AND     A               ;
16349   313B             
16350   313B             ;; MAKE-EXPT
16351   313B 3D          L313B:   DEC     A               ;
16352   313C 3F                  CCF                     ; Complement Carry Flag
16353   313D             
16354   313D             ;; DIVN-EXPT
16355   313D 17          L313D:   RLA                     ;
16356   313E 3F                  CCF                     ; Complement Carry Flag
16357   313F 1F                  RRA                     ;
16358   3140 F2 46 31            JP      P,L3146         ; to OFLW1-CLR
16359   3143             
16360   3143 30 68               JR      NC,L31AD        ; to REPORT-6
16361   3145             
16362   3145 A7                  AND     A               ;
16363   3146             
16364   3146             ;; OFLW1-CLR
16365   3146 3C          L3146:   INC     A               ;
16366   3147 20 08               JR      NZ,L3151        ; to OFLW2-CLR
16367   3149             
16368   3149 38 06               JR      C,L3151         ; to OFLW2-CLR
16369   314B             
16370   314B D9                  EXX                     ;
16371   314C CB 7A               BIT     7,D             ;
16372   314E D9                  EXX                     ;
16373   314F 20 5C               JR      NZ,L31AD        ; to REPORT-6
16374   3151             
16375   3151             ;; OFLW2-CLR
16376   3151 77          L3151:   LD      (HL),A          ;
16377   3152 D9                  EXX                     ;
16378   3153 78                  LD      A,B             ;
16379   3154 D9                  EXX                     ;
16380   3155             
16381   3155             ;; TEST-NORM
16382   3155 30 15       L3155:   JR      NC,L316C        ; to NORMALISE
16383   3157             
16384   3157 7E                  LD      A,(HL)          ;
16385   3158 A7                  AND     A               ;
16386   3159             
16387   3159             ;; NEAR-ZERO
16388   3159 3E 80       L3159:   LD      A,$80           ;
16389   315B 28 01               JR      Z,L315E         ; to SKIP-ZERO
16390   315D             
16391   315D             ;; ZERO-RSLT
16392   315D AF          L315D:   XOR     A               ;
16393   315E             
16394   315E             ;; SKIP-ZERO
16395   315E D9          L315E:   EXX                     ;
16396   315F A2                  AND     D               ;
16397   3160 CD FB 2F            CALL    L2FFB           ; routine ZEROS-4/5
16398   3163 07                  RLCA                    ;
16399   3164 77                  LD      (HL),A          ;
16400   3165 38 2E               JR      C,L3195         ; to OFLOW-CLR
16401   3167             
16402   3167 23                  INC     HL              ;
16403   3168 77                  LD      (HL),A          ;
16404   3169 2B                  DEC     HL              ;
16405   316A 18 29               JR      L3195           ; to OFLOW-CLR
16406   316C             
16407   316C             ; ---
16408   316C             
16409   316C             ;; NORMALISE
16410   316C 06 20       L316C:   LD      B,$20           ;
16411   316E             
16412   316E             ;; SHIFT-ONE
16413   316E D9          L316E:   EXX                     ;
16414   316F CB 7A               BIT     7,D             ;
16415   3171 D9                  EXX                     ;
16416   3172 20 12               JR      NZ,L3186        ; to NORML-NOW
16417   3174             
16418   3174 07                  RLCA                    ;
16419   3175 CB 13               RL      E               ;
16420   3177 CB 12               RL      D               ;
16421   3179 D9                  EXX                     ;
16422   317A CB 13               RL      E               ;
16423   317C CB 12               RL      D               ;
16424   317E D9                  EXX                     ;
16425   317F 35                  DEC     (HL)            ;
16426   3180 28 D7               JR      Z,L3159         ; to NEAR-ZERO
16427   3182             
16428   3182 10 EA               DJNZ    L316E           ; to SHIFT-ONE
16429   3184             
16430   3184 18 D7               JR      L315D           ; to ZERO-RSLT
16431   3186             
16432   3186             ; ---
16433   3186             
16434   3186             ;; NORML-NOW
16435   3186 17          L3186:   RLA                     ;
16436   3187 30 0C               JR      NC,L3195        ; to OFLOW-CLR
16437   3189             
16438   3189 CD 04 30            CALL    L3004           ; routine ADD-BACK
16439   318C 20 07               JR      NZ,L3195        ; to OFLOW-CLR
16440   318E             
16441   318E D9                  EXX                     ;
16442   318F 16 80               LD       D,$80          ;
16443   3191 D9                  EXX                     ;
16444   3192 34                  INC     (HL)            ;
16445   3193 28 18               JR      Z,L31AD         ; to REPORT-6
16446   3195             
16447   3195             ;; OFLOW-CLR
16448   3195 E5          L3195:   PUSH    HL              ;
16449   3196 23                  INC     HL              ;
16450   3197 D9                  EXX                     ;
16451   3198 D5                  PUSH    DE              ;
16452   3199 D9                  EXX                     ;
16453   319A C1                  POP     BC              ;
16454   319B 78                  LD      A,B             ;
16455   319C 17                  RLA                     ;
16456   319D CB 16               RL      (HL)            ;
16457   319F 1F                  RRA                     ;
16458   31A0 77                  LD      (HL),A          ;
16459   31A1 23                  INC     HL              ;
16460   31A2 71                  LD      (HL),C          ;
16461   31A3 23                  INC     HL              ;
16462   31A4 72                  LD      (HL),D          ;
16463   31A5 23                  INC     HL              ;
16464   31A6 73                  LD      (HL),E          ;
16465   31A7 E1                  POP     HL              ;
16466   31A8 D1                  POP     DE              ;
16467   31A9 D9                  EXX                     ;
16468   31AA E1                  POP     HL              ;
16469   31AB D9                  EXX                     ;
16470   31AC C9                  RET                     ;
16471   31AD             
16472   31AD             ; ---
16473   31AD             
16474   31AD             ;; REPORT-6
16475   31AD CF          L31AD:   RST     08H             ; ERROR-1
16476   31AE 05                  DEFB    $05             ; Error Report: Number too big
16477   31AF             
16478   31AF             ; ----------------------
16479   31AF             ; THE 'DIVISION' ROUTINE
16480   31AF             ; ----------------------
16481   31AF             ; (offset: $05 'division')
16482   31AF             ;
16483   31AF             ;   "He who can properly define and divide is to be considered a god"
16484   31AF             ;   - Plato,  429 - 347 B.C.
16485   31AF             
16486   31AF             ;; division
16487   31AF CD 93 32    L31AF:   CALL    L3293           ; routine RE-ST-TWO
16488   31B2 EB                  EX      DE,HL           ;
16489   31B3 AF                  XOR     A               ;
16490   31B4 CD C0 30            CALL    L30C0           ; routine PREP-M/D
16491   31B7 38 F4               JR      C,L31AD         ; to REPORT-6
16492   31B9             
16493   31B9 EB                  EX      DE,HL           ;
16494   31BA CD C0 30            CALL    L30C0           ; routine PREP-M/D
16495   31BD D8                  RET     C               ;
16496   31BE             
16497   31BE D9                  EXX                     ;
16498   31BF E5                  PUSH    HL              ;
16499   31C0 D9                  EXX                     ;
16500   31C1 D5                  PUSH    DE              ;
16501   31C2 E5                  PUSH    HL              ;
16502   31C3 CD BA 2F            CALL    L2FBA           ; routine FETCH-TWO
16503   31C6 D9                  EXX                     ;
16504   31C7 E5                  PUSH    HL              ;
16505   31C8 60                  LD      H,B             ;
16506   31C9 69                  LD      L,C             ;
16507   31CA D9                  EXX                     ;
16508   31CB 61                  LD      H,C             ;
16509   31CC 68                  LD      L,B             ;
16510   31CD AF                  XOR     A               ;
16511   31CE 06 DF               LD      B,$DF           ;
16512   31D0 18 10               JR      L31E2           ; to DIV-START
16513   31D2             
16514   31D2             ; ---
16515   31D2             
16516   31D2             ;; DIV-LOOP
16517   31D2 17          L31D2:   RLA                     ;
16518   31D3 CB 11               RL      C               ;
16519   31D5 D9                  EXX                     ;
16520   31D6 CB 11               RL      C               ;
16521   31D8 CB 10               RL      B               ;
16522   31DA D9                  EXX                     ;
16523   31DB             
16524   31DB             ;; div-34th
16525   31DB 29          L31DB:   ADD     HL,HL           ;
16526   31DC D9                  EXX                     ;
16527   31DD ED 6A               ADC     HL,HL           ;
16528   31DF D9                  EXX                     ;
16529   31E0 38 10               JR      C,L31F2         ; to SUBN-ONLY
16530   31E2             
16531   31E2             ;; DIV-START
16532   31E2 ED 52       L31E2:   SBC     HL,DE           ;
16533   31E4 D9                  EXX                     ;
16534   31E5 ED 52               SBC     HL,DE           ;
16535   31E7 D9                  EXX                     ;
16536   31E8 30 0F               JR      NC,L31F9        ; to NO-RSTORE
16537   31EA             
16538   31EA 19                  ADD     HL,DE           ;
16539   31EB D9                  EXX                     ;
16540   31EC ED 5A               ADC     HL,DE           ;
16541   31EE D9                  EXX                     ;
16542   31EF A7                  AND     A               ;
16543   31F0 18 08               JR      L31FA           ; to COUNT-ONE
16544   31F2             
16545   31F2             ; ---
16546   31F2             
16547   31F2             ;; SUBN-ONLY
16548   31F2 A7          L31F2:   AND     A               ;
16549   31F3 ED 52               SBC     HL,DE           ;
16550   31F5 D9                  EXX                     ;
16551   31F6 ED 52               SBC     HL,DE           ;
16552   31F8 D9                  EXX                     ;
16553   31F9             
16554   31F9             ;; NO-RSTORE
16555   31F9 37          L31F9:   SCF                     ; Set Carry Flag
16556   31FA             
16557   31FA             ;; COUNT-ONE
16558   31FA 04          L31FA:   INC     B               ;
16559   31FB FA D2 31            JP      M,L31D2         ; to DIV-LOOP
16560   31FE             
16561   31FE F5                  PUSH    AF              ;
16562   31FF 28 E1               JR      Z,L31E2         ; to DIV-START
16563   3201             
16564   3201             ;
16565   3201             ;
16566   3201             ;
16567   3201             ;
16568   3201             
16569   3201 5F                  LD      E,A             ;
16570   3202 51                  LD      D,C             ;
16571   3203 D9                  EXX                     ;
16572   3204 59                  LD      E,C             ;
16573   3205 50                  LD      D,B             ;
16574   3206 F1                  POP     AF              ;
16575   3207 CB 18               RR      B               ;
16576   3209 F1                  POP     AF              ;
16577   320A CB 18               RR      B               ;
16578   320C D9                  EXX                     ;
16579   320D C1                  POP     BC              ;
16580   320E E1                  POP     HL              ;
16581   320F 78                  LD      A,B             ;
16582   3210 91                  SUB     C               ;
16583   3211 C3 3D 31            JP      L313D           ; jump back to DIVN-EXPT
16584   3214             
16585   3214             ; ------------------------------------
16586   3214             ; Integer truncation towards zero ($3A)
16587   3214             ; ------------------------------------
16588   3214             ;
16589   3214             ;
16590   3214             
16591   3214             ;; truncate
16592   3214 7E          L3214:   LD      A,(HL)          ;
16593   3215 A7                  AND     A               ;
16594   3216 C8                  RET     Z               ;
16595   3217             
16596   3217 FE 81               CP      $81             ;
16597   3219 30 06               JR      NC,L3221        ; to T-GR-ZERO
16598   321B             
16599   321B 36 00               LD      (HL),$00        ;
16600   321D 3E 20               LD      A,$20           ;
16601   321F 18 51               JR      L3272           ; to NIL-BYTES
16602   3221             
16603   3221             ; ---
16604   3221             
16605   3221             ;; T-GR-ZERO
16606   3221 FE 91       L3221:   CP      $91             ;
16607   3223 20 1A               JR      NZ,L323F        ; to T-SMALL
16608   3225             
16609   3225 23                  INC     HL              ;
16610   3226 23                  INC     HL              ;
16611   3227 23                  INC     HL              ;
16612   3228 3E 80               LD      A,$80           ;
16613   322A A6                  AND     (HL)            ;
16614   322B 2B                  DEC     HL              ;
16615   322C B6                  OR      (HL)            ;
16616   322D 2B                  DEC     HL              ;
16617   322E 20 03               JR      NZ,L3233        ; to T-FIRST
16618   3230             
16619   3230 3E 80               LD      A,$80           ;
16620   3232 AE                  XOR     (HL)            ;
16621   3233             
16622   3233             ;; T-FIRST
16623   3233 2B          L3233:   DEC     HL              ;
16624   3234 20 36               JR      NZ,L326C        ; to T-EXPNENT
16625   3236             
16626   3236 77                  LD      (HL),A          ;
16627   3237 23                  INC     HL              ;
16628   3238 36 FF               LD      (HL),$FF        ;
16629   323A 2B                  DEC     HL              ;
16630   323B 3E 18               LD      A,$18           ;
16631   323D 18 33               JR      L3272           ; to NIL-BYTES
16632   323F             
16633   323F             ; ---
16634   323F             
16635   323F             ;; T-SMALL
16636   323F 30 2C       L323F:   JR      NC,L326D        ; to X-LARGE
16637   3241             
16638   3241 D5                  PUSH    DE              ;
16639   3242 2F                  CPL                     ;
16640   3243 C6 91               ADD     A,$91           ;
16641   3245 23                  INC     HL              ;
16642   3246 56                  LD      D,(HL)          ;
16643   3247 23                  INC     HL              ;
16644   3248 5E                  LD      E,(HL)          ;
16645   3249 2B                  DEC     HL              ;
16646   324A 2B                  DEC     HL              ;
16647   324B 0E 00               LD      C,$00           ;
16648   324D CB 7A               BIT     7,D             ;
16649   324F 28 01               JR      Z,L3252         ; to T-NUMERIC
16650   3251             
16651   3251 0D                  DEC     C               ;
16652   3252             
16653   3252             ;; T-NUMERIC
16654   3252 CB FA       L3252:   SET     7,D             ;
16655   3254 06 08               LD      B,$08           ;
16656   3256 90                  SUB     B               ;
16657   3257 80                  ADD     A,B             ;
16658   3258 38 04               JR      C,L325E         ; to T-TEST
16659   325A             
16660   325A 5A                  LD      E,D             ;
16661   325B 16 00               LD      D,$00           ;
16662   325D 90                  SUB     B               ;
16663   325E             
16664   325E             ;; T-TEST
16665   325E 28 07       L325E:   JR      Z,L3267         ; to T-STORE
16666   3260             
16667   3260 47                  LD      B,A             ;
16668   3261             
16669   3261             ;; T-SHIFT
16670   3261 CB 3A       L3261:   SRL     D               ;
16671   3263 CB 1B               RR      E               ;
16672   3265 10 FA               DJNZ    L3261           ; to T-SHIFT
16673   3267             
16674   3267             ;; T-STORE
16675   3267 CD 8E 2D    L3267:   CALL    L2D8E           ; routine INT-STORE
16676   326A D1                  POP     DE              ;
16677   326B C9                  RET                     ;
16678   326C             
16679   326C             ; ---
16680   326C             
16681   326C             ;; T-EXPNENT
16682   326C 7E          L326C:   LD      A,(HL)          ;
16683   326D             
16684   326D             ;; X-LARGE
16685   326D D6 A0       L326D:   SUB     $A0             ;
16686   326F F0                  RET     P               ;
16687   3270             
16688   3270 ED 44               NEG                     ; Negate
16689   3272             
16690   3272             ;; NIL-BYTES
16691   3272 D5          L3272:   PUSH    DE              ;
16692   3273 EB                  EX      DE,HL           ;
16693   3274 2B                  DEC     HL              ;
16694   3275 47                  LD      B,A             ;
16695   3276 CB 38               SRL     B               ;
16696   3278 CB 38               SRL     B               ;
16697   327A CB 38               SRL     B               ;
16698   327C 28 05               JR      Z,L3283         ; to BITS-ZERO
16699   327E             
16700   327E             ;; BYTE-ZERO
16701   327E 36 00       L327E:   LD      (HL),$00        ;
16702   3280 2B                  DEC     HL              ;
16703   3281 10 FB               DJNZ    L327E           ; to BYTE-ZERO
16704   3283             
16705   3283             ;; BITS-ZERO
16706   3283 E6 07       L3283:   AND     $07             ;
16707   3285 28 09               JR      Z,L3290         ; to IX-END
16708   3287             
16709   3287 47                  LD      B,A             ;
16710   3288 3E FF               LD      A,$FF           ;
16711   328A             
16712   328A             ;; LESS-MASK
16713   328A CB 27       L328A:   SLA     A               ;
16714   328C 10 FC               DJNZ    L328A           ; to LESS-MASK
16715   328E             
16716   328E A6                  AND     (HL)            ;
16717   328F 77                  LD      (HL),A          ;
16718   3290             
16719   3290             ;; IX-END
16720   3290 EB          L3290:   EX      DE,HL           ;
16721   3291 D1                  POP     DE              ;
16722   3292 C9                  RET                     ;
16723   3293             
16724   3293             ; ----------------------------------
16725   3293             ; Storage of numbers in 5 byte form.
16726   3293             ; ==================================
16727   3293             ; Both integers and floating-point numbers can be stored in five bytes.
16728   3293             ; Zero is a special case stored as 5 zeros.
16729   3293             ; For integers the form is
16730   3293             ; Byte 1 - zero,
16731   3293             ; Byte 2 - sign byte, $00 +ve, $FF -ve.
16732   3293             ; Byte 3 - Low byte of integer.
16733   3293             ; Byte 4 - High byte
16734   3293             ; Byte 5 - unused but always zero.
16735   3293             ;
16736   3293             ; it seems unusual to store the low byte first but it is just as easy either
16737   3293             ; way. Statistically it just increases the chances of trailing zeros which
16738   3293             ; is an advantage elsewhere in saving ROM code.
16739   3293             ;
16740   3293             ;             zero     sign     low      high    unused
16741   3293             ; So +1 is  00000000 00000000 00000001 00000000 00000000
16742   3293             ;
16743   3293             ; and -1 is 00000000 11111111 11111111 11111111 00000000
16744   3293             ;
16745   3293             ; much of the arithmetic found in BASIC lines can be done using numbers
16746   3293             ; in this form using the Z80's 16 bit register operation ADD.
16747   3293             ; (multiplication is done by a sequence of additions).
16748   3293             ;
16749   3293             ; Storing -ve integers in two's complement form, means that they are ready for
16750   3293             ; addition and you might like to add the numbers above to prove that the
16751   3293             ; answer is zero. If, as in this case, the carry is set then that denotes that
16752   3293             ; the result is positive. This only applies when the signs don't match.
16753   3293             ; With positive numbers a carry denotes the result is out of integer range.
16754   3293             ; With negative numbers a carry denotes the result is within range.
16755   3293             ; The exception to the last rule is when the result is -65536
16756   3293             ;
16757   3293             ; Floating point form is an alternative method of storing numbers which can
16758   3293             ; be used for integers and larger (or fractional) numbers.
16759   3293             ;
16760   3293             ; In this form 1 is stored as
16761   3293             ;           10000001 00000000 00000000 00000000 00000000
16762   3293             ;
16763   3293             ; When a small integer is converted to a floating point number the last two
16764   3293             ; bytes are always blank so they are omitted in the following steps
16765   3293             ;
16766   3293             ; first make exponent +1 +16d  (bit 7 of the exponent is set if positive)
16767   3293             
16768   3293             ; 10010001 00000000 00000001
16769   3293             ; 10010000 00000000 00000010 <-  now shift left and decrement exponent
16770   3293             ; ...
16771   3293             ; 10000010 01000000 00000000 <-  until a 1 abuts the imaginary point
16772   3293             ; 10000001 10000000 00000000     to the left of the mantissa.
16773   3293             ;
16774   3293             ; however since the leftmost bit of the mantissa is always set then it can
16775   3293             ; be used to denote the sign of the mantissa and put back when needed by the
16776   3293             ; PREP routines which gives
16777   3293             ;
16778   3293             ; 10000001 00000000 00000000
16779   3293             
16780   3293             ; ----------------------------------------------
16781   3293             ; THE 'RE-STACK TWO "SMALL" INTEGERS' SUBROUTINE
16782   3293             ; ----------------------------------------------
16783   3293             ;   This routine is called to re-stack two numbers in full floating point form
16784   3293             ;   e.g. from mult when integer multiplication has overflowed.
16785   3293             
16786   3293             ;; RE-ST-TWO
16787   3293 CD 96 32    L3293:   CALL    L3296           ; routine RESTK-SUB  below and continue
16788   3296                                             ; into the routine to do the other one.
16789   3296             
16790   3296             ;; RESTK-SUB
16791   3296 EB          L3296:   EX      DE,HL           ; swap pointers
16792   3297             
16793   3297             ; ---------------------------------------------
16794   3297             ; THE 'RE-STACK ONE "SMALL" INTEGER' SUBROUTINE
16795   3297             ; ---------------------------------------------
16796   3297             ; (offset: $3D 're-stack')
16797   3297             ;   This routine re-stacks an integer, usually on the calculator stack, in full 
16798   3297             ;   floating point form.  HL points to first byte.
16799   3297             
16800   3297             ;; re-stack
16801   3297 7E          L3297:   LD      A,(HL)          ; Fetch Exponent byte to A
16802   3298 A7                  AND     A               ; test it
16803   3299 C0                  RET     NZ              ; return if not zero as already in full
16804   329A                                             ; floating-point form.
16805   329A             
16806   329A D5                  PUSH    DE              ; preserve DE.
16807   329B CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH
16808   329E                                             ; integer to DE, sign to C.
16809   329E             
16810   329E             ; HL points to 4th byte.
16811   329E             
16812   329E AF                  XOR     A               ; clear accumulator.
16813   329F 23                  INC     HL              ; point to 5th.
16814   32A0 77                  LD      (HL),A          ; and blank.
16815   32A1 2B                  DEC     HL              ; point to 4th.
16816   32A2 77                  LD      (HL),A          ; and blank.
16817   32A3             
16818   32A3 06 91               LD      B,$91           ; set exponent byte +ve $81
16819   32A5                                             ; and imaginary dec point 16 bits to right
16820   32A5                                             ; of first bit.
16821   32A5             
16822   32A5             ;   we could skip to normalize now but it's quicker to avoid normalizing 
16823   32A5             ;   through an empty D.
16824   32A5             
16825   32A5 7A                  LD      A,D             ; fetch the high byte D
16826   32A6 A7                  AND     A               ; is it zero ?
16827   32A7 20 08               JR      NZ,L32B1        ; skip to RS-NRMLSE if not.
16828   32A9             
16829   32A9 B3                  OR      E               ; low byte E to A and test for zero
16830   32AA 42                  LD      B,D             ; set B exponent to 0
16831   32AB 28 10               JR      Z,L32BD         ; forward to RS-STORE if value is zero.
16832   32AD             
16833   32AD 53                  LD      D,E             ; transfer E to D
16834   32AE 58                  LD      E,B             ; set E to 0
16835   32AF 06 89               LD      B,$89           ; reduce the initial exponent by eight.
16836   32B1             
16837   32B1             
16838   32B1             ;; RS-NRMLSE
16839   32B1 EB          L32B1:   EX      DE,HL           ; integer to HL, addr of 4th byte to DE.
16840   32B2             
16841   32B2             ;; RSTK-LOOP
16842   32B2 05          L32B2:   DEC     B               ; decrease exponent
16843   32B3 29                  ADD     HL,HL           ; shift DE left
16844   32B4 30 FC               JR      NC,L32B2        ; loop back to RSTK-LOOP
16845   32B6                                             ; until a set bit pops into carry
16846   32B6             
16847   32B6 CB 09               RRC     C               ; now rotate the sign byte $00 or $FF
16848   32B8                                             ; into carry to give a sign bit
16849   32B8             
16850   32B8 CB 1C               RR      H               ; rotate the sign bit to left of H
16851   32BA CB 1D               RR      L               ; rotate any carry into L
16852   32BC             
16853   32BC EB                  EX      DE,HL           ; address 4th byte, normalized int to DE
16854   32BD             
16855   32BD             ;; RS-STORE
16856   32BD 2B          L32BD:   DEC     HL              ; address 3rd byte
16857   32BE 73                  LD      (HL),E          ; place E
16858   32BF 2B                  DEC     HL              ; address 2nd byte
16859   32C0 72                  LD      (HL),D          ; place D
16860   32C1 2B                  DEC     HL              ; address 1st byte
16861   32C2 70                  LD      (HL),B          ; store the exponent
16862   32C3             
16863   32C3 D1                  POP     DE              ; restore initial DE.
16864   32C4 C9                  RET                     ; return.
16865   32C5             
16866   32C5             ;****************************************
16867   32C5             ;** Part 10. FLOATING-POINT CALCULATOR **
16868   32C5             ;****************************************
16869   32C5             
16870   32C5             ; As a general rule the calculator avoids using the IY register.
16871   32C5             ; exceptions are val, val$ and str$.
16872   32C5             ; So an assembly language programmer who has disabled interrupts to use
16873   32C5             ; IY for other purposes can still use the calculator for mathematical
16874   32C5             ; purposes.
16875   32C5             
16876   32C5             
16877   32C5             ; ------------------------
16878   32C5             ; THE 'TABLE OF CONSTANTS'
16879   32C5             ; ------------------------
16880   32C5             ;
16881   32C5             ;
16882   32C5             
16883   32C5             ; used 11 times
16884   32C5             ;; stk-zero                                                 00 00 00 00 00
16885   32C5 00          L32C5:   DEFB    $00             ;;Bytes: 1
16886   32C6 B0                  DEFB    $B0             ;;Exponent $00
16887   32C7 00                  DEFB    $00             ;;(+00,+00,+00)
16888   32C8             
16889   32C8             ; used 19 times
16890   32C8             ;; stk-one                                                  00 00 01 00 00
16891   32C8 40          L32C8:   DEFB    $40             ;;Bytes: 2
16892   32C9 B0                  DEFB    $B0             ;;Exponent $00
16893   32CA 00 01               DEFB    $00,$01         ;;(+00,+00)
16894   32CC             
16895   32CC             ; used 9 times
16896   32CC             ;; stk-half                                                 80 00 00 00 00
16897   32CC 30          L32CC:   DEFB    $30             ;;Exponent: $80, Bytes: 1
16898   32CD 00                  DEFB    $00             ;;(+00,+00,+00)
16899   32CE             
16900   32CE             ; used 4 times.
16901   32CE             ;; stk-pi/2                                                 81 49 0F DA A2
16902   32CE F1          L32CE:   DEFB    $F1             ;;Exponent: $81, Bytes: 4
16903   32CF 49 0F DA A2         DEFB    $49,$0F,$DA,$A2 ;;
16904   32D3             
16905   32D3             ; used 3 times.
16906   32D3             ;; stk-ten                                                  00 00 0A 00 00
16907   32D3 40          L32D3:   DEFB    $40             ;;Bytes: 2
16908   32D4 B0                  DEFB    $B0             ;;Exponent $00
16909   32D5 00 0A               DEFB    $00,$0A         ;;(+00,+00)
16910   32D7             
16911   32D7             
16912   32D7             ; ------------------------
16913   32D7             ; THE 'TABLE OF ADDRESSES'
16914   32D7             ; ------------------------
16915   32D7             ;  "Each problem that I solved became a rule which served afterwards to solve 
16916   32D7             ;   other problems" - Rene Descartes 1596 - 1650.
16917   32D7             ;
16918   32D7             ;   Starts with binary operations which have two operands and one result.
16919   32D7             ;   Three pseudo binary operations first.
16920   32D7             
16921   32D7             ;; tbl-addrs
16922   32D7 8F 36       L32D7:   DEFW    L368F           ; $00 Address: $368F - jump-true
16923   32D9 3C 34               DEFW    L343C           ; $01 Address: $343C - exchange
16924   32DB A1 33               DEFW    L33A1           ; $02 Address: $33A1 - delete
16925   32DD             
16926   32DD             ;   True binary operations.
16927   32DD             
16928   32DD 0F 30               DEFW    L300F           ; $03 Address: $300F - subtract
16929   32DF CA 30               DEFW    L30CA           ; $04 Address: $30CA - multiply
16930   32E1 AF 31               DEFW    L31AF           ; $05 Address: $31AF - division
16931   32E3 51 38               DEFW    L3851           ; $06 Address: $3851 - to-power
16932   32E5 1B 35               DEFW    L351B           ; $07 Address: $351B - or
16933   32E7             
16934   32E7 24 35               DEFW    L3524           ; $08 Address: $3524 - no-&-no
16935   32E9 3B 35               DEFW    L353B           ; $09 Address: $353B - no-l-eql
16936   32EB 3B 35               DEFW    L353B           ; $0A Address: $353B - no-gr-eql
16937   32ED 3B 35               DEFW    L353B           ; $0B Address: $353B - nos-neql
16938   32EF 3B 35               DEFW    L353B           ; $0C Address: $353B - no-grtr
16939   32F1 3B 35               DEFW    L353B           ; $0D Address: $353B - no-less
16940   32F3 3B 35               DEFW    L353B           ; $0E Address: $353B - nos-eql
16941   32F5 14 30               DEFW    L3014           ; $0F Address: $3014 - addition
16942   32F7             
16943   32F7 2D 35               DEFW    L352D           ; $10 Address: $352D - str-&-no
16944   32F9 3B 35               DEFW    L353B           ; $11 Address: $353B - str-l-eql
16945   32FB 3B 35               DEFW    L353B           ; $12 Address: $353B - str-gr-eql
16946   32FD 3B 35               DEFW    L353B           ; $13 Address: $353B - strs-neql
16947   32FF 3B 35               DEFW    L353B           ; $14 Address: $353B - str-grtr
16948   3301 3B 35               DEFW    L353B           ; $15 Address: $353B - str-less
16949   3303 3B 35               DEFW    L353B           ; $16 Address: $353B - strs-eql
16950   3305 9C 35               DEFW    L359C           ; $17 Address: $359C - strs-add
16951   3307             
16952   3307             ;   Unary follow.
16953   3307             
16954   3307 DE 35               DEFW    L35DE           ; $18 Address: $35DE - val$
16955   3309 BC 34               DEFW    L34BC           ; $19 Address: $34BC - usr-$
16956   330B 45 36               DEFW    L3645           ; $1A Address: $3645 - read-in
16957   330D 6E 34               DEFW    L346E           ; $1B Address: $346E - negate
16958   330F             
16959   330F 69 36               DEFW    L3669           ; $1C Address: $3669 - code
16960   3311 DE 35               DEFW    L35DE           ; $1D Address: $35DE - val
16961   3313 74 36               DEFW    L3674           ; $1E Address: $3674 - len
16962   3315 B5 37               DEFW    L37B5           ; $1F Address: $37B5 - sin
16963   3317 AA 37               DEFW    L37AA           ; $20 Address: $37AA - cos
16964   3319 DA 37               DEFW    L37DA           ; $21 Address: $37DA - tan
16965   331B 33 38               DEFW    L3833           ; $22 Address: $3833 - asn
16966   331D 43 38               DEFW    L3843           ; $23 Address: $3843 - acs
16967   331F E2 37               DEFW    L37E2           ; $24 Address: $37E2 - atn
16968   3321 13 37               DEFW    L3713           ; $25 Address: $3713 - ln
16969   3323 C4 36               DEFW    L36C4           ; $26 Address: $36C4 - exp
16970   3325 AF 36               DEFW    L36AF           ; $27 Address: $36AF - int
16971   3327 4A 38               DEFW    L384A           ; $28 Address: $384A - sqr
16972   3329 92 34               DEFW    L3492           ; $29 Address: $3492 - sgn
16973   332B 6A 34               DEFW    L346A           ; $2A Address: $346A - abs
16974   332D AC 34               DEFW    L34AC           ; $2B Address: $34AC - peek
16975   332F A5 34               DEFW    L34A5           ; $2C Address: $34A5 - in
16976   3331 B3 34               DEFW    L34B3           ; $2D Address: $34B3 - usr-no
16977   3333 1F 36               DEFW    L361F           ; $2E Address: $361F - str$
16978   3335 C9 35               DEFW    L35C9           ; $2F Address: $35C9 - chrs
16979   3337 01 35               DEFW    L3501           ; $30 Address: $3501 - not
16980   3339             
16981   3339             ;   End of true unary.
16982   3339             
16983   3339 C0 33               DEFW    L33C0           ; $31 Address: $33C0 - duplicate
16984   333B A0 36               DEFW    L36A0           ; $32 Address: $36A0 - n-mod-m
16985   333D 86 36               DEFW    L3686           ; $33 Address: $3686 - jump
16986   333F C6 33               DEFW    L33C6           ; $34 Address: $33C6 - stk-data
16987   3341 7A 36               DEFW    L367A           ; $35 Address: $367A - dec-jr-nz
16988   3343 06 35               DEFW    L3506           ; $36 Address: $3506 - less-0
16989   3345 F9 34               DEFW    L34F9           ; $37 Address: $34F9 - greater-0
16990   3347 9B 36               DEFW    L369B           ; $38 Address: $369B - end-calc
16991   3349 83 37               DEFW    L3783           ; $39 Address: $3783 - get-argt
16992   334B 14 32               DEFW    L3214           ; $3A Address: $3214 - truncate
16993   334D A2 33               DEFW    L33A2           ; $3B Address: $33A2 - fp-calc-2
16994   334F 4F 2D               DEFW    L2D4F           ; $3C Address: $2D4F - e-to-fp
16995   3351 97 32               DEFW    L3297           ; $3D Address: $3297 - re-stack
16996   3353             
16997   3353             ;   The following are just the next available slots for the 128 compound 
16998   3353             ;   literals which are in range $80 - $FF.
16999   3353             
17000   3353 49 34               DEFW    L3449           ;     Address: $3449 - series-xx    $80 - $9F.
17001   3355 1B 34               DEFW    L341B           ;     Address: $341B - stk-const-xx $A0 - $BF.
17002   3357 2D 34               DEFW    L342D           ;     Address: $342D - st-mem-xx    $C0 - $DF.
17003   3359 0F 34               DEFW    L340F           ;     Address: $340F - get-mem-xx   $E0 - $FF.
17004   335B             
17005   335B             ;   Aside: 3E - 3F are therefore unused calculator literals.
17006   335B             ;   If the literal has to be also usable as a function then bits 6 and 7 are 
17007   335B             ;   used to show type of arguments and result.
17008   335B             
17009   335B             ; --------------
17010   335B             ; The Calculator
17011   335B             ; --------------
17012   335B             ;  "A good calculator does not need artificial aids"
17013   335B             ;  Lao Tze 604 - 531 B.C.
17014   335B             
17015   335B             ;; CALCULATE
17016   335B CD BF 35    L335B:   CALL    L35BF           ; routine STK-PNTRS is called to set up the
17017   335E                                             ; calculator stack pointers for a default
17018   335E                                             ; unary operation. HL = last value on stack.
17019   335E                                             ; DE = STKEND first location after stack.
17020   335E             
17021   335E             ; the calculate routine is called at this point by the series generator...
17022   335E             
17023   335E             ;; GEN-ENT-1
17024   335E 78          L335E:   LD      A,B             ; fetch the Z80 B register to A
17025   335F 32 67 5C            LD      ($5C67),A       ; and store value in system variable BREG.
17026   3362                                             ; this will be the counter for dec-jr-nz
17027   3362                                             ; or if used from fp-calc2 the calculator
17028   3362                                             ; instruction.
17029   3362             
17030   3362             ; ... and again later at this point
17031   3362             
17032   3362             ;; GEN-ENT-2
17033   3362 D9          L3362:   EXX                     ; switch sets
17034   3363 E3                  EX      (SP),HL         ; and store the address of next instruction,
17035   3364                                             ; the return address, in H'L'.
17036   3364                                             ; If this is a recursive call the H'L'
17037   3364                                             ; of the previous invocation goes on stack.
17038   3364                                             ; c.f. end-calc.
17039   3364 D9                  EXX                     ; switch back to main set
17040   3365             
17041   3365             ; this is the re-entry looping point when handling a string of literals.
17042   3365             
17043   3365             ;; RE-ENTRY
17044   3365 ED 53 65 5C L3365:   LD      ($5C65),DE      ; save end of stack in system variable STKEND
17045   3369 D9                  EXX                     ; switch to alt
17046   336A 7E                  LD      A,(HL)          ; get next literal
17047   336B 23                  INC     HL              ; increase pointer'
17048   336C             
17049   336C             ; single operation jumps back to here
17050   336C             
17051   336C             ;; SCAN-ENT
17052   336C E5          L336C:   PUSH    HL              ; save pointer on stack
17053   336D A7                  AND     A               ; now test the literal
17054   336E F2 80 33            JP      P,L3380         ; forward to FIRST-3D if in range $00 - $3D
17055   3371                                             ; anything with bit 7 set will be one of
17056   3371                                             ; 128 compound literals.
17057   3371             
17058   3371             ; compound literals have the following format.
17059   3371             ; bit 7 set indicates compound.
17060   3371             ; bits 6-5 the subgroup 0-3.
17061   3371             ; bits 4-0 the embedded parameter $00 - $1F.
17062   3371             ; The subgroup 0-3 needs to be manipulated to form the next available four
17063   3371             ; address places after the simple literals in the address table.
17064   3371             
17065   3371 57                  LD      D,A             ; save literal in D
17066   3372 E6 60               AND     $60             ; and with 01100000 to isolate subgroup
17067   3374 0F                  RRCA                    ; rotate bits
17068   3375 0F                  RRCA                    ; 4 places to right
17069   3376 0F                  RRCA                    ; not five as we need offset * 2
17070   3377 0F                  RRCA                    ; 00000xx0
17071   3378 C6 7C               ADD     A,$7C           ; add ($3E * 2) to give correct offset.
17072   337A                                             ; alter above if you add more literals.
17073   337A 6F                  LD      L,A             ; store in L for later indexing.
17074   337B 7A                  LD      A,D             ; bring back compound literal
17075   337C E6 1F               AND     $1F             ; use mask to isolate parameter bits
17076   337E 18 0E               JR      L338E           ; forward to ENT-TABLE
17077   3380             
17078   3380             ; ---
17079   3380             
17080   3380             ; the branch was here with simple literals.
17081   3380             
17082   3380             ;; FIRST-3D
17083   3380 FE 18       L3380:   CP      $18             ; compare with first unary operations.
17084   3382 30 08               JR      NC,L338C        ; to DOUBLE-A with unary operations
17085   3384             
17086   3384             ; it is binary so adjust pointers.
17087   3384             
17088   3384 D9                  EXX                     ;
17089   3385 01 FB FF            LD      BC,$FFFB        ; the value -5
17090   3388 54                  LD      D,H             ; transfer HL, the last value, to DE.
17091   3389 5D                  LD      E,L             ;
17092   338A 09                  ADD     HL,BC           ; subtract 5 making HL point to second
17093   338B                                             ; value.
17094   338B D9                  EXX                     ;
17095   338C             
17096   338C             ;; DOUBLE-A
17097   338C 07          L338C:   RLCA                    ; double the literal
17098   338D 6F                  LD      L,A             ; and store in L for indexing
17099   338E             
17100   338E             ;; ENT-TABLE
17101   338E 11 D7 32    L338E:   LD      DE,L32D7        ; Address: tbl-addrs
17102   3391 26 00               LD      H,$00           ; prepare to index
17103   3393 19                  ADD     HL,DE           ; add to get address of routine
17104   3394 5E                  LD      E,(HL)          ; low byte to E
17105   3395 23                  INC     HL              ;
17106   3396 56                  LD      D,(HL)          ; high byte to D
17107   3397 21 65 33            LD      HL,L3365        ; Address: RE-ENTRY
17108   339A E3                  EX      (SP),HL         ; goes to stack
17109   339B D5                  PUSH    DE              ; now address of routine
17110   339C D9                  EXX                     ; main set
17111   339D                                             ; avoid using IY register.
17112   339D ED 4B 66 5C         LD      BC,($5C66)      ; STKEND_hi
17113   33A1                                             ; nothing much goes to C but BREG to B
17114   33A1                                             ; and continue into next ret instruction
17115   33A1                                             ; which has a dual identity
17116   33A1             
17117   33A1             
17118   33A1             ; ------------------
17119   33A1             ; Handle delete (02)
17120   33A1             ; ------------------
17121   33A1             ; A simple return but when used as a calculator literal this
17122   33A1             ; deletes the last value from the calculator stack.
17123   33A1             ; On entry, as always with binary operations,
17124   33A1             ; HL=first number, DE=second number
17125   33A1             ; On exit, HL=result, DE=stkend.
17126   33A1             ; So nothing to do
17127   33A1             
17128   33A1             ;; delete
17129   33A1 C9          L33A1:   RET                     ; return - indirect jump if from above.
17130   33A2             
17131   33A2             ; ---------------------
17132   33A2             ; Single operation (3B)
17133   33A2             ; ---------------------
17134   33A2             ;   This single operation is used, in the first instance, to evaluate most
17135   33A2             ;   of the mathematical and string functions found in BASIC expressions.
17136   33A2             
17137   33A2             ;; fp-calc-2
17138   33A2 F1          L33A2:   POP     AF              ; drop return address.
17139   33A3 3A 67 5C            LD      A,($5C67)       ; load accumulator from system variable BREG
17140   33A6                                             ; value will be literal e.g. 'tan'
17141   33A6 D9                  EXX                     ; switch to alt
17142   33A7 18 C3               JR      L336C           ; back to SCAN-ENT
17143   33A9                                             ; next literal will be end-calc at L2758
17144   33A9             
17145   33A9             ; ---------------------------------
17146   33A9             ; THE 'TEST FIVE SPACES' SUBROUTINE
17147   33A9             ; ---------------------------------
17148   33A9             ;   This routine is called from MOVE-FP, STK-CONST and STK-STORE to test that 
17149   33A9             ;   there is enough space between the calculator stack and the machine stack 
17150   33A9             ;   for another five-byte value.  It returns with BC holding the value 5 ready 
17151   33A9             ;   for any subsequent LDIR.
17152   33A9             
17153   33A9             ;; TEST-5-SP
17154   33A9 D5          L33A9:   PUSH    DE              ; save
17155   33AA E5                  PUSH    HL              ; registers
17156   33AB 01 05 00            LD      BC,$0005        ; an overhead of five bytes
17157   33AE CD 05 1F            CALL    L1F05           ; routine TEST-ROOM tests free RAM raising
17158   33B1                                             ; an error if not.
17159   33B1 E1                  POP     HL              ; else restore
17160   33B2 D1                  POP     DE              ; registers.
17161   33B3 C9                  RET                     ; return with BC set at 5.
17162   33B4             
17163   33B4             ; -----------------------------
17164   33B4             ; THE 'STACK NUMBER' SUBROUTINE
17165   33B4             ; -----------------------------
17166   33B4             ;   This routine is called to stack a hidden floating point number found in
17167   33B4             ;   a BASIC line.  It is also called to stack a numeric variable value, and
17168   33B4             ;   from BEEP, to stack an entry in the semi-tone table.  It is not part of the
17169   33B4             ;   calculator suite of routines.  On entry, HL points to the number to be 
17170   33B4             ;   stacked.
17171   33B4             
17172   33B4             ;; STACK-NUM
17173   33B4 ED 5B 65 5C L33B4:   LD      DE,($5C65)      ; Load destination from STKEND system variable.
17174   33B8             
17175   33B8 CD C0 33            CALL    L33C0           ; Routine MOVE-FP puts on calculator stack 
17176   33BB                                             ; with a memory check.
17177   33BB ED 53 65 5C         LD      ($5C65),DE      ; Set STKEND to next free location.
17178   33BF             
17179   33BF C9                  RET                     ; Return.
17180   33C0             
17181   33C0             ; ---------------------------------
17182   33C0             ; Move a floating point number (31)
17183   33C0             ; ---------------------------------
17184   33C0             
17185   33C0             ; This simple routine is a 5-byte LDIR instruction
17186   33C0             ; that incorporates a memory check.
17187   33C0             ; When used as a calculator literal it duplicates the last value on the
17188   33C0             ; calculator stack.
17189   33C0             ; Unary so on entry HL points to last value, DE to stkend
17190   33C0             
17191   33C0             ;; duplicate
17192   33C0             ;; MOVE-FP
17193   33C0 CD A9 33    L33C0:   CALL    L33A9           ; routine TEST-5-SP test free memory
17194   33C3                                             ; and sets BC to 5.
17195   33C3 ED B0               LDIR                    ; copy the five bytes.
17196   33C5 C9                  RET                     ; return with DE addressing new STKEND
17197   33C6                                             ; and HL addressing new last value.
17198   33C6             
17199   33C6             ; -------------------
17200   33C6             ; Stack literals ($34)
17201   33C6             ; -------------------
17202   33C6             ; When a calculator subroutine needs to put a value on the calculator
17203   33C6             ; stack that is not a regular constant this routine is called with a
17204   33C6             ; variable number of following data bytes that convey to the routine
17205   33C6             ; the integer or floating point form as succinctly as is possible.
17206   33C6             
17207   33C6             ;; stk-data
17208   33C6 62          L33C6:   LD      H,D             ; transfer STKEND
17209   33C7 6B                  LD      L,E             ; to HL for result.
17210   33C8             
17211   33C8             ;; STK-CONST
17212   33C8 CD A9 33    L33C8:   CALL    L33A9           ; routine TEST-5-SP tests that room exists
17213   33CB                                             ; and sets BC to $05.
17214   33CB             
17215   33CB D9                  EXX                     ; switch to alternate set
17216   33CC E5                  PUSH    HL              ; save the pointer to next literal on stack
17217   33CD D9                  EXX                     ; switch back to main set
17218   33CE             
17219   33CE E3                  EX      (SP),HL         ; pointer to HL, destination to stack.
17220   33CF             
17221   33CF C5                  PUSH    BC              ; save BC - value 5 from test room ??.
17222   33D0             
17223   33D0 7E                  LD      A,(HL)          ; fetch the byte following 'stk-data'
17224   33D1 E6 C0               AND     $C0             ; isolate bits 7 and 6
17225   33D3 07                  RLCA                    ; rotate
17226   33D4 07                  RLCA                    ; to bits 1 and 0  range $00 - $03.
17227   33D5 4F                  LD      C,A             ; transfer to C
17228   33D6 0C                  INC     C               ; and increment to give number of bytes
17229   33D7                                             ; to read. $01 - $04
17230   33D7 7E                  LD      A,(HL)          ; reload the first byte
17231   33D8 E6 3F               AND     $3F             ; mask off to give possible exponent.
17232   33DA 20 02               JR      NZ,L33DE        ; forward to FORM-EXP if it was possible to
17233   33DC                                             ; include the exponent.
17234   33DC             
17235   33DC             ; else byte is just a byte count and exponent comes next.
17236   33DC             
17237   33DC 23                  INC     HL              ; address next byte and
17238   33DD 7E                  LD      A,(HL)          ; pick up the exponent ( - $50).
17239   33DE             
17240   33DE             ;; FORM-EXP
17241   33DE C6 50       L33DE:   ADD     A,$50           ; now add $50 to form actual exponent
17242   33E0 12                  LD      (DE),A          ; and load into first destination byte.
17243   33E1 3E 05               LD      A,$05           ; load accumulator with $05 and
17244   33E3 91                  SUB     C               ; subtract C to give count of trailing
17245   33E4                                             ; zeros plus one.
17246   33E4 23                  INC     HL              ; increment source
17247   33E5 13                  INC     DE              ; increment destination
17248   33E6 06 00               LD      B,$00           ; prepare to copy
17249   33E8 ED B0               LDIR                    ; copy C bytes
17250   33EA             
17251   33EA C1                  POP     BC              ; restore 5 counter to BC ??.
17252   33EB             
17253   33EB E3                  EX      (SP),HL         ; put HL on stack as next literal pointer
17254   33EC                                             ; and the stack value - result pointer -
17255   33EC                                             ; to HL.
17256   33EC             
17257   33EC D9                  EXX                     ; switch to alternate set.
17258   33ED E1                  POP     HL              ; restore next literal pointer from stack
17259   33EE                                             ; to H'L'.
17260   33EE D9                  EXX                     ; switch back to main set.
17261   33EF             
17262   33EF 47                  LD      B,A             ; zero count to B
17263   33F0 AF                  XOR     A               ; clear accumulator
17264   33F1             
17265   33F1             ;; STK-ZEROS
17266   33F1 05          L33F1:   DEC     B               ; decrement B counter
17267   33F2 C8                  RET     Z               ; return if zero.          >>
17268   33F3                                             ; DE points to new STKEND
17269   33F3                                             ; HL to new number.
17270   33F3             
17271   33F3 12                  LD      (DE),A          ; else load zero to destination
17272   33F4 13                  INC     DE              ; increase destination
17273   33F5 18 FA               JR      L33F1           ; loop back to STK-ZEROS until done.
17274   33F7             
17275   33F7             ; -------------------------------
17276   33F7             ; THE 'SKIP CONSTANTS' SUBROUTINE
17277   33F7             ; -------------------------------
17278   33F7             ;   This routine traverses variable-length entries in the table of constants,
17279   33F7             ;   stacking intermediate, unwanted constants onto a dummy calculator stack,
17280   33F7             ;   in the first five bytes of ROM.  The destination DE normally points to the
17281   33F7             ;   end of the calculator stack which might be in the normal place or in the
17282   33F7             ;   system variables area during E-LINE-NO; INT-TO-FP; stk-ten.  In any case,
17283   33F7             ;   it would be simpler all round if the routine just shoved unwanted values 
17284   33F7             ;   where it is going to stick the wanted value.  The instruction LD DE, $0000 
17285   33F7             ;   can be removed.
17286   33F7             
17287   33F7             ;; SKIP-CONS
17288   33F7 A7          L33F7:   AND     A               ; test if initially zero.
17289   33F8             
17290   33F8             ;; SKIP-NEXT
17291   33F8 C8          L33F8:   RET     Z               ; return if zero.          >>
17292   33F9             
17293   33F9 F5                  PUSH    AF              ; save count.
17294   33FA D5                  PUSH    DE              ; and normal STKEND
17295   33FB             
17296   33FB 11 00 00            LD      DE,$0000        ; dummy value for STKEND at start of ROM
17297   33FE                                             ; Note. not a fault but this has to be
17298   33FE                                             ; moved elsewhere when running in RAM.
17299   33FE                                             ; e.g. with Expandor Systems 'Soft ROM'.
17300   33FE                                             ; Better still, write to the normal place.
17301   33FE CD C8 33            CALL    L33C8           ; routine STK-CONST works through variable
17302   3401                                             ; length records.
17303   3401             
17304   3401 D1                  POP     DE              ; restore real STKEND
17305   3402 F1                  POP     AF              ; restore count
17306   3403 3D                  DEC     A               ; decrease
17307   3404 18 F2               JR      L33F8           ; loop back to SKIP-NEXT
17308   3406             
17309   3406             ; ------------------------------
17310   3406             ; THE 'LOCATE MEMORY' SUBROUTINE
17311   3406             ; ------------------------------
17312   3406             ;   This routine, when supplied with a base address in HL and an index in A,
17313   3406             ;   will calculate the address of the A'th entry, where each entry occupies
17314   3406             ;   five bytes.  It is used for reading the semi-tone table and addressing
17315   3406             ;   floating-point numbers in the calculator's memory area.
17316   3406             ;   It is not possible to use this routine for the table of constants as these
17317   3406             ;   six values are held in compressed format.
17318   3406             
17319   3406             ;; LOC-MEM
17320   3406 4F          L3406:   LD      C,A             ; store the original number $00-$1F.
17321   3407 07                  RLCA                    ; X2 - double.
17322   3408 07                  RLCA                    ; X4 - quadruple.
17323   3409 81                  ADD     A,C             ; X5 - now add original to multiply by five.
17324   340A             
17325   340A 4F                  LD      C,A             ; place the result in the low byte.
17326   340B 06 00               LD      B,$00           ; set high byte to zero.
17327   340D 09                  ADD     HL,BC           ; add to form address of start of number in HL.
17328   340E             
17329   340E C9                  RET                     ; return.
17330   340F             
17331   340F             ; ------------------------------
17332   340F             ; Get from memory area ($E0 etc.)
17333   340F             ; ------------------------------
17334   340F             ; Literals $E0 to $FF
17335   340F             ; A holds $00-$1F offset.
17336   340F             ; The calculator stack increases by 5 bytes.
17337   340F             
17338   340F             ;; get-mem-xx
17339   340F D5          L340F:   PUSH    DE              ; save STKEND
17340   3410 2A 68 5C            LD      HL,($5C68)      ; MEM is base address of the memory cells.
17341   3413 CD 06 34            CALL    L3406           ; routine LOC-MEM so that HL = first byte
17342   3416 CD C0 33            CALL    L33C0           ; routine MOVE-FP moves 5 bytes with memory
17343   3419                                             ; check.
17344   3419                                             ; DE now points to new STKEND.
17345   3419 E1                  POP     HL              ; original STKEND is now RESULT pointer.
17346   341A C9                  RET                     ; return.
17347   341B             
17348   341B             ; --------------------------
17349   341B             ; Stack a constant (A0 etc.)
17350   341B             ; --------------------------
17351   341B             ; This routine allows a one-byte instruction to stack up to 32 constants
17352   341B             ; held in short form in a table of constants. In fact only 5 constants are
17353   341B             ; required. On entry the A register holds the literal ANDed with 1F.
17354   341B             ; It isn't very efficient and it would have been better to hold the
17355   341B             ; numbers in full, five byte form and stack them in a similar manner
17356   341B             ; to that used for semi-tone table values.
17357   341B             
17358   341B             ;; stk-const-xx
17359   341B 62          L341B:   LD      H,D             ; save STKEND - required for result
17360   341C 6B                  LD      L,E             ;
17361   341D D9                  EXX                     ; swap
17362   341E E5                  PUSH    HL              ; save pointer to next literal
17363   341F 21 C5 32            LD      HL,L32C5        ; Address: stk-zero - start of table of
17364   3422                                             ; constants
17365   3422 D9                  EXX                     ;
17366   3423 CD F7 33            CALL    L33F7           ; routine SKIP-CONS
17367   3426 CD C8 33            CALL    L33C8           ; routine STK-CONST
17368   3429 D9                  EXX                     ;
17369   342A E1                  POP     HL              ; restore pointer to next literal.
17370   342B D9                  EXX                     ;
17371   342C C9                  RET                     ; return.
17372   342D             
17373   342D             ; --------------------------------
17374   342D             ; Store in a memory area ($C0 etc.)
17375   342D             ; --------------------------------
17376   342D             ; Offsets $C0 to $DF
17377   342D             ; Although 32 memory storage locations can be addressed, only six
17378   342D             ; $C0 to $C5 are required by the ROM and only the thirty bytes (6*5)
17379   342D             ; required for these are allocated. Spectrum programmers who wish to
17380   342D             ; use the floating point routines from assembly language may wish to
17381   342D             ; alter the system variable MEM to point to 160 bytes of RAM to have 
17382   342D             ; use the full range available.
17383   342D             ; A holds the derived offset $00-$1F.
17384   342D             ; This is a unary operation, so on entry HL points to the last value and DE 
17385   342D             ; points to STKEND.
17386   342D             
17387   342D             ;; st-mem-xx
17388   342D E5          L342D:   PUSH    HL              ; save the result pointer.
17389   342E EB                  EX      DE,HL           ; transfer to DE.
17390   342F 2A 68 5C            LD      HL,($5C68)      ; fetch MEM the base of memory area.
17391   3432 CD 06 34            CALL    L3406           ; routine LOC-MEM sets HL to the destination.
17392   3435 EB                  EX      DE,HL           ; swap - HL is start, DE is destination.
17393   3436 CD C0 33            CALL    L33C0           ; routine MOVE-FP.
17394   3439                                             ; note. a short ld bc,5; ldir
17395   3439                                             ; the embedded memory check is not required
17396   3439                                             ; so these instructions would be faster.
17397   3439 EB                  EX      DE,HL           ; DE = STKEND
17398   343A E1                  POP     HL              ; restore original result pointer
17399   343B C9                  RET                     ; return.
17400   343C             
17401   343C             ; -------------------------
17402   343C             ; THE 'EXCHANGE' SUBROUTINE
17403   343C             ; -------------------------
17404   343C             ; (offset: $01 'exchange')
17405   343C             ;   This routine swaps the last two values on the calculator stack.
17406   343C             ;   On entry, as always with binary operations,
17407   343C             ;   HL=first number, DE=second number
17408   343C             ;   On exit, HL=result, DE=stkend.
17409   343C             
17410   343C             ;; exchange
17411   343C 06 05       L343C:   LD      B,$05           ; there are five bytes to be swapped
17412   343E             
17413   343E             ; start of loop.
17414   343E             
17415   343E             ;; SWAP-BYTE
17416   343E 1A          L343E:   LD      A,(DE)          ; each byte of second
17417   343F 4E                  LD      C,(HL)          ; each byte of first
17418   3440 EB                  EX      DE,HL           ; swap pointers
17419   3441 12                  LD      (DE),A          ; store each byte of first
17420   3442 71                  LD      (HL),C          ; store each byte of second
17421   3443 23                  INC     HL              ; advance both
17422   3444 13                  INC     DE              ; pointers.
17423   3445 10 F7               DJNZ    L343E           ; loop back to SWAP-BYTE until all 5 done.
17424   3447             
17425   3447 EB                  EX      DE,HL           ; even up the exchanges so that DE addresses 
17426   3448                                             ; STKEND.
17427   3448             
17428   3448 C9                  RET                     ; return.
17429   3449             
17430   3449             ; ------------------------------
17431   3449             ; THE 'SERIES GENERATOR' ROUTINE
17432   3449             ; ------------------------------
17433   3449             ; (offset: $86 'series-06')
17434   3449             ; (offset: $88 'series-08')
17435   3449             ; (offset: $8C 'series-0C')
17436   3449             ;   The Spectrum uses Chebyshev polynomials to generate approximations for
17437   3449             ;   SIN, ATN, LN and EXP.  These are named after the Russian mathematician
17438   3449             ;   Pafnuty Chebyshev, born in 1821, who did much pioneering work on numerical
17439   3449             ;   series.  As far as calculators are concerned, Chebyshev polynomials have an
17440   3449             ;   advantage over other series, for example the Taylor series, as they can
17441   3449             ;   reach an approximation in just six iterations for SIN, eight for EXP and
17442   3449             ;   twelve for LN and ATN.  The mechanics of the routine are interesting but
17443   3449             ;   for full treatment of how these are generated with demonstrations in
17444   3449             ;   Sinclair BASIC see "The Complete Spectrum ROM Disassembly" by Dr Ian Logan
17445   3449             ;   and Dr Frank O'Hara, published 1983 by Melbourne House.
17446   3449             
17447   3449             ;; series-xx
17448   3449 47          L3449:   LD      B,A             ; parameter $00 - $1F to B counter
17449   344A CD 5E 33            CALL    L335E           ; routine GEN-ENT-1 is called.
17450   344D                                             ; A recursive call to a special entry point
17451   344D                                             ; in the calculator that puts the B register
17452   344D                                             ; in the system variable BREG. The return
17453   344D                                             ; address is the next location and where
17454   344D                                             ; the calculator will expect its first
17455   344D                                             ; instruction - now pointed to by HL'.
17456   344D                                             ; The previous pointer to the series of
17457   344D                                             ; five-byte numbers goes on the machine stack.
17458   344D             
17459   344D             ; The initialization phase.
17460   344D             
17461   344D 31                  DEFB    $31             ;;duplicate       x,x
17462   344E 0F                  DEFB    $0F             ;;addition        x+x
17463   344F C0                  DEFB    $C0             ;;st-mem-0        x+x
17464   3450 02                  DEFB    $02             ;;delete          .
17465   3451 A0                  DEFB    $A0             ;;stk-zero        0
17466   3452 C2                  DEFB    $C2             ;;st-mem-2        0
17467   3453             
17468   3453             ; a loop is now entered to perform the algebraic calculation for each of
17469   3453             ; the numbers in the series
17470   3453             
17471   3453             ;; G-LOOP
17472   3453 31          L3453:   DEFB    $31             ;;duplicate       v,v.
17473   3454 E0                  DEFB    $E0             ;;get-mem-0       v,v,x+2
17474   3455 04                  DEFB    $04             ;;multiply        v,v*x+2
17475   3456 E2                  DEFB    $E2             ;;get-mem-2       v,v*x+2,v
17476   3457 C1                  DEFB    $C1             ;;st-mem-1
17477   3458 03                  DEFB    $03             ;;subtract
17478   3459 38                  DEFB    $38             ;;end-calc
17479   345A             
17480   345A             ; the previous pointer is fetched from the machine stack to H'L' where it
17481   345A             ; addresses one of the numbers of the series following the series literal.
17482   345A             
17483   345A CD C6 33            CALL    L33C6           ; routine STK-DATA is called directly to
17484   345D                                             ; push a value and advance H'L'.
17485   345D CD 62 33            CALL    L3362           ; routine GEN-ENT-2 recursively re-enters
17486   3460                                             ; the calculator without disturbing
17487   3460                                             ; system variable BREG
17488   3460                                             ; H'L' value goes on the machine stack and is
17489   3460                                             ; then loaded as usual with the next address.
17490   3460             
17491   3460 0F                  DEFB    $0F             ;;addition
17492   3461 01                  DEFB    $01             ;;exchange
17493   3462 C2                  DEFB    $C2             ;;st-mem-2
17494   3463 02                  DEFB    $02             ;;delete
17495   3464             
17496   3464 35                  DEFB    $35             ;;dec-jr-nz
17497   3465 EE                  DEFB    $EE             ;;back to L3453, G-LOOP
17498   3466             
17499   3466             ; when the counted loop is complete the final subtraction yields the result
17500   3466             ; for example SIN X.
17501   3466             
17502   3466 E1                  DEFB    $E1             ;;get-mem-1
17503   3467 03                  DEFB    $03             ;;subtract
17504   3468 38                  DEFB    $38             ;;end-calc
17505   3469             
17506   3469 C9                  RET                     ; return with H'L' pointing to location
17507   346A                                             ; after last number in series.
17508   346A             
17509   346A             ; ---------------------------------
17510   346A             ; THE 'ABSOLUTE MAGNITUDE' FUNCTION
17511   346A             ; ---------------------------------
17512   346A             ; (offset: $2A 'abs')
17513   346A             ;   This calculator literal finds the absolute value of the last value,
17514   346A             ;   integer or floating point, on calculator stack.
17515   346A             
17516   346A             ;; abs
17517   346A 06 FF       L346A:   LD      B,$FF           ; signal abs
17518   346C 18 06               JR      L3474           ; forward to NEG-TEST
17519   346E             
17520   346E             ; ---------------------------
17521   346E             ; THE 'UNARY MINUS' OPERATION
17522   346E             ; ---------------------------
17523   346E             ; (offset: $1B 'negate')
17524   346E             ;   Unary so on entry HL points to last value, DE to STKEND.
17525   346E             
17526   346E             ;; NEGATE
17527   346E             ;; negate
17528   346E CD E9 34    L346E:   CALL    L34E9           ; call routine TEST-ZERO and
17529   3471 D8                  RET     C               ; return if so leaving zero unchanged.
17530   3472             
17531   3472 06 00               LD      B,$00           ; signal negate required before joining
17532   3474                                             ; common code.
17533   3474             
17534   3474             ;; NEG-TEST
17535   3474 7E          L3474:   LD      A,(HL)          ; load first byte and 
17536   3475 A7                  AND     A               ; test for zero
17537   3476 28 0B               JR      Z,L3483         ; forward to INT-CASE if a small integer
17538   3478             
17539   3478             ; for floating point numbers a single bit denotes the sign.
17540   3478             
17541   3478 23                  INC     HL              ; address the first byte of mantissa.
17542   3479 78                  LD      A,B             ; action flag $FF=abs, $00=neg.
17543   347A E6 80               AND     $80             ; now         $80      $00
17544   347C B6                  OR      (HL)            ; sets bit 7 for abs
17545   347D 17                  RLA                     ; sets carry for abs and if number negative
17546   347E 3F                  CCF                     ; complement carry flag
17547   347F 1F                  RRA                     ; and rotate back in altering sign
17548   3480 77                  LD      (HL),A          ; put the altered adjusted number back
17549   3481 2B                  DEC     HL              ; HL points to result
17550   3482 C9                  RET                     ; return with DE unchanged
17551   3483             
17552   3483             ; ---
17553   3483             
17554   3483             ; for integer numbers an entire byte denotes the sign.
17555   3483             
17556   3483             ;; INT-CASE
17557   3483 D5          L3483:   PUSH    DE              ; save STKEND.
17558   3484             
17559   3484 E5                  PUSH    HL              ; save pointer to the last value/result.
17560   3485             
17561   3485 CD 7F 2D            CALL    L2D7F           ; routine INT-FETCH puts integer in DE
17562   3488                                             ; and the sign in C.
17563   3488             
17564   3488 E1                  POP     HL              ; restore the result pointer.
17565   3489             
17566   3489 78                  LD      A,B             ; $FF=abs, $00=neg
17567   348A B1                  OR      C               ; $FF for abs, no change neg
17568   348B 2F                  CPL                     ; $00 for abs, switched for neg
17569   348C 4F                  LD      C,A             ; transfer result to sign byte.
17570   348D             
17571   348D CD 8E 2D            CALL    L2D8E           ; routine INT-STORE to re-write the integer.
17572   3490             
17573   3490 D1                  POP     DE              ; restore STKEND.
17574   3491 C9                  RET                     ; return.
17575   3492             
17576   3492             ; ---------------------
17577   3492             ; THE 'SIGNUM' FUNCTION
17578   3492             ; ---------------------
17579   3492             ; (offset: $29 'sgn')
17580   3492             ;   This routine replaces the last value on the calculator stack,
17581   3492             ;   which may be in floating point or integer form, with the integer values
17582   3492             ;   zero if zero, with one if positive and  with -minus one if negative.
17583   3492             
17584   3492             ;; sgn
17585   3492 CD E9 34    L3492:   CALL    L34E9           ; call routine TEST-ZERO and
17586   3495 D8                  RET     C               ; exit if so as no change is required.
17587   3496             
17588   3496 D5                  PUSH    DE              ; save pointer to STKEND.
17589   3497             
17590   3497 11 01 00            LD      DE,$0001        ; the result will be 1.
17591   349A 23                  INC     HL              ; skip over the exponent.
17592   349B CB 16               RL      (HL)            ; rotate the sign bit into the carry flag.
17593   349D 2B                  DEC     HL              ; step back to point to the result.
17594   349E 9F                  SBC     A,A             ; byte will be $FF if negative, $00 if positive.
17595   349F 4F                  LD      C,A             ; store the sign byte in the C register.
17596   34A0 CD 8E 2D            CALL    L2D8E           ; routine INT-STORE to overwrite the last
17597   34A3                                             ; value with 0001 and sign.
17598   34A3             
17599   34A3 D1                  POP     DE              ; restore STKEND.
17600   34A4 C9                  RET                     ; return.
17601   34A5             
17602   34A5             ; -----------------
17603   34A5             ; THE 'IN' FUNCTION
17604   34A5             ; -----------------
17605   34A5             ; (offset: $2C 'in')
17606   34A5             ;   This function reads a byte from an input port.
17607   34A5             
17608   34A5             ;; in
17609   34A5 CD 99 1E    L34A5:   CALL    L1E99           ; Routine FIND-INT2 puts port address in BC.
17610   34A8                                             ; All 16 bits are put on the address line.
17611   34A8             
17612   34A8 ED 78               IN      A,(C)           ; Read the port.
17613   34AA             
17614   34AA 18 04               JR      L34B0           ; exit to STACK-A (via IN-PK-STK to save a byte 
17615   34AC                                             ; of instruction code).
17616   34AC             
17617   34AC             ; -------------------
17618   34AC             ; THE 'PEEK' FUNCTION
17619   34AC             ; -------------------
17620   34AC             ; (offset: $2B 'peek')
17621   34AC             ;   This function returns the contents of a memory address.
17622   34AC             ;   The entire address space can be peeked including the ROM.
17623   34AC             
17624   34AC             ;; peek
17625   34AC CD 99 1E    L34AC:   CALL    L1E99           ; routine FIND-INT2 puts address in BC.
17626   34AF 0A                  LD      A,(BC)          ; load contents into A register.
17627   34B0             
17628   34B0             ;; IN-PK-STK
17629   34B0 C3 28 2D    L34B0:   JP      L2D28           ; exit via STACK-A to put the value on the 
17630   34B3                                             ; calculator stack.
17631   34B3             
17632   34B3             ; ------------------
17633   34B3             ; THE 'USR' FUNCTION
17634   34B3             ; ------------------
17635   34B3             ; (offset: $2d 'usr-no')
17636   34B3             ;   The USR function followed by a number 0-65535 is the method by which
17637   34B3             ;   the Spectrum invokes machine code programs. This function returns the
17638   34B3             ;   contents of the BC register pair.
17639   34B3             ;   Note. that STACK-BC re-initializes the IY register if a user-written
17640   34B3             ;   program has altered it.
17641   34B3             
17642   34B3             ;; usr-no
17643   34B3 CD 99 1E    L34B3:   CALL    L1E99           ; routine FIND-INT2 to fetch the
17644   34B6                                             ; supplied address into BC.
17645   34B6             
17646   34B6 21 2B 2D            LD      HL,L2D2B        ; address: STACK-BC is
17647   34B9 E5                  PUSH    HL              ; pushed onto the machine stack.
17648   34BA C5                  PUSH    BC              ; then the address of the machine code
17649   34BB                                             ; routine.
17650   34BB             
17651   34BB C9                  RET                     ; make an indirect jump to the routine
17652   34BC                                             ; and, hopefully, to STACK-BC also.
17653   34BC             
17654   34BC             ; -------------------------
17655   34BC             ; THE 'USR STRING' FUNCTION
17656   34BC             ; -------------------------
17657   34BC             ; (offset: $19 'usr-$')
17658   34BC             ;   The user function with a one-character string argument, calculates the
17659   34BC             ;   address of the User Defined Graphic character that is in the string.
17660   34BC             ;   As an alternative, the ASCII equivalent, upper or lower case,
17661   34BC             ;   may be supplied. This provides a user-friendly method of redefining
17662   34BC             ;   the 21 User Definable Graphics e.g.
17663   34BC             ;   POKE USR "a", BIN 10000000 will put a dot in the top left corner of the
17664   34BC             ;   character 144.
17665   34BC             ;   Note. the curious double check on the range. With 26 UDGs the first check
17666   34BC             ;   only is necessary. With anything less the second check only is required.
17667   34BC             ;   It is highly likely that the first check was written by Steven Vickers.
17668   34BC             
17669   34BC             ;; usr-$
17670   34BC CD F1 2B    L34BC:   CALL    L2BF1           ; routine STK-FETCH fetches the string
17671   34BF                                             ; parameters.
17672   34BF 0B                  DEC     BC              ; decrease BC by
17673   34C0 78                  LD      A,B             ; one to test
17674   34C1 B1                  OR      C               ; the length.
17675   34C2 20 23               JR      NZ,L34E7        ; to REPORT-A if not a single character.
17676   34C4             
17677   34C4 1A                  LD      A,(DE)          ; fetch the character
17678   34C5 CD 8D 2C            CALL    L2C8D           ; routine ALPHA sets carry if 'A-Z' or 'a-z'.
17679   34C8 38 09               JR      C,L34D3         ; forward to USR-RANGE if ASCII.
17680   34CA             
17681   34CA D6 90               SUB     $90             ; make UDGs range 0-20d
17682   34CC 38 19               JR      C,L34E7         ; to REPORT-A if too low. e.g. usr " ".
17683   34CE             
17684   34CE FE 15               CP      $15             ; Note. this test is not necessary.
17685   34D0 30 15               JR      NC,L34E7        ; to REPORT-A if higher than 20.
17686   34D2             
17687   34D2 3C                  INC     A               ; make range 1-21d to match LSBs of ASCII
17688   34D3             
17689   34D3             ;; USR-RANGE
17690   34D3 3D          L34D3:   DEC     A               ; make range of bits 0-4 start at zero
17691   34D4 87                  ADD     A,A             ; multiply by eight
17692   34D5 87                  ADD     A,A             ; and lose any set bits
17693   34D6 87                  ADD     A,A             ; range now 0 - 25*8
17694   34D7 FE A8               CP      $A8             ; compare to 21*8
17695   34D9 30 0C               JR      NC,L34E7        ; to REPORT-A if originally higher 
17696   34DB                                             ; than 'U','u' or graphics U.
17697   34DB             
17698   34DB ED 4B 7B 5C         LD      BC,($5C7B)      ; fetch the UDG system variable value.
17699   34DF 81                  ADD     A,C             ; add the offset to character
17700   34E0 4F                  LD      C,A             ; and store back in register C.
17701   34E1 30 01               JR      NC,L34E4        ; forward to USR-STACK if no overflow.
17702   34E3             
17703   34E3 04                  INC     B               ; increment high byte.
17704   34E4             
17705   34E4             ;; USR-STACK
17706   34E4 C3 2B 2D    L34E4:   JP      L2D2B           ; jump back and exit via STACK-BC to store
17707   34E7             
17708   34E7             ; ---
17709   34E7             
17710   34E7             ;; REPORT-A
17711   34E7 CF          L34E7:   RST     08H             ; ERROR-1
17712   34E8 09                  DEFB    $09             ; Error Report: Invalid argument
17713   34E9             
17714   34E9             ; ------------------------------
17715   34E9             ; THE 'TEST FOR ZERO' SUBROUTINE
17716   34E9             ; ------------------------------
17717   34E9             ;   Test if top value on calculator stack is zero.  The carry flag is set if 
17718   34E9             ;   the last value is zero but no registers are altered.
17719   34E9             ;   All five bytes will be zero but first four only need be tested.
17720   34E9             ;   On entry, HL points to the exponent the first byte of the value.
17721   34E9             
17722   34E9             ;; TEST-ZERO
17723   34E9 E5          L34E9:   PUSH    HL              ; preserve HL which is used to address.
17724   34EA C5                  PUSH    BC              ; preserve BC which is used as a store.
17725   34EB 47                  LD      B,A             ; preserve A in B.
17726   34EC             
17727   34EC 7E                  LD      A,(HL)          ; load first byte to accumulator
17728   34ED 23                  INC     HL              ; advance.
17729   34EE B6                  OR      (HL)            ; OR with second byte and clear carry.
17730   34EF 23                  INC     HL              ; advance.
17731   34F0 B6                  OR      (HL)            ; OR with third byte.
17732   34F1 23                  INC     HL              ; advance.
17733   34F2 B6                  OR      (HL)            ; OR with fourth byte.
17734   34F3             
17735   34F3 78                  LD      A,B             ; restore A without affecting flags.
17736   34F4 C1                  POP     BC              ; restore the saved
17737   34F5 E1                  POP     HL              ; registers.
17738   34F6             
17739   34F6 C0                  RET     NZ              ; return if not zero and with carry reset.
17740   34F7             
17741   34F7 37                  SCF                     ; set the carry flag.
17742   34F8 C9                  RET                     ; return with carry set if zero.
17743   34F9             
17744   34F9             ; --------------------------------
17745   34F9             ; THE 'GREATER THAN ZERO' OPERATOR
17746   34F9             ; --------------------------------
17747   34F9             ; (offset: $37 'greater-0' )
17748   34F9             ;   Test if the last value on the calculator stack is greater than zero.
17749   34F9             ;   This routine is also called directly from the end-tests of the comparison 
17750   34F9             ;   routine.
17751   34F9             
17752   34F9             ;; GREATER-0
17753   34F9             ;; greater-0
17754   34F9 CD E9 34    L34F9:   CALL    L34E9           ; routine TEST-ZERO
17755   34FC D8                  RET     C               ; return if was zero as this
17756   34FD                                             ; is also the Boolean 'false' value.
17757   34FD             
17758   34FD 3E FF               LD      A,$FF           ; prepare XOR mask for sign bit
17759   34FF 18 06               JR      L3507           ; forward to SIGN-TO-C
17760   3501                                             ; to put sign in carry
17761   3501                                             ; (carry will become set if sign is positive)
17762   3501                                             ; and then overwrite location with 1 or 0 
17763   3501                                             ; as appropriate.
17764   3501             
17765   3501             ; ------------------
17766   3501             ; THE 'NOT' FUNCTION
17767   3501             ; ------------------
17768   3501             ; (offset: $30 'not')
17769   3501             ;   This overwrites the last value with 1 if it was zero else with zero
17770   3501             ;   if it was any other value.
17771   3501             ;
17772   3501             ;   e.g. NOT 0 returns 1, NOT 1 returns 0, NOT -3 returns 0.
17773   3501             ;
17774   3501             ;   The subroutine is also called directly from the end-tests of the comparison
17775   3501             ;   operator.
17776   3501             
17777   3501             ;; NOT
17778   3501             ;; not
17779   3501 CD E9 34    L3501:   CALL    L34E9           ; routine TEST-ZERO sets carry if zero
17780   3504             
17781   3504 18 05               JR      L350B           ; to FP-0/1 to overwrite operand with
17782   3506                                             ; 1 if carry is set else to overwrite with zero.
17783   3506             
17784   3506             ; ------------------------------
17785   3506             ; THE 'LESS THAN ZERO' OPERATION
17786   3506             ; ------------------------------
17787   3506             ; (offset: $36 'less-0' )
17788   3506             ;   Destructively test if last value on calculator stack is less than zero.
17789   3506             ;   Bit 7 of second byte will be set if so.
17790   3506             
17791   3506             ;; less-0
17792   3506 AF          L3506:   XOR     A               ; set XOR mask to zero
17793   3507                                             ; (carry will become set if sign is negative).
17794   3507             
17795   3507             ;   transfer sign of mantissa to Carry Flag.
17796   3507             
17797   3507             ;; SIGN-TO-C
17798   3507 23          L3507:   INC     HL              ; address 2nd byte.
17799   3508 AE                  XOR     (HL)            ; bit 7 of HL will be set if number is negative.
17800   3509 2B                  DEC     HL              ; address 1st byte again.
17801   350A 07                  RLCA                    ; rotate bit 7 of A to carry.
17802   350B             
17803   350B             ; ----------------------------
17804   350B             ; THE 'ZERO OR ONE' SUBROUTINE
17805   350B             ; ----------------------------
17806   350B             ;   This routine places an integer value of zero or one at the addressed 
17807   350B             ;   location of the calculator stack or MEM area.  The value one is written if 
17808   350B             ;   carry is set on entry else zero.
17809   350B             
17810   350B             ;; FP-0/1
17811   350B E5          L350B:   PUSH    HL              ; save pointer to the first byte
17812   350C 3E 00               LD      A,$00           ; load accumulator with zero - without
17813   350E                                             ; disturbing flags.
17814   350E 77                  LD      (HL),A          ; zero to first byte
17815   350F 23                  INC     HL              ; address next
17816   3510 77                  LD      (HL),A          ; zero to 2nd byte
17817   3511 23                  INC     HL              ; address low byte of integer
17818   3512 17                  RLA                     ; carry to bit 0 of A
17819   3513 77                  LD      (HL),A          ; load one or zero to low byte.
17820   3514 1F                  RRA                     ; restore zero to accumulator.
17821   3515 23                  INC     HL              ; address high byte of integer.
17822   3516 77                  LD      (HL),A          ; put a zero there.
17823   3517 23                  INC     HL              ; address fifth byte.
17824   3518 77                  LD      (HL),A          ; put a zero there.
17825   3519 E1                  POP     HL              ; restore pointer to the first byte.
17826   351A C9                  RET                     ; return.
17827   351B             
17828   351B             ; -----------------
17829   351B             ; THE 'OR' OPERATOR
17830   351B             ; -----------------
17831   351B             ; (offset: $07 'or' )
17832   351B             ; The Boolean OR operator. e.g. X OR Y
17833   351B             ; The result is zero if both values are zero else a non-zero value.
17834   351B             ;
17835   351B             ; e.g.    0 OR 0  returns 0.
17836   351B             ;        -3 OR 0  returns -3.
17837   351B             ;         0 OR -3 returns 1.
17838   351B             ;        -3 OR 2  returns 1.
17839   351B             ;
17840   351B             ; A binary operation.
17841   351B             ; On entry HL points to first operand (X) and DE to second operand (Y).
17842   351B             
17843   351B             ;; or
17844   351B EB          L351B:   EX      DE,HL           ; make HL point to second number
17845   351C CD E9 34            CALL    L34E9           ; routine TEST-ZERO
17846   351F EB                  EX      DE,HL           ; restore pointers
17847   3520 D8                  RET     C               ; return if result was zero - first operand, 
17848   3521                                             ; now the last value, is the result.
17849   3521             
17850   3521 37                  SCF                     ; set carry flag
17851   3522 18 E7               JR      L350B           ; back to FP-0/1 to overwrite the first operand
17852   3524                                             ; with the value 1.
17853   3524             
17854   3524             
17855   3524             ; ---------------------------------
17856   3524             ; THE 'NUMBER AND NUMBER' OPERATION
17857   3524             ; ---------------------------------
17858   3524             ; (offset: $08 'no-&-no')
17859   3524             ;   The Boolean AND operator.
17860   3524             ;
17861   3524             ;   e.g.    -3 AND 2  returns -3.
17862   3524             ;           -3 AND 0  returns 0.
17863   3524             ;            0 and -2 returns 0.
17864   3524             ;            0 and 0  returns 0.
17865   3524             ;
17866   3524             ;   Compare with OR routine above.
17867   3524             
17868   3524             ;; no-&-no
17869   3524 EB          L3524:   EX      DE,HL           ; make HL address second operand.
17870   3525             
17871   3525 CD E9 34            CALL    L34E9           ; routine TEST-ZERO sets carry if zero.
17872   3528             
17873   3528 EB                  EX      DE,HL           ; restore pointers.
17874   3529 D0                  RET     NC              ; return if second non-zero, first is result.
17875   352A             
17876   352A             ;
17877   352A             
17878   352A A7                  AND     A               ; else clear carry.
17879   352B 18 DE               JR      L350B           ; back to FP-0/1 to overwrite first operand
17880   352D                                             ; with zero for return value.
17881   352D             
17882   352D             ; ---------------------------------
17883   352D             ; THE 'STRING AND NUMBER' OPERATION
17884   352D             ; ---------------------------------
17885   352D             ; (offset: $10 'str-&-no')
17886   352D             ;   e.g. "You Win" AND score>99 will return the string if condition is true
17887   352D             ;   or the null string if false.
17888   352D             
17889   352D             ;; str-&-no
17890   352D EB          L352D:   EX      DE,HL           ; make HL point to the number.
17891   352E CD E9 34            CALL    L34E9           ; routine TEST-ZERO.
17892   3531 EB                  EX      DE,HL           ; restore pointers. 
17893   3532 D0                  RET     NC              ; return if number was not zero - the string 
17894   3533                                             ; is the result.
17895   3533             
17896   3533             ;   if the number was zero (false) then the null string must be returned by
17897   3533             ;   altering the length of the string on the calculator stack to zero.
17898   3533             
17899   3533 D5                  PUSH    DE              ; save pointer to the now obsolete number 
17900   3534                                             ; (which will become the new STKEND)
17901   3534             
17902   3534 1B                  DEC     DE              ; point to the 5th byte of string descriptor.
17903   3535 AF                  XOR     A               ; clear the accumulator.
17904   3536 12                  LD      (DE),A          ; place zero in high byte of length.
17905   3537 1B                  DEC     DE              ; address low byte of length.
17906   3538 12                  LD      (DE),A          ; place zero there - now the null string.
17907   3539             
17908   3539 D1                  POP     DE              ; restore pointer - new STKEND.
17909   353A C9                  RET                     ; return.
17910   353B             
17911   353B             ; ---------------------------
17912   353B             ; THE 'COMPARISON' OPERATIONS
17913   353B             ; ---------------------------
17914   353B             ; (offset: $0A 'no-gr-eql')
17915   353B             ; (offset: $0B 'nos-neql')
17916   353B             ; (offset: $0C 'no-grtr')
17917   353B             ; (offset: $0D 'no-less')
17918   353B             ; (offset: $0E 'nos-eql')
17919   353B             ; (offset: $11 'str-l-eql')
17920   353B             ; (offset: $12 'str-gr-eql')
17921   353B             ; (offset: $13 'strs-neql')
17922   353B             ; (offset: $14 'str-grtr')
17923   353B             ; (offset: $15 'str-less')
17924   353B             ; (offset: $16 'strs-eql')
17925   353B             
17926   353B             ;   True binary operations.
17927   353B             ;   A single entry point is used to evaluate six numeric and six string
17928   353B             ;   comparisons. On entry, the calculator literal is in the B register and
17929   353B             ;   the two numeric values, or the two string parameters, are on the 
17930   353B             ;   calculator stack.
17931   353B             ;   The individual bits of the literal are manipulated to group similar
17932   353B             ;   operations although the SUB 8 instruction does nothing useful and merely
17933   353B             ;   alters the string test bit.
17934   353B             ;   Numbers are compared by subtracting one from the other, strings are 
17935   353B             ;   compared by comparing every character until a mismatch, or the end of one
17936   353B             ;   or both, is reached.
17937   353B             ;
17938   353B             ;   Numeric Comparisons.
17939   353B             ;   --------------------
17940   353B             ;   The 'x>y' example is the easiest as it employs straight-thru logic.
17941   353B             ;   Number y is subtracted from x and the result tested for greater-0 yielding
17942   353B             ;   a final value 1 (true) or 0 (false). 
17943   353B             ;   For 'x<y' the same logic is used but the two values are first swapped on the
17944   353B             ;   calculator stack. 
17945   353B             ;   For 'x=y' NOT is applied to the subtraction result yielding true if the
17946   353B             ;   difference was zero and false with anything else. 
17947   353B             ;   The first three numeric comparisons are just the opposite of the last three
17948   353B             ;   so the same processing steps are used and then a final NOT is applied.
17949   353B             ;
17950   353B             ; literal    Test   No  sub 8       ExOrNot  1st RRCA  exch sub  ?   End-Tests
17951   353B             ; =========  ====   == ======== === ======== ========  ==== ===  =  === === ===
17952   353B             ; no-l-eql   x<=y   09 00000001 dec 00000000 00000000  ---- x-y  ?  --- >0? NOT
17953   353B             ; no-gr-eql  x>=y   0A 00000010 dec 00000001 10000000c swap y-x  ?  --- >0? NOT
17954   353B             ; nos-neql   x<>y   0B 00000011 dec 00000010 00000001  ---- x-y  ?  NOT --- NOT
17955   353B             ; no-grtr    x>y    0C 00000100  -  00000100 00000010  ---- x-y  ?  --- >0? ---
17956   353B             ; no-less    x<y    0D 00000101  -  00000101 10000010c swap y-x  ?  --- >0? ---
17957   353B             ; nos-eql    x=y    0E 00000110  -  00000110 00000011  ---- x-y  ?  NOT --- ---
17958   353B             ;
17959   353B             ;                                                           comp -> C/F
17960   353B             ;                                                           ====    ===
17961   353B             ; str-l-eql  x$<=y$ 11 00001001 dec 00001000 00000100  ---- x$y$ 0  !or >0? NOT
17962   353B             ; str-gr-eql x$>=y$ 12 00001010 dec 00001001 10000100c swap y$x$ 0  !or >0? NOT
17963   353B             ; strs-neql  x$<>y$ 13 00001011 dec 00001010 00000101  ---- x$y$ 0  !or >0? NOT
17964   353B             ; str-grtr   x$>y$  14 00001100  -  00001100 00000110  ---- x$y$ 0  !or >0? ---
17965   353B             ; str-less   x$<y$  15 00001101  -  00001101 10000110c swap y$x$ 0  !or >0? ---
17966   353B             ; strs-eql   x$=y$  16 00001110  -  00001110 00000111  ---- x$y$ 0  !or >0? ---
17967   353B             ;
17968   353B             ;   String comparisons are a little different in that the eql/neql carry flag
17969   353B             ;   from the 2nd RRCA is, as before, fed into the first of the end tests but
17970   353B             ;   along the way it gets modified by the comparison process. The result on the
17971   353B             ;   stack always starts off as zero and the carry fed in determines if NOT is 
17972   353B             ;   applied to it. So the only time the greater-0 test is applied is if the
17973   353B             ;   stack holds zero which is not very efficient as the test will always yield
17974   353B             ;   zero. The most likely explanation is that there were once separate end tests
17975   353B             ;   for numbers and strings.
17976   353B             
17977   353B             ;; no-l-eql,etc.
17978   353B 78          L353B:   LD      A,B             ; transfer literal to accumulator.
17979   353C D6 08               SUB     $08             ; subtract eight - which is not useful. 
17980   353E             
17981   353E CB 57               BIT     2,A             ; isolate '>', '<', '='.
17982   3540             
17983   3540 20 01               JR      NZ,L3543        ; skip to EX-OR-NOT with these.
17984   3542             
17985   3542 3D                  DEC     A               ; else make $00-$02, $08-$0A to match bits 0-2.
17986   3543             
17987   3543             ;; EX-OR-NOT
17988   3543 0F          L3543:   RRCA                    ; the first RRCA sets carry for a swap. 
17989   3544 30 08               JR      NC,L354E        ; forward to NU-OR-STR with other 8 cases
17990   3546             
17991   3546             ; for the other 4 cases the two values on the calculator stack are exchanged.
17992   3546             
17993   3546 F5                  PUSH    AF              ; save A and carry.
17994   3547 E5                  PUSH    HL              ; save HL - pointer to first operand.
17995   3548                                             ; (DE points to second operand).
17996   3548             
17997   3548 CD 3C 34            CALL    L343C           ; routine exchange swaps the two values.
17998   354B                                             ; (HL = second operand, DE = STKEND)
17999   354B             
18000   354B D1                  POP     DE              ; DE = first operand
18001   354C EB                  EX      DE,HL           ; as we were.
18002   354D F1                  POP     AF              ; restore A and carry.
18003   354E             
18004   354E             ; Note. it would be better if the 2nd RRCA preceded the string test.
18005   354E             ; It would save two duplicate bytes and if we also got rid of that sub 8 
18006   354E             ; at the beginning we wouldn't have to alter which bit we test.
18007   354E             
18008   354E             ;; NU-OR-STR
18009   354E CB 57       L354E:   BIT     2,A             ; test if a string comparison.
18010   3550 20 07               JR      NZ,L3559        ; forward to STRINGS if so.
18011   3552             
18012   3552             ; continue with numeric comparisons.
18013   3552             
18014   3552 0F                  RRCA                    ; 2nd RRCA causes eql/neql to set carry.
18015   3553 F5                  PUSH    AF              ; save A and carry
18016   3554             
18017   3554 CD 0F 30            CALL    L300F           ; routine subtract leaves result on stack.
18018   3557 18 33               JR      L358C           ; forward to END-TESTS
18019   3559             
18020   3559             ; ---
18021   3559             
18022   3559             ;; STRINGS
18023   3559 0F          L3559:   RRCA                    ; 2nd RRCA causes eql/neql to set carry.
18024   355A F5                  PUSH    AF              ; save A and carry.
18025   355B             
18026   355B CD F1 2B            CALL    L2BF1           ; routine STK-FETCH gets 2nd string params
18027   355E D5                  PUSH    DE              ; save start2 *.
18028   355F C5                  PUSH    BC              ; and the length.
18029   3560             
18030   3560 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH gets 1st string 
18031   3563                                             ; parameters - start in DE, length in BC.
18032   3563 E1                  POP     HL              ; restore length of second to HL.
18033   3564             
18034   3564             ; A loop is now entered to compare, by subtraction, each corresponding character
18035   3564             ; of the strings. For each successful match, the pointers are incremented and 
18036   3564             ; the lengths decreased and the branch taken back to here. If both string 
18037   3564             ; remainders become null at the same time, then an exact match exists.
18038   3564             
18039   3564             ;; BYTE-COMP
18040   3564 7C          L3564:   LD      A,H             ; test if the second string
18041   3565 B5                  OR      L               ; is the null string and hold flags.
18042   3566             
18043   3566 E3                  EX      (SP),HL         ; put length2 on stack, bring start2 to HL *.
18044   3567 78                  LD      A,B             ; hi byte of length1 to A
18045   3568             
18046   3568 20 0B               JR      NZ,L3575        ; forward to SEC-PLUS if second not null.
18047   356A             
18048   356A B1                  OR      C               ; test length of first string.
18049   356B             
18050   356B             ;; SECND-LOW
18051   356B C1          L356B:   POP     BC              ; pop the second length off stack.
18052   356C 28 04               JR      Z,L3572         ; forward to BOTH-NULL if first string is also
18053   356E                                             ; of zero length.
18054   356E             
18055   356E             ; the true condition - first is longer than second (SECND-LESS)
18056   356E             
18057   356E F1                  POP     AF              ; restore carry (set if eql/neql)
18058   356F 3F                  CCF                     ; complement carry flag.
18059   3570                                             ; Note. equality becomes false.
18060   3570                                             ; Inequality is true. By swapping or applying
18061   3570                                             ; a terminal 'not', all comparisons have been
18062   3570                                             ; manipulated so that this is success path. 
18063   3570 18 16               JR      L3588           ; forward to leave via STR-TEST
18064   3572             
18065   3572             ; ---
18066   3572             ; the branch was here with a match
18067   3572             
18068   3572             ;; BOTH-NULL
18069   3572 F1          L3572:   POP     AF              ; restore carry - set for eql/neql
18070   3573 18 13               JR      L3588           ; forward to STR-TEST
18071   3575             
18072   3575             ; ---  
18073   3575             ; the branch was here when 2nd string not null and low byte of first is yet
18074   3575             ; to be tested.
18075   3575             
18076   3575             
18077   3575             ;; SEC-PLUS
18078   3575 B1          L3575:   OR      C               ; test the length of first string.
18079   3576 28 0D               JR      Z,L3585         ; forward to FRST-LESS if length is zero.
18080   3578             
18081   3578             ; both strings have at least one character left.
18082   3578             
18083   3578 1A                  LD      A,(DE)          ; fetch character of first string. 
18084   3579 96                  SUB     (HL)            ; subtract with that of 2nd string.
18085   357A 38 09               JR      C,L3585         ; forward to FRST-LESS if carry set
18086   357C             
18087   357C 20 ED               JR      NZ,L356B        ; back to SECND-LOW and then STR-TEST
18088   357E                                             ; if not exact match.
18089   357E             
18090   357E 0B                  DEC     BC              ; decrease length of 1st string.
18091   357F 13                  INC     DE              ; increment 1st string pointer.
18092   3580             
18093   3580 23                  INC     HL              ; increment 2nd string pointer.
18094   3581 E3                  EX      (SP),HL         ; swap with length on stack
18095   3582 2B                  DEC     HL              ; decrement 2nd string length
18096   3583 18 DF               JR      L3564           ; back to BYTE-COMP
18097   3585             
18098   3585             ; ---
18099   3585             ; the false condition.
18100   3585             
18101   3585             ;; FRST-LESS
18102   3585 C1          L3585:   POP     BC              ; discard length
18103   3586 F1                  POP     AF              ; pop A
18104   3587 A7                  AND     A               ; clear the carry for false result.
18105   3588             
18106   3588             ; ---
18107   3588             ; exact match and x$>y$ rejoin here
18108   3588             
18109   3588             ;; STR-TEST
18110   3588 F5          L3588:   PUSH    AF              ; save A and carry
18111   3589             
18112   3589 EF                  RST     28H             ;; FP-CALC
18113   358A A0                  DEFB    $A0             ;;stk-zero      an initial false value.
18114   358B 38                  DEFB    $38             ;;end-calc
18115   358C             
18116   358C             ; both numeric and string paths converge here.
18117   358C             
18118   358C             ;; END-TESTS
18119   358C F1          L358C:   POP     AF              ; pop carry  - will be set if eql/neql
18120   358D F5                  PUSH    AF              ; save it again.
18121   358E             
18122   358E DC 01 35            CALL    C,L3501         ; routine NOT sets true(1) if equal(0)
18123   3591                                             ; or, for strings, applies true result.
18124   3591             
18125   3591 F1                  POP     AF              ; pop carry and
18126   3592 F5                  PUSH    AF              ; save A
18127   3593             
18128   3593 D4 F9 34            CALL    NC,L34F9        ; routine GREATER-0 tests numeric subtraction 
18129   3596                                             ; result but also needlessly tests the string 
18130   3596                                             ; value for zero - it must be.
18131   3596             
18132   3596 F1                  POP     AF              ; pop A 
18133   3597 0F                  RRCA                    ; the third RRCA - test for '<=', '>=' or '<>'.
18134   3598 D4 01 35            CALL    NC,L3501        ; apply a terminal NOT if so.
18135   359B C9                  RET                     ; return.
18136   359C             
18137   359C             ; ------------------------------------
18138   359C             ; THE 'STRING CONCATENATION' OPERATION
18139   359C             ; ------------------------------------
18140   359C             ; (offset: $17 'strs-add')
18141   359C             ;   This literal combines two strings into one e.g. LET a$ = b$ + c$
18142   359C             ;   The two parameters of the two strings to be combined are on the stack.
18143   359C             
18144   359C             ;; strs-add
18145   359C CD F1 2B    L359C:   CALL    L2BF1           ; routine STK-FETCH fetches string parameters
18146   359F                                             ; and deletes calculator stack entry.
18147   359F D5                  PUSH    DE              ; save start address.
18148   35A0 C5                  PUSH    BC              ; and length.
18149   35A1             
18150   35A1 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH for first string
18151   35A4 E1                  POP     HL              ; re-fetch first length
18152   35A5 E5                  PUSH    HL              ; and save again
18153   35A6 D5                  PUSH    DE              ; save start of second string
18154   35A7 C5                  PUSH    BC              ; and its length.
18155   35A8             
18156   35A8 09                  ADD     HL,BC           ; add the two lengths.
18157   35A9 44                  LD      B,H             ; transfer to BC
18158   35AA 4D                  LD      C,L             ; and create
18159   35AB F7                  RST     30H             ; BC-SPACES in workspace.
18160   35AC                                             ; DE points to start of space.
18161   35AC             
18162   35AC CD B2 2A            CALL    L2AB2           ; routine STK-STO-$ stores parameters
18163   35AF                                             ; of new string updating STKEND.
18164   35AF             
18165   35AF C1                  POP     BC              ; length of first
18166   35B0 E1                  POP     HL              ; address of start
18167   35B1 78                  LD      A,B             ; test for
18168   35B2 B1                  OR      C               ; zero length.
18169   35B3 28 02               JR      Z,L35B7         ; to OTHER-STR if null string
18170   35B5             
18171   35B5 ED B0               LDIR                    ; copy string to workspace.
18172   35B7             
18173   35B7             ;; OTHER-STR
18174   35B7 C1          L35B7:   POP     BC              ; now second length
18175   35B8 E1                  POP     HL              ; and start of string
18176   35B9 78                  LD      A,B             ; test this one
18177   35BA B1                  OR      C               ; for zero length
18178   35BB 28 02               JR      Z,L35BF         ; skip forward to STK-PNTRS if so as complete.
18179   35BD             
18180   35BD ED B0               LDIR                    ; else copy the bytes.
18181   35BF                                             ; and continue into next routine which
18182   35BF                                             ; sets the calculator stack pointers.
18183   35BF             
18184   35BF             ; -----------------------------------
18185   35BF             ; THE 'SET STACK POINTERS' SUBROUTINE
18186   35BF             ; -----------------------------------
18187   35BF             ;   Register DE is set to STKEND and HL, the result pointer, is set to five 
18188   35BF             ;   locations below this.
18189   35BF             ;   This routine is used when it is inconvenient to save these values at the
18190   35BF             ;   time the calculator stack is manipulated due to other activity on the 
18191   35BF             ;   machine stack.
18192   35BF             ;   This routine is also used to terminate the VAL and READ-IN  routines for
18193   35BF             ;   the same reason and to initialize the calculator stack at the start of
18194   35BF             ;   the CALCULATE routine.
18195   35BF             
18196   35BF             ;; STK-PNTRS
18197   35BF 2A 65 5C    L35BF:   LD      HL,($5C65)      ; fetch STKEND value from system variable.
18198   35C2 11 FB FF            LD      DE,$FFFB        ; the value -5
18199   35C5 E5                  PUSH    HL              ; push STKEND value.
18200   35C6             
18201   35C6 19                  ADD     HL,DE           ; subtract 5 from HL.
18202   35C7             
18203   35C7 D1                  POP     DE              ; pop STKEND to DE.
18204   35C8 C9                  RET                     ; return.
18205   35C9             
18206   35C9             ; -------------------
18207   35C9             ; THE 'CHR$' FUNCTION
18208   35C9             ; -------------------
18209   35C9             ; (offset: $2f 'chr$')
18210   35C9             ;   This function returns a single character string that is a result of 
18211   35C9             ;   converting a number in the range 0-255 to a string e.g. CHR$ 65 = "A".
18212   35C9             
18213   35C9             ;; chrs
18214   35C9 CD D5 2D    L35C9:   CALL    L2DD5           ; routine FP-TO-A puts the number in A.
18215   35CC             
18216   35CC 38 0E               JR      C,L35DC         ; forward to REPORT-Bd if overflow
18217   35CE 20 0C               JR      NZ,L35DC        ; forward to REPORT-Bd if negative
18218   35D0             
18219   35D0 F5                  PUSH    AF              ; save the argument.
18220   35D1             
18221   35D1 01 01 00            LD      BC,$0001        ; one space required.
18222   35D4 F7                  RST     30H             ; BC-SPACES makes DE point to start
18223   35D5             
18224   35D5 F1                  POP     AF              ; restore the number.
18225   35D6             
18226   35D6 12                  LD      (DE),A          ; and store in workspace
18227   35D7             
18228   35D7 CD B2 2A            CALL    L2AB2           ; routine STK-STO-$ stacks descriptor.
18229   35DA             
18230   35DA EB                  EX      DE,HL           ; make HL point to result and DE to STKEND.
18231   35DB C9                  RET                     ; return.
18232   35DC             
18233   35DC             ; ---
18234   35DC             
18235   35DC             ;; REPORT-Bd
18236   35DC CF          L35DC:   RST     08H             ; ERROR-1
18237   35DD 0A                  DEFB    $0A             ; Error Report: Integer out of range
18238   35DE             
18239   35DE             ; ----------------------------
18240   35DE             ; THE 'VAL and VAL$' FUNCTIONS
18241   35DE             ; ----------------------------
18242   35DE             ; (offset: $1d 'val')
18243   35DE             ; (offset: $18 'val$')
18244   35DE             ;   VAL treats the characters in a string as a numeric expression.
18245   35DE             ;   e.g. VAL "2.3" = 2.3, VAL "2+4" = 6, VAL ("2" + "4") = 24.
18246   35DE             ;   VAL$ treats the characters in a string as a string expression.
18247   35DE             ;   e.g. VAL$ (z$+"(2)") = a$(2) if z$ happens to be "a$".
18248   35DE             
18249   35DE             ;; val
18250   35DE             ;; val$
18251   35DE 2A 5D 5C    L35DE:   LD      HL,($5C5D)      ; fetch value of system variable CH_ADD
18252   35E1 E5                  PUSH    HL              ; and save on the machine stack.
18253   35E2 78                  LD      A,B             ; fetch the literal (either $1D or $18).
18254   35E3 C6 E3               ADD     A,$E3           ; add $E3 to form $00 (setting carry) or $FB.
18255   35E5 9F                  SBC     A,A             ; now form $FF bit 6 = numeric result
18256   35E6                                             ; or $00 bit 6 = string result.
18257   35E6 F5                  PUSH    AF              ; save this mask on the stack
18258   35E7             
18259   35E7 CD F1 2B            CALL    L2BF1           ; routine STK-FETCH fetches the string operand
18260   35EA                                             ; from calculator stack.
18261   35EA             
18262   35EA D5                  PUSH    DE              ; save the address of the start of the string.
18263   35EB 03                  INC     BC              ; increment the length for a carriage return.
18264   35EC             
18265   35EC F7                  RST     30H             ; BC-SPACES creates the space in workspace.
18266   35ED E1                  POP     HL              ; restore start of string to HL.
18267   35EE ED 53 5D 5C         LD      ($5C5D),DE      ; load CH_ADD with start DE in workspace.
18268   35F2             
18269   35F2 D5                  PUSH    DE              ; save the start in workspace
18270   35F3 ED B0               LDIR                    ; copy string from program or variables or
18271   35F5                                             ; workspace to the workspace area.
18272   35F5 EB                  EX      DE,HL           ; end of string + 1 to HL
18273   35F6 2B                  DEC     HL              ; decrement HL to point to end of new area.
18274   35F7 36 0D               LD      (HL),$0D        ; insert a carriage return at end.
18275   35F9 FD CB 01 BE         RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax.
18276   35FD CD FB 24            CALL    L24FB           ; routine SCANNING evaluates string
18277   3600                                             ; expression and result.
18278   3600             
18279   3600 DF                  RST     18H             ; GET-CHAR fetches next character.
18280   3601 FE 0D               CP      $0D             ; is it the expected carriage return ?
18281   3603 20 07               JR      NZ,L360C        ; forward to V-RPORT-C if not
18282   3605                                             ; 'Nonsense in BASIC'.
18283   3605             
18284   3605 E1                  POP     HL              ; restore start of string in workspace.
18285   3606 F1                  POP     AF              ; restore expected result flag (bit 6).
18286   3607 FD AE 01            XOR     (IY+$01)        ; xor with FLAGS now updated by SCANNING.
18287   360A E6 40               AND     $40             ; test bit 6 - should be zero if result types
18288   360C                                             ; match.
18289   360C             
18290   360C             ;; V-RPORT-C
18291   360C C2 8A 1C    L360C:   JP      NZ,L1C8A        ; jump back to REPORT-C with a result mismatch.
18292   360F             
18293   360F 22 5D 5C            LD      ($5C5D),HL      ; set CH_ADD to the start of the string again.
18294   3612 FD CB 01 FE         SET     7,(IY+$01)      ; update FLAGS  - signal running program.
18295   3616 CD FB 24            CALL    L24FB           ; routine SCANNING evaluates the string
18296   3619                                             ; in full leaving result on calculator stack.
18297   3619             
18298   3619 E1                  POP     HL              ; restore saved character address in program.
18299   361A 22 5D 5C            LD      ($5C5D),HL      ; and reset the system variable CH_ADD.
18300   361D             
18301   361D 18 A0               JR      L35BF           ; back to exit via STK-PNTRS.
18302   361F                                             ; resetting the calculator stack pointers
18303   361F                                             ; HL and DE from STKEND as it wasn't possible 
18304   361F                                             ; to preserve them during this routine.
18305   361F             
18306   361F             ; -------------------
18307   361F             ; THE 'STR$' FUNCTION
18308   361F             ; -------------------
18309   361F             ; (offset: $2e 'str$')
18310   361F             ;   This function produces a string comprising the characters that would appear
18311   361F             ;   if the numeric argument were printed.
18312   361F             ;   e.g. STR$ (1/10) produces "0.1".
18313   361F             
18314   361F             ;; str$
18315   361F 01 01 00    L361F:   LD      BC,$0001        ; create an initial byte in workspace
18316   3622 F7                  RST     30H             ; using BC-SPACES restart.
18317   3623             
18318   3623 22 5B 5C            LD      ($5C5B),HL      ; set system variable K_CUR to new location.
18319   3626 E5                  PUSH    HL              ; and save start on machine stack also.
18320   3627             
18321   3627 2A 51 5C            LD      HL,($5C51)      ; fetch value of system variable CURCHL
18322   362A E5                  PUSH    HL              ; and save that too.
18323   362B             
18324   362B 3E FF               LD      A,$FF           ; select system channel 'R'.
18325   362D CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens it.
18326   3630 CD E3 2D            CALL    L2DE3           ; routine PRINT-FP outputs the number to
18327   3633                                             ; workspace updating K-CUR.
18328   3633             
18329   3633 E1                  POP     HL              ; restore current channel.
18330   3634 CD 15 16            CALL    L1615           ; routine CHAN-FLAG resets flags.
18331   3637             
18332   3637 D1                  POP     DE              ; fetch saved start of string to DE.
18333   3638 2A 5B 5C            LD      HL,($5C5B)      ; load HL with end of string from K_CUR.
18334   363B             
18335   363B A7                  AND     A               ; prepare for true subtraction.
18336   363C ED 52               SBC     HL,DE           ; subtract start from end to give length.
18337   363E 44                  LD      B,H             ; transfer the length to
18338   363F 4D                  LD      C,L             ; the BC register pair.
18339   3640             
18340   3640 CD B2 2A            CALL    L2AB2           ; routine STK-STO-$ stores string parameters
18341   3643                                             ; on the calculator stack.
18342   3643             
18343   3643 EB                  EX      DE,HL           ; HL = last value, DE = STKEND.
18344   3644 C9                  RET                     ; return.
18345   3645             
18346   3645             ; ------------------------
18347   3645             ; THE 'READ-IN' SUBROUTINE
18348   3645             ; ------------------------
18349   3645             ; (offset: $1a 'read-in')
18350   3645             ;   This is the calculator literal used by the INKEY$ function when a '#'
18351   3645             ;   is encountered after the keyword.
18352   3645             ;   INKEY$ # does not interact correctly with the keyboard, #0 or #1, and
18353   3645             ;   its uses are for other channels.
18354   3645             
18355   3645             ;; read-in
18356   3645 CD 94 1E    L3645:   CALL    L1E94           ; routine FIND-INT1 fetches stream to A
18357   3648 FE 10               CP      $10             ; compare with 16 decimal.
18358   364A D2 9F 1E            JP      NC,L1E9F        ; JUMP to REPORT-Bb if not in range 0 - 15.
18359   364D                                             ; 'Integer out of range'
18360   364D                                             ; (REPORT-Bd is within range)
18361   364D             
18362   364D 2A 51 5C            LD      HL,($5C51)      ; fetch current channel CURCHL
18363   3650 E5                  PUSH    HL              ; save it
18364   3651             
18365   3651 CD 01 16            CALL    L1601           ; routine CHAN-OPEN opens channel
18366   3654             
18367   3654 CD E6 15            CALL    L15E6           ; routine INPUT-AD - the channel must have an
18368   3657                                             ; input stream or else error here from stream
18369   3657                                             ; stub.
18370   3657 01 00 00            LD      BC,$0000        ; initialize length of string to zero
18371   365A 30 03               JR      NC,L365F        ; forward to R-I-STORE if no key detected.
18372   365C             
18373   365C 0C                  INC     C               ; increase length to one.
18374   365D             
18375   365D F7                  RST     30H             ; BC-SPACES creates space for one character
18376   365E                                             ; in workspace.
18377   365E 12                  LD      (DE),A          ; the character is inserted.
18378   365F             
18379   365F             ;; R-I-STORE
18380   365F CD B2 2A    L365F:   CALL    L2AB2           ; routine STK-STO-$ stacks the string
18381   3662                                             ; parameters.
18382   3662 E1                  POP     HL              ; restore current channel address
18383   3663             
18384   3663 CD 15 16            CALL    L1615           ; routine CHAN-FLAG resets current channel
18385   3666                                             ; system variable and flags.
18386   3666             
18387   3666 C3 BF 35            JP      L35BF           ; jump back to STK-PNTRS
18388   3669             
18389   3669             ; -------------------
18390   3669             ; THE 'CODE' FUNCTION
18391   3669             ; -------------------
18392   3669             ; (offset: $1c 'code')
18393   3669             ;   Returns the ASCII code of a character or first character of a string
18394   3669             ;   e.g. CODE "Aardvark" = 65, CODE "" = 0.
18395   3669             
18396   3669             ;; code
18397   3669 CD F1 2B    L3669:   CALL    L2BF1           ; routine STK-FETCH to fetch and delete the
18398   366C                                             ; string parameters.
18399   366C                                             ; DE points to the start, BC holds the length.
18400   366C             
18401   366C 78                  LD      A,B             ; test length
18402   366D B1                  OR      C               ; of the string.
18403   366E 28 01               JR      Z,L3671         ; skip to STK-CODE with zero if the null string.
18404   3670             
18405   3670 1A                  LD      A,(DE)          ; else fetch the first character.
18406   3671             
18407   3671             ;; STK-CODE
18408   3671 C3 28 2D    L3671:   JP      L2D28           ; jump back to STACK-A (with memory check)
18409   3674             
18410   3674             ; ------------------
18411   3674             ; THE 'LEN' FUNCTION
18412   3674             ; ------------------
18413   3674             ; (offset: $1e 'len')
18414   3674             ;   Returns the length of a string.
18415   3674             ;   In Sinclair BASIC strings can be more than twenty thousand characters long
18416   3674             ;   so a sixteen-bit register is required to store the length
18417   3674             
18418   3674             ;; len
18419   3674 CD F1 2B    L3674:   CALL    L2BF1           ; Routine STK-FETCH to fetch and delete the
18420   3677                                             ; string parameters from the calculator stack.
18421   3677                                             ; Register BC now holds the length of string.
18422   3677             
18423   3677 C3 2B 2D            JP      L2D2B           ; Jump back to STACK-BC to save result on the
18424   367A                                             ; calculator stack (with memory check).
18425   367A             
18426   367A             ; -------------------------------------
18427   367A             ; THE 'DECREASE THE COUNTER' SUBROUTINE
18428   367A             ; -------------------------------------
18429   367A             ; (offset: $35 'dec-jr-nz')
18430   367A             ;   The calculator has an instruction that decrements a single-byte
18431   367A             ;   pseudo-register and makes consequential relative jumps just like
18432   367A             ;   the Z80's DJNZ instruction.
18433   367A             
18434   367A             ;; dec-jr-nz
18435   367A D9          L367A:   EXX                     ; switch in set that addresses code
18436   367B             
18437   367B E5                  PUSH    HL              ; save pointer to offset byte
18438   367C 21 67 5C            LD      HL,$5C67        ; address BREG in system variables
18439   367F 35                  DEC     (HL)            ; decrement it
18440   3680 E1                  POP     HL              ; restore pointer
18441   3681             
18442   3681 20 04               JR      NZ,L3687        ; to JUMP-2 if not zero
18443   3683             
18444   3683 23                  INC     HL              ; step past the jump length.
18445   3684 D9                  EXX                     ; switch in the main set.
18446   3685 C9                  RET                     ; return.
18447   3686             
18448   3686             ; Note. as a general rule the calculator avoids using the IY register
18449   3686             ; otherwise the cumbersome 4 instructions in the middle could be replaced by
18450   3686             ; dec (iy+$2d) - three bytes instead of six.
18451   3686             
18452   3686             
18453   3686             ; ---------------------
18454   3686             ; THE 'JUMP' SUBROUTINE
18455   3686             ; ---------------------
18456   3686             ; (offset: $33 'jump')
18457   3686             ;   This enables the calculator to perform relative jumps just like the Z80 
18458   3686             ;   chip's JR instruction.
18459   3686             
18460   3686             ;; jump
18461   3686             ;; JUMP
18462   3686 D9          L3686:   EXX                     ; switch in pointer set
18463   3687             
18464   3687             ;; JUMP-2
18465   3687 5E          L3687:   LD      E,(HL)          ; the jump byte 0-127 forward, 128-255 back.
18466   3688 7B                  LD      A,E             ; transfer to accumulator.
18467   3689 17                  RLA                     ; if backward jump, carry is set.
18468   368A 9F                  SBC     A,A             ; will be $FF if backward or $00 if forward.
18469   368B 57                  LD      D,A             ; transfer to high byte.
18470   368C 19                  ADD     HL,DE           ; advance calculator pointer forward or back.
18471   368D             
18472   368D D9                  EXX                     ; switch back.
18473   368E C9                  RET                     ; return.
18474   368F             
18475   368F             ; --------------------------
18476   368F             ; THE 'JUMP-TRUE' SUBROUTINE
18477   368F             ; --------------------------
18478   368F             ; (offset: $00 'jump-true')
18479   368F             ;   This enables the calculator to perform conditional relative jumps dependent
18480   368F             ;   on whether the last test gave a true result.
18481   368F             
18482   368F             ;; jump-true
18483   368F 13          L368F:   INC     DE              ; Collect the 
18484   3690 13                  INC     DE              ; third byte
18485   3691 1A                  LD      A,(DE)          ; of the test
18486   3692 1B                  DEC     DE              ; result and
18487   3693 1B                  DEC     DE              ; backtrack.
18488   3694             
18489   3694 A7                  AND     A               ; Is result 0 or 1 ? 
18490   3695 20 EF               JR      NZ,L3686        ; Back to JUMP if true (1).
18491   3697             
18492   3697 D9                  EXX                     ; Else switch in the pointer set.
18493   3698 23                  INC     HL              ; Step past the jump length.
18494   3699 D9                  EXX                     ; Switch in the main set.
18495   369A C9                  RET                     ; Return.
18496   369B             
18497   369B             ; -------------------------
18498   369B             ; THE 'END-CALC' SUBROUTINE
18499   369B             ; -------------------------
18500   369B             ; (offset: $38 'end-calc')
18501   369B             ;   The end-calc literal terminates a mini-program written in the Spectrum's
18502   369B             ;   internal language.
18503   369B             
18504   369B             ;; end-calc
18505   369B F1          L369B:   POP     AF              ; Drop the calculator return address RE-ENTRY
18506   369C D9                  EXX                     ; Switch to the other set.
18507   369D             
18508   369D E3                  EX      (SP),HL         ; Transfer H'L' to machine stack for the
18509   369E                                             ; return address.
18510   369E                                             ; When exiting recursion, then the previous
18511   369E                                             ; pointer is transferred to H'L'.
18512   369E             
18513   369E D9                  EXX                     ; Switch back to main set.
18514   369F C9                  RET                     ; Return.
18515   36A0             
18516   36A0             
18517   36A0             ; ------------------------
18518   36A0             ; THE 'MODULUS' SUBROUTINE 
18519   36A0             ; ------------------------
18520   36A0             ; (offset: $32 'n-mod-m')
18521   36A0             ; (n1,n2 -- r,q)  
18522   36A0             ;   Similar to FORTH's 'divide mod' /MOD
18523   36A0             ;   On the Spectrum, this is only used internally by the RND function and could
18524   36A0             ;   have been implemented inline.  On the ZX81, this calculator routine was also
18525   36A0             ;   used by PRINT-FP.
18526   36A0             
18527   36A0             ;; n-mod-m
18528   36A0 EF          L36A0:   RST     28H             ;; FP-CALC          17, 3.
18529   36A1 C0                  DEFB    $C0             ;;st-mem-0          17, 3.
18530   36A2 02                  DEFB    $02             ;;delete            17.
18531   36A3 31                  DEFB    $31             ;;duplicate         17, 17.
18532   36A4 E0                  DEFB    $E0             ;;get-mem-0         17, 17, 3.
18533   36A5 05                  DEFB    $05             ;;division          17, 17/3.
18534   36A6 27                  DEFB    $27             ;;int               17, 5.
18535   36A7 E0                  DEFB    $E0             ;;get-mem-0         17, 5, 3.
18536   36A8 01                  DEFB    $01             ;;exchange          17, 3, 5.
18537   36A9 C0                  DEFB    $C0             ;;st-mem-0          17, 3, 5.
18538   36AA 04                  DEFB    $04             ;;multiply          17, 15.
18539   36AB 03                  DEFB    $03             ;;subtract          2.
18540   36AC E0                  DEFB    $E0             ;;get-mem-0         2, 5.
18541   36AD 38                  DEFB    $38             ;;end-calc          2, 5.
18542   36AE             
18543   36AE C9                  RET                     ; return.
18544   36AF             
18545   36AF             
18546   36AF             ; ------------------
18547   36AF             ; THE 'INT' FUNCTION
18548   36AF             ; ------------------
18549   36AF             ; (offset $27: 'int' )
18550   36AF             ; This function returns the integer of x, which is just the same as truncate
18551   36AF             ; for positive numbers. The truncate literal truncates negative numbers
18552   36AF             ; upwards so that -3.4 gives -3 whereas the BASIC INT function has to
18553   36AF             ; truncate negative numbers down so that INT -3.4 is -4.
18554   36AF             ; It is best to work through using, say, +-3.4 as examples.
18555   36AF             
18556   36AF             ;; int
18557   36AF EF          L36AF:   RST     28H             ;; FP-CALC              x.    (= 3.4 or -3.4).
18558   36B0 31                  DEFB    $31             ;;duplicate             x, x.
18559   36B1 36                  DEFB    $36             ;;less-0                x, (1/0)
18560   36B2 00                  DEFB    $00             ;;jump-true             x, (1/0)
18561   36B3 04                  DEFB    $04             ;;to L36B7, X-NEG
18562   36B4             
18563   36B4 3A                  DEFB    $3A             ;;truncate              trunc 3.4 = 3.
18564   36B5 38                  DEFB    $38             ;;end-calc              3.
18565   36B6             
18566   36B6 C9                  RET                     ; return with + int x on stack.
18567   36B7             
18568   36B7             ; ---
18569   36B7             
18570   36B7             
18571   36B7             ;; X-NEG
18572   36B7 31          L36B7:   DEFB    $31             ;;duplicate             -3.4, -3.4.
18573   36B8 3A                  DEFB    $3A             ;;truncate              -3.4, -3.
18574   36B9 C0                  DEFB    $C0             ;;st-mem-0              -3.4, -3.
18575   36BA 03                  DEFB    $03             ;;subtract              -.4
18576   36BB E0                  DEFB    $E0             ;;get-mem-0             -.4, -3.
18577   36BC 01                  DEFB    $01             ;;exchange              -3, -.4.
18578   36BD 30                  DEFB    $30             ;;not                   -3, (0).
18579   36BE 00                  DEFB    $00             ;;jump-true             -3.
18580   36BF 03                  DEFB    $03             ;;to L36C2, EXIT        -3.
18581   36C0             
18582   36C0 A1                  DEFB    $A1             ;;stk-one               -3, 1.
18583   36C1 03                  DEFB    $03             ;;subtract              -4.
18584   36C2             
18585   36C2             ;; EXIT
18586   36C2 38          L36C2:   DEFB    $38             ;;end-calc              -4.
18587   36C3             
18588   36C3 C9                  RET                     ; return.
18589   36C4             
18590   36C4             
18591   36C4             ; ------------------
18592   36C4             ; THE 'EXP' FUNCTION
18593   36C4             ; ------------------
18594   36C4             ; (offset $26: 'exp')
18595   36C4             ;   The exponential function EXP x is equal to e^x, where e is the mathematical
18596   36C4             ;   name for a number approximated to 2.718281828.
18597   36C4             ;   ERROR 6 if argument is more than about 88.
18598   36C4             
18599   36C4             ;; EXP
18600   36C4             ;; exp
18601   36C4 EF          L36C4:   RST     28H             ;; FP-CALC
18602   36C5 3D                  DEFB    $3D             ;;re-stack      (not required - mult will do)
18603   36C6 34                  DEFB    $34             ;;stk-data
18604   36C7 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
18605   36C8 38 AA 3B 29         DEFB    $38,$AA,$3B,$29 ;;
18606   36CC 04                  DEFB    $04             ;;multiply
18607   36CD 31                  DEFB    $31             ;;duplicate
18608   36CE 27                  DEFB    $27             ;;int
18609   36CF C3                  DEFB    $C3             ;;st-mem-3
18610   36D0 03                  DEFB    $03             ;;subtract
18611   36D1 31                  DEFB    $31             ;;duplicate
18612   36D2 0F                  DEFB    $0F             ;;addition
18613   36D3 A1                  DEFB    $A1             ;;stk-one
18614   36D4 03                  DEFB    $03             ;;subtract
18615   36D5 88                  DEFB    $88             ;;series-08
18616   36D6 13                  DEFB    $13             ;;Exponent: $63, Bytes: 1
18617   36D7 36                  DEFB    $36             ;;(+00,+00,+00)
18618   36D8 58                  DEFB    $58             ;;Exponent: $68, Bytes: 2
18619   36D9 65 66               DEFB    $65,$66         ;;(+00,+00)
18620   36DB 9D                  DEFB    $9D             ;;Exponent: $6D, Bytes: 3
18621   36DC 78 65 40            DEFB    $78,$65,$40     ;;(+00)
18622   36DF A2                  DEFB    $A2             ;;Exponent: $72, Bytes: 3
18623   36E0 60 32 C9            DEFB    $60,$32,$C9     ;;(+00)
18624   36E3 E7                  DEFB    $E7             ;;Exponent: $77, Bytes: 4
18625   36E4 21 F7 AF 24         DEFB    $21,$F7,$AF,$24 ;;
18626   36E8 EB                  DEFB    $EB             ;;Exponent: $7B, Bytes: 4
18627   36E9 2F B0 B0 14         DEFB    $2F,$B0,$B0,$14 ;;
18628   36ED EE                  DEFB    $EE             ;;Exponent: $7E, Bytes: 4
18629   36EE 7E BB 94 58         DEFB    $7E,$BB,$94,$58 ;;
18630   36F2 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
18631   36F3 3A 7E F8 CF         DEFB    $3A,$7E,$F8,$CF ;;
18632   36F7 E3                  DEFB    $E3             ;;get-mem-3
18633   36F8 38                  DEFB    $38             ;;end-calc
18634   36F9             
18635   36F9 CD D5 2D            CALL    L2DD5           ; routine FP-TO-A
18636   36FC 20 07               JR      NZ,L3705        ; to N-NEGTV
18637   36FE             
18638   36FE 38 03               JR      C,L3703         ; to REPORT-6b
18639   3700                                             ; 'Number too big'
18640   3700             
18641   3700 86                  ADD     A,(HL)          ;
18642   3701 30 09               JR      NC,L370C        ; to RESULT-OK
18643   3703             
18644   3703             
18645   3703             ;; REPORT-6b
18646   3703 CF          L3703:   RST     08H             ; ERROR-1
18647   3704 05                  DEFB    $05             ; Error Report: Number too big
18648   3705             
18649   3705             ; ---
18650   3705             
18651   3705             ;; N-NEGTV
18652   3705 38 07       L3705:   JR      C,L370E         ; to RSLT-ZERO
18653   3707             
18654   3707 96                  SUB     (HL)            ;
18655   3708 30 04               JR      NC,L370E        ; to RSLT-ZERO
18656   370A             
18657   370A ED 44               NEG                     ; Negate
18658   370C             
18659   370C             ;; RESULT-OK
18660   370C 77          L370C:   LD      (HL),A          ;
18661   370D C9                  RET                     ; return.
18662   370E             
18663   370E             ; ---
18664   370E             
18665   370E             
18666   370E             ;; RSLT-ZERO
18667   370E EF          L370E:   RST     28H             ;; FP-CALC
18668   370F 02                  DEFB    $02             ;;delete
18669   3710 A0                  DEFB    $A0             ;;stk-zero
18670   3711 38                  DEFB    $38             ;;end-calc
18671   3712             
18672   3712 C9                  RET                     ; return.
18673   3713             
18674   3713             
18675   3713             ; --------------------------------
18676   3713             ; THE 'NATURAL LOGARITHM' FUNCTION 
18677   3713             ; --------------------------------
18678   3713             ; (offset $25: 'ln')
18679   3713             ;   Function to calculate the natural logarithm (to the base e ). 
18680   3713             ;   Natural logarithms were devised in 1614 by well-traveled Scotsman John 
18681   3713             ;   Napier who noted
18682   3713             ;   "Nothing doth more molest and hinder calculators than the multiplications,
18683   3713             ;    divisions, square and cubical extractions of great numbers".
18684   3713             ;
18685   3713             ;   Napier's logarithms enabled the above operations to be accomplished by 
18686   3713             ;   simple addition and subtraction simplifying the navigational and 
18687   3713             ;   astronomical calculations which beset his age.
18688   3713             ;   Napier's logarithms were quickly overtaken by logarithms to the base 10
18689   3713             ;   devised, in conjunction with Napier, by Henry Briggs a Cambridge-educated 
18690   3713             ;   professor of Geometry at Oxford University. These simplified the layout
18691   3713             ;   of the tables enabling humans to easily scale calculations.
18692   3713             ;
18693   3713             ;   It is only recently with the introduction of pocket calculators and machines
18694   3713             ;   like the ZX Spectrum that natural logarithms are once more at the fore,
18695   3713             ;   although some computers retain logarithms to the base ten.
18696   3713             ;
18697   3713             ;   'Natural' logarithms are powers to the base 'e', which like 'pi' is a 
18698   3713             ;   naturally occurring number in branches of mathematics.
18699   3713             ;   Like 'pi' also, 'e' is an irrational number and starts 2.718281828...
18700   3713             ;
18701   3713             ;   The tabular use of logarithms was that to multiply two numbers one looked
18702   3713             ;   up their two logarithms in the tables, added them together and then looked 
18703   3713             ;   for the result in a table of antilogarithms to give the desired product.
18704   3713             ;
18705   3713             ;   The EXP function is the BASIC equivalent of a calculator's 'antiln' function 
18706   3713             ;   and by picking any two numbers, 1.72 and 6.89 say,
18707   3713             ;     10 PRINT EXP ( LN 1.72 + LN 6.89 ) 
18708   3713             ;   will give just the same result as
18709   3713             ;     20 PRINT 1.72 * 6.89.
18710   3713             ;   Division is accomplished by subtracting the two logs.
18711   3713             ;
18712   3713             ;   Napier also mentioned "square and cubicle extractions". 
18713   3713             ;   To raise a number to the power 3, find its 'ln', multiply by 3 and find the 
18714   3713             ;   'antiln'.  e.g. PRINT EXP( LN 4 * 3 )  gives 64.
18715   3713             ;   Similarly to find the n'th root divide the logarithm by 'n'.
18716   3713             ;   The ZX81 ROM used PRINT EXP ( LN 9 / 2 ) to find the square root of the 
18717   3713             ;   number 9. The Napieran square root function is just a special case of 
18718   3713             ;   the 'to_power' function. A cube root or indeed any root/power would be just
18719   3713             ;   as simple.
18720   3713             
18721   3713             ;   First test that the argument to LN is a positive, non-zero number.
18722   3713             ;   Error A if the argument is 0 or negative.
18723   3713             
18724   3713             ;; ln
18725   3713 EF          L3713:   RST     28H             ;; FP-CALC
18726   3714 3D                  DEFB    $3D             ;;re-stack
18727   3715 31                  DEFB    $31             ;;duplicate
18728   3716 37                  DEFB    $37             ;;greater-0
18729   3717 00                  DEFB    $00             ;;jump-true
18730   3718 04                  DEFB    $04             ;;to L371C, VALID
18731   3719             
18732   3719 38                  DEFB    $38             ;;end-calc
18733   371A             
18734   371A             
18735   371A             ;; REPORT-Ab
18736   371A CF          L371A:   RST     08H             ; ERROR-1
18737   371B 09                  DEFB    $09             ; Error Report: Invalid argument
18738   371C             
18739   371C             ;; VALID
18740   371C A0          L371C:   DEFB    $A0             ;;stk-zero              Note. not 
18741   371D 02                  DEFB    $02             ;;delete                necessary.
18742   371E 38                  DEFB    $38             ;;end-calc
18743   371F 7E                  LD      A,(HL)          ;
18744   3720             
18745   3720 36 80               LD      (HL),$80        ;
18746   3722 CD 28 2D            CALL    L2D28           ; routine STACK-A
18747   3725             
18748   3725 EF                  RST     28H             ;; FP-CALC
18749   3726 34                  DEFB    $34             ;;stk-data
18750   3727 38                  DEFB    $38             ;;Exponent: $88, Bytes: 1
18751   3728 00                  DEFB    $00             ;;(+00,+00,+00)
18752   3729 03                  DEFB    $03             ;;subtract
18753   372A 01                  DEFB    $01             ;;exchange
18754   372B 31                  DEFB    $31             ;;duplicate
18755   372C 34                  DEFB    $34             ;;stk-data
18756   372D F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18757   372E 4C CC CC CD         DEFB    $4C,$CC,$CC,$CD ;;
18758   3732 03                  DEFB    $03             ;;subtract
18759   3733 37                  DEFB    $37             ;;greater-0
18760   3734 00                  DEFB    $00             ;;jump-true
18761   3735 08                  DEFB    $08             ;;to L373D, GRE.8
18762   3736             
18763   3736 01                  DEFB    $01             ;;exchange
18764   3737 A1                  DEFB    $A1             ;;stk-one
18765   3738 03                  DEFB    $03             ;;subtract
18766   3739 01                  DEFB    $01             ;;exchange
18767   373A 38                  DEFB    $38             ;;end-calc
18768   373B             
18769   373B 34                  INC     (HL)            ;
18770   373C             
18771   373C EF                  RST     28H             ;; FP-CALC
18772   373D             
18773   373D             ;; GRE.8
18774   373D 01          L373D:   DEFB    $01             ;;exchange
18775   373E 34                  DEFB    $34             ;;stk-data
18776   373F F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18777   3740 31 72 17 F8         DEFB    $31,$72,$17,$F8 ;;
18778   3744 04                  DEFB    $04             ;;multiply
18779   3745 01                  DEFB    $01             ;;exchange
18780   3746 A2                  DEFB    $A2             ;;stk-half
18781   3747 03                  DEFB    $03             ;;subtract
18782   3748 A2                  DEFB    $A2             ;;stk-half
18783   3749 03                  DEFB    $03             ;;subtract
18784   374A 31                  DEFB    $31             ;;duplicate
18785   374B 34                  DEFB    $34             ;;stk-data
18786   374C 32                  DEFB    $32             ;;Exponent: $82, Bytes: 1
18787   374D 20                  DEFB    $20             ;;(+00,+00,+00)
18788   374E 04                  DEFB    $04             ;;multiply
18789   374F A2                  DEFB    $A2             ;;stk-half
18790   3750 03                  DEFB    $03             ;;subtract
18791   3751 8C                  DEFB    $8C             ;;series-0C
18792   3752 11                  DEFB    $11             ;;Exponent: $61, Bytes: 1
18793   3753 AC                  DEFB    $AC             ;;(+00,+00,+00)
18794   3754 14                  DEFB    $14             ;;Exponent: $64, Bytes: 1
18795   3755 09                  DEFB    $09             ;;(+00,+00,+00)
18796   3756 56                  DEFB    $56             ;;Exponent: $66, Bytes: 2
18797   3757 DA A5               DEFB    $DA,$A5         ;;(+00,+00)
18798   3759 59                  DEFB    $59             ;;Exponent: $69, Bytes: 2
18799   375A 30 C5               DEFB    $30,$C5         ;;(+00,+00)
18800   375C 5C                  DEFB    $5C             ;;Exponent: $6C, Bytes: 2
18801   375D 90 AA               DEFB    $90,$AA         ;;(+00,+00)
18802   375F 9E                  DEFB    $9E             ;;Exponent: $6E, Bytes: 3
18803   3760 70 6F 61            DEFB    $70,$6F,$61     ;;(+00)
18804   3763 A1                  DEFB    $A1             ;;Exponent: $71, Bytes: 3
18805   3764 CB DA 96            DEFB    $CB,$DA,$96     ;;(+00)
18806   3767 A4                  DEFB    $A4             ;;Exponent: $74, Bytes: 3
18807   3768 31 9F B4            DEFB    $31,$9F,$B4     ;;(+00)
18808   376B E7                  DEFB    $E7             ;;Exponent: $77, Bytes: 4
18809   376C A0 FE 5C FC         DEFB    $A0,$FE,$5C,$FC ;;
18810   3770 EA                  DEFB    $EA             ;;Exponent: $7A, Bytes: 4
18811   3771 1B 43 CA 36         DEFB    $1B,$43,$CA,$36 ;;
18812   3775 ED                  DEFB    $ED             ;;Exponent: $7D, Bytes: 4
18813   3776 A7 9C 7E 5E         DEFB    $A7,$9C,$7E,$5E ;;
18814   377A F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
18815   377B 6E 23 80 93         DEFB    $6E,$23,$80,$93 ;;
18816   377F 04                  DEFB    $04             ;;multiply
18817   3780 0F                  DEFB    $0F             ;;addition
18818   3781 38                  DEFB    $38             ;;end-calc
18819   3782             
18820   3782 C9                  RET                     ; return.
18821   3783             
18822   3783             
18823   3783             ; -----------------------------
18824   3783             ; THE 'TRIGONOMETRIC' FUNCTIONS
18825   3783             ; -----------------------------
18826   3783             ; Trigonometry is rocket science. It is also used by carpenters and pyramid
18827   3783             ; builders. 
18828   3783             ; Some uses can be quite abstract but the principles can be seen in simple
18829   3783             ; right-angled triangles. Triangles have some special properties -
18830   3783             ;
18831   3783             ; 1) The sum of the three angles is always PI radians (180 degrees).
18832   3783             ;    Very helpful if you know two angles and wish to find the third.
18833   3783             ; 2) In any right-angled triangle the sum of the squares of the two shorter
18834   3783             ;    sides is equal to the square of the longest side opposite the right-angle.
18835   3783             ;    Very useful if you know the length of two sides and wish to know the
18836   3783             ;    length of the third side.
18837   3783             ; 3) Functions sine, cosine and tangent enable one to calculate the length 
18838   3783             ;    of an unknown side when the length of one other side and an angle is 
18839   3783             ;    known.
18840   3783             ; 4) Functions arcsin, arccosine and arctan enable one to calculate an unknown
18841   3783             ;    angle when the length of two of the sides is known.
18842   3783             
18843   3783             ; --------------------------------
18844   3783             ; THE 'REDUCE ARGUMENT' SUBROUTINE
18845   3783             ; --------------------------------
18846   3783             ; (offset $39: 'get-argt')
18847   3783             ;
18848   3783             ; This routine performs two functions on the angle, in radians, that forms
18849   3783             ; the argument to the sine and cosine functions.
18850   3783             ; First it ensures that the angle 'wraps round'. That if a ship turns through 
18851   3783             ; an angle of, say, 3*PI radians (540 degrees) then the net effect is to turn 
18852   3783             ; through an angle of PI radians (180 degrees).
18853   3783             ; Secondly it converts the angle in radians to a fraction of a right angle,
18854   3783             ; depending within which quadrant the angle lies, with the periodicity 
18855   3783             ; resembling that of the desired sine value.
18856   3783             ; The result lies in the range -1 to +1.              
18857   3783             ;
18858   3783             ;                     90 deg.
18859   3783             ; 
18860   3783             ;                     (pi/2)
18861   3783             ;              II       +1        I
18862   3783             ;                       |
18863   3783             ;        sin+      |\   |   /|    sin+
18864   3783             ;        cos-      | \  |  / |    cos+
18865   3783             ;        tan-      |  \ | /  |    tan+
18866   3783             ;                  |   \|/)  |           
18867   3783             ; 180 deg. (pi) 0 -|----+----|-- 0  (0)   0 degrees
18868   3783             ;                  |   /|\   |
18869   3783             ;        sin-      |  / | \  |    sin-
18870   3783             ;        cos-      | /  |  \ |    cos+
18871   3783             ;        tan+      |/   |   \|    tan-
18872   3783             ;                       |
18873   3783             ;              III      -1       IV
18874   3783             ;                     (3pi/2)
18875   3783             ;
18876   3783             ;                     270 deg.
18877   3783             ;
18878   3783             
18879   3783             ;; get-argt
18880   3783 EF          L3783:   RST     28H             ;; FP-CALC      X.
18881   3784 3D                  DEFB    $3D             ;;re-stack      (not rquired done by mult)
18882   3785 34                  DEFB    $34             ;;stk-data
18883   3786 EE                  DEFB    $EE             ;;Exponent: $7E, 
18884   3787                                             ;;Bytes: 4
18885   3787 22 F9 83 6E         DEFB    $22,$F9,$83,$6E ;;              X, 1/(2*PI)
18886   378B 04                  DEFB    $04             ;;multiply      X/(2*PI) = fraction
18887   378C 31                  DEFB    $31             ;;duplicate
18888   378D A2                  DEFB    $A2             ;;stk-half
18889   378E 0F                  DEFB    $0F             ;;addition
18890   378F 27                  DEFB    $27             ;;int
18891   3790             
18892   3790 03                  DEFB    $03             ;;subtract      now range -.5 to .5
18893   3791             
18894   3791 31                  DEFB    $31             ;;duplicate
18895   3792 0F                  DEFB    $0F             ;;addition      now range -1 to 1.
18896   3793 31                  DEFB    $31             ;;duplicate
18897   3794 0F                  DEFB    $0F             ;;addition      now range -2 to +2.
18898   3795             
18899   3795             ; quadrant I (0 to +1) and quadrant IV (-1 to 0) are now correct.
18900   3795             ; quadrant II ranges +1 to +2.
18901   3795             ; quadrant III ranges -2 to -1.
18902   3795             
18903   3795 31                  DEFB    $31             ;;duplicate     Y, Y.
18904   3796 2A                  DEFB    $2A             ;;abs           Y, abs(Y).    range 1 to 2
18905   3797 A1                  DEFB    $A1             ;;stk-one       Y, abs(Y), 1.
18906   3798 03                  DEFB    $03             ;;subtract      Y, abs(Y)-1.  range 0 to 1
18907   3799 31                  DEFB    $31             ;;duplicate     Y, Z, Z.
18908   379A 37                  DEFB    $37             ;;greater-0     Y, Z, (1/0).
18909   379B             
18910   379B C0                  DEFB    $C0             ;;st-mem-0         store as possible sign 
18911   379C                                             ;;                 for cosine function.
18912   379C             
18913   379C 00                  DEFB    $00             ;;jump-true
18914   379D 04                  DEFB    $04             ;;to L37A1, ZPLUS  with quadrants II and III.
18915   379E             
18916   379E             ; else the angle lies in quadrant I or IV and value Y is already correct.
18917   379E             
18918   379E 02                  DEFB    $02             ;;delete        Y.   delete the test value.
18919   379F 38                  DEFB    $38             ;;end-calc      Y.
18920   37A0             
18921   37A0 C9                  RET                     ; return.       with Q1 and Q4           >>>
18922   37A1             
18923   37A1             ; ---
18924   37A1             
18925   37A1             ; the branch was here with quadrants II (0 to 1) and III (1 to 0).
18926   37A1             ; Y will hold -2 to -1 if this is quadrant III.
18927   37A1             
18928   37A1             ;; ZPLUS
18929   37A1 A1          L37A1:   DEFB    $A1             ;;stk-one         Y, Z, 1.
18930   37A2 03                  DEFB    $03             ;;subtract        Y, Z-1.       Q3 = 0 to -1
18931   37A3 01                  DEFB    $01             ;;exchange        Z-1, Y.
18932   37A4 36                  DEFB    $36             ;;less-0          Z-1, (1/0).
18933   37A5 00                  DEFB    $00             ;;jump-true       Z-1.
18934   37A6 02                  DEFB    $02             ;;to L37A8, YNEG
18935   37A7                                             ;;if angle in quadrant III
18936   37A7             
18937   37A7             ; else angle is within quadrant II (-1 to 0)
18938   37A7             
18939   37A7 1B                  DEFB    $1B             ;;negate          range +1 to 0.
18940   37A8             
18941   37A8             ;; YNEG
18942   37A8 38          L37A8:   DEFB    $38             ;;end-calc        quadrants II and III correct.
18943   37A9             
18944   37A9 C9                  RET                     ; return.
18945   37AA             
18946   37AA             
18947   37AA             ; ---------------------
18948   37AA             ; THE 'COSINE' FUNCTION
18949   37AA             ; ---------------------
18950   37AA             ; (offset $20: 'cos')
18951   37AA             ; Cosines are calculated as the sine of the opposite angle rectifying the 
18952   37AA             ; sign depending on the quadrant rules. 
18953   37AA             ;
18954   37AA             ;
18955   37AA             ;           /|
18956   37AA             ;        h /y|
18957   37AA             ;         /  |o
18958   37AA             ;        /x  |
18959   37AA             ;       /----|    
18960   37AA             ;         a
18961   37AA             ;
18962   37AA             ; The cosine of angle x is the adjacent side (a) divided by the hypotenuse 1.
18963   37AA             ; However if we examine angle y then a/h is the sine of that angle.
18964   37AA             ; Since angle x plus angle y equals a right-angle, we can find angle y by 
18965   37AA             ; subtracting angle x from pi/2.
18966   37AA             ; However it's just as easy to reduce the argument first and subtract the
18967   37AA             ; reduced argument from the value 1 (a reduced right-angle).
18968   37AA             ; It's even easier to subtract 1 from the angle and rectify the sign.
18969   37AA             ; In fact, after reducing the argument, the absolute value of the argument
18970   37AA             ; is used and rectified using the test result stored in mem-0 by 'get-argt'
18971   37AA             ; for that purpose.
18972   37AA             ;
18973   37AA             
18974   37AA             ;; cos
18975   37AA EF          L37AA:   RST     28H             ;; FP-CALC              angle in radians.
18976   37AB 39                  DEFB    $39             ;;get-argt              X     reduce -1 to +1 
18977   37AC             
18978   37AC 2A                  DEFB    $2A             ;;abs                   ABS X.   0 to 1
18979   37AD A1                  DEFB    $A1             ;;stk-one               ABS X, 1.
18980   37AE 03                  DEFB    $03             ;;subtract              now opposite angle
18981   37AF                                             ;;                      although sign is -ve.
18982   37AF             
18983   37AF E0                  DEFB    $E0             ;;get-mem-0             fetch the sign indicator
18984   37B0 00                  DEFB    $00             ;;jump-true
18985   37B1 06                  DEFB    $06             ;;fwd to L37B7, C-ENT
18986   37B2                                             ;;forward to common code if in QII or QIII.
18987   37B2             
18988   37B2 1B                  DEFB    $1B             ;;negate                else make sign +ve.
18989   37B3 33                  DEFB    $33             ;;jump
18990   37B4 03                  DEFB    $03             ;;fwd to L37B7, C-ENT
18991   37B5                                             ;; with quadrants I and IV.
18992   37B5             
18993   37B5             ; -------------------
18994   37B5             ; THE 'SINE' FUNCTION
18995   37B5             ; -------------------
18996   37B5             ; (offset $1F: 'sin')
18997   37B5             ; This is a fundamental transcendental function from which others such as cos
18998   37B5             ; and tan are directly, or indirectly, derived.
18999   37B5             ; It uses the series generator to produce Chebyshev polynomials.
19000   37B5             ;
19001   37B5             ;
19002   37B5             ;           /|
19003   37B5             ;        1 / |
19004   37B5             ;         /  |x
19005   37B5             ;        /a  |
19006   37B5             ;       /----|    
19007   37B5             ;         y
19008   37B5             ;
19009   37B5             ; The 'get-argt' function is designed to modify the angle and its sign 
19010   37B5             ; in line with the desired sine value and afterwards it can launch straight
19011   37B5             ; into common code.
19012   37B5             
19013   37B5             ;; sin
19014   37B5 EF          L37B5:   RST     28H             ;; FP-CALC      angle in radians
19015   37B6 39                  DEFB    $39             ;;get-argt      reduce - sign now correct.
19016   37B7             
19017   37B7             ;; C-ENT
19018   37B7 31          L37B7:   DEFB    $31             ;;duplicate
19019   37B8 31                  DEFB    $31             ;;duplicate
19020   37B9 04                  DEFB    $04             ;;multiply
19021   37BA 31                  DEFB    $31             ;;duplicate
19022   37BB 0F                  DEFB    $0F             ;;addition
19023   37BC A1                  DEFB    $A1             ;;stk-one
19024   37BD 03                  DEFB    $03             ;;subtract
19025   37BE             
19026   37BE 86                  DEFB    $86             ;;series-06
19027   37BF 14                  DEFB    $14             ;;Exponent: $64, Bytes: 1
19028   37C0 E6                  DEFB    $E6             ;;(+00,+00,+00)
19029   37C1 5C                  DEFB    $5C             ;;Exponent: $6C, Bytes: 2
19030   37C2 1F 0B               DEFB    $1F,$0B         ;;(+00,+00)
19031   37C4 A3                  DEFB    $A3             ;;Exponent: $73, Bytes: 3
19032   37C5 8F 38 EE            DEFB    $8F,$38,$EE     ;;(+00)
19033   37C8 E9                  DEFB    $E9             ;;Exponent: $79, Bytes: 4
19034   37C9 15 63 BB 23         DEFB    $15,$63,$BB,$23 ;;
19035   37CD EE                  DEFB    $EE             ;;Exponent: $7E, Bytes: 4
19036   37CE 92 0D CD ED         DEFB    $92,$0D,$CD,$ED ;;
19037   37D2 F1                  DEFB    $F1             ;;Exponent: $81, Bytes: 4
19038   37D3 23 5D 1B EA         DEFB    $23,$5D,$1B,$EA ;;
19039   37D7 04                  DEFB    $04             ;;multiply
19040   37D8 38                  DEFB    $38             ;;end-calc
19041   37D9             
19042   37D9 C9                  RET                     ; return.
19043   37DA             
19044   37DA             ; ----------------------
19045   37DA             ; THE 'TANGENT' FUNCTION
19046   37DA             ; ----------------------
19047   37DA             ; (offset $21: 'tan')
19048   37DA             ;
19049   37DA             ; Evaluates tangent x as    sin(x) / cos(x).
19050   37DA             ;
19051   37DA             ;
19052   37DA             ;           /|
19053   37DA             ;        h / |
19054   37DA             ;         /  |o
19055   37DA             ;        /x  |
19056   37DA             ;       /----|    
19057   37DA             ;         a
19058   37DA             ;
19059   37DA             ; the tangent of angle x is the ratio of the length of the opposite side 
19060   37DA             ; divided by the length of the adjacent side. As the opposite length can 
19061   37DA             ; be calculates using sin(x) and the adjacent length using cos(x) then 
19062   37DA             ; the tangent can be defined in terms of the previous two functions.
19063   37DA             
19064   37DA             ; Error 6 if the argument, in radians, is too close to one like pi/2
19065   37DA             ; which has an infinite tangent. e.g. PRINT TAN (PI/2)  evaluates as 1/0.
19066   37DA             ; Similarly PRINT TAN (3*PI/2), TAN (5*PI/2) etc.
19067   37DA             
19068   37DA             ;; tan
19069   37DA EF          L37DA:   RST     28H             ;; FP-CALC          x.
19070   37DB 31                  DEFB    $31             ;;duplicate         x, x.
19071   37DC 1F                  DEFB    $1F             ;;sin               x, sin x.
19072   37DD 01                  DEFB    $01             ;;exchange          sin x, x.
19073   37DE 20                  DEFB    $20             ;;cos               sin x, cos x.
19074   37DF 05                  DEFB    $05             ;;division          sin x/cos x (= tan x).
19075   37E0 38                  DEFB    $38             ;;end-calc          tan x.
19076   37E1             
19077   37E1 C9                  RET                     ; return.
19078   37E2             
19079   37E2             ; ---------------------
19080   37E2             ; THE 'ARCTAN' FUNCTION
19081   37E2             ; ---------------------
19082   37E2             ; (Offset $24: 'atn')
19083   37E2             ; the inverse tangent function with the result in radians.
19084   37E2             ; This is a fundamental transcendental function from which others such as asn
19085   37E2             ; and acs are directly, or indirectly, derived.
19086   37E2             ; It uses the series generator to produce Chebyshev polynomials.
19087   37E2             
19088   37E2             ;; atn
19089   37E2 CD 97 32    L37E2:   CALL    L3297           ; routine re-stack
19090   37E5 7E                  LD      A,(HL)          ; fetch exponent byte.
19091   37E6 FE 81               CP      $81             ; compare to that for 'one'
19092   37E8 38 0E               JR      C,L37F8         ; forward, if less, to SMALL
19093   37EA             
19094   37EA EF                  RST     28H             ;; FP-CALC
19095   37EB A1                  DEFB    $A1             ;;stk-one
19096   37EC 1B                  DEFB    $1B             ;;negate
19097   37ED 01                  DEFB    $01             ;;exchange
19098   37EE 05                  DEFB    $05             ;;division
19099   37EF 31                  DEFB    $31             ;;duplicate
19100   37F0 36                  DEFB    $36             ;;less-0
19101   37F1 A3                  DEFB    $A3             ;;stk-pi/2
19102   37F2 01                  DEFB    $01             ;;exchange
19103   37F3 00                  DEFB    $00             ;;jump-true
19104   37F4 06                  DEFB    $06             ;;to L37FA, CASES
19105   37F5             
19106   37F5 1B                  DEFB    $1B             ;;negate
19107   37F6 33                  DEFB    $33             ;;jump
19108   37F7 03                  DEFB    $03             ;;to L37FA, CASES
19109   37F8             
19110   37F8             ;; SMALL
19111   37F8 EF          L37F8:   RST     28H             ;; FP-CALC
19112   37F9 A0                  DEFB    $A0             ;;stk-zero
19113   37FA             
19114   37FA             ;; CASES
19115   37FA 01          L37FA:   DEFB    $01             ;;exchange
19116   37FB 31                  DEFB    $31             ;;duplicate
19117   37FC 31                  DEFB    $31             ;;duplicate
19118   37FD 04                  DEFB    $04             ;;multiply
19119   37FE 31                  DEFB    $31             ;;duplicate
19120   37FF 0F                  DEFB    $0F             ;;addition
19121   3800 A1                  DEFB    $A1             ;;stk-one
19122   3801 03                  DEFB    $03             ;;subtract
19123   3802 8C                  DEFB    $8C             ;;series-0C
19124   3803 10                  DEFB    $10             ;;Exponent: $60, Bytes: 1
19125   3804 B2                  DEFB    $B2             ;;(+00,+00,+00)
19126   3805 13                  DEFB    $13             ;;Exponent: $63, Bytes: 1
19127   3806 0E                  DEFB    $0E             ;;(+00,+00,+00)
19128   3807 55                  DEFB    $55             ;;Exponent: $65, Bytes: 2
19129   3808 E4 8D               DEFB    $E4,$8D         ;;(+00,+00)
19130   380A 58                  DEFB    $58             ;;Exponent: $68, Bytes: 2
19131   380B 39 BC               DEFB    $39,$BC         ;;(+00,+00)
19132   380D 5B                  DEFB    $5B             ;;Exponent: $6B, Bytes: 2
19133   380E 98 FD               DEFB    $98,$FD         ;;(+00,+00)
19134   3810 9E                  DEFB    $9E             ;;Exponent: $6E, Bytes: 3
19135   3811 00 36 75            DEFB    $00,$36,$75     ;;(+00)
19136   3814 A0                  DEFB    $A0             ;;Exponent: $70, Bytes: 3
19137   3815 DB E8 B4            DEFB    $DB,$E8,$B4     ;;(+00)
19138   3818 63                  DEFB    $63             ;;Exponent: $73, Bytes: 2
19139   3819 42 C4               DEFB    $42,$C4         ;;(+00,+00)
19140   381B E6                  DEFB    $E6             ;;Exponent: $76, Bytes: 4
19141   381C B5 09 36 BE         DEFB    $B5,$09,$36,$BE ;;
19142   3820 E9                  DEFB    $E9             ;;Exponent: $79, Bytes: 4
19143   3821 36 73 1B 5D         DEFB    $36,$73,$1B,$5D ;;
19144   3825 EC                  DEFB    $EC             ;;Exponent: $7C, Bytes: 4
19145   3826 D8 DE 63 BE         DEFB    $D8,$DE,$63,$BE ;;
19146   382A F0                  DEFB    $F0             ;;Exponent: $80, Bytes: 4
19147   382B 61 A1 B3 0C         DEFB    $61,$A1,$B3,$0C ;;
19148   382F 04                  DEFB    $04             ;;multiply
19149   3830 0F                  DEFB    $0F             ;;addition
19150   3831 38                  DEFB    $38             ;;end-calc
19151   3832             
19152   3832 C9                  RET                     ; return.
19153   3833             
19154   3833             
19155   3833             ; ---------------------
19156   3833             ; THE 'ARCSIN' FUNCTION
19157   3833             ; ---------------------
19158   3833             ; (Offset $22: 'asn')
19159   3833             ;   The inverse sine function with result in radians.
19160   3833             ;   Derived from arctan function above.
19161   3833             ;   Error A unless the argument is between -1 and +1 inclusive.
19162   3833             ;   Uses an adaptation of the formula asn(x) = atn(x/sqr(1-x*x))
19163   3833             ;
19164   3833             ;
19165   3833             ;                 /|
19166   3833             ;                / |
19167   3833             ;              1/  |x
19168   3833             ;              /a  |
19169   3833             ;             /----|    
19170   3833             ;               y
19171   3833             ;
19172   3833             ;   e.g. We know the opposite side (x) and hypotenuse (1) 
19173   3833             ;   and we wish to find angle a in radians.
19174   3833             ;   We can derive length y by Pythagoras and then use ATN instead. 
19175   3833             ;   Since y*y + x*x = 1*1 (Pythagoras Theorem) then
19176   3833             ;   y=sqr(1-x*x)                         - no need to multiply 1 by itself.
19177   3833             ;   So, asn(a) = atn(x/y)
19178   3833             ;   or more fully,
19179   3833             ;   asn(a) = atn(x/sqr(1-x*x))
19180   3833             
19181   3833             ;   Close but no cigar.
19182   3833             
19183   3833             ;   While PRINT ATN (x/SQR (1-x*x)) gives the same results as PRINT ASN x,
19184   3833             ;   it leads to division by zero when x is 1 or -1.
19185   3833             ;   To overcome this, 1 is added to y giving half the required angle and the 
19186   3833             ;   result is then doubled. 
19187   3833             ;   That is, PRINT ATN (x/(SQR (1-x*x) +1)) *2
19188   3833             ;
19189   3833             ;   GEOMETRIC PROOF.
19190   3833             ;
19191   3833             ;
19192   3833             ;               . /|
19193   3833             ;            .  c/ |
19194   3833             ;         .     /1 |x
19195   3833             ;      . c   b /a  |
19196   3833             ;    ---------/----|    
19197   3833             ;      1      y
19198   3833             ;
19199   3833             ;   By creating an isosceles triangle with two equal sides of 1, angles c and 
19200   3833             ;   c are also equal. If b+c+c = 180 degrees and b+a = 180 degrees then c=a/2.
19201   3833             ;
19202   3833             ;   A value higher than 1 gives the required error as attempting to find  the
19203   3833             ;   square root of a negative number generates an error in Sinclair BASIC.
19204   3833             
19205   3833             ;; asn
19206   3833 EF          L3833:   RST     28H             ;; FP-CALC      x.
19207   3834 31                  DEFB    $31             ;;duplicate     x, x.
19208   3835 31                  DEFB    $31             ;;duplicate     x, x, x.
19209   3836 04                  DEFB    $04             ;;multiply      x, x*x.
19210   3837 A1                  DEFB    $A1             ;;stk-one       x, x*x, 1.
19211   3838 03                  DEFB    $03             ;;subtract      x, x*x-1.
19212   3839 1B                  DEFB    $1B             ;;negate        x, 1-x*x.
19213   383A 28                  DEFB    $28             ;;sqr           x, sqr(1-x*x) = y
19214   383B A1                  DEFB    $A1             ;;stk-one       x, y, 1.
19215   383C 0F                  DEFB    $0F             ;;addition      x, y+1.
19216   383D 05                  DEFB    $05             ;;division      x/y+1.
19217   383E 24                  DEFB    $24             ;;atn           a/2       (half the angle)
19218   383F 31                  DEFB    $31             ;;duplicate     a/2, a/2.
19219   3840 0F                  DEFB    $0F             ;;addition      a.
19220   3841 38                  DEFB    $38             ;;end-calc      a.
19221   3842             
19222   3842 C9                  RET                     ; return.
19223   3843             
19224   3843             
19225   3843             ; ---------------------
19226   3843             ; THE 'ARCCOS' FUNCTION
19227   3843             ; ---------------------
19228   3843             ; (Offset $23: 'acs')
19229   3843             ; the inverse cosine function with the result in radians.
19230   3843             ; Error A unless the argument is between -1 and +1.
19231   3843             ; Result in range 0 to pi.
19232   3843             ; Derived from asn above which is in turn derived from the preceding atn.
19233   3843             ; It could have been derived directly from atn using acs(x) = atn(sqr(1-x*x)/x).
19234   3843             ; However, as sine and cosine are horizontal translations of each other,
19235   3843             ; uses acs(x) = pi/2 - asn(x)
19236   3843             
19237   3843             ; e.g. the arccosine of a known x value will give the required angle b in 
19238   3843             ; radians.
19239   3843             ; We know, from above, how to calculate the angle a using asn(x). 
19240   3843             ; Since the three angles of any triangle add up to 180 degrees, or pi radians,
19241   3843             ; and the largest angle in this case is a right-angle (pi/2 radians), then
19242   3843             ; we can calculate angle b as pi/2 (both angles) minus asn(x) (angle a).
19243   3843             ; 
19244   3843             ;
19245   3843             ;           /|
19246   3843             ;        1 /b|
19247   3843             ;         /  |x
19248   3843             ;        /a  |
19249   3843             ;       /----|    
19250   3843             ;         y
19251   3843             ;
19252   3843             
19253   3843             ;; acs
19254   3843 EF          L3843:   RST     28H             ;; FP-CALC      x.
19255   3844 22                  DEFB    $22             ;;asn           asn(x).
19256   3845 A3                  DEFB    $A3             ;;stk-pi/2      asn(x), pi/2.
19257   3846 03                  DEFB    $03             ;;subtract      asn(x) - pi/2.
19258   3847 1B                  DEFB    $1B             ;;negate        pi/2 -asn(x)  =  acs(x).
19259   3848 38                  DEFB    $38             ;;end-calc      acs(x).
19260   3849             
19261   3849 C9                  RET                     ; return.
19262   384A             
19263   384A             
19264   384A             ; --------------------------
19265   384A             ; THE 'SQUARE ROOT' FUNCTION
19266   384A             ; --------------------------
19267   384A             ; (Offset $28: 'sqr')
19268   384A             ; This routine is remarkable for its brevity - 7 bytes.
19269   384A             ; It wasn't written here but in the ZX81 where the programmers had to squeeze
19270   384A             ; a bulky operating system into an 8K ROM. It simply calculates 
19271   384A             ; the square root by stacking the value .5 and continuing into the 'to-power'
19272   384A             ; routine. With more space available the much faster Newton-Raphson method
19273   384A             ; could have been used as on the Jupiter Ace.
19274   384A             
19275   384A             ;; sqr
19276   384A EF          L384A:   RST     28H             ;; FP-CALC
19277   384B 31                  DEFB    $31             ;;duplicate
19278   384C 30                  DEFB    $30             ;;not
19279   384D 00                  DEFB    $00             ;;jump-true
19280   384E 1E                  DEFB    $1E             ;;to L386C, LAST
19281   384F             
19282   384F A2                  DEFB    $A2             ;;stk-half
19283   3850 38                  DEFB    $38             ;;end-calc
19284   3851             
19285   3851             
19286   3851             ; ------------------------------
19287   3851             ; THE 'EXPONENTIATION' OPERATION
19288   3851             ; ------------------------------
19289   3851             ; (Offset $06: 'to-power')
19290   3851             ; This raises the first number X to the power of the second number Y.
19291   3851             ; As with the ZX80,
19292   3851             ; 0 ^ 0 = 1.
19293   3851             ; 0 ^ +n = 0.
19294   3851             ; 0 ^ -n = arithmetic overflow.
19295   3851             ;
19296   3851             
19297   3851             ;; to-power
19298   3851 EF          L3851:   RST     28H             ;; FP-CALC              X, Y.
19299   3852 01                  DEFB    $01             ;;exchange              Y, X.
19300   3853 31                  DEFB    $31             ;;duplicate             Y, X, X.
19301   3854 30                  DEFB    $30             ;;not                   Y, X, (1/0).
19302   3855 00                  DEFB    $00             ;;jump-true
19303   3856 07                  DEFB    $07             ;;to L385D, XIS0   if X is zero.
19304   3857             
19305   3857             ;   else X is non-zero. Function 'ln' will catch a negative value of X.
19306   3857             
19307   3857 25                  DEFB    $25             ;;ln                    Y, LN X.
19308   3858 04                  DEFB    $04             ;;multiply              Y * LN X.
19309   3859 38                  DEFB    $38             ;;end-calc
19310   385A             
19311   385A C3 C4 36            JP      L36C4           ; jump back to EXP routine   ->
19312   385D             
19313   385D             ; ---
19314   385D             
19315   385D             ;   these routines form the three simple results when the number is zero.
19316   385D             ;   begin by deleting the known zero to leave Y the power factor.
19317   385D             
19318   385D             ;; XIS0
19319   385D 02          L385D:   DEFB    $02             ;;delete                Y.
19320   385E 31                  DEFB    $31             ;;duplicate             Y, Y.
19321   385F 30                  DEFB    $30             ;;not                   Y, (1/0).
19322   3860 00                  DEFB    $00             ;;jump-true
19323   3861 09                  DEFB    $09             ;;to L386A, ONE         if Y is zero.
19324   3862             
19325   3862 A0                  DEFB    $A0             ;;stk-zero              Y, 0.
19326   3863 01                  DEFB    $01             ;;exchange              0, Y.
19327   3864 37                  DEFB    $37             ;;greater-0             0, (1/0).
19328   3865 00                  DEFB    $00             ;;jump-true             0.
19329   3866 06                  DEFB    $06             ;;to L386C, LAST        if Y was any positive 
19330   3867                                             ;;                      number.
19331   3867             
19332   3867             ;   else force division by zero thereby raising an Arithmetic overflow error.
19333   3867             ;   There are some one and two-byte alternatives but perhaps the most formal
19334   3867             ;   might have been to use end-calc; rst 08; defb 05.
19335   3867             
19336   3867 A1                  DEFB    $A1             ;;stk-one               0, 1.
19337   3868 01                  DEFB    $01             ;;exchange              1, 0.
19338   3869 05                  DEFB    $05             ;;division              1/0        ouch!
19339   386A             
19340   386A             ; ---
19341   386A             
19342   386A             ;; ONE
19343   386A 02          L386A:   DEFB    $02             ;;delete                .
19344   386B A1                  DEFB    $A1             ;;stk-one               1.
19345   386C             
19346   386C             ;; LAST
19347   386C 38          L386C:   DEFB    $38             ;;end-calc              last value is 1 or 0.
19348   386D             
19349   386D C9                  RET                     ; return.               
19350   386E             
19351   386E             ;   "Everything should be made as simple as possible, but not simpler"
19352   386E             ;   - Albert Einstein, 1879-1955.
19353   386E             
19354   386E             ; ---------------------
19355   386E             ; THE 'SPARE' LOCATIONS
19356   386E             ; ---------------------
19357   386E             
19358   386E             ;; spare
19359   386E FF          L386E:   DEFS    $3D00-$,$FF
19360   3D00             ; -------------------------------
19361   3D00             ; THE 'ZX SPECTRUM CHARACTER SET'
19362   3D00             ; -------------------------------
19363   3D00             
19364   3D00             ;; char-set
19365   3D00             
19366   3D00             ; $20 - Character: ' '          CHR$(32)
19367   3D00             
19368   3D00 00          L3D00:   DEFB    %00000000
19369   3D01 00                  DEFB    %00000000
19370   3D02 00                  DEFB    %00000000
19371   3D03 00                  DEFB    %00000000
19372   3D04 00                  DEFB    %00000000
19373   3D05 00                  DEFB    %00000000
19374   3D06 00                  DEFB    %00000000
19375   3D07 00                  DEFB    %00000000
19376   3D08             
19377   3D08             ; $21 - Character: '!'          CHR$(33)
19378   3D08             
19379   3D08 00                  DEFB    %00000000
19380   3D09 10                  DEFB    %00010000
19381   3D0A 10                  DEFB    %00010000
19382   3D0B 10                  DEFB    %00010000
19383   3D0C 10                  DEFB    %00010000
19384   3D0D 00                  DEFB    %00000000
19385   3D0E 10                  DEFB    %00010000
19386   3D0F 00                  DEFB    %00000000
19387   3D10             
19388   3D10             ; $22 - Character: '"'          CHR$(34)
19389   3D10             
19390   3D10 00                  DEFB    %00000000
19391   3D11 24                  DEFB    %00100100
19392   3D12 24                  DEFB    %00100100
19393   3D13 00                  DEFB    %00000000
19394   3D14 00                  DEFB    %00000000
19395   3D15 00                  DEFB    %00000000
19396   3D16 00                  DEFB    %00000000
19397   3D17 00                  DEFB    %00000000
19398   3D18             
19399   3D18             ; $23 - Character: '#'          CHR$(35)
19400   3D18             
19401   3D18 00                  DEFB    %00000000
19402   3D19 24                  DEFB    %00100100
19403   3D1A 7E                  DEFB    %01111110
19404   3D1B 24                  DEFB    %00100100
19405   3D1C 24                  DEFB    %00100100
19406   3D1D 7E                  DEFB    %01111110
19407   3D1E 24                  DEFB    %00100100
19408   3D1F 00                  DEFB    %00000000
19409   3D20             
19410   3D20             ; $24 - Character: '$'          CHR$(36)
19411   3D20             
19412   3D20 00                  DEFB    %00000000
19413   3D21 08                  DEFB    %00001000
19414   3D22 3E                  DEFB    %00111110
19415   3D23 28                  DEFB    %00101000
19416   3D24 3E                  DEFB    %00111110
19417   3D25 0A                  DEFB    %00001010
19418   3D26 3E                  DEFB    %00111110
19419   3D27 08                  DEFB    %00001000
19420   3D28             
19421   3D28             ; $25 - Character: '%'          CHR$(37)
19422   3D28             
19423   3D28 00                  DEFB    %00000000
19424   3D29 62                  DEFB    %01100010
19425   3D2A 64                  DEFB    %01100100
19426   3D2B 08                  DEFB    %00001000
19427   3D2C 10                  DEFB    %00010000
19428   3D2D 26                  DEFB    %00100110
19429   3D2E 46                  DEFB    %01000110
19430   3D2F 00                  DEFB    %00000000
19431   3D30             
19432   3D30             ; $26 - Character: '&'          CHR$(38)
19433   3D30             
19434   3D30 00                  DEFB    %00000000
19435   3D31 10                  DEFB    %00010000
19436   3D32 28                  DEFB    %00101000
19437   3D33 10                  DEFB    %00010000
19438   3D34 2A                  DEFB    %00101010
19439   3D35 44                  DEFB    %01000100
19440   3D36 3A                  DEFB    %00111010
19441   3D37 00                  DEFB    %00000000
19442   3D38             
19443   3D38             ; $27 - Character: '''          CHR$(39)
19444   3D38             
19445   3D38 00                  DEFB    %00000000
19446   3D39 08                  DEFB    %00001000
19447   3D3A 10                  DEFB    %00010000
19448   3D3B 00                  DEFB    %00000000
19449   3D3C 00                  DEFB    %00000000
19450   3D3D 00                  DEFB    %00000000
19451   3D3E 00                  DEFB    %00000000
19452   3D3F 00                  DEFB    %00000000
19453   3D40             
19454   3D40             ; $28 - Character: '('          CHR$(40)
19455   3D40             
19456   3D40 00                  DEFB    %00000000
19457   3D41 04                  DEFB    %00000100
19458   3D42 08                  DEFB    %00001000
19459   3D43 08                  DEFB    %00001000
19460   3D44 08                  DEFB    %00001000
19461   3D45 08                  DEFB    %00001000
19462   3D46 04                  DEFB    %00000100
19463   3D47 00                  DEFB    %00000000
19464   3D48             
19465   3D48             ; $29 - Character: ')'          CHR$(41)
19466   3D48             
19467   3D48 00                  DEFB    %00000000
19468   3D49 20                  DEFB    %00100000
19469   3D4A 10                  DEFB    %00010000
19470   3D4B 10                  DEFB    %00010000
19471   3D4C 10                  DEFB    %00010000
19472   3D4D 10                  DEFB    %00010000
19473   3D4E 20                  DEFB    %00100000
19474   3D4F 00                  DEFB    %00000000
19475   3D50             
19476   3D50             ; $2A - Character: '*'          CHR$(42)
19477   3D50             
19478   3D50 00                  DEFB    %00000000
19479   3D51 00                  DEFB    %00000000
19480   3D52 14                  DEFB    %00010100
19481   3D53 08                  DEFB    %00001000
19482   3D54 3E                  DEFB    %00111110
19483   3D55 08                  DEFB    %00001000
19484   3D56 14                  DEFB    %00010100
19485   3D57 00                  DEFB    %00000000
19486   3D58             
19487   3D58             ; $2B - Character: '+'          CHR$(43)
19488   3D58             
19489   3D58 00                  DEFB    %00000000
19490   3D59 00                  DEFB    %00000000
19491   3D5A 08                  DEFB    %00001000
19492   3D5B 08                  DEFB    %00001000
19493   3D5C 3E                  DEFB    %00111110
19494   3D5D 08                  DEFB    %00001000
19495   3D5E 08                  DEFB    %00001000
19496   3D5F 00                  DEFB    %00000000
19497   3D60             
19498   3D60             ; $2C - Character: ','          CHR$(44)
19499   3D60             
19500   3D60 00                  DEFB    %00000000
19501   3D61 00                  DEFB    %00000000
19502   3D62 00                  DEFB    %00000000
19503   3D63 00                  DEFB    %00000000
19504   3D64 00                  DEFB    %00000000
19505   3D65 08                  DEFB    %00001000
19506   3D66 08                  DEFB    %00001000
19507   3D67 10                  DEFB    %00010000
19508   3D68             
19509   3D68             ; $2D - Character: '-'          CHR$(45)
19510   3D68             
19511   3D68 00                  DEFB    %00000000
19512   3D69 00                  DEFB    %00000000
19513   3D6A 00                  DEFB    %00000000
19514   3D6B 00                  DEFB    %00000000
19515   3D6C 3E                  DEFB    %00111110
19516   3D6D 00                  DEFB    %00000000
19517   3D6E 00                  DEFB    %00000000
19518   3D6F 00                  DEFB    %00000000
19519   3D70             
19520   3D70             ; $2E - Character: '.'          CHR$(46)
19521   3D70             
19522   3D70 00                  DEFB    %00000000
19523   3D71 00                  DEFB    %00000000
19524   3D72 00                  DEFB    %00000000
19525   3D73 00                  DEFB    %00000000
19526   3D74 00                  DEFB    %00000000
19527   3D75 18                  DEFB    %00011000
19528   3D76 18                  DEFB    %00011000
19529   3D77 00                  DEFB    %00000000
19530   3D78             
19531   3D78             ; $2F - Character: '/'          CHR$(47)
19532   3D78             
19533   3D78 00                  DEFB    %00000000
19534   3D79 00                  DEFB    %00000000
19535   3D7A 02                  DEFB    %00000010
19536   3D7B 04                  DEFB    %00000100
19537   3D7C 08                  DEFB    %00001000
19538   3D7D 10                  DEFB    %00010000
19539   3D7E 20                  DEFB    %00100000
19540   3D7F 00                  DEFB    %00000000
19541   3D80             
19542   3D80             ; $30 - Character: '0'          CHR$(48)
19543   3D80             
19544   3D80 00                  DEFB    %00000000
19545   3D81 3C                  DEFB    %00111100
19546   3D82 46                  DEFB    %01000110
19547   3D83 4A                  DEFB    %01001010
19548   3D84 52                  DEFB    %01010010
19549   3D85 62                  DEFB    %01100010
19550   3D86 3C                  DEFB    %00111100
19551   3D87 00                  DEFB    %00000000
19552   3D88             
19553   3D88             ; $31 - Character: '1'          CHR$(49)
19554   3D88             
19555   3D88 00                  DEFB    %00000000
19556   3D89 18                  DEFB    %00011000
19557   3D8A 28                  DEFB    %00101000
19558   3D8B 08                  DEFB    %00001000
19559   3D8C 08                  DEFB    %00001000
19560   3D8D 08                  DEFB    %00001000
19561   3D8E 3E                  DEFB    %00111110
19562   3D8F 00                  DEFB    %00000000
19563   3D90             
19564   3D90             ; $32 - Character: '2'          CHR$(50)
19565   3D90             
19566   3D90 00                  DEFB    %00000000
19567   3D91 3C                  DEFB    %00111100
19568   3D92 42                  DEFB    %01000010
19569   3D93 02                  DEFB    %00000010
19570   3D94 3C                  DEFB    %00111100
19571   3D95 40                  DEFB    %01000000
19572   3D96 7E                  DEFB    %01111110
19573   3D97 00                  DEFB    %00000000
19574   3D98             
19575   3D98             ; $33 - Character: '3'          CHR$(51)
19576   3D98             
19577   3D98 00                  DEFB    %00000000
19578   3D99 3C                  DEFB    %00111100
19579   3D9A 42                  DEFB    %01000010
19580   3D9B 0C                  DEFB    %00001100
19581   3D9C 02                  DEFB    %00000010
19582   3D9D 42                  DEFB    %01000010
19583   3D9E 3C                  DEFB    %00111100
19584   3D9F 00                  DEFB    %00000000
19585   3DA0             
19586   3DA0             ; $34 - Character: '4'          CHR$(52)
19587   3DA0             
19588   3DA0 00                  DEFB    %00000000
19589   3DA1 08                  DEFB    %00001000
19590   3DA2 18                  DEFB    %00011000
19591   3DA3 28                  DEFB    %00101000
19592   3DA4 48                  DEFB    %01001000
19593   3DA5 7E                  DEFB    %01111110
19594   3DA6 08                  DEFB    %00001000
19595   3DA7 00                  DEFB    %00000000
19596   3DA8             
19597   3DA8             ; $35 - Character: '5'          CHR$(53)
19598   3DA8             
19599   3DA8 00                  DEFB    %00000000
19600   3DA9 7E                  DEFB    %01111110
19601   3DAA 40                  DEFB    %01000000
19602   3DAB 7C                  DEFB    %01111100
19603   3DAC 02                  DEFB    %00000010
19604   3DAD 42                  DEFB    %01000010
19605   3DAE 3C                  DEFB    %00111100
19606   3DAF 00                  DEFB    %00000000
19607   3DB0             
19608   3DB0             ; $36 - Character: '6'          CHR$(54)
19609   3DB0             
19610   3DB0 00                  DEFB    %00000000
19611   3DB1 3C                  DEFB    %00111100
19612   3DB2 40                  DEFB    %01000000
19613   3DB3 7C                  DEFB    %01111100
19614   3DB4 42                  DEFB    %01000010
19615   3DB5 42                  DEFB    %01000010
19616   3DB6 3C                  DEFB    %00111100
19617   3DB7 00                  DEFB    %00000000
19618   3DB8             
19619   3DB8             ; $37 - Character: '7'          CHR$(55)
19620   3DB8             
19621   3DB8 00                  DEFB    %00000000
19622   3DB9 7E                  DEFB    %01111110
19623   3DBA 02                  DEFB    %00000010
19624   3DBB 04                  DEFB    %00000100
19625   3DBC 08                  DEFB    %00001000
19626   3DBD 10                  DEFB    %00010000
19627   3DBE 10                  DEFB    %00010000
19628   3DBF 00                  DEFB    %00000000
19629   3DC0             
19630   3DC0             ; $38 - Character: '8'          CHR$(56)
19631   3DC0             
19632   3DC0 00                  DEFB    %00000000
19633   3DC1 3C                  DEFB    %00111100
19634   3DC2 42                  DEFB    %01000010
19635   3DC3 3C                  DEFB    %00111100
19636   3DC4 42                  DEFB    %01000010
19637   3DC5 42                  DEFB    %01000010
19638   3DC6 3C                  DEFB    %00111100
19639   3DC7 00                  DEFB    %00000000
19640   3DC8             
19641   3DC8             ; $39 - Character: '9'          CHR$(57)
19642   3DC8             
19643   3DC8 00                  DEFB    %00000000
19644   3DC9 3C                  DEFB    %00111100
19645   3DCA 42                  DEFB    %01000010
19646   3DCB 42                  DEFB    %01000010
19647   3DCC 3E                  DEFB    %00111110
19648   3DCD 02                  DEFB    %00000010
19649   3DCE 3C                  DEFB    %00111100
19650   3DCF 00                  DEFB    %00000000
19651   3DD0             
19652   3DD0             ; $3A - Character: ':'          CHR$(58)
19653   3DD0             
19654   3DD0 00                  DEFB    %00000000
19655   3DD1 00                  DEFB    %00000000
19656   3DD2 00                  DEFB    %00000000
19657   3DD3 10                  DEFB    %00010000
19658   3DD4 00                  DEFB    %00000000
19659   3DD5 00                  DEFB    %00000000
19660   3DD6 10                  DEFB    %00010000
19661   3DD7 00                  DEFB    %00000000
19662   3DD8             
19663   3DD8             ; $3B - Character: ';'          CHR$(59)
19664   3DD8             
19665   3DD8 00                  DEFB    %00000000
19666   3DD9 00                  DEFB    %00000000
19667   3DDA 10                  DEFB    %00010000
19668   3DDB 00                  DEFB    %00000000
19669   3DDC 00                  DEFB    %00000000
19670   3DDD 10                  DEFB    %00010000
19671   3DDE 10                  DEFB    %00010000
19672   3DDF 20                  DEFB    %00100000
19673   3DE0             
19674   3DE0             ; $3C - Character: '<'          CHR$(60)
19675   3DE0             
19676   3DE0 00                  DEFB    %00000000
19677   3DE1 00                  DEFB    %00000000
19678   3DE2 04                  DEFB    %00000100
19679   3DE3 08                  DEFB    %00001000
19680   3DE4 10                  DEFB    %00010000
19681   3DE5 08                  DEFB    %00001000
19682   3DE6 04                  DEFB    %00000100
19683   3DE7 00                  DEFB    %00000000
19684   3DE8             
19685   3DE8             ; $3D - Character: '='          CHR$(61)
19686   3DE8             
19687   3DE8 00                  DEFB    %00000000
19688   3DE9 00                  DEFB    %00000000
19689   3DEA 00                  DEFB    %00000000
19690   3DEB 3E                  DEFB    %00111110
19691   3DEC 00                  DEFB    %00000000
19692   3DED 3E                  DEFB    %00111110
19693   3DEE 00                  DEFB    %00000000
19694   3DEF 00                  DEFB    %00000000
19695   3DF0             
19696   3DF0             ; $3E - Character: '>'          CHR$(62)
19697   3DF0             
19698   3DF0 00                  DEFB    %00000000
19699   3DF1 00                  DEFB    %00000000
19700   3DF2 10                  DEFB    %00010000
19701   3DF3 08                  DEFB    %00001000
19702   3DF4 04                  DEFB    %00000100
19703   3DF5 08                  DEFB    %00001000
19704   3DF6 10                  DEFB    %00010000
19705   3DF7 00                  DEFB    %00000000
19706   3DF8             
19707   3DF8             ; $3F - Character: '?'          CHR$(63)
19708   3DF8             
19709   3DF8 00                  DEFB    %00000000
19710   3DF9 3C                  DEFB    %00111100
19711   3DFA 42                  DEFB    %01000010
19712   3DFB 04                  DEFB    %00000100
19713   3DFC 08                  DEFB    %00001000
19714   3DFD 00                  DEFB    %00000000
19715   3DFE 08                  DEFB    %00001000
19716   3DFF 00                  DEFB    %00000000
19717   3E00             
19718   3E00             ; $40 - Character: '@'          CHR$(64)
19719   3E00             
19720   3E00 00                  DEFB    %00000000
19721   3E01 3C                  DEFB    %00111100
19722   3E02 4A                  DEFB    %01001010
19723   3E03 56                  DEFB    %01010110
19724   3E04 5E                  DEFB    %01011110
19725   3E05 40                  DEFB    %01000000
19726   3E06 3C                  DEFB    %00111100
19727   3E07 00                  DEFB    %00000000
19728   3E08             
19729   3E08             ; $41 - Character: 'A'          CHR$(65)
19730   3E08             
19731   3E08 00                  DEFB    %00000000
19732   3E09 3C                  DEFB    %00111100
19733   3E0A 42                  DEFB    %01000010
19734   3E0B 42                  DEFB    %01000010
19735   3E0C 7E                  DEFB    %01111110
19736   3E0D 42                  DEFB    %01000010
19737   3E0E 42                  DEFB    %01000010
19738   3E0F 00                  DEFB    %00000000
19739   3E10             
19740   3E10             ; $42 - Character: 'B'          CHR$(66)
19741   3E10             
19742   3E10 00                  DEFB    %00000000
19743   3E11 7C                  DEFB    %01111100
19744   3E12 42                  DEFB    %01000010
19745   3E13 7C                  DEFB    %01111100
19746   3E14 42                  DEFB    %01000010
19747   3E15 42                  DEFB    %01000010
19748   3E16 7C                  DEFB    %01111100
19749   3E17 00                  DEFB    %00000000
19750   3E18             
19751   3E18             ; $43 - Character: 'C'          CHR$(67)
19752   3E18             
19753   3E18 00                  DEFB    %00000000
19754   3E19 3C                  DEFB    %00111100
19755   3E1A 42                  DEFB    %01000010
19756   3E1B 40                  DEFB    %01000000
19757   3E1C 40                  DEFB    %01000000
19758   3E1D 42                  DEFB    %01000010
19759   3E1E 3C                  DEFB    %00111100
19760   3E1F 00                  DEFB    %00000000
19761   3E20             
19762   3E20             ; $44 - Character: 'D'          CHR$(68)
19763   3E20             
19764   3E20 00                  DEFB    %00000000
19765   3E21 78                  DEFB    %01111000
19766   3E22 44                  DEFB    %01000100
19767   3E23 42                  DEFB    %01000010
19768   3E24 42                  DEFB    %01000010
19769   3E25 44                  DEFB    %01000100
19770   3E26 78                  DEFB    %01111000
19771   3E27 00                  DEFB    %00000000
19772   3E28             
19773   3E28             ; $45 - Character: 'E'          CHR$(69)
19774   3E28             
19775   3E28 00                  DEFB    %00000000
19776   3E29 7E                  DEFB    %01111110
19777   3E2A 40                  DEFB    %01000000
19778   3E2B 7C                  DEFB    %01111100
19779   3E2C 40                  DEFB    %01000000
19780   3E2D 40                  DEFB    %01000000
19781   3E2E 7E                  DEFB    %01111110
19782   3E2F 00                  DEFB    %00000000
19783   3E30             
19784   3E30             ; $46 - Character: 'F'          CHR$(70)
19785   3E30             
19786   3E30 00                  DEFB    %00000000
19787   3E31 7E                  DEFB    %01111110
19788   3E32 40                  DEFB    %01000000
19789   3E33 7C                  DEFB    %01111100
19790   3E34 40                  DEFB    %01000000
19791   3E35 40                  DEFB    %01000000
19792   3E36 40                  DEFB    %01000000
19793   3E37 00                  DEFB    %00000000
19794   3E38             
19795   3E38             ; $47 - Character: 'G'          CHR$(71)
19796   3E38             
19797   3E38 00                  DEFB    %00000000
19798   3E39 3C                  DEFB    %00111100
19799   3E3A 42                  DEFB    %01000010
19800   3E3B 40                  DEFB    %01000000
19801   3E3C 4E                  DEFB    %01001110
19802   3E3D 42                  DEFB    %01000010
19803   3E3E 3C                  DEFB    %00111100
19804   3E3F 00                  DEFB    %00000000
19805   3E40             
19806   3E40             ; $48 - Character: 'H'          CHR$(72)
19807   3E40             
19808   3E40 00                  DEFB    %00000000
19809   3E41 42                  DEFB    %01000010
19810   3E42 42                  DEFB    %01000010
19811   3E43 7E                  DEFB    %01111110
19812   3E44 42                  DEFB    %01000010
19813   3E45 42                  DEFB    %01000010
19814   3E46 42                  DEFB    %01000010
19815   3E47 00                  DEFB    %00000000
19816   3E48             
19817   3E48             ; $49 - Character: 'I'          CHR$(73)
19818   3E48             
19819   3E48 00                  DEFB    %00000000
19820   3E49 3E                  DEFB    %00111110
19821   3E4A 08                  DEFB    %00001000
19822   3E4B 08                  DEFB    %00001000
19823   3E4C 08                  DEFB    %00001000
19824   3E4D 08                  DEFB    %00001000
19825   3E4E 3E                  DEFB    %00111110
19826   3E4F 00                  DEFB    %00000000
19827   3E50             
19828   3E50             ; $4A - Character: 'J'          CHR$(74)
19829   3E50             
19830   3E50 00                  DEFB    %00000000
19831   3E51 02                  DEFB    %00000010
19832   3E52 02                  DEFB    %00000010
19833   3E53 02                  DEFB    %00000010
19834   3E54 42                  DEFB    %01000010
19835   3E55 42                  DEFB    %01000010
19836   3E56 3C                  DEFB    %00111100
19837   3E57 00                  DEFB    %00000000
19838   3E58             
19839   3E58             ; $4B - Character: 'K'          CHR$(75)
19840   3E58             
19841   3E58 00                  DEFB    %00000000
19842   3E59 44                  DEFB    %01000100
19843   3E5A 48                  DEFB    %01001000
19844   3E5B 70                  DEFB    %01110000
19845   3E5C 48                  DEFB    %01001000
19846   3E5D 44                  DEFB    %01000100
19847   3E5E 42                  DEFB    %01000010
19848   3E5F 00                  DEFB    %00000000
19849   3E60             
19850   3E60             ; $4C - Character: 'L'          CHR$(76)
19851   3E60             
19852   3E60 00                  DEFB    %00000000
19853   3E61 40                  DEFB    %01000000
19854   3E62 40                  DEFB    %01000000
19855   3E63 40                  DEFB    %01000000
19856   3E64 40                  DEFB    %01000000
19857   3E65 40                  DEFB    %01000000
19858   3E66 7E                  DEFB    %01111110
19859   3E67 00                  DEFB    %00000000
19860   3E68             
19861   3E68             ; $4D - Character: 'M'          CHR$(77)
19862   3E68             
19863   3E68 00                  DEFB    %00000000
19864   3E69 42                  DEFB    %01000010
19865   3E6A 66                  DEFB    %01100110
19866   3E6B 5A                  DEFB    %01011010
19867   3E6C 42                  DEFB    %01000010
19868   3E6D 42                  DEFB    %01000010
19869   3E6E 42                  DEFB    %01000010
19870   3E6F 00                  DEFB    %00000000
19871   3E70             
19872   3E70             ; $4E - Character: 'N'          CHR$(78)
19873   3E70             
19874   3E70 00                  DEFB    %00000000
19875   3E71 42                  DEFB    %01000010
19876   3E72 62                  DEFB    %01100010
19877   3E73 52                  DEFB    %01010010
19878   3E74 4A                  DEFB    %01001010
19879   3E75 46                  DEFB    %01000110
19880   3E76 42                  DEFB    %01000010
19881   3E77 00                  DEFB    %00000000
19882   3E78             
19883   3E78             ; $4F - Character: 'O'          CHR$(79)
19884   3E78             
19885   3E78 00                  DEFB    %00000000
19886   3E79 3C                  DEFB    %00111100
19887   3E7A 42                  DEFB    %01000010
19888   3E7B 42                  DEFB    %01000010
19889   3E7C 42                  DEFB    %01000010
19890   3E7D 42                  DEFB    %01000010
19891   3E7E 3C                  DEFB    %00111100
19892   3E7F 00                  DEFB    %00000000
19893   3E80             
19894   3E80             ; $50 - Character: 'P'          CHR$(80)
19895   3E80             
19896   3E80 00                  DEFB    %00000000
19897   3E81 7C                  DEFB    %01111100
19898   3E82 42                  DEFB    %01000010
19899   3E83 42                  DEFB    %01000010
19900   3E84 7C                  DEFB    %01111100
19901   3E85 40                  DEFB    %01000000
19902   3E86 40                  DEFB    %01000000
19903   3E87 00                  DEFB    %00000000
19904   3E88             
19905   3E88             ; $51 - Character: 'Q'          CHR$(81)
19906   3E88             
19907   3E88 00                  DEFB    %00000000
19908   3E89 3C                  DEFB    %00111100
19909   3E8A 42                  DEFB    %01000010
19910   3E8B 42                  DEFB    %01000010
19911   3E8C 52                  DEFB    %01010010
19912   3E8D 4A                  DEFB    %01001010
19913   3E8E 3C                  DEFB    %00111100
19914   3E8F 00                  DEFB    %00000000
19915   3E90             
19916   3E90             ; $52 - Character: 'R'          CHR$(82)
19917   3E90             
19918   3E90 00                  DEFB    %00000000
19919   3E91 7C                  DEFB    %01111100
19920   3E92 42                  DEFB    %01000010
19921   3E93 42                  DEFB    %01000010
19922   3E94 7C                  DEFB    %01111100
19923   3E95 44                  DEFB    %01000100
19924   3E96 42                  DEFB    %01000010
19925   3E97 00                  DEFB    %00000000
19926   3E98             
19927   3E98             ; $53 - Character: 'S'          CHR$(83)
19928   3E98             
19929   3E98 00                  DEFB    %00000000
19930   3E99 3C                  DEFB    %00111100
19931   3E9A 40                  DEFB    %01000000
19932   3E9B 3C                  DEFB    %00111100
19933   3E9C 02                  DEFB    %00000010
19934   3E9D 42                  DEFB    %01000010
19935   3E9E 3C                  DEFB    %00111100
19936   3E9F 00                  DEFB    %00000000
19937   3EA0             
19938   3EA0             ; $54 - Character: 'T'          CHR$(84)
19939   3EA0             
19940   3EA0 00                  DEFB    %00000000
19941   3EA1 FE                  DEFB    %11111110
19942   3EA2 10                  DEFB    %00010000
19943   3EA3 10                  DEFB    %00010000
19944   3EA4 10                  DEFB    %00010000
19945   3EA5 10                  DEFB    %00010000
19946   3EA6 10                  DEFB    %00010000
19947   3EA7 00                  DEFB    %00000000
19948   3EA8             
19949   3EA8             ; $55 - Character: 'U'          CHR$(85)
19950   3EA8             
19951   3EA8 00                  DEFB    %00000000
19952   3EA9 42                  DEFB    %01000010
19953   3EAA 42                  DEFB    %01000010
19954   3EAB 42                  DEFB    %01000010
19955   3EAC 42                  DEFB    %01000010
19956   3EAD 42                  DEFB    %01000010
19957   3EAE 3C                  DEFB    %00111100
19958   3EAF 00                  DEFB    %00000000
19959   3EB0             
19960   3EB0             ; $56 - Character: 'V'          CHR$(86)
19961   3EB0             
19962   3EB0 00                  DEFB    %00000000
19963   3EB1 42                  DEFB    %01000010
19964   3EB2 42                  DEFB    %01000010
19965   3EB3 42                  DEFB    %01000010
19966   3EB4 42                  DEFB    %01000010
19967   3EB5 24                  DEFB    %00100100
19968   3EB6 18                  DEFB    %00011000
19969   3EB7 00                  DEFB    %00000000
19970   3EB8             
19971   3EB8             ; $57 - Character: 'W'          CHR$(87)
19972   3EB8             
19973   3EB8 00                  DEFB    %00000000
19974   3EB9 42                  DEFB    %01000010
19975   3EBA 42                  DEFB    %01000010
19976   3EBB 42                  DEFB    %01000010
19977   3EBC 42                  DEFB    %01000010
19978   3EBD 5A                  DEFB    %01011010
19979   3EBE 24                  DEFB    %00100100
19980   3EBF 00                  DEFB    %00000000
19981   3EC0             
19982   3EC0             ; $58 - Character: 'X'          CHR$(88)
19983   3EC0             
19984   3EC0 00                  DEFB    %00000000
19985   3EC1 42                  DEFB    %01000010
19986   3EC2 24                  DEFB    %00100100
19987   3EC3 18                  DEFB    %00011000
19988   3EC4 18                  DEFB    %00011000
19989   3EC5 24                  DEFB    %00100100
19990   3EC6 42                  DEFB    %01000010
19991   3EC7 00                  DEFB    %00000000
19992   3EC8             
19993   3EC8             ; $59 - Character: 'Y'          CHR$(89)
19994   3EC8             
19995   3EC8 00                  DEFB    %00000000
19996   3EC9 82                  DEFB    %10000010
19997   3ECA 44                  DEFB    %01000100
19998   3ECB 28                  DEFB    %00101000
19999   3ECC 10                  DEFB    %00010000
20000   3ECD 10                  DEFB    %00010000
20001   3ECE 10                  DEFB    %00010000
20002   3ECF 00                  DEFB    %00000000
20003   3ED0             
20004   3ED0             ; $5A - Character: 'Z'          CHR$(90)
20005   3ED0             
20006   3ED0 00                  DEFB    %00000000
20007   3ED1 7E                  DEFB    %01111110
20008   3ED2 04                  DEFB    %00000100
20009   3ED3 08                  DEFB    %00001000
20010   3ED4 10                  DEFB    %00010000
20011   3ED5 20                  DEFB    %00100000
20012   3ED6 7E                  DEFB    %01111110
20013   3ED7 00                  DEFB    %00000000
20014   3ED8             
20015   3ED8             ; $5B - Character: '['          CHR$(91)
20016   3ED8             
20017   3ED8 00                  DEFB    %00000000
20018   3ED9 0E                  DEFB    %00001110
20019   3EDA 08                  DEFB    %00001000
20020   3EDB 08                  DEFB    %00001000
20021   3EDC 08                  DEFB    %00001000
20022   3EDD 08                  DEFB    %00001000
20023   3EDE 0E                  DEFB    %00001110
20024   3EDF 00                  DEFB    %00000000
20025   3EE0             
20026   3EE0             ; $5C - Character: '\'          CHR$(92)
20027   3EE0             
20028   3EE0 00                  DEFB    %00000000
20029   3EE1 00                  DEFB    %00000000
20030   3EE2 40                  DEFB    %01000000
20031   3EE3 20                  DEFB    %00100000
20032   3EE4 10                  DEFB    %00010000
20033   3EE5 08                  DEFB    %00001000
20034   3EE6 04                  DEFB    %00000100
20035   3EE7 00                  DEFB    %00000000
20036   3EE8             
20037   3EE8             ; $5D - Character: ']'          CHR$(93)
20038   3EE8             
20039   3EE8 00                  DEFB    %00000000
20040   3EE9 70                  DEFB    %01110000
20041   3EEA 10                  DEFB    %00010000
20042   3EEB 10                  DEFB    %00010000
20043   3EEC 10                  DEFB    %00010000
20044   3EED 10                  DEFB    %00010000
20045   3EEE 70                  DEFB    %01110000
20046   3EEF 00                  DEFB    %00000000
20047   3EF0             
20048   3EF0             ; $5E - Character: '^'          CHR$(94)
20049   3EF0             
20050   3EF0 00                  DEFB    %00000000
20051   3EF1 10                  DEFB    %00010000
20052   3EF2 38                  DEFB    %00111000
20053   3EF3 54                  DEFB    %01010100
20054   3EF4 10                  DEFB    %00010000
20055   3EF5 10                  DEFB    %00010000
20056   3EF6 10                  DEFB    %00010000
20057   3EF7 00                  DEFB    %00000000
20058   3EF8             
20059   3EF8             ; $5F - Character: '_'          CHR$(95)
20060   3EF8             
20061   3EF8 00                  DEFB    %00000000
20062   3EF9 00                  DEFB    %00000000
20063   3EFA 00                  DEFB    %00000000
20064   3EFB 00                  DEFB    %00000000
20065   3EFC 00                  DEFB    %00000000
20066   3EFD 00                  DEFB    %00000000
20067   3EFE 00                  DEFB    %00000000
20068   3EFF FF                  DEFB    %11111111
20069   3F00             
20070   3F00             ; $60 - Character: ' £ '        CHR$(96)
20071   3F00             
20072   3F00 00                  DEFB    %00000000
20073   3F01 1C                  DEFB    %00011100
20074   3F02 22                  DEFB    %00100010
20075   3F03 78                  DEFB    %01111000
20076   3F04 20                  DEFB    %00100000
20077   3F05 20                  DEFB    %00100000
20078   3F06 7E                  DEFB    %01111110
20079   3F07 00                  DEFB    %00000000
20080   3F08             
20081   3F08             ; $61 - Character: 'a'          CHR$(97)
20082   3F08             
20083   3F08 00                  DEFB    %00000000
20084   3F09 00                  DEFB    %00000000
20085   3F0A 38                  DEFB    %00111000
20086   3F0B 04                  DEFB    %00000100
20087   3F0C 3C                  DEFB    %00111100
20088   3F0D 44                  DEFB    %01000100
20089   3F0E 3C                  DEFB    %00111100
20090   3F0F 00                  DEFB    %00000000
20091   3F10             
20092   3F10             ; $62 - Character: 'b'          CHR$(98)
20093   3F10             
20094   3F10 00                  DEFB    %00000000
20095   3F11 20                  DEFB    %00100000
20096   3F12 20                  DEFB    %00100000
20097   3F13 3C                  DEFB    %00111100
20098   3F14 22                  DEFB    %00100010
20099   3F15 22                  DEFB    %00100010
20100   3F16 3C                  DEFB    %00111100
20101   3F17 00                  DEFB    %00000000
20102   3F18             
20103   3F18             ; $63 - Character: 'c'          CHR$(99)
20104   3F18             
20105   3F18 00                  DEFB    %00000000
20106   3F19 00                  DEFB    %00000000
20107   3F1A 1C                  DEFB    %00011100
20108   3F1B 20                  DEFB    %00100000
20109   3F1C 20                  DEFB    %00100000
20110   3F1D 20                  DEFB    %00100000
20111   3F1E 1C                  DEFB    %00011100
20112   3F1F 00                  DEFB    %00000000
20113   3F20             
20114   3F20             ; $64 - Character: 'd'          CHR$(100)
20115   3F20             
20116   3F20 00                  DEFB    %00000000
20117   3F21 04                  DEFB    %00000100
20118   3F22 04                  DEFB    %00000100
20119   3F23 3C                  DEFB    %00111100
20120   3F24 44                  DEFB    %01000100
20121   3F25 44                  DEFB    %01000100
20122   3F26 3C                  DEFB    %00111100
20123   3F27 00                  DEFB    %00000000
20124   3F28             
20125   3F28             ; $65 - Character: 'e'          CHR$(101)
20126   3F28             
20127   3F28 00                  DEFB    %00000000
20128   3F29 00                  DEFB    %00000000
20129   3F2A 38                  DEFB    %00111000
20130   3F2B 44                  DEFB    %01000100
20131   3F2C 78                  DEFB    %01111000
20132   3F2D 40                  DEFB    %01000000
20133   3F2E 3C                  DEFB    %00111100
20134   3F2F 00                  DEFB    %00000000
20135   3F30             
20136   3F30             ; $66 - Character: 'f'          CHR$(102)
20137   3F30             
20138   3F30 00                  DEFB    %00000000
20139   3F31 0C                  DEFB    %00001100
20140   3F32 10                  DEFB    %00010000
20141   3F33 18                  DEFB    %00011000
20142   3F34 10                  DEFB    %00010000
20143   3F35 10                  DEFB    %00010000
20144   3F36 10                  DEFB    %00010000
20145   3F37 00                  DEFB    %00000000
20146   3F38             
20147   3F38             ; $67 - Character: 'g'          CHR$(103)
20148   3F38             
20149   3F38 00                  DEFB    %00000000
20150   3F39 00                  DEFB    %00000000
20151   3F3A 3C                  DEFB    %00111100
20152   3F3B 44                  DEFB    %01000100
20153   3F3C 44                  DEFB    %01000100
20154   3F3D 3C                  DEFB    %00111100
20155   3F3E 04                  DEFB    %00000100
20156   3F3F 38                  DEFB    %00111000
20157   3F40             
20158   3F40             ; $68 - Character: 'h'          CHR$(104)
20159   3F40             
20160   3F40 00                  DEFB    %00000000
20161   3F41 40                  DEFB    %01000000
20162   3F42 40                  DEFB    %01000000
20163   3F43 78                  DEFB    %01111000
20164   3F44 44                  DEFB    %01000100
20165   3F45 44                  DEFB    %01000100
20166   3F46 44                  DEFB    %01000100
20167   3F47 00                  DEFB    %00000000
20168   3F48             
20169   3F48             ; $69 - Character: 'i'          CHR$(105)
20170   3F48             
20171   3F48 00                  DEFB    %00000000
20172   3F49 10                  DEFB    %00010000
20173   3F4A 00                  DEFB    %00000000
20174   3F4B 30                  DEFB    %00110000
20175   3F4C 10                  DEFB    %00010000
20176   3F4D 10                  DEFB    %00010000
20177   3F4E 38                  DEFB    %00111000
20178   3F4F 00                  DEFB    %00000000
20179   3F50             
20180   3F50             ; $6A - Character: 'j'          CHR$(106)
20181   3F50             
20182   3F50 00                  DEFB    %00000000
20183   3F51 04                  DEFB    %00000100
20184   3F52 00                  DEFB    %00000000
20185   3F53 04                  DEFB    %00000100
20186   3F54 04                  DEFB    %00000100
20187   3F55 04                  DEFB    %00000100
20188   3F56 24                  DEFB    %00100100
20189   3F57 18                  DEFB    %00011000
20190   3F58             
20191   3F58             ; $6B - Character: 'k'          CHR$(107)
20192   3F58             
20193   3F58 00                  DEFB    %00000000
20194   3F59 20                  DEFB    %00100000
20195   3F5A 28                  DEFB    %00101000
20196   3F5B 30                  DEFB    %00110000
20197   3F5C 30                  DEFB    %00110000
20198   3F5D 28                  DEFB    %00101000
20199   3F5E 24                  DEFB    %00100100
20200   3F5F 00                  DEFB    %00000000
20201   3F60             
20202   3F60             ; $6C - Character: 'l'          CHR$(108)
20203   3F60             
20204   3F60 00                  DEFB    %00000000
20205   3F61 10                  DEFB    %00010000
20206   3F62 10                  DEFB    %00010000
20207   3F63 10                  DEFB    %00010000
20208   3F64 10                  DEFB    %00010000
20209   3F65 10                  DEFB    %00010000
20210   3F66 0C                  DEFB    %00001100
20211   3F67 00                  DEFB    %00000000
20212   3F68             
20213   3F68             ; $6D - Character: 'm'          CHR$(109)
20214   3F68             
20215   3F68 00                  DEFB    %00000000
20216   3F69 00                  DEFB    %00000000
20217   3F6A 68                  DEFB    %01101000
20218   3F6B 54                  DEFB    %01010100
20219   3F6C 54                  DEFB    %01010100
20220   3F6D 54                  DEFB    %01010100
20221   3F6E 54                  DEFB    %01010100
20222   3F6F 00                  DEFB    %00000000
20223   3F70             
20224   3F70             ; $6E - Character: 'n'          CHR$(110)
20225   3F70             
20226   3F70 00                  DEFB    %00000000
20227   3F71 00                  DEFB    %00000000
20228   3F72 78                  DEFB    %01111000
20229   3F73 44                  DEFB    %01000100
20230   3F74 44                  DEFB    %01000100
20231   3F75 44                  DEFB    %01000100
20232   3F76 44                  DEFB    %01000100
20233   3F77 00                  DEFB    %00000000
20234   3F78             
20235   3F78             ; $6F - Character: 'o'          CHR$(111)
20236   3F78             
20237   3F78 00                  DEFB    %00000000
20238   3F79 00                  DEFB    %00000000
20239   3F7A 38                  DEFB    %00111000
20240   3F7B 44                  DEFB    %01000100
20241   3F7C 44                  DEFB    %01000100
20242   3F7D 44                  DEFB    %01000100
20243   3F7E 38                  DEFB    %00111000
20244   3F7F 00                  DEFB    %00000000
20245   3F80             
20246   3F80             ; $70 - Character: 'p'          CHR$(112)
20247   3F80             
20248   3F80 00                  DEFB    %00000000
20249   3F81 00                  DEFB    %00000000
20250   3F82 78                  DEFB    %01111000
20251   3F83 44                  DEFB    %01000100
20252   3F84 44                  DEFB    %01000100
20253   3F85 78                  DEFB    %01111000
20254   3F86 40                  DEFB    %01000000
20255   3F87 40                  DEFB    %01000000
20256   3F88             
20257   3F88             ; $71 - Character: 'q'          CHR$(113)
20258   3F88             
20259   3F88 00                  DEFB    %00000000
20260   3F89 00                  DEFB    %00000000
20261   3F8A 3C                  DEFB    %00111100
20262   3F8B 44                  DEFB    %01000100
20263   3F8C 44                  DEFB    %01000100
20264   3F8D 3C                  DEFB    %00111100
20265   3F8E 04                  DEFB    %00000100
20266   3F8F 06                  DEFB    %00000110
20267   3F90             
20268   3F90             ; $72 - Character: 'r'          CHR$(114)
20269   3F90             
20270   3F90 00                  DEFB    %00000000
20271   3F91 00                  DEFB    %00000000
20272   3F92 1C                  DEFB    %00011100
20273   3F93 20                  DEFB    %00100000
20274   3F94 20                  DEFB    %00100000
20275   3F95 20                  DEFB    %00100000
20276   3F96 20                  DEFB    %00100000
20277   3F97 00                  DEFB    %00000000
20278   3F98             
20279   3F98             ; $73 - Character: 's'          CHR$(115)
20280   3F98             
20281   3F98 00                  DEFB    %00000000
20282   3F99 00                  DEFB    %00000000
20283   3F9A 38                  DEFB    %00111000
20284   3F9B 40                  DEFB    %01000000
20285   3F9C 38                  DEFB    %00111000
20286   3F9D 04                  DEFB    %00000100
20287   3F9E 78                  DEFB    %01111000
20288   3F9F 00                  DEFB    %00000000
20289   3FA0             
20290   3FA0             ; $74 - Character: 't'          CHR$(116)
20291   3FA0             
20292   3FA0 00                  DEFB    %00000000
20293   3FA1 10                  DEFB    %00010000
20294   3FA2 38                  DEFB    %00111000
20295   3FA3 10                  DEFB    %00010000
20296   3FA4 10                  DEFB    %00010000
20297   3FA5 10                  DEFB    %00010000
20298   3FA6 0C                  DEFB    %00001100
20299   3FA7 00                  DEFB    %00000000
20300   3FA8             
20301   3FA8             ; $75 - Character: 'u'          CHR$(117)
20302   3FA8             
20303   3FA8 00                  DEFB    %00000000
20304   3FA9 00                  DEFB    %00000000
20305   3FAA 44                  DEFB    %01000100
20306   3FAB 44                  DEFB    %01000100
20307   3FAC 44                  DEFB    %01000100
20308   3FAD 44                  DEFB    %01000100
20309   3FAE 38                  DEFB    %00111000
20310   3FAF 00                  DEFB    %00000000
20311   3FB0             
20312   3FB0             ; $76 - Character: 'v'          CHR$(118)
20313   3FB0             
20314   3FB0 00                  DEFB    %00000000
20315   3FB1 00                  DEFB    %00000000
20316   3FB2 44                  DEFB    %01000100
20317   3FB3 44                  DEFB    %01000100
20318   3FB4 28                  DEFB    %00101000
20319   3FB5 28                  DEFB    %00101000
20320   3FB6 10                  DEFB    %00010000
20321   3FB7 00                  DEFB    %00000000
20322   3FB8             
20323   3FB8             ; $77 - Character: 'w'          CHR$(119)
20324   3FB8             
20325   3FB8 00                  DEFB    %00000000
20326   3FB9 00                  DEFB    %00000000
20327   3FBA 44                  DEFB    %01000100
20328   3FBB 54                  DEFB    %01010100
20329   3FBC 54                  DEFB    %01010100
20330   3FBD 54                  DEFB    %01010100
20331   3FBE 28                  DEFB    %00101000
20332   3FBF 00                  DEFB    %00000000
20333   3FC0             
20334   3FC0             ; $78 - Character: 'x'          CHR$(120)
20335   3FC0             
20336   3FC0 00                  DEFB    %00000000
20337   3FC1 00                  DEFB    %00000000
20338   3FC2 44                  DEFB    %01000100
20339   3FC3 28                  DEFB    %00101000
20340   3FC4 10                  DEFB    %00010000
20341   3FC5 28                  DEFB    %00101000
20342   3FC6 44                  DEFB    %01000100
20343   3FC7 00                  DEFB    %00000000
20344   3FC8             
20345   3FC8             ; $79 - Character: 'y'          CHR$(121)
20346   3FC8             
20347   3FC8 00                  DEFB    %00000000
20348   3FC9 00                  DEFB    %00000000
20349   3FCA 44                  DEFB    %01000100
20350   3FCB 44                  DEFB    %01000100
20351   3FCC 44                  DEFB    %01000100
20352   3FCD 3C                  DEFB    %00111100
20353   3FCE 04                  DEFB    %00000100
20354   3FCF 38                  DEFB    %00111000
20355   3FD0             
20356   3FD0             ; $7A - Character: 'z'          CHR$(122)
20357   3FD0             
20358   3FD0 00                  DEFB    %00000000
20359   3FD1 00                  DEFB    %00000000
20360   3FD2 7C                  DEFB    %01111100
20361   3FD3 08                  DEFB    %00001000
20362   3FD4 10                  DEFB    %00010000
20363   3FD5 20                  DEFB    %00100000
20364   3FD6 7C                  DEFB    %01111100
20365   3FD7 00                  DEFB    %00000000
20366   3FD8             
20367   3FD8             ; $7B - Character: '{'          CHR$(123)
20368   3FD8             
20369   3FD8 00                  DEFB    %00000000
20370   3FD9 0E                  DEFB    %00001110
20371   3FDA 08                  DEFB    %00001000
20372   3FDB 30                  DEFB    %00110000
20373   3FDC 08                  DEFB    %00001000
20374   3FDD 08                  DEFB    %00001000
20375   3FDE 0E                  DEFB    %00001110
20376   3FDF 00                  DEFB    %00000000
20377   3FE0             
20378   3FE0             ; $7C - Character: '|'          CHR$(124)
20379   3FE0             
20380   3FE0 00                  DEFB    %00000000
20381   3FE1 08                  DEFB    %00001000
20382   3FE2 08                  DEFB    %00001000
20383   3FE3 08                  DEFB    %00001000
20384   3FE4 08                  DEFB    %00001000
20385   3FE5 08                  DEFB    %00001000
20386   3FE6 08                  DEFB    %00001000
20387   3FE7 00                  DEFB    %00000000
20388   3FE8             
20389   3FE8             ; $7D - Character: '}'          CHR$(125)
20390   3FE8             
20391   3FE8 00                  DEFB    %00000000
20392   3FE9 70                  DEFB    %01110000
20393   3FEA 10                  DEFB    %00010000
20394   3FEB 0C                  DEFB    %00001100
20395   3FEC 10                  DEFB    %00010000
20396   3FED 10                  DEFB    %00010000
20397   3FEE 70                  DEFB    %01110000
20398   3FEF 00                  DEFB    %00000000
20399   3FF0             
20400   3FF0             ; $7E - Character: '~'          CHR$(126)
20401   3FF0             
20402   3FF0 00                  DEFB    %00000000
20403   3FF1 14                  DEFB    %00010100
20404   3FF2 28                  DEFB    %00101000
20405   3FF3 00                  DEFB    %00000000
20406   3FF4 00                  DEFB    %00000000
20407   3FF5 00                  DEFB    %00000000
20408   3FF6 00                  DEFB    %00000000
20409   3FF7 00                  DEFB    %00000000
20410   3FF8             
20411   3FF8             ; $7F - Character: ' © '        CHR$(127)
20412   3FF8             
20413   3FF8 3C                  DEFB    %00111100
20414   3FF9 42                  DEFB    %01000010
20415   3FFA 99                  DEFB    %10011001
20416   3FFB A1                  DEFB    %10100001
20417   3FFC A1                  DEFB    %10100001
20418   3FFD 99                  DEFB    %10011001
20419   3FFE 42                  DEFB    %01000010
20420   3FFF 3C                  DEFB    %00111100
20421   4000             
20422   4000             
20423   4000             ;#end                            ; generic cross-assembler directive 
20424   4000             
20425   4000             ; Acknowledgements
20426   4000             ; -----------------
20427   4000             ; Sean Irvine               for default list of section headings
20428   4000             ; Dr. Ian Logan             for labels and functional disassembly.
20429   4000             ; Dr. Frank O'Hara          for labels and functional disassembly.
20430   4000             ;
20431   4000             ; Credits
20432   4000             ; -------
20433   4000             ; Alex Pallero Gonzales     for corrections.
20434   4000             ; Mike Dailly               for comments.
20435   4000             ; Alvin Albrecht            for comments.
20436   4000             ; Andy Styles               for full relocatability implementation and testing.                    testing.
20437   4000             ; Andrew Owen               for ZASM compatibility and format improvements.
20438   4000             
20439   4000             ;   For other assemblers you may have to add directives like these near the 
20440   4000             ;   beginning - see accompanying documentation.
20441   4000             ;   ZASM (MacOs) cross-assembler directives. (uncomment by removing ';' )
20442   4000             ;   #target rom           ; declare target file format as binary.
20443   4000             ;   #code   0,$4000       ; declare code segment.
20444   4000             ;   Also see notes at Address Labels 0609 and 1CA5 if your assembler has 
20445   4000             ;   trouble with expressions.
20446   4000             ;
20447   4000             ;   Note. The Sinclair Interface 1 ROM written by Dr. Ian Logan and Martin 
20448   4000             ;   Brennan calls numerous routines in this ROM.  
20449   4000             ;   Non-standard entry points have a label beginning with X. 
20450   4000             

Value    Label
------ - -----------------------------------------------------------
0x003F   OVERALL_COLOURS
0x0009   LOADBORDER
0x00FE   HLclrPAG
0xFEFF   HLfrom
0xBEFF   BCfrom
0x0000 X L0000
0x11C8   L11C8
0x0008 X L0008
0x0053   L0053
0x0010 X L0010
0x15F2   L15F2
0x0018   L0018
0x001C   L001C
0x007D   L007D
0x0020 X L0020
0x0074   L0074
0x0028 X L0028
0x335B   L335B
0x0030 X L0030
0x169E   L169E
0x0038 X L0038
0x0048   L0048
0x02BF   L02BF
0x0055   L0055
0x16C5   L16C5
0x0066 X L0066
0x0070   L0070
0x0077   L0077
0x0078   L0078
0x007B X X007B
0x0090   L0090
0x0095   L0095
0x0205   L0205
0x022C   L022C
0x0246   L0246
0x0260   L0260
0x026A   L026A
0x0284   L0284
0x028E   L028E
0x0296   L0296
0x02AB   L02AB
0x029F   L029F
0x02A1   L02A1
0x02C6   L02C6
0x02D1   L02D1
0x031E   L031E
0x0310   L0310
0x02F1   L02F1
0x0333   L0333
0x0308   L0308
0x032C   L032C
0x0367   L0367
0x034F   L034F
0x0341   L0341
0x034A   L034A
0x0364   L0364
0x039D   L039D
0x0389   L0389
0x0382   L0382
0x03B2   L03B2
0x03B5   L03B5
0x03D1   L03D1
0x03D2 X L03D2
0x03D3 X L03D3
0x03D4 X L03D4
0x03D6   L03D6
0x03F2   L03F2
0x03F6   L03F6
0x03F8   L03F8
0x046C   L046C
0x0425   L0425
0x0427   L0427
0x046E   L046E
0x3406   L3406
0x33B4   L33B4
0x1E94   L1E94
0x1E99   L1E99
0x04AA X L04AA
0x24FB   L24FB
0x1C8A   L1C8A
0x2BF1   L2BF1
0x04C2   L04C2
0x053F   L053F
0x04D0   L04D0
0x04D8   L04D8
0x04EA   L04EA
0x04F2   L04F2
0x0507   L0507
0x04FE   L04FE
0x050E   L050E
0x0505   L0505
0x0525   L0525
0x0511   L0511
0x0514   L0514
0x051C   L051C
0x051A   L051A
0x053C   L053C
0x0554   L0554
0x0552 X L0552
0x0556   L0556
0x056B   L056B
0x056C   L056C
0x05E7   L05E7
0x0574   L0574
0x05E3   L05E3
0x0580   L0580
0x058F   L058F
0x05C8   L05C8
0x05A9   L05A9
0x05B3   L05B3
0x05BD   L05BD
0x05C2   L05C2
0x05C4   L05C4
0x05CA   L05CA
0x05E9   L05E9
0x05ED   L05ED
0x0605   L0605
0x0609 X L0609
0x1ADF   L1ADF
0x1C8C   L1C8C
0x2530   L2530
0x0652   L0652
0x0621   L0621
0x0629   L0629
0x064B   L064B
0x0644   L0644
0x0642 X L0642
0x06A0   L06A0
0x28B2   L28B2
0x0672   L0672
0x0685   L0685
0x0670 X L0670
0x0692   L0692
0x068F   L068F
0x1BEE   L1BEE
0x075A   L075A
0x06C3   L06C3
0x0710   L0710
0x0716   L0716
0x2048   L2048
0x06E1   L06E1
0x1CE6   L1CE6
0x06F0   L06F0
0x1C82   L1C82
0x06F5   L06F5
0x06F9   L06F9
0x0723   L0723
0x073A   L073A
0x0970   L0970
0x0767   L0767
0x1601   L1601
0x078A   L078A
0x09C0   L09C0
0x0C0A   L0C0A
0x07A6   L07A6
0x07AD   L07AD
0x07CB   L07CB
0x0808   L0808
0x08B6   L08B6
0x07E9   L07E9
0x0806   L0806
0x07F4   L07F4
0x0800   L0800
0x0802   L0802
0x0819   L0819
0x0825   L0825
0x082E   L082E
0x1F05   L1F05
0x0873   L0873
0x084C   L084C
0x19E8   L19E8
0x1655   L1655
0x19E5   L19E5
0x08AD   L08AD
0x08CE X X08CE
0x08D2   L08D2
0x08F0   L08F0
0x08D7   L08D7
0x08DF   L08DF
0x08EB   L08EB
0x19B8   L19B8
0x092C   L092C
0x08F9   L08F9
0x0923   L0923
0x0909   L0909
0x0901   L0901
0x0921   L0921
0x0912   L0912
0x091E   L091E
0x093E   L093E
0x0955   L0955
0x0958   L0958
0x09A1   L09A1
0x15D4   L15D4
0x0991   L0991
0x09F4   L09F4
0x0B03   L0B03
0x0AD9   L0AD9
0x0A69   L0A69
0x0A11   L0A11
0x0A5F   L0A5F
0x0A23   L0A23
0x0A3D   L0A3D
0x0A4F   L0A4F
0x0A7A   L0A7A
0x0A75   L0A75
0x0A3A   L0A3A
0x0A38   L0A38
0x0DD9   L0DD9
0x0B65   L0B65
0x0ECD   L0ECD
0x0C55   L0C55
0x0AC3   L0AC3
0x0A6D   L0A6D
0x0A87   L0A87
0x0A80   L0A80
0x0A7D   L0A7D
0x2211   L2211
0x0AC2   L0AC2
0x0AAC   L0AAC
0x0ABF   L0ABF
0x1E9F   L1E9F
0x0C86   L0C86
0x0AD0   L0AD0
0x0C3B   L0C3B
0x0B24   L0B24
0x0ADC   L0ADC
0x0AFC   L0AFC
0x0AF0   L0AF0
0x0B1D   L0B1D
0x0B52   L0B52
0x0B38   L0B38
0x0B7F   L0B7F
0x0B3E   L0B3E
0x0B4C   L0B4C
0x0B5F   L0B5F
0x0B6A   L0B6A
0x0C10   L0C10
0x0B76   L0B76
0x0B93   L0B93
0x0BA4   L0BA4
0x0BB6   L0BB6
0x0BB7   L0BB7
0x0BD3   L0BD3
0x0BC1   L0BC1
0x0BDB   L0BDB
0x0BFA   L0BFA
0x0C08   L0C08
0x0C14   L0C14
0x0C41   L0C41
0x0C22   L0C22
0x0C35   L0C35
0x0C44   L0C44
0x0D02   L0D02
0x0C88   L0C88
0x0CD2   L0CD2
0x0CF8   L0CF8
0x0D00   L0D00
0x0DFE   L0DFE
0x0E9B   L0E9B
0x0CF0   L0CF0
0x0D4D   L0D4D
0x0D1C   L0D1C
0x0D2D   L0D2D
0x0E00   L0E00
0x0D5B   L0D5B
0x0D65   L0D65
0x0D6B   L0D6B
0x0DAF   L0DAF
0x0D6E   L0D6E
0x0E44   L0E44
0x0D8E   L0D8E
0x0D87   L0D87
0x0D89   L0D89
0x0D94   L0D94
0x0DA0   L0DA0
0x10A8   L10A8
0x0DF4   L0DF4
0x0DEE   L0DEE
0x0E05   L0E05
0x0E19   L0E19
0x0E0D   L0E0D
0x0E88   L0E88
0x0E4A   L0E4A
0x0E4D   L0E4D
0x0E80   L0E80
0x0EAC   L0EAC
0x0EAF X L0EAF
0x0EB2   L0EB2
0x0EF4   L0EF4
0x0EC9   L0EC9
0x0EDA   L0EDA
0x0ED3   L0ED3
0x0EDF   L0EDF
0x0EE7   L0EE7
0x0EFD   L0EFD
0x1F54   L1F54
0x0F0C   L0F0C
0x0F0A X L0F0A
0x0F14   L0F14
0x0F18   L0F18
0x0F1E   L0F1E
0x0F2C   L0F2C
0x0F30   L0F30
0x107F   L107F
0x0F38   L0F38
0x0F81   L0F81
0x0F92   L0F92
0x0F6C   L0F6C
0x101E   L101E
0x0F8B   L0F8B
0x0F85 X X0F85
0x1652   L1652
0x0FA0   L0FA0
0x0FA9   L0FA9
0x1007   L1007
0x100C   L100C
0x0FF3   L0FF3
0x1059   L1059
0x1015   L1015
0x1024   L1024
0x1076   L1076
0x107C   L107C
0x1097   L1097
0x196E   L196E
0x1695   L1695
0x1855   L1855
0x1615   L1615
0x1001   L1001
0x190F   L190F
0x106E   L106E
0x1031   L1031
0x1011   L1011
0x1026   L1026
0x1195   L1195
0x103E   L103E
0x1051   L1051
0x191C   L191C
0x1795   L1795
0x1190   L1190
0x111D   L111D
0x111B   L111B
0x10FA   L10FA
0x10DB   L10DB
0x1105   L1105
0x10E6   L10E6
0x10F4   L10F4
0x110D   L110D
0x1113   L1113
0x1167   L1167
0x187D   L187D
0x18E1   L18E1
0x1150   L1150
0x117C   L117C
0x115E   L115E
0x117E   L117E
0x11A7   L11A7
0x11B7   L11B7
0x11DB X L11DB
0x1201   L1201
0x15AF   L15AF
0x129D   L129D
0x164D   L164D
0x1539   L1539
0x1303   L1303
0x12A2   L12A2
0x12A9 X L12A9
0x16B0   L16B0
0x12AC   L12AC
0x1B17   L1B17
0x12CF   L12CF
0x19FB   L19FB
0x155D   L155D
0x1B8A   L1B8A
0x1313   L1313
0x133C   L133C
0x15EF   L15EF
0x1391   L1391
0x1349 X X1349
0x1537   L1537
0x1A1B   L1A1B
0x1386   L1386
0x1373   L1373
0x1376   L1376
0x1384   L1384
0x1555   L1555
0x157D   L157D
0x15AB   L15AB
0x15C4   L15C4
0x15C6   L15C6
0x15DE   L15DE
0x15E6   L15E6
0x15E4 X L15E4
0x15F7   L15F7
0x162C   L162C
0x1610   L1610
0x160E   L160E
0x162D   L162D
0x16DC   L16DC
0x1634   L1634
0x1642   L1642
0x1646   L1646
0x1664   L1664
0x166B   L166B
0x167F   L167F
0x168F   L168F
0x1691   L1691
0x16BF   L16BF
0x16D4 X L16D4
0x16DB   L16DB
0x16E5   L16E5
0x171E   L171E
0x1701   L1701
0x16FC   L16FC
0x1708 X L1708
0x1716   L1716
0x171C   L171C
0x1727   L1727
0x1725   L1725
0x1736   L1736
0x1756   L1756
0x175D   L175D
0x1767   L1767
0x1765   L1765
0x177A   L177A
0x1781   L1781
0x1785   L1785
0x1789   L1789
0x178B   L178B
0x1793   L1793
0x17E1   L17E1
0x17CE   L17CE
0x17E4   L17E4
0x17ED   L17ED
0x1833   L1833
0x17F5   L17F5
0x17FB   L17FB
0x17F9   L17F9
0x2070   L2070
0x181F   L181F
0x1814   L1814
0x181A   L181A
0x1822   L1822
0x1CDE   L1CDE
0x1835   L1835
0x1980   L1980
0x1865   L1865
0x1A28   L1A28
0x1881   L1881
0x1894   L1894
0x18A1   L18A1
0x18C1   L18C1
0x18B6   L18B6
0x18B4   L18B4
0x1937   L1937
0x18F3   L18F3
0x1909   L1909
0x1925   L1925
0x192A   L192A
0x192B   L192B
0x2D1B   L2D1B
0x196C   L196C
0x195A   L195A
0x1968   L1968
0x1974   L1974
0x1988 X L1988
0x198B   L198B
0x1990   L1990
0x199A   L199A
0x1998   L1998
0x19A5   L19A5
0x19AD   L19AD
0x19B1   L19B1
0x19D5   L19D5
0x19D6   L19D6
0x19C7   L19C7
0x19CE   L19CE
0x19DB   L19DB
0x19DD   L19DD
0x2D3B   L2D3B
0x2DA2   L2DA2
0x1A15   L1A15
0x1A42   L1A42
0x1A30   L1A30
0x1A48   L1A48
0x1AF9   L1AF9
0x1B14   L1B14
0x1B06   L1B06
0x1B0A   L1B0A
0x1B10   L1B10
0x1AFC   L1AFC
0x1B02   L1B02
0x1AE2   L1AE2
0x1AE1   L1AE1
0x1AE3   L1AE3
0x1AE7   L1AE7
0x1AEB   L1AEB
0x1AEC   L1AEC
0x1AED   L1AED
0x1AEE   L1AEE
0x1AEF   L1AEF
0x1AF0   L1AF0
0x1AF1   L1AF1
0x1AD9   L1AD9
0x1ADC   L1ADC
0x1A8A   L1A8A
0x1AC9   L1AC9
0x1ACC   L1ACC
0x1ACF   L1ACF
0x1AA8   L1AA8
0x1AF5   L1AF5
0x1AB8   L1AB8
0x1AA2   L1AA2
0x1AA5   L1AA5
0x1A90   L1A90
0x1A7D   L1A7D
0x1A86   L1A86
0x1A9F   L1A9F
0x1AE0   L1AE0
0x1AAE   L1AAE
0x1A7A   L1A7A
0x1AC5   L1AC5
0x1A98   L1A98
0x1AB1   L1AB1
0x1A9C   L1A9C
0x1AC1   L1AC1
0x1AAB   L1AAB
0x1AB5   L1AB5
0x1A81   L1A81
0x1ABE   L1ABE
0x1AD2   L1AD2
0x1ABB   L1ABB
0x1A8D   L1A8D
0x1AD6   L1AD6
0x1E67   L1E67
0x1CF0   L1CF0
0x1EED   L1EED
0x1CEE   L1CEE
0x1F23   L1F23
0x1D03   L1D03
0x1DAB   L1DAB
0x1FCD   L1FCD
0x2089   L2089
0x2C02   L2C02
0x1BB2   L1BB2
0x1EA1   L1EA1
0x1E80   L1E80
0x1E4F   L1E4F
0x1E5F   L1E5F
0x1EAC   L1EAC
0x22DC   L22DC
0x1F3A   L1F3A
0x1DED   L1DED
0x1E27   L1E27
0x1E42   L1E42
0x2382   L2382
0x1FC9   L1FC9
0x2320   L2320
0x1E7A   L1E7A
0x2294   L2294
0x1F60   L1F60
0x1B29   L1B29
0x1B28   L1B28
0x1BB3   L1BB3
0x1B76   L1B76
0x1B55   L1B55
0x1B52   L1B52
0x1B6F   L1B6F
0x1C01   L1C01
0x1B7D   L1B7D
0x1B7B X L1B7B
0x1BF4   L1BF4
0x1B9E   L1B9E
0x1BD1   L1BD1
0x1BBF   L1BBF
0x1BEC   L1BEC
0x1BB0 X L1BB0
0x1C10   L1C10
0x1C1F   L1C1F
0x1C4E   L1C4E
0x1C0D   L1C0D
0x1C6C   L1C6C
0x1C11   L1C11
0x1C96   L1C96
0x1C7A   L1C7A
0x1CBE   L1CBE
0x1CDB   L1CDB
0x1C22   L1C22
0x1C30   L1C30
0x1C46   L1C46
0x1C2E   L1C2E
0x2996   L2996
0x1C56   L1C56
0x1C59   L1C59
0x2AFF   L2AFF
0x1C79   L1C79
0x1CA5 X L1CA5
0x21FC   L21FC
0x1CD6   L1CD6
0x21E2   L21E2
0x1D00   L1D00
0x34E9   L34E9
0x1D10   L1D10
0x1D16   L1D16
0x1D34   L1D34
0x1DDA   L1DDA
0x1D64   L1D64
0x1D86   L1D86
0x1D84   L1D84
0x1D7C   L1D7C
0x1DA3   L1DA3
0x1D8B   L1D8B
0x1DD8   L1DD8
0x1E73   L1E73
0x1DE2 X L1DE2
0x1DE9 X L1DE9
0x1DEC   L1DEC
0x1E1E   L1E1E
0x1E0A   L1E0A
0x1E08 X L1E08
0x1E37   L1E37
0x1E2C   L1E2C
0x1E39   L1E39
0x1E45   L1E45
0x1E5A   L1E5A
0x1E85   L1E85
0x2DD5   L2DD5
0x1E8E   L1E8E
0x1E9C   L1E9C
0x1EAF   L1EAF
0x1EB7   L1EB7
0x1EDA   L1EDA
0x1EDC   L1EDC
0x1F15   L1F15
0x1F1A X L1F1A
0x1F36   L1F36
0x1F3D   L1F3D
0x1F4F   L1F4F
0x1F49   L1F49
0x1F6A   L1F6A
0x2C8D   L2C8D
0x1F89   L1F89
0x1F7D   L1F7D
0x1FBD   L1FBD
0x1FA6   L1FA6
0x1F86   L1F86
0x1F94   L1F94
0x1FC3   L1FC3
0x1FCF   L1FCF
0x1FDF   L1FDF
0x2045   L2045
0x1FF2   L1FF2
0x1FE5   L1FE5
0x204E   L204E
0x1FFC   L1FFC
0x1FF5   L1FF5
0x200E   L200E
0x2307   L2307
0x201E   L201E
0x2024   L2024
0x21F2   L21F2
0x2DE3   L2DE3
0x203C   L203C
0x2067   L2067
0x2061   L2061
0x206E   L206E
0x2096   L2096
0x20C1   L20C1
0x20AD   L20AD
0x20D8   L20D8
0x21B2   L21B2
0x20ED   L20ED
0x20FA   L20FA
0x21AF   L21AF
0x211C   L211C
0x211A   L211A
0x2129   L2129
0x215E   L215E
0x213A   L213A
0x2148   L2148
0x21B9   L21B9
0x2161   L2161
0x21D6   L21D6
0x2174   L2174
0x219B   L219B
0x2AB2   L2AB2
0x21D0   L21D0
0x21CE X L21CE
0x21D4 X L21D4
0x21E1   L21E1
0x2234   L2234
0x2273   L2273
0x2228   L2228
0x2244   L2244
0x226C   L226C
0x223E   L223E
0x2246   L2246
0x2258   L2258
0x2257   L2257
0x227D   L227D
0x2287   L2287
0x22A6   L22A6
0x22AA   L22AA
0x24F9   L24F9
0x22CB   L22CB
0x22D4   L22D4
0x2D28   L2D28
0x22E5   L22E5
0x22F0   L22F0
0x22FD   L22FD
0x2303   L2303
0x2314   L2314
0x233B   L233B
0x247D   L247D
0x235A   L235A
0x2420   L2420
0x238D   L238D
0x2477   L2477
0x23A3 X L23A3
0x23C1   L23C1
0x245F   L245F
0x2439   L2439
0x2425   L2425
0x24B7   L24B7
0x2495   L2495
0x2497   L2497
0x24C4   L24C4
0x24CB   L24CB
0x24CE   L24CE
0x24D4   L24D4
0x24DB   L24DB
0x24DF   L24DF
0x24F7   L24F7
0x24EC   L24EC
0x24FF   L24FF
0x2596   L2596
0x2684   L2684
0x250F   L250F
0x2522   L2522
0x252D   L252D
0x2535   L2535
0x254F   L254F
0x255A   L255A
0x2573   L2573
0x255D   L255D
0x257D   L257D
0x2580   L2580
0x25B3   L25B3
0x25E8   L25E8
0x268D   L268D
0x25AF   L25AF
0x25F5   L25F5
0x25F8   L25F8
0x2627   L2627
0x2634   L2634
0x2668   L2668
0x2672   L2672
0x267B   L267B
0x25D9   L25D9
0x25BE   L25BE
0x25CB   L25CB
0x25DB   L25DB
0x2712   L2712
0x27BD   L27BD
0x2625   L2625
0x2D2B   L2D2B
0x2630   L2630
0x26C3   L26C3
0x270D   L270D
0x2665   L2665
0x2660   L2660
0x2C88   L2C88
0x26DF   L26DF
0x26C9   L26C9
0x26B5   L26B5
0x2C9B   L2C9B
0x26B6   L26B6
0x26DD   L26DD
0x2707   L2707
0x2713   L2713
0x2723   L2723
0x2734   L2734
0x2A52   L2A52
0x2795   L2795
0x27B0   L27B0
0x2773   L2773
0x274C   L274C
0x275B   L275B
0x2758 X L2758
0x2764   L2764
0x2761   L2761
0x2770   L2770
0x2790   L2790
0x2788   L2788
0x27F7   L27F7
0x27D0   L27D0
0x27E6   L27E6
0x27E9   L27E9
0x27D9   L27D9
0x27E4   L27E4
0x27F4   L27F4
0x2802   L2802
0x2808   L2808
0x2814   L2814
0x2812 X L2812
0x28AB   L28AB
0x2825   L2825
0x2831   L2831
0x2885   L2885
0x2843   L2843
0x2852   L2852
0x288B   L288B
0x288D   L288D
0x28EF   L28EF
0x28DE   L28DE
0x28E3   L28E3
0x28D4   L28D4
0x2951   L2951
0x28FD   L28FD
0x2934   L2934
0x2900   L2900
0x2932   L2932
0x292A   L292A
0x293F   L293F
0x2912   L2912
0x2913   L2913
0x2929   L2929
0x293E   L293E
0x2943   L2943
0x294B   L294B
0x295A   L295A
0x296B   L296B
0x2981   L2981
0x2991   L2991
0x33C0   L33C0
0x29E7   L29E7
0x29AE   L29AE
0x29A1   L29A1
0x2A49   L2A49
0x29C0   L29C0
0x2A20   L2A20
0x29C3   L29C3
0x29EA   L29EA
0x29D8   L29D8
0x2A12   L2A12
0x2A48   L2A48
0x29E0   L29E0
0x2A45   L2A45
0x29FB   L29FB
0x2AEE   L2AEE
0x2ACC   L2ACC
0x2AF4   L2AF4
0x2A7A   L2A7A
0x2A2C   L2A2C
0x2A22   L2A22
0x2AB1   L2AB1
0x2AAD   L2AAD
0x2A81   L2A81
0x2ACD   L2ACD
0x2A94   L2A94
0x2AA8   L2AA8
0x2AB6   L2AB6
0x33A9   L33A9
0x2AEB   L2AEB
0x2AE8   L2AE8
0x30A9   L30A9
0x2B66   L2B66
0x2B0B   L2B0B
0x2B0C   L2B0C
0x2B1F   L2B1F
0x2B29   L2B29
0x2BC0   L2BC0
0x2B4F   L2B4F
0x2B3E   L2B3E
0x2BEA   L2BEA
0x2B59   L2B59
0x2BA6   L2BA6
0x2B72   L2B72
0x2BAF   L2BAF
0x2B9B   L2B9B
0x2BA3   L2BA3
0x2BC6   L2BC6
0x2C05   L2C05
0x2C15   L2C15
0x2C1F   L2C1F
0x2C2D   L2C2D
0x2C2E   L2C2E
0x2C7C   L2C7C
0x2C7F   L2C7F
0x2CB8   L2CB8
0x2CA2   L2CA2
0x2CB3   L2CB3
0x31AD   L31AD
0x2CCB   L2CCB
0x2CEB   L2CEB
0x2CD5   L2CD5
0x2CCF   L2CCF
0x2CDA   L2CDA
0x2D22   L2D22
0x2CF2   L2CF2
0x2CFE   L2CFE
0x2CFF   L2CFF
0x2D18   L2D18
0x2D4F   L2D4F
0x2D40   L2D40
0x2D55   L2D55
0x350B   L350B
0x2D60   L2D60
0x2D71   L2D71
0x2D6D X L2D6D
0x2D6E X L2D6E
0x2D7B   L2D7B
0x2D7F   L2D7F
0x2D8C X L2D8C
0x2D8E   L2D8E
0x2DAD   L2DAD
0x2DC1   L2DC1
0x2DE1   L2DE1
0x2DF2 X L2DF2
0x2DF8 X L2DF8
0x2E01   L2E01
0x2E56   L2E56
0x2E1E   L2E1E
0x2E24   L2E24
0x2E7B   L2E7B
0x2E25 X L2E25
0x2ECF   L2ECF
0x2E6F   L2E6F
0x2FBA   L2FBA
0x2E8A   L2E8A
0x2EA1   L2EA1
0x2EA9   L2EA9
0x2EB3   L2EB3
0x2EB8   L2EB8
0x2ECB   L2ECB
0x2F0C   L2F0C
0x2FDD   L2FDD
0x2EDF   L2EDF
0x2EEC   L2EEC
0x2EEF   L2EEF
0x2F8B   L2F8B
0x2F18   L2F18
0x2F25   L2F25
0x2F2D   L2F2D
0x2F46   L2F46
0x2F6C   L2F6C
0x2F4A   L2F4A
0x2F52   L2F52
0x2F5E   L2F5E
0x2F59   L2F59
0x2F64   L2F64
0x2F83   L2F83
0x2F85   L2F85
0x2F9B   L2F9B
0x2FAF   L2FAF
0x2FF9   L2FF9
0x2FE5   L2FE5
0x3004   L3004
0x2FFB   L2FFB
0x300D   L300D
0x300F   L300F
0x346E   L346E
0x3014   L3014
0x303E   L303E
0x303C   L303C
0x3293   L3293
0x3055   L3055
0x307C   L307C
0x309F   L309F
0x30A5   L30A5
0x30A3   L30A3
0x3155   L3155
0x30B1   L30B1
0x30BE   L30BE
0x30BC   L30BC
0x30C0   L30C0
0x30CA   L30CA
0x30F0   L30F0
0x30EF   L30EF
0x30EA   L30EA
0x315D   L315D
0x3125   L3125
0x3114   L3114
0x311B   L311B
0x313B   L313B
0x313D   L313D
0x3146   L3146
0x3151   L3151
0x316C   L316C
0x3159   L3159
0x315E   L315E
0x3195   L3195
0x316E   L316E
0x3186   L3186
0x31AF   L31AF
0x31E2   L31E2
0x31D2   L31D2
0x31DB X L31DB
0x31F2   L31F2
0x31F9   L31F9
0x31FA   L31FA
0x3214   L3214
0x3221   L3221
0x3272   L3272
0x323F   L323F
0x3233   L3233
0x326C   L326C
0x326D   L326D
0x3252   L3252
0x325E   L325E
0x3267   L3267
0x3261   L3261
0x3283   L3283
0x327E   L327E
0x3290   L3290
0x328A   L328A
0x3296   L3296
0x3297   L3297
0x32B1   L32B1
0x32BD   L32BD
0x32B2   L32B2
0x32C5   L32C5
0x32C8 X L32C8
0x32CC X L32CC
0x32CE X L32CE
0x32D3 X L32D3
0x32D7   L32D7
0x368F   L368F
0x343C   L343C
0x33A1   L33A1
0x3851   L3851
0x351B   L351B
0x3524   L3524
0x353B   L353B
0x352D   L352D
0x359C   L359C
0x35DE   L35DE
0x34BC   L34BC
0x3645   L3645
0x3669   L3669
0x3674   L3674
0x37B5   L37B5
0x37AA   L37AA
0x37DA   L37DA
0x3833   L3833
0x3843   L3843
0x37E2   L37E2
0x3713   L3713
0x36C4   L36C4
0x36AF   L36AF
0x384A   L384A
0x3492   L3492
0x346A   L346A
0x34AC   L34AC
0x34A5   L34A5
0x34B3   L34B3
0x361F   L361F
0x35C9   L35C9
0x3501   L3501
0x36A0   L36A0
0x3686   L3686
0x33C6   L33C6
0x367A   L367A
0x3506   L3506
0x34F9   L34F9
0x369B   L369B
0x3783   L3783
0x33A2   L33A2
0x3449   L3449
0x341B   L341B
0x342D   L342D
0x340F   L340F
0x35BF   L35BF
0x335E   L335E
0x3362   L3362
0x3365   L3365
0x336C   L336C
0x3380   L3380
0x338E   L338E
0x338C   L338C
0x33C8   L33C8
0x33DE   L33DE
0x33F1   L33F1
0x33F7   L33F7
0x33F8   L33F8
0x343E   L343E
0x3453 X L3453
0x3474   L3474
0x3483   L3483
0x34B0   L34B0
0x34E7   L34E7
0x34D3   L34D3
0x34E4   L34E4
0x3507   L3507
0x3543   L3543
0x354E   L354E
0x3559   L3559
0x358C   L358C
0x3564   L3564
0x3575   L3575
0x356B   L356B
0x3572   L3572
0x3588   L3588
0x3585   L3585
0x35B7   L35B7
0x35DC   L35DC
0x360C   L360C
0x365F   L365F
0x3671   L3671
0x3687   L3687
0x36B7 X L36B7
0x36C2 X L36C2
0x3705   L3705
0x3703   L3703
0x370C   L370C
0x370E   L370E
0x371A X L371A
0x371C X L371C
0x373D X L373D
0x37A1 X L37A1
0x37A8 X L37A8
0x37B7 X L37B7
0x37F8   L37F8
0x37FA X L37FA
0x385D X L385D
0x386A X L386A
0x386C X L386C
0x386E X L386E
0x3D00 X L3D00
